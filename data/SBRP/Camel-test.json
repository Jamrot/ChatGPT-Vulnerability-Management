{
    "Camel": {
        "3416": {
            "ground_truth": "0",
            "bug_report": "DefaultTimeoutMap should force scheduler in contructor\nSee nabblehttp://camel.465427.n5.nabble.com/Do-I-have-to-give-a-ScheduledExecutorService-instance-when-initializing-DefualtTimeoutMap-tp3298252p3298252.html",
            "id": "3416"
        },
        "3425": {
            "ground_truth": "0",
            "bug_report": "CamelContext is started twice when using camel-blueprint\nFor example if you run the testRouteWithAllComponents test in CamelBlueprintTest in tests/camel-itest-osgi you will see a lot of logging. But notice[RMI TCP Connection(1)-10.0.1.2] INFO org.apache.camel.core.osgi.OsgiDefaultCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 67-camel-2) is starting[RMI TCP Connection(1)-10.0.1.2] INFO org.apache.camel.core.osgi.OsgiDefaultCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 67-camel-2) started in 0.147 secondsThen blueprint does something[Blueprint Extender: 3] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 4-camel-5) is starting[Blueprint Extender: 3] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 4-camel-5) started in 0.071 secondsAnd likewise both CamelContext's is shutdown when the test completes. There are logging events for that as well.Pay attention to the name of the 1st CamelContext 67-camel-2. This is the correct name as its based on the bundle id  our end user Camel application is given. This ensures that the CamelContext from his application has a name which is unique and refers to the bundle id as well.Now if you look at the 2nd CamelContext being started its given another name 4-camel-5. That id is most likely using a shared bundle id with a low number. For example camel-blueprint or camel-core bundle  or something like that. In essence camel-blueprint should only create one CamelContext and it should use the 67-camel-2 as the name of the CamelContext (eg. include the bundle id of the end user application).",
            "id": "3425"
        },
        "3430": {
            "ground_truth": "0",
            "bug_report": "InterceptSendToEndpoint has issues with interception http endpoints which has multiple parameters\nSee nabblehttp://camel.465427.n5.nabble.com/interceptSendToEndpoint-with-dynamic-endpoint-tp3301978p3301978.htmlThe issue is when any endpoints have parameters which may be re-ordered when the endpoint is normalized.",
            "id": "3430"
        },
        "3441": {
            "ground_truth": "0",
            "bug_report": "DataFormat - Support for CamelContextAware injection and start/stop callbacks with Service\nThis allows custom DataFormat to do any initialization logic in start and stop methods from Service.Also they will get access to CamelContext by implementing CamelContextAware",
            "id": "3441"
        },
        "3458": {
            "ground_truth": "0",
            "bug_report": "Bindy should support clipping fields if they exceed maximum length allowed when using fixed length\nAdding a new option to bindy annotation /** * Indicates to clip data in the field if it exceeds the allowed length when using fixed length. */ boolean clip() default false;Then if enabled it will clip the data so it can fit the length.Also now Camel throws an exception if the data is too long and you have clip set as false.",
            "id": "3458"
        },
        "3478": {
            "ground_truth": "0",
            "bug_report": "Camel-XMPP Consumer doesn't pass XMPP headers\nXMPP Consumer should pass XMPP headers as message headers  just like XMPP Producer accepts message headers as XMPP headers.",
            "id": "3478"
        },
        "3486": {
            "ground_truth": "0",
            "bug_report": "NotifyBuilder - Should throw exception if it hasn't been created and matches is invoked\nThis helps use of NotifyBuilder as matches doesn't operate until you have created the notifier.",
            "id": "3486"
        },
        "3488": {
            "ground_truth": "0",
            "bug_report": "Some of JpaTraceEventMessage's attributes require @Lob annotation\nJpaTraceEventMessage has a bunch of String attributes defined. Applying no annotations on String attributes of an @Entity result in generated database columns with a constrained length (e.g.  using EclipseLink and MySQL  a String attribute of an @Entity is mapped to a VARCHAR(255) field).Several values of JpaTraceEventMessage are probably carrying values larger than 255 characters. Using JPAs @Lob annotation tackles this problem by generating (C)LOB fields. The attached patch defines the @Lob annotation on attributes which are expected to carry such large values.",
            "id": "3488"
        },
        "3489": {
            "ground_truth": "0",
            "bug_report": "BindyCsvDataFormat broken for pipe delimited files\nAttempting to unmarshall a pipe delimited CSV file into a POJO using Bindy causese the first and last character the the line processed to be dropped. It appears that the BindyCsvDataFormat class removes the first and the last character from the line read from the CSV if the seperator is &gt; 1 characters in length (see below or line 162-165 in BindyCsvDataFormat). For pipe delimited files  you need to specify | as the seperator  as | is not evaluated correctly as a java regex by the split fuction. This leads to the first and last character for the line being parsed being dropped. From the comments it appears a 'fix' was added to remove the first and last character of the line when the seperator contains quotes or double quotes. Making this determination using the length of the seperator  rather than evaluating using a regex seems to be a poor solution that breaks other CSV delimiters.See Attached for an code example.",
            "id": "3489"
        },
        "3493": {
            "ground_truth": "0",
            "bug_report": "ConcurrentModificationException in DefaultCamelContext.removeRouteDefinitions()\nI get the following exception in DefaultCamelContext.removeRouteDefinitions(). We are removing route definitions from multiple threads. I see synchronization in various other methods  but not this one. Caused by: java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372) at java.util.AbstractList$Itr.next(AbstractList.java:343) at java.util.AbstractCollection.removeAll(AbstractCollection.java:336) at org.apache.camel.impl.DefaultCamelContext.removeRouteDefinitions(DefaultCamelContext.java:588)",
            "id": "3493"
        },
        "3530": {
            "ground_truth": "0",
            "bug_report": "Additional TypeConverters\nAdd TypeConverters to scala.xml.Elem from String  DOM Document  and DOM Node.",
            "id": "3530"
        },
        "3531": {
            "ground_truth": "0",
            "bug_report": "scala - xpath not working together with choice/when\nWhen using the Scala DSL  xpath expressions inside when() do not work as expected. As an example: 'direct:a' ==&gt; { choice { when (xpath('//hello')) to ('mock:english') when (xpath('//hallo')) { to ('mock:dutch') to ('mock:german') } otherwise to ('mock:french') } }// Send messages'direct:a' ! ('&lt;hello/&gt;'  '&lt;hallo/&gt;'  '&lt;hellos/&gt;')Here we should receive 1 message in each of the mocks. For whatever reason  all 3 messages go to mock:english. Similar routes work as expected with the Java DSL.",
            "id": "3531"
        },
        "3533": {
            "ground_truth": "0",
            "bug_report": "classpath problem with camel:dot and provided dependencies\ncamel:dot in is failing with a class not found exception when the application context instantiates a class in a jar with provided scope.If in your maven project you have: &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;and in your application context there is  for example  a subclass of ServletContextListener  mvn camel:dot fails with:...Caused by: java.lang.ClassNotFoundException:javax.servlet.ServletContextListener at java.net.URLClassLoader$1.run(URLClassLoader.java:217) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:205) at java.lang.ClassLoader.loadClass(ClassLoader.java:321) at java.lang.ClassLoader.loadClass(ClassLoader.java:266) ... 92 moreIf you change it to: &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;then camel-maven-plugin correctly generates the output. The fact isthat the servlet-api jar must not be included in the final war.I don't know the correct way to fix this. One option would be to add the includePluginDependencies option in the plugin and add the provided jars as runtime dependencies of the plugin.The other  very easy to implement  option would be to change the requiresDependencyResolution from runtime to test.The third option would be to make the requiresDependencyResolution configurable.Attached is a patch for the 2nd option (lazy me).",
            "id": "3533"
        },
        "3535": {
            "ground_truth": "1",
            "bug_report": "Aggregation fails to call onComplete for exchanges if the aggregation is after a bean or process.\nWhen creating a route that contains an aggregation  if that aggregation is preceded by a bean or process  it will fail to call AggregateOnCompletion.onComplete(). I've attached a unit test that can show you the behavior. Trace level loggging will need to be enabled to see the difference. With the call to the bean  it won't show the following log entry:TRACE org.apache.camel.processor.aggregate.AggregateProcessor - Aggregated exchange onComplete: Exchange[Message: ab]If you remove the bean call  it'll start calling onComplete() again.What I've noticed is that if this call is not made  it ends up in a memory leak since the inProgressCompleteExchanges HashSet in AggregateProcessor never has any exchange ID's removed.",
            "id": "3535"
        },
        "3538": {
            "ground_truth": "0",
            "bug_report": "PollingConsumerPollStrategy - Add information to commit how many messages was polled\nSee nabblehttp://camel.465427.n5.nabble.com/how-to-find-out-if-a-ftp-file-consumer-has-finished-reading-all-files-available-tp3337532p3337532.htmlHaving the number of messages polled allows end users to react accordingly. For example if there is 0 then they can do something special.",
            "id": "3538"
        },
        "3540": {
            "ground_truth": "0",
            "bug_report": "Jt400DataQueueConsumer incorrectly implements timeout semantics (jt400 component)\nJt400DataQueueConsumer implementation of receive(long) passes the timeout argument directly to com.ibm.as400.access.DataQueue.read(int)  not performing unit conversion. However  Jt400DataQueueConsumer.receive(long) accepts milliseconds  whereas DataQueue.read(int) accepts seconds as the time unit.Also  invoking Jt400DataQueueConsumer.receive() results in a call to DataQueue.read()  which is not a blocking call; on the contrary  it will not wait for entries.Code snippet below.Jt400DataQueueConsumer.java DataQueue queue = endpoint.getDataQueue(); try { DataQueueEntry entry; if (timeout &gt;= 0) { entry = queue.read((int)timeout); } else { entry = queue.read(); }Note that the submitted patch floors the timeout value when converting to seconds  but different rounding might be desired  which should be specified in the class documentation.",
            "id": "3540"
        },
        "3555": {
            "ground_truth": "0",
            "bug_report": "camel-jms - Improve logic waiting for ReplyTo destination to be computed when doing request/reply\nWhen you use request/reply over JMS a JMSReplyTo destination must be computed which happens async by the MessageListenerContainer which is to listen for the replies.The currently logic uses some low-level thread wait/notify scheme.We should change that to use the concurrency API using a countdown latch. That's much better.",
            "id": "3555"
        },
        "3559": {
            "ground_truth": "0",
            "bug_report": "Aggregator - The completionFromBatchConsumer option dont aggregate the last incoming exchange\nSee nabblehttp://camel.465427.n5.nabble.com/Last-Aggregated-Exchange-lost-Aggregator-with-a-Batch-Consumer-and-persistent-AggregationRepository-tp3346214p3346214.html",
            "id": "3559"
        },
        "3560": {
            "ground_truth": "0",
            "bug_report": "Detect uncaught exceptions in UoWProcessor to ensure UoW is done even for those uncaught exceptions\nThe Camel routing engines will handle this in 99.9% of the cases  but when you shutdown a Spring AC then Spring may stop beans in whatever order and this can cause those beans to fail operating during a graceful shutdown. And in worst case exceptions is thrown in situations where they are not normally done.To cater for that and other situations the UoWProcessor should detect this and act accordingly.This ensure the in flight registry will be tracked and we are not stuck with a missing inflight message  causing Camel to wait for the 300 sec timeout to shutdown.For example just try hitting ctrl + c in that camel-example-management and you can see such an example.",
            "id": "3560"
        },
        "3562": {
            "ground_truth": "0",
            "bug_report": "BindyFixedLengthDataFormat does a trim on Fixed Length record\nBindyFixedLengthDataFormat does a trim on Fixed Length record  although Fixed Length recordare strictly positional in nature and may contain lot of fillers with empty spaces  doing a trim causes Bindy to fail the message length validation and exception is thrown on message length // Read the line String line = scanner.nextLine().trim(); Should be changed to // Read the line String line = scanner.nextLine(); Or a conditional option should be provided in FixedLengthRecord annotation whether or not to trim the entire record",
            "id": "3562"
        },
        "3565": {
            "ground_truth": "0",
            "bug_report": "When Camel loads properties Camel should remove spaces (trim) from the end of the line.\nIf Camel reads a property from a properties-file that has a space at the end of a line like:some.property = theValue &lt;---Camel will resolve 'theValue ' and then crash at route creation. Should be 'theValue'.",
            "id": "3565"
        },
        "3568": {
            "ground_truth": "0",
            "bug_report": "Update archetypes to use new descriptor format\nCamel archetypes use the old descriptor format and give the following output:[INFO] ********************* End of debug info from resources from generated POM ***********************[INFO] project created from Old (1.x) Archetype in dir: /w1/apache/camel/projects/camel-xxxWe need to update to use the archetype-metadata.xml descriptor",
            "id": "3568"
        },
        "3570": {
            "ground_truth": "1",
            "bug_report": "camel-snmp - Should mask password in the endpoint class\nSee nabblehttp://camel.465427.n5.nabble.com/password-shown-in-plain-text-in-the-log-file-while-starting-amp-stopping-context-td3347883.htmlThe password should be masked which can be done by overriding toString and mask it in the output.",
            "id": "3570"
        },
        "3573": {
            "ground_truth": "0",
            "bug_report": "In some places we use ObjectHelper.loadClass() instead of ClassResolver.resolveClass()\nsee Nabble",
            "id": "3573"
        },
        "3584": {
            "ground_truth": "0",
            "bug_report": "Concurrent writes to the same file has race condition\nSee nabblehttp://camel.465427.n5.nabble.com/Using-Splitter-and-file-producer-with-option-fileExist-Append-failed-tp3353618p3353618.htmlWe need to synchronize on the file name to avoid concurrent writes to the same file.",
            "id": "3584"
        },
        "3588": {
            "ground_truth": "0",
            "bug_report": "JMS spec and JPA spec JARs should not be compile scoped by provided\nSee nabblehttp://camel.465427.n5.nabble.com/dependency-compile-scope-to-geronimo-XYZ-VERSION-spec-in-camel-jpa-amp-camel-jms-td3356320.html#a3356541",
            "id": "3588"
        },
        "3595": {
            "ground_truth": "0",
            "bug_report": "FTP rename fails\n(This is related to the user group discussion http://camel.465427.n5.nabble.com/Problem-renaming-existing-file-in-FTP-td3307670.html)When using a tmpPrefix when uploading  the rename from the tmp-file to the destination file fails  if the destination file is already present  even though the option fileExist=Override is used.We have the problem on just a few destination servers which all seems to be windows machines.I have fetched the 2.4 branch of camel-ftp to find out why it does not work  since the unit test you refer to in your previous post do excercise the problem.It appears that the cause of the problem is  that the FtpOperations.existsFile fails to return true  which then causes the code not to enter the part where it deletes the exisiting file.The reason for the FtpOperations.existsFile to return false  is  that the list of existing files has the directoryname prepended  e.g. I'm trying to upload Test.REN to folder test/rename  and in the code 'if (existing.equals(onlyName))' existing=test/rename/Test.REN and onlyName=Test.REN - which returns false - but causes the later rename to fail as the target folder did contain the Test.REN. My guess is that it is server dependent whether the returned list of names in the directory include the directory name or not?To fix this I have added the following line of code before the if-statementexisting = FileUtil.stripPath(FileUtil.normalizePath(existing));So it will strip the path part of the file name before comparing it to onlyName.",
            "id": "3595"
        },
        "3600": {
            "ground_truth": "0",
            "bug_report": "ServiceHelper - Avoid started/stopping service if already started/stopped\nWe should optimize ServiceHelper to detect if the service is already started/stopped (if it extends ServiceSupport  as then it provides state).Also DefaultEndpoint should extends ServiceSupport to provide state so we know if the endpoint is started/stopped.This avoid double starting or stopping services which is not needed.And some custom components may not work well if they are started twice  just because Camel handles it lifecycle and invokes start multiple times.Also refine the logging in ServiceHelper from TRACE to DEBUG level so its easier to spot the lifecycle.",
            "id": "3600"
        },
        "3612": {
            "ground_truth": "0",
            "bug_report": "Include test directories in the archetypes\nA reader of Camel in Action pointed out that typically folks write unit tests for their projects so we should of course add the test directories (empty or not) to the archetypes (http://www.manning-sandbox.com/thread.jspa?threadID=41702&amp;tstart=0). I agree but of course this is not possible with the current archetype descriptor we are using. Will do this once CAMEL-3611 is complete.",
            "id": "3612"
        },
        "3616": {
            "ground_truth": "0",
            "bug_report": "camel-josql doesnot export org.apache.camel.language.sql.*\ncamel-josql doesnot export org.apache.camel.language.sql.*",
            "id": "3616"
        },
        "3617": {
            "ground_truth": "0",
            "bug_report": "Inconsistent filename value when move attribute is used with File component\nUnless I miss a point  when I use the following endpoint  the file:name value is incorrect and is equal to file:absolute.path&lt;endpoint id='fileEndpoint' uri='file:${queue.input.folder}?recursive=true&amp;include=.*/.dat&amp;move=${queue.done.folder}/$simple{file:name}&amp;moveFailed=${queue.failed.folder}/$simple{file:name}' /&gt;${queue.input.folder}  ${queue.done.folder} and ${queue.failed.folder} are absolute paths resolved by Spring.In fact  Camel tries to move the file to ${queue.done.folder}/${queue.input.folder}/$simple{file:name}I've also tried using $simple{header.CamelFileName} instead of $simple{file:name} and it gives the same result.For now  I've found a workaround using a processor which put the CamelFileName header value into a 'destFile' property &lt;endpoint id='fileEndpoint' uri='file:${queue.input.folder}?recursive=true&amp;include=.*/.dat&amp;move=${queue.done.folder}/$simple{property.destFile}&amp;moveFailed=${queue.failed.folder}/$simple{property.destFile}' /&gt;",
            "id": "3617"
        },
        "3624": {
            "ground_truth": "0",
            "bug_report": "camel-smpp should unbind from SMSC before disconnecting\nSee Nabble",
            "id": "3624"
        },
        "3633": {
            "ground_truth": "0",
            "bug_report": "Force disable Quartz UpdateChecker\nThis is really terrible that Terracotta added a 'malware' kinda feature in Quartz that automatic checks if there is a new version of Quartz. WTF that doesn't work nice in enterprises  where they want to be in control of their communication.We should force disabling this.See more details here:http://forums.terracotta.org/forums/posts/list/3395.page#19058https://jira.terracotta.org/jira/browse/QTZ-29",
            "id": "3633"
        },
        "3637": {
            "ground_truth": "0",
            "bug_report": "Mistake in camel-eventAdmin feature\nThe Camel Karaf feature camel-eventAdmin is not correct.The features is described as follow:&lt;feature name='camel-eventAdmin' version='2.6.0'&gt; &lt;feature version='2.6.0'&gt;camel-core&lt;/feature&gt; &lt;bundle&gt;mvn:org.apache.camel/camel-eventAdmin/2.6.0&lt;/bundle&gt;&lt;/feature&gt;but the camel-eventAdmin artifact correct name is camel-eventadmin:http://repo2.maven.org/maven2/org/apache/camel/camel-eventadmin/2.6.0/camel-eventadmin-2.6.0.jarThis typo mistake provides:Downloading: http://repo1.maven.org/maven2/org/apache/camel/camel-eventAdmin/2.6.0/camel-eventAdmin-2.6.0.jar&#91;INFO&#93; Unable to find resource 'org.apache.camel:camel-eventAdmin:jar:2.6.0' in repository central (http://repo1.maven.org/maven2)&#91;INFO&#93; ------------------------------------------------------------------------&#91;ERROR&#93; BUILD FAILURE&#91;INFO&#93; ------------------------------------------------------------------------&#91;INFO&#93; Can't resolve bundle org.apache.camel:camel-eventAdmin:jar:2.6.0&#91;INFO&#93; ------------------------------------------------------------------------I'm gonna submit a patch to fix that.",
            "id": "3637"
        },
        "3638": {
            "ground_truth": "0",
            "bug_report": "Upgrade maven-bundle-plugin to version 1.3.4\nAccording to Guillaume Nodet we should try to upgrade to the 1.3.4 version of the maven bundle plugin as it simplyfies several osgi related definitions.I will do a full build before committing but as far as I know we do not test in osgi so we need some testing in osgi too. Perhaps Willem can run some servicemix tests.",
            "id": "3638"
        },
        "3644": {
            "ground_truth": "0",
            "bug_report": "camel-core-xml - Add getter/sett for endpoints\nWe have listed @XmlElement(name = 'endpoint'  required = false) private List&lt;CamelEndpointFactoryBean&gt; endpoints;in the camel-spring  but we dont have getter/setter.We should enforce this by adding getter/setter in camel-core-xml which we have for most of the stuff.",
            "id": "3644"
        },
        "3647": {
            "ground_truth": "0",
            "bug_report": "Fix the Sonar Blocker: Performance - Maps and sets of URLs can be performance hogs\nThe Camel Sonar Pilot lists 4 blocker for Camel &#91;1&#93;. All in org.apache.camel.impl.converter.AnnotationTypeConverterLoader because it use the URL.equals() and URL.hashCode() methods.You can find the explanation in &#91;2&#93; why this is not a good idea. I would like to change it url.toURI()? Any doubt?&#91;1&#93; http://sonar.apache.org/drilldown/violations/org.apache.camel:camel?priority=BLOCKER#&#91;2&#93; http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html",
            "id": "3647"
        },
        "3650": {
            "ground_truth": "0",
            "bug_report": "SMSC initiated unbind spawns exponential amounts of reconnect threads\nIt took me a bit of time to put my finger on this problem.When an unbind PDU is sent from the SMSC side to a camel-smpp endpoint  a cascading amount reconnect threads are spawned by the reconnect code. I can reliably re-produce this problem having a simple smpp consumer to a SMSC / simulator and issuing an unbind from the SMSC / simulator.Here are some logs (I have added additional debug messages to the SmppConsumer to show the object references and state of the SmppSession objects):",
            "id": "3650"
        },
        "3654": {
            "ground_truth": "0",
            "bug_report": "BinaryPredicate - Dont store state to ensure thread safety\nWe should introduce a new matches method which is used by mock's when they report failure messages. The new method should return the failure message which ensures we dont have to store state on the binary predicate instance.",
            "id": "3654"
        },
        "3666": {
            "ground_truth": "0",
            "bug_report": "Make Content-Type HTTP Header Optional\nAs per section 7.2.1 of RFC 2616  any HTTP/1.1 message containing an entity-body SHOULD (not MUST) include a Content- Type header field defining the media type of that body.The populateExchangeFromRestletRequest method of the DefaultRestletBinding class  unlike others in the same class  needs to be changed:if (request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM)) { ...} else { inMessage.setBody(request.getEntity().getStream());}",
            "id": "3666"
        },
        "3672": {
            "ground_truth": "0",
            "bug_report": "Make it easier to derive from the Camel model\nIn order to facilitate the building of derivations of Camel  some methods in builder and model need to use accessors for member variables  and types to allow for sub types",
            "id": "3672"
        },
        "3678": {
            "ground_truth": "0",
            "bug_report": "Java DSL - Allow load balancer to be used inside CBR\nWe should allow to use the load balancer inside the CBR  in eg the when predicate.See nabblehttp://camel.465427.n5.nabble.com/DISCUSS-Java-DSL-caveat-with-the-Content-Based-Router-td3389083.html",
            "id": "3678"
        },
        "3690": {
            "ground_truth": "0",
            "bug_report": "Endpoints may be shutdown twice as they are tracked in two lists in CamelContext\nEndpoint is a Service which means they are listed in both a endpoint and service list. They should only be listed in the endpoint list.This avoids issues with endpoints may be shutdown twice when Camel shutdown.See nabblehttp://camel.465427.n5.nabble.com/QuartzComponent-do-not-delete-quartz-worker-threads-when-shutdown-Camel-tp3393728p3393728.html",
            "id": "3690"
        },
        "3708": {
            "ground_truth": "0",
            "bug_report": "Tidy up AST model to proper support output or not\nWe should tidy up the model  so they clearly indicate if outputs supported no outputseg when an EIP supports output  they can be nested/added to it  eg in XML its like&lt;split&gt; &lt;output 1&gt; &lt;output 2&gt;&lt;/split&gt;But some EIPs indicate they support output  but they dont. For example &lt;to&gt; should not support output as it doesn't make sense.We should introduce a isOutputSupported on the ProcessorDefinition and then check each EIP.This will cause changes to the XSD in that regard EIPs which really didn't support output (eg it was hacked that way in Java code) but the XSD would allow outputs  eg&lt;to uri='xxx'&gt; &lt;output 1&gt; &lt;output 2&gt;&lt;/to&gt;Now this would not be possible and you would have to do&lt;to uri='xxx'/&gt;&lt;output 1&gt;&lt;output 2&gt;This will in fact reduce the XSD and make it more concise when outputs is supported or not.",
            "id": "3708"
        },
        "3709": {
            "ground_truth": "0",
            "bug_report": "interceptFrom and from(Endpoint) don't work together\nWhen using interceptFrom(String) together with from(Endpoint)  the below Exception occurs during the routes building process. Looking at RoutesDefinition.java:217 reveals  that the FromDefintion just created has no URI. That causes the comparison to all the interceptFroms' URIs to fail. As far as I can tell  the way to fix this would be to add setUri(myEndpoint.getEndpointUri()) in the constructor FromDefinition(Endpoint endpoint).Below the stack trace  there is a unit test that demonstrates the issue. Until it if fixed  it can be easily circumvented by adding the commented-out line  and then change to from('myEndpoint').org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: null due to: null at org.apache.camel.util.EndpointHelper.matchEndpoint(EndpointHelper.java:109) at org.apache.camel.model.RoutesDefinition.route(RoutesDefinition.java:217) at org.apache.camel.model.RoutesDefinition.from(RoutesDefinition.java:167) at org.apache.camel.builder.RouteBuilder.from(RouteBuilder.java:101) at dk.mobilethink.adc2.endpoint.UnsetUriTest$1.configure(UnsetUriTest.java:18) at org.apache.camel.builder.RouteBuilder.checkInitialized(RouteBuilder.java:318) at org.apache.camel.builder.RouteBuilder.configureRoutes(RouteBuilder.java:273) at org.apache.camel.builder.RouteBuilder.addRoutesToCamelContext(RouteBuilder.java:259) at org.apache.camel.impl.DefaultCamelContext.addRoutes(DefaultCamelContext.java:612) at org.apache.camel.test.CamelTestSupport.setUp(CamelTestSupport.java:111) at junit.framework.TestCase.runBare(TestCase.java:132) at org.apache.camel.test.TestSupport.runBare(TestSupport.java:65) at junit.framework.TestResult$1.protect(TestResult.java:110) at junit.framework.TestResult.runProtected(TestResult.java:128) at junit.framework.TestResult.run(TestResult.java:113) at junit.framework.TestCase.run(TestCase.java:124) at junit.framework.TestSuite.runTest(TestSuite.java:232) at junit.framework.TestSuite.run(TestSuite.java:227) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)Caused by: java.lang.NullPointerException at org.apache.camel.util.UnsafeUriCharactersEncoder.encode(UnsafeUriCharactersEncoder.java:56) at org.apache.camel.util.URISupport.normalizeUri(URISupport.java:162) at org.apache.camel.util.EndpointHelper.matchEndpoint(EndpointHelper.java:107) ... 24 morepackage dk.mobilethink.adc2.endpoint;import org.apache.camel.Endpoint;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.test.CamelTestSupport;public class UnsetUriTest extends CamelTestSupport { @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { public void configure() throws Exception { interceptFrom('URI1').to('irrelevantURI'); Endpoint myEndpoint = getContext().getComponent('direct').createEndpoint('ignoredURI'); // getContext().addEndpoint('myEndpoint'  myEndpoint); from(myEndpoint) .inOnly('log:foo'); } }; } public void testNothing() { }}",
            "id": "3709"
        },
        "3711": {
            "ground_truth": "0",
            "bug_report": "OnException - The order they are defined in the RouteBuilder / XML should be preserved when you have multiple of the same exception type\nWhen you have 2+ of onException(MyExcpetion.class) then the order may get reversed  in the logic which prepares the routes. The logic should cater for clashes and ensure orders is preserved.This currently only occurs for XML based routes. The Java DSL works.",
            "id": "3711"
        },
        "3714": {
            "ground_truth": "0",
            "bug_report": "camel-jms: testConnectionOnStartup does not test connection for producers\nI have a camel context which configures jms producers  but no jms consumers. With this configuration  the 'testConnectionOnStartup' jms option did not test the connection when I started the camel context. I have discovered that (with the current implementation) the 'testConnectionOnStartup' option only applies to consumers. I see that it is implemented in JmsConsumer.doStart() -&gt; JmsConsumer.testConnectionOnStartup(). It would be useful if this option could also applied to producers.As a workaround  I configured a dummy route and a dummy jms consumer.",
            "id": "3714"
        },
        "3715": {
            "ground_truth": "0",
            "bug_report": "Sending to http endpoint may double encoding parameters\nSee nabbleThe workaround is to use either HTTP_URI or HTTP_QUERY as a header with the parameters. Then they are not double encoded.Also the HTTP_URI should be placeholder resolved  so we can use port or the likes to inject the port number dynamic.",
            "id": "3715"
        },
        "3721": {
            "ground_truth": "0",
            "bug_report": "Camel properties component - Add support for using jvm system/env in location\nFor example you may want to say {{location=${karaf.hom}/etc/myprop.properties}}.eg where karaf.home is a jvm system property.Take a look at simple as we may want to be able to lookup environment variable also.",
            "id": "3721"
        },
        "3722": {
            "ground_truth": "0",
            "bug_report": "ThreadPoolProfile - Use string types so its much easier to use property placeholders\nIn the XML DSL you can use threadPoolProfile to define profiles for thread pools. People may want to use property placeholders for min/max values etc. Using xs:string is thus much easier to do that. We do that for some of the others such as &lt;jmxAgent&gt;",
            "id": "3722"
        },
        "3729": {
            "ground_truth": "0",
            "bug_report": "JAXB marshaling broken in 2.6.0\nThis used to work in 2.5.0 but in 2.6.0 it throws:Caused by: javax.xml.bind.JAXBException: class com.ask.ugc.camel.Jask3061$Foo nor any of its super class is known to this context. at com.sun.xml.bind.v2.runtime.JAXBContextImpl.getBeanInfo(JAXBContextImpl.java:594) at com.sun.xml.bind.v2.runtime.XMLSerializer.childAsRoot(XMLSerializer.java:482) at com.sun.xml.bind.v2.runtime.MarshallerImpl.write(MarshallerImpl.java:315) at com.sun.xml.bind.v2.runtime.MarshallerImpl.marshal(MarshallerImpl.java:244) at javax.xml.bind.helpers.AbstractMarshallerImpl.marshal(AbstractMarshallerImpl.java:75) at org.apache.camel.converter.jaxb.JaxbDataFormat.marshal(JaxbDataFormat.java:117) at org.apache.camel.converter.jaxb.JaxbDataFormat.marshal(JaxbDataFormat.java:96)...@ContextConfiguration( locations = 'foo.bar.JaxbBug$ContextConfig'  loader = JavaConfigContextLoader.class)public class JaxbBug extends AbstractTestNGSpringContextTests { @EndpointInject(uri = 'mock:end') protected MockEndpoint mockEndpoint; @Produce(uri = 'direct:test') protected ProducerTemplate producer; @Test @DirtiesContext public void testJaxbMarshalling() throws InterruptedException { mockEndpoint.expectedMessageCount(1); producer.sendBody(new Foo()); mockEndpoint.assertIsSatisfied(); } @Configuration public static class ContextConfig extends SingleRouteCamelConfiguration { @Bean public RouteBuilder route() { return new RouteBuilder() { @Override public void configure() throws Exception { JaxbDataFormat jaxb = new JaxbDataFormat(JAXBContext.newInstance(Foo.class)); from('direct:test').marshal(jaxb).to('mock:end'); } }; } } @XmlRootElement public static class Foo { String bar; public String getBar() { return bar; } public void setBar(String bar) { this.bar = bar; } }}",
            "id": "3729"
        },
        "3731": {
            "ground_truth": "0",
            "bug_report": "IgnoreInvalidEndpoint should log invalid endpoints at DEBUG level\nCurrently its logged at INFO level with full stacktrace. If end user enabled this option we should only log it at DEBUG level to avoid spamming production logs.See nabblehttp://camel.465427.n5.nabble.com/camel-recipientList-with-ignoreInvalidEndpoints-true-tp3404103p3404103.html",
            "id": "3731"
        },
        "3733": {
            "ground_truth": "0",
            "bug_report": "Add comments on the CamelContextTestSupport class to tell user to start the camel context manually when the test doesn't use the RouteBuilder\nCurrent CamelContextTestSupport class will not start the camelcontext if the isUseRouteBuilder() return false.If the component that is used by template needs to be started  your test method will get the NPE or some strange error.And you can these load when shutting down the camel context.Mar 1  2011 4:31:29 PM org.apache.camel.test.junit4.CamelTestSupport tearDownINFO: Testing done: com.fusesource.example.camel.cxf.jms.HelloWorldClient@e49d67cMar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultCamelContext doStopINFO: Apache Camel 2.6.0-fuse-00-00 (CamelContext:camel-1) is shutting downMar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultCamelContext createManagementStrategyINFO: JMX is disabled. Using DefaultManagementStrategy.Mar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultShutdownStrategy doShutdownINFO: Starting to graceful shutdown 0 routes (timeout 10 seconds)Mar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultShutdownStrategy doShutdownINFO: Graceful shutdown of 0 routes completed in 0 secondsMar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultCamelContext doStopINFO: Uptime: not startedMar 1  2011 4:31:29 PM org.apache.camel.impl.DefaultCamelContext doStopINFO: Apache Camel 2.6.0-fuse-00-00 (CamelContext: camel-1) is shutdown in 0.023 seconds",
            "id": "3733"
        },
        "3738": {
            "ground_truth": "0",
            "bug_report": "Let log  log eip and mock producer be async processor\nWe should prefer to use the async processor for the Camel EIPs and components when possible. This avoids the tiny overhead of having a sync to async adapter (implemented using a converter).",
            "id": "3738"
        },
        "3749": {
            "ground_truth": "0",
            "bug_report": "sftp producer runs in exception fileName does not contain any path information\nWhen the fileName uri option does not contain any folder information  ie: 'fileName=filename.txt' the producer runs in exceptionThe exception is thrown when the producer calls ls method of jsch ChannelSftp passing an empty string as directory parameter in org.apache.camel.component.file.remote.SftpOperations.existsFile line 704sample URI: sftp://user@hostname:22?disconnect=true&amp;eagerDeleteTargetFile=false%3Bstepwise%3Dfalse&amp;fileName=SYSTEM01&amp;password=******&amp;soTimeout=30000&amp;tempFileName=%24%7Bfile%3Aname.noext%7D.tmpStack trace:[2011-03-03 14:40:40 827][RecipientList (thread #4)][ERROR][org.apache.camel.processor.DefaultErrorHandler][] Failed delivery for exchangeId: ID-******-33331-1299163043684-0-10. Exhausted after delivery attempt: 1 caught: org.apache.camel.component.file.GenericFileOperationFailedExcept on: org.apache.camel.component.file.GenericFileOperationFailedException: at org.apache.camel.component.file.remote.SftpOperations.existsFile(SftpOperations.java:727) at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:130) at org.apache.camel.component.file.remote.RemoteFileProducer.process(RemoteFileProducer.java:50) at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:103) at org.apache.camel.processor.MulticastProcessor.doProcessParallel(MulticastProcessor.java:716) at org.apache.camel.processor.MulticastProcessor.access$100(MulticastProcessor.java:78) at org.apache.camel.processor.MulticastProcessor$1.call(MulticastProcessor.java:282) at org.apache.camel.processor.MulticastProcessor$1.call(MulticastProcessor.java:274) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619) Caused by: 4: at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1353) at org.apache.camel.component.file.remote.SftpOperations.existsFile(SftpOperations.java:704) ... 20 more Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 0 at java.lang.String.charAt(String.java:686) at com.jcraft.jsch.ChannelSftp.remoteAbsolutePath(ChannelSftp.java:2367) at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1185) ... 21 more",
            "id": "3749"
        },
        "3756": {
            "ground_truth": "0",
            "bug_report": "Add an example which use CXF bean binding and the OSGI HTTP Service (e.g. PAX Web with jetty)\nPlease see Nabble for details.",
            "id": "3756"
        },
        "3759": {
            "ground_truth": "0",
            "bug_report": "After switching to slf4j  we can get rid of the 'isTraceEnabled'  'isDebugEnabled' and 'isInfoEnabled' statements\nwe can get rid of the 'isTraceEnabled'  'isDebugEnabled' and 'isInfoEnabled' statements with slf4j and uselogger.debug('Temperature set to {}. Old temperature was {}.'  t  oldT);insteadchristian-muellers-macbook-pro:camel cmueller$ egrep -r 'isTraceEnabled|isDebugEnabled|isInfoEnabled]' . | wc -l 1485",
            "id": "3759"
        },
        "3769": {
            "ground_truth": "0",
            "bug_report": "Mail component issue with starttls option\nThe problem occurs when I read from a pop3 endpoint and send to an smtp endpoint in the same camel context with the mail.pop3.starttls.enable=true and mail.smtp.starttls.enable=true options.Required Java options for starttls are set:-Djavax.net.ssl.trustStore=D:/test/xxx.jks-Djavax.net.ssl.trustStorePassword=yyyWhen I only configure one of either route  everything works fine. When I configure both  I get the following exception:AUTH LOGINC: STAT530 Must issue STARTTLS command firstSTARTTLSS: +OK 0 0C: NOOP220 begin TLS negotiationS: +OKC: RSETS: +OKC: QUITAUTH LOGINS: +OK POP3 server closing connection503 wrong state for AUTH command2011-03-03 10:08:36 797 &#91;foo&#93; ERROR DefaultErrorHandler - Failed delivery for exchangeId: ID-E6500-ahi-61446-1299143304838-0-2. Exhausted after delivery attempt: 1 caught: org.springframework.mail.MailAuthenticationException: Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 503 wrong state for AUTH commandorg.springframework.mail.MailAuthenticationException: Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 503 wrong state for AUTH command at org.springframework.mail.javamail.JavaMailSenderImpl.doSend(JavaMailSenderImpl.java:392)&#91;org.springframework.context.support-3.0.5.RELEASE.jar:3.0.5.RELEASE&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:340)&#91;org.springframework.context.support-3.0.5.RELEASE.jar:3.0.5.RELEASE&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:355)&#91;org.springframework.context.support-3.0.5.RELEASE.jar:3.0.5.RELEASE&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:344)&#91;org.springframework.context.support-3.0.5.RELEASE.jar:3.0.5.RELEASE&#93; at org.apache.camel.component.mail.MailProducer.process(MailProducer.java:44)&#91;camel-mail-2.6.0.jar:2.6.0&#93; at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:104)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:272)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:98)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:125)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:102)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.RoutePolicyProcessor.process(RoutePolicyProcessor.java:75)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:91)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.component.timer.TimerConsumer.sendTimerExchange(TimerConsumer.java:104)&#91;camel-core-2.6.0.jar:2.6.0&#93; at org.apache.camel.component.timer.TimerConsumer$1.run(TimerConsumer.java:49)&#91;camel-core-2.6.0.jar:2.6.0&#93; at java.util.TimerThread.mainLoop(Unknown Source)&#91;:1.5.0_22&#93; at java.util.TimerThread.run(Unknown Source)&#91;:1.5.0_22&#93;The problem seems to be in org.apache.camel.component.mail.MailConfiguration.createJavaMailSender() where it uses the same mail session for both connection; see Session.getDefaultInstance below if (session != null) { answer.setSession(session); } else { // use our authenticator that does no live user interaction but returns the already configured username and password Session session; try { session = Session.getDefaultInstance(answer.getJavaMailProperties()  getAuthenticator()); } catch (Throwable t) { // fallback as default instance may not be allowed on some systems session = Session.getInstance(answer.getJavaMailProperties()  getAuthenticator()); } answer.setSession(session); }This is because getDefaultInstance creates a Session object the first time it is called. Then it caches that Session and returns it for all subsequent calls. It also ignores the new and different properties for the second route.See also http://camel.465427.n5.nabble.com/Mail-component-with-starttls-td3409505.html",
            "id": "3769"
        },
        "3779": {
            "ground_truth": "1",
            "bug_report": "HttpProducer drops authentification parameters.\nHi  I run into the following problem with Camel 2.6.0:An HTML file contain an URI lists of files to be downloaded from a web server to the local file system.The HTML file is parsed via a Java Bean Splitter. The Java Bean Splitter produces a Set of URI strings.These files should be downloaded from a web server to the local file system. The files are protected with BASIC authentification.The extraction and the splitting of the download URIs works quite well with the Java Bean Splitter.The Java Bean Splitter produces URI like: http4://download.acme.com/file_1.txt?username=foo&amp;password=baaHere's the setup:&lt;route&gt; &lt;from uri='file:///tmp/files_to_retrieve/' /&gt; &lt;method bean='prepareDownLoadUri' method='parseIndexHtml' /&gt; &lt;setHeader headerName='CamelHttpMethod'&gt; &lt;constant&gt;GET&lt;/constant&gt; &lt;/setHeader&gt; &lt;setHeader headerName='CamelHttpUri'&gt; &lt;simple&gt;${body}&lt;/simple&gt; &lt;/setHeader&gt; &lt;to uri='http4://download.acme.com/' /&gt; &lt;to uri='bean:saveFileProcessor' /&gt;&lt;/route&gt;&lt;bean id='prepareDownLoadUri' class='com.acme.PrepareDownLoadUri' /&gt;&lt;bean id='saveFileProcessor' class='com.acme.SaveFileProcessor' /&gt;The injection of the URIs from the Splitter into the HttpProducer  works quite well. I debugged into the HttpProducer and it seems  that the HttpProducer does not provide the unterlying http client (in this case Apache HttpClient 4) with the authentification settings from the URI.At first  the queryString is extracted from the Exchange-Header (if provided)HttpProducer.createMethod()  line 273String url = HttpHelper.createURL(exchange  getEndpoint());The url string contains the URI produces by the splitter including the authentification parameters: http4://download.acme.com/file_1.txt?username=foo&amp;password=baaThen the HttpProducer assembles a new URI for the requests. The new URI is assembled from parts of the string url (line 273) and other parameters from the Exchange Header: HttpProducer.createMethod()  lines 285-300 // is a query string provided in the endpoint URI or in a header (header overrules endpoint) String queryString = exchange.getIn().getHeader(Exchange.HTTP_QUERY  String.class); if (queryString == null) { queryString = getEndpoint().getHttpUri().getRawQuery(); } StringBuilder builder = new StringBuilder(uri.getScheme()).append('://').append(uri.getHost()); if (uri.getPort() != -1) { builder.append(':').append(uri.getPort()); } if (uri.getPath() != null) { builder.append(uri.getRawPath()); } if (queryString != null) { builder.append('?'); builder.append(queryString); } HttpRequestBase httpRequest = methodToUse.createMethod(builder.toString());The problem is  in the assembling of the new URI  the authentification parameters are dropped. One possible solution could be:  check for authentification parameters in the url (line 273) and extract them. build the credentials  AuthScheme and provide it to the underlying http client.thanks in advance ben",
            "id": "3779"
        },
        "3782": {
            "ground_truth": "0",
            "bug_report": "option to force sending original JMS message\nWhen using mapJmsMessage=false you would think that Camel would send along the original JMS message. However  if you touch the Camel Message headers (get or set) this effectively disables the mapJmsMessage option. I came across this issue when using the failover loadbalancer. We should add an option to force Camel to send along the orginal JMS message.",
            "id": "3782"
        },
        "3788": {
            "ground_truth": "0",
            "bug_report": "HTTP Producer seems to send an empty body request on redelivery when the original request fails due to a connection timeout\nCamel HTTP Producer is throwing an exception when it encounters a connection timeout. However instead of preserving the original message it is treating it processing the exception output. When connected to a redelivery meachanism  this results in an exception message being sent as input to the HTTP Consumer. The older versions of Camel behaved differently on read timeout. In Camel 1.x  in a read timeout  the Exception is thrown and the input message to the producer is passed through the pipeline. Now there is a difference: An exception is thrown and the output of the HTTP Producer is passed through the pipeline. Need to study why and what changed since Camel 1.x and ensure that the above does not happen.For more details  please check out the following nabble entryhttp://camel.465427.n5.nabble.com/Http-route-returning-with-200-but-also-getting-read-timed-out-td3741631.html#a3897410Cheers Ashwin...",
            "id": "3788"
        },
        "3789": {
            "ground_truth": "0",
            "bug_report": "org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy is not thread-safe\nMarkerFileExclusiveReadLockStrategy is not thread-safe. When I run a File endpoint with more than one thread the MarkerFileExclusiveReadLockStrategy only deletes the last file to start being processed. The MarkerFileExclusiveReadLockStrategy uses global variables: private File lock; private String lockFileName; and gives them values on the acquireExclusiveReadLock method. When another thread calls the releaseExclusiveReadLock method it uses the global variables to delete the locked file. That means that if another thread came and called the acquireExclusiveReadLock it would have changed the values on the global variables. If lock and lockFileName are not global variables the problem seems to disappear and I can a multithreaded File endpoint and not locked file is left undeleted.",
            "id": "3789"
        },
        "3793": {
            "ground_truth": "0",
            "bug_report": "Try to copy file when rename fails\nI have a setup where I use file component to move files after being processed ou when processing fails.As I have no troubles neither on my development workstation neither on local directory on my linux environnement. It fails when the monitored directory is a NFS mounted directory pointing to a Windows 2008 Server shared directory.While it's not a camel bug  the generated logs are just useless because we can't get the reason of failure.Investigating the source code tells me that the File.renameTo method is used (with the three times try hack for Windows   so I can't get any further information on the reason.Could you implement a fallback strategy like copy the file and delete the original one ? (should it be made optional)To workaround this  I currently do the move operations manually by invoking the FileUtils.moveTo(...) from commons-io (which implements exactly the fallback method I described on renameTo failure).But  I have side effects as I'm forced to use the noop attribute.(in fact  it doesn't explain why the rename fails  but it works  and should it be a failure I'll get an explicit error message).",
            "id": "3793"
        },
        "3794": {
            "ground_truth": "1",
            "bug_report": "Polish the aws component\nPolish the aws component",
            "id": "3794"
        },
        "3797": {
            "ground_truth": "0",
            "bug_report": "Web Console: NPE when browsing routes with no description\nWhen some of the routes does not have a description NPE will be thrown  because of the code${i.getDescription.getText}To prevent it  just use${i.getDescriptionText}",
            "id": "3797"
        },
        "3799": {
            "ground_truth": "0",
            "bug_report": "maven eclipse goal failure\nThe error is:[ERROR] BUILD ERROR[INFO] ------------------------------------------------------------------------[INFO] Request to merge when 'filtering' is not identical. Original=resource src/main/resources: output=target/classes  include=[]  exclude=[**/*.java]  test=false  filtering=false  merging with=resource src/main/resources: output=target/classes  include=[**/archetype-metadata.xml]  exclude=[**/*.java]  test=false  filtering=trueand it seems to be resolved in the upcoming maven-eclipse-plugin:2.9.0 (see MECLIPSE-576). An update to the new release of the plugin  once available  should resolve this.",
            "id": "3799"
        },
        "3804": {
            "ground_truth": "1",
            "bug_report": "The camel-cometd component does not support a custom SecurityPolicy or Extension as described on http://cometd.org/documentation/howtos/authentication\nThe camel-cometd component does not support a custom SecurityPolicy or Extension as described on http://cometd.org/documentation/howtos/authenticationA simple solution is to add setters for SecurityPolicy and Extension to the component. If these attributes are set then also set them on the underlying AbstractBayeux class.About the patch:The existing unit test is based on an interactive scenario that involves human intervention. A similar test is made that uses an extension and another one is made that needs authentication. To provide feedback on a failed authentication a cometd listener is used. The version of the cometd-dojo extension used does not support listeners so this dojo extension has also been upgraded to 1.1.4.",
            "id": "3804"
        },
        "3812": {
            "ground_truth": "0",
            "bug_report": "BeanInfo not reset when new bean looked up\nIn camel-bean  when a bean is looked-up and it is not the same bean as the previous one beanInfo has to be reset.This is done in getBean() method of org.apache.camel.component.bean.RegistryBean but the test is placed after setting bean=value so beanInfo is never reset :if (value != bean) {  bean = value;  processor = null;  if (!ObjectHelper.equal(ObjectHelper.type(bean)  ObjectHelper.type(value))) { beanInfo = null; }",
            "id": "3812"
        },
        "3824": {
            "ground_truth": "0",
            "bug_report": "Allow cometd component to send message headers with the message\nCurrently the cometd component ignores message headers. ======Code snippet from CometdConsumer.java: Message message = new DefaultMessage(); message.setBody(data); Exchange exchange = endpoint.createExchange(); exchange.setIn(message);======Exchange message headers should be maintained (perhaps with a flag?).",
            "id": "3824"
        },
        "3828": {
            "ground_truth": "0",
            "bug_report": "camel-jms default cache level should be CACHE_NONE when transaction is enabled\nI lost a huge amount of time chasing the problem as the default value just screw the whole transaction (the session is created outside the transaction and cached  so usually not enlisted in the tx).",
            "id": "3828"
        },
        "3834": {
            "ground_truth": "0",
            "bug_report": "SmppProducer sends incorrect data_coding parameter\nThe dataCoding parameter on the SMPP uri allows for a value of 0 4  or 8. Our aggregator expects the data_coding parameter on the SMPP request from the SmppProducer to be 0=SMSC Default Alphabet. However  when 0  4  or 8 is specified for the dataCoding parameter  the actual value sent on the smpp request is 1  5  or 9. It appears the MessageClass.Class1 on the GeneralDataCoding object in SmppProducer is masking an additional 1 to the byte value.It seems the dataCoding parameter should allow you to specify the actual value that is needed as defined by the SMPP Protocol specification.",
            "id": "3834"
        },
        "3849": {
            "ground_truth": "0",
            "bug_report": "OSGi - No possibility to enable ehcache clustering as: ehcache.xml is ignored and there is no possibility to set cacheManagerFactory described camel-cache docs\nThis bug is caused by more than one problem as:1. camel-cache bundle provides ehcache.xml config which is ignored so then default ehcache-failsafe.xml is taken by ehcache bundle.2. according to camel-cache docs there is a way to set cacheManagerFactory but it seems to be not implemented asa) default CacheManagerFactory instance is created when when CacheComponent is instantiated.b) setter method: public void setCacheManagerFactory(CacheManagerFactory cacheManagerFactory) is used just nowhere.c) there is no suitable filed in class CacheConfigurationAll above problems cause camel-cache to be not able to work in java- clustered world as default failsafe config. is really failsafe- w/o clustering.",
            "id": "3849"
        },
        "3852": {
            "ground_truth": "0",
            "bug_report": "camel-cache - Should use Camel style constant keys\nThe CacheConstant use all upper cases and they are not using the Camel style which we should use.It should be'CamelCacheAdd' instead of 'ADD'and so forth.This also ensures those headers is not propagated over remote transports as they should not.In fact we should consider removing those headers in the camel-cache code as they are just input parameters to control the operation.",
            "id": "3852"
        },
        "3861": {
            "ground_truth": "1",
            "bug_report": "camel-web - Cannot browse endpoints if messages was consumed from jms queue\nYou get a NPE if you brows the endpoint.Caused by: java.lang.NullPointerException at org.apache.camel.web.resources.$scalate$ExchangeResource_index_ssp$$anonfun$$scalate$render$2.apply(ExchangeResource.index.ssp.scala:46) at org.apache.camel.web.resources.$scalate$ExchangeResource_index_ssp$$anonfun$$scalate$render$2.apply(ExchangeResource.index.ssp.scala:40) at scala.collection.Iterator$class.foreach(Iterator.scala:631)",
            "id": "3861"
        },
        "3873": {
            "ground_truth": "1",
            "bug_report": "camel-xmpp - Should stop and clean session  so hot-deploy works\nSee this stacktrace14:10:55 806 | ERROR | ExtenderThread-8 | ContextLoaderListener | 72 - org.springframework.osgi.extender - 1.2.0 | Application context refresh failed (OsgiBundleXmlApplicationContext(bundle=qbus-camel-osgi  config=osgibundle:/META-INF/spring/*.xml))org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: Endpoint[xmpp://articleRoute@localhost?password=******&amp;room=mechatron%40conference.mw-pc]. Reason: java.lang.NullPointerException at org.apache.camel.impl.ProducerCache.doGetProducer(ProducerCache.java:362)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ProducerCache.acquireProducer(ProducerCache.java:93)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ProducerCache.startProducer(ProducerCache.java:124)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.SendProcessor.doStart(SendProcessor.java:146)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.DelegateAsyncProcessor.doStart(DelegateAsyncProcessor.java:77)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.DelegateAsyncProcessor.doStart(DelegateAsyncProcessor.java:77)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.interceptor.TraceInterceptor.doStart(TraceInterceptor.java:429)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.RedeliveryErrorHandler.doStart(RedeliveryErrorHandler.java:847)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.DefaultChannel.doStart(DefaultChannel.java:146)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:86)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.MulticastProcessor.doStart(MulticastProcessor.java:893)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.DelegateAsyncProcessor.doStart(DelegateAsyncProcessor.java:77)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startServices(ServiceHelper.java:74)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.processor.DelegateAsyncProcessor.doStart(DelegateAsyncProcessor.java:77)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.RouteService.startChildService(RouteService.java:250)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.RouteService.warmUp(RouteService.java:146)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.doWarmUpRoutes(DefaultCamelContext.java:1800)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.safelyStartRouteServices(DefaultCamelContext.java:1726)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRoutes(DefaultCamelContext.java:1528)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1420)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1321)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:164)[75:org.apache.camel.camel-spring:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1299)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:203)[75:org.apache.camel.camel-spring:2.6.0.fuse-01-09] at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:101)[75:org.apache.camel.camel-spring:2.6.0.fuse-01-09] at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:238)[75:org.apache.camel.camel-spring:2.6.0.fuse-01-09] at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97)[61:org.springframework.context:3.0.5.RELEASE] at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:303)[61:org.springframework.context:3.0.5.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:911)[61:org.springframework.context:3.0.5.RELEASE] at org.springframework.osgi.context.support.AbstractOsgiBundleApplicationContext.finishRefresh(AbstractOsgiBundleApplicationContext.java:235)[71:org.springframework.osgi.core:1.2.0] at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$4.run(AbstractDelegatedExecutionApplicationContext.java:358)[71:org.springframework.osgi.core:1.2.0] at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)[71:org.springframework.osgi.core:1.2.0] at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(AbstractDelegatedExecutionApplicationContext.java:320)[71:org.springframework.osgi.core:1.2.0] at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$CompleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:136)[72:org.springframework.osgi.extender:1.2.0] at java.lang.Thread.run(Thread.java:619)[:1.6.0_14]Caused by: java.lang.NullPointerException at org.jivesoftware.smackx.muc.MultiUserChat$1.connectionCreated(MultiUserChat.java:84)[247:org.apache.servicemix.bundles.smack:3.1.0.2] at org.jivesoftware.smack.XMPPConnection.initConnection(XMPPConnection.java:957)[247:org.apache.servicemix.bundles.smack:3.1.0.2] at org.jivesoftware.smack.XMPPConnection.connectUsingConfiguration(XMPPConnection.java:904)[247:org.apache.servicemix.bundles.smack:3.1.0.2] at org.jivesoftware.smack.XMPPConnection.connect(XMPPConnection.java:1415)[247:org.apache.servicemix.bundles.smack:3.1.0.2] at org.apache.camel.component.xmpp.XmppEndpoint.createConnection(XmppEndpoint.java:140)[248:org.apache.camel.camel-xmpp:2.6.0.fuse-01-09] at org.apache.camel.component.xmpp.XmppGroupChatProducer.doStart(XmppGroupChatProducer.java:76)[248:org.apache.camel.camel-xmpp:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:65)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:60)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] at org.apache.camel.impl.ProducerCache.doGetProducer(ProducerCache.java:360)[68:org.apache.camel.camel-core:2.6.0.fuse-01-09] ... 65 more",
            "id": "3873"
        },
        "3891": {
            "ground_truth": "0",
            "bug_report": "Avoiding to process the bean which value is null in CamelBeanPostProcessor\nWhen user use the FactoryBean to return a null object within Spring 2.x  the CamelBeanPostProcessor will throw a NPE exception.Although this issue can't be reproduced within Spring 3.x  we should consider to put the NP check in the CamelBeanPostProcessor as an enhancement.",
            "id": "3891"
        },
        "3905": {
            "ground_truth": "0",
            "bug_report": "camel-cache exception message: CamelCacheOperation not specified in the message header [CamelCacheKey]\nCaused by: net.sf.ehcache.CacheException: CamelCacheOperation not specified in the message header &#91;CamelCacheKey&#93;Sound like a mistake? Or maybe my English is so bad? as this message doesn't make sense for me...Simply it should be:Caused by: net.sf.ehcache.CacheException: CamelCacheOperation header not specified in message",
            "id": "3905"
        },
        "3908": {
            "ground_truth": "0",
            "bug_report": "Prevent 'FolderNotOpen' exception when closing out an email exchange\nWhen an email exchange is complete it should set either the SEEN or DELETED flags in the folder on the email server. But if the folder isn't open  either because of automatic closing or timeout  attempting to set the flag results in a FolderNotOpen exception. The attached version of MailConsumer includes a check in processCommit() that opens the folder if it's not open at exchange completion.",
            "id": "3908"
        },
        "3912": {
            "ground_truth": "0",
            "bug_report": "Consumer URI parameters ignored after Route Restart\nThe URI parameters for a consumer appear to be ignored or disappear when the route where this consumer defined gets restarted.One example could be JPA query passed in the URI and is used to filter the results from the consumer.The attached test case shows this.Look at the Readme.txt  camel-context.xml  and JPARouteRestartTest class for more information.Also  took a stab at fixing the problem and provided a patch with a possible solution. I ran the unit tests after that change and all passed.",
            "id": "3912"
        },
        "3917": {
            "ground_truth": "0",
            "bug_report": "CxfPayloadConverter may start failing to convert a CxfPayload to a Node\nThere is an issue with CxfPayloadConverter that can lead to a failure in converting the CxfPayload into something which is actually convertible. This problem happens when you try to convert a CxfPayload instance that has an empty body list into a Node instance. This returns null and subsequently registers this type mapping key (CxfPayload-&gt;Node) in org.apache.camel.impl.converter.BaseTypeConverterRegistry's conversion-misses table. Because of this  a subsequent conversion using a CxfPayload instance with an non empty body list will permanently fail.I am attaching a modified CxfPayloadConversionTest that includes testCxfPayloadToNode that illustrates this problem. Currently  the last assertion of this test is failing when this issue is present.I think we can fix this problem by returning Void.TYPE instead of a null for this case.In this way  the conversion is regarded as a success and there will be no entry in the conversion-misses table.So  I am also attaching the modiefied CxfPayloadConverter class that can handle this test case.",
            "id": "3917"
        },
        "3936": {
            "ground_truth": "0",
            "bug_report": "JdbcAggregationRepository count (*) is not working with MySQL 5.0\nThe JdbcAggregationRepository makes a  'SELECT COUNT (*) FROM....' SQL request at line 131 in the source code. This appears to be incorrect with MySQL because theire is a space between COUNT and (. By replacing the request with  'SELECT COUNT(*) FROM....' (without the white space) the bug is corrected for MySQL (I think it should be tested with other database without the space). This request can be tested with Mysql Query Browser (the returned error is the same as the one encountered when we execute the JdbcAggregationRepository with Camel). The exception returned is the following:  ERROR DefaultErrorHandler - Failed delivery for exchangeId: ID:COE-WRKST2-1749-1304443569312-2:2:1:88:1. Exhausted after delivery attempt: 1 caught: org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT COUNT (*) FROM aggregation_repo_0 WHERE id = ?]; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '*) FROM aggregation_repo_0 WHERE id = '92'' at line 1org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT COUNT (*) FROM aggregation_repo_0 WHERE id = ?]; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '*) FROM aggregation_repo_0 WHERE id = '92'' at line 1 at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:233) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:602) at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:636) at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:665) at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:673) at org.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:728) at org.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:744) at org.springframework.jdbc.core.JdbcTemplate.queryForInt(JdbcTemplate.java:775) at org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository$1.doInTransaction(JdbcAggregationRepository.java:131) at org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository$1.doInTransaction(JdbcAggregationRepository.java:114) at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:130) at org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository.add(JdbcAggregationRepository.java:114) at org.apache.camel.processor.aggregate.AggregateProcessor.doAggregation(AggregateProcessor.java:251) at org.apache.camel.processor.aggregate.AggregateProcessor.process(AggregateProcessor.java:189) at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208) at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:103) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85) at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:84) at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:560) at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:498) at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:467) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1058) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1050) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:947) at java.lang.Thread.run(Thread.java:662)Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '*) FROM aggregation_repo_0 WHERE id = '92'' at line 1 at sun.reflect.GeneratedConstructorAccessor83.newInstance(Unknown Source) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27) at java.lang.reflect.Constructor.newInstance(Constructor.java:513) at com.mysql.jdbc.Util.handleNewInstance(Util.java:409) at com.mysql.jdbc.Util.getInstance(Util.java:384) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1054) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3566) at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3498) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1959) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2113) at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2568) at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2113) at com.mysql.jdbc.PreparedStatement.executeQuery(PreparedStatement.java:2275) at org.apache.commons.dbcp.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:96) at org.apache.commons.dbcp.DelegatingPreparedStatement.executeQuery(DelegatingPreparedStatement.java:96) at org.springframework.jdbc.core.JdbcTemplate$1.doInPreparedStatement(JdbcTemplate.java:643) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:586) ... 42 more",
            "id": "3936"
        },
        "3942": {
            "ground_truth": "0",
            "bug_report": "AnnotationTypeConverterLoader fails for folders containing spaces\nThis problem appears when jar dependencies with type converters have path containing space characters.In my case  the camel-mail-2.7.1.jar jar is located in my local maven repository.I get this error during my project startup: [...]Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:/D:/Documents and Settings/501915291/.m2/repository/org/apache/camel/camel-mail/2.7.1/camel-mail-2.7.1.jar!/META-INF/services/org/apache/camel/TypeConverter at java.net.URI$Parser.fail(URI.java:2809) at java.net.URI$Parser.checkChars(URI.java:2982) at java.net.URI$Parser.parse(URI.java:3019) at java.net.URI.&lt;init&gt;(URI.java:578) at java.net.URL.toURI(URL.java:918) at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.findPackages(AnnotationTypeConverterLoader.java:118) at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.findPackageNames(AnnotationTypeConverterLoader.java:108) at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:69) ... 63 moreFIX:findPackages method in AnnotationTypeConverterLoader shouldn't use URIs to store already visited jars.",
            "id": "3942"
        },
        "3949": {
            "ground_truth": "1",
            "bug_report": "Sending a message to log endpoint should not convert payload to StreamCache\nWe should not automatic try to convert the payload to a StreamCache if you send a message to a log endpoint. StreamCache newBody = message.getBody(StreamCache.class); if (newBody != null) { message.setBody(newBody); }Only if people have explicit enabled stream cache we can safely log it.Otherwise we should not output streams in the log.We should use the extractBodyForLogging from MessageHelper instead which cater for this.",
            "id": "3949"
        },
        "3950": {
            "ground_truth": "0",
            "bug_report": "Route cannot be started within web-console  if autoStartup='false' is set in camel.xml\nWhen a route has autoStartup='false' set in the camel.xml  it cannot be started anymore in the web- console.In the logfile  an entry is generated  similar to this:'Cannot start route route2 as its configured with autoStartup=false | org.apache.camel.spring.SpringCamelContext | qtp7446303-52'If a route does not have autoStartup='false'  it can be stopped and started normally (as before with ActiveMQ 5.4.2 / Camel 2.4.0)Reproduce steps: Configure a route with '&lt;route autoStartup='false'&gt;' Start the ActiveMQ Service Navigate to 'http://server.domain.tld:8161/camel/routes try to start the route with the button 'Start' check the logfile 'activemq.log'",
            "id": "3950"
        },
        "3964": {
            "ground_truth": "0",
            "bug_report": "Script arguments\nAs I said here : http://fusesource.com/forums/thread.jspa?threadID=2946&amp;tstart=0  the ScriptEngine class (http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html) provides a put method which enable to add a Java object into the created script  thanks to the JSR-223. But Camel does not provide a 'bridge' to this method.So I propose to pass the arguments via the header map of the message.Indeed  on client side  I created a Map&lt;String  Object&gt; which contains the future scripts arguments. Then I put this map into the header.Next on the camel-script component  I check a particular key (a public static final attribute that I added) and if the value returned is a Map  I try to add the Map's objects with the engine.put(String  Object) method.",
            "id": "3964"
        },
        "3968": {
            "ground_truth": "0",
            "bug_report": "camel-soap - Add support for multiple parameters\ncamel-soap is limited to only work with one parameter.There is some code that throws an exception stating multiple parameters is not supported.We should add support for that.See nabblehttp://camel.465427.n5.nabble.com/Multiple-parameters-in-CXF-service-method-tp4386208p4386208.html",
            "id": "3968"
        },
        "3971": {
            "ground_truth": "0",
            "bug_report": "Dumping route to XML created by Java DSL using an expression may not output the actual used expression\nSee this unit testManagedCamelContextDumpRoutesAsXmlTestThe route in Java DSL from('seda:bar').routeId('myOtherRoute') .filter().header('bar') .to('mock:bar') .end();And the output in XML &lt;route group='org.apache.camel.management.ManagedCamelContextDumpRoutesAsXmlTest$1' id='myOtherRoute'&gt; &lt;from uri='seda:bar'/&gt; &lt;filter id='filter1'&gt; &lt;expressionDefinition/&gt; &lt;to uri='mock:bar' id='to2'/&gt; &lt;/filter&gt; &lt;/route&gt;The same example created by Spring XML  outputs the XML correct",
            "id": "3971"
        },
        "3973": {
            "ground_truth": "0",
            "bug_report": "Add send body operations to managed CamelContext so you can pass in headers as well\nCurrently we only support sendBody / requestBody on ManagedCamelContext. We should add operations that includes a map of headers. Then we supports sending a message that has headers as well.Also the existing operations should accept a java.lang.Object as body instead of a fixed String.",
            "id": "3973"
        },
        "3974": {
            "ground_truth": "0",
            "bug_report": "Spring-WS producer doesn't propagate headers\nThe Spring-WS producer only sets the body of the exchange  headers aren't propagated.See Nabble: http://camel.465427.n5.nabble.com/spring-ws-component-not-propagating-in-headers-to-out-message-td4393731.html",
            "id": "3974"
        },
        "3982": {
            "ground_truth": "0",
            "bug_report": "Updated Hazelcast to version 1.9.3\nUpdated Hazelcast to version 1.9.3. This offers some major bugfixes in Hazelcast and new functionality in the camel camponent (e.g. list inserting by index).",
            "id": "3982"
        },
        "3994": {
            "ground_truth": "0",
            "bug_report": "Java DSL - New means to explicitly end try/catch blocks\nWe are facing a problem with split() in combination with doTry/doCatch().Could you add a method 'endDoTry()' to the ProcessorDefinition? My use case is this: @Override public void configure() throws Exception { from('timer://myTimer?period=10000) .log('begin') .setBody(constant('x y z')) .doTry() .log('processing') .split(body()) .log('split') .end() .endDoTry() // would need some way like this to get back to the TryDefinition .doCatch(Exception.class) .log('Exception') .end(); }I tested this by adding endDoTry() to the ProcessorDefinition  and it works just fine. public TryDefinition endDoTry() { return (TryDefinition) this; }An endDoCatch in the TryDefinition would be great too. Is it possible that these endXXX() methods get added to 2.6.0  not just 2.7.0 or trunk?See also: http://camel.465427.n5.nabble.com/Route-with-choice-and-split-td4375184.html",
            "id": "3994"
        },
        "4010": {
            "ground_truth": "0",
            "bug_report": "Camel FTP component fails to process multiple files at once from a specified folder\nCamel FTP component fails to process multiple files at once from a specified folder (let's assume the folder is /in).When the consumer connects to a ftp account and finds a list of  let's say  3 files  it will try to retrieve them in parallel but this is not handled properly.As you can see from the below FTP server log  this is what Camel FTP does: it changes the current directory to /in retrieves the file it changes the current directory to / the second (probably) thread changes the directory to /in retreives the second file the first (probably) thread sends a delete command but it sends it as if it were in the root folder but it is actually in the /in folder the FTP gives an error that the file doesn't exist somehow the FTP Component blocks itself on the first file...See my comments in the following log starting with *****(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 257 '/' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; CWD in(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 250 CWD successful. '/in' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; PASV(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 227 Entering Passive Mode (192 168 0 25 228 206)(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; RETR WS_1001_1.xml(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 150 Connection accepted(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; SSL connection for data connection established(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 226 Transfer OK(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; CWD /(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 250 CWD successful. '/' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; PWD(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 257 '/' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; CWD in(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 250 CWD successful. '/in' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; PASV(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 227 Entering Passive Mode (192 168 0 25 228 207)(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; RETR WS_1001_2.xml(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 150 Connection accepted(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; DELE in/WS_1001_1.xml ***** The location is already /in  should be DELE WS_1001_1.xml(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 550 File not found(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; PASV(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 227 Entering Passive Mode (192 168 0 25 228 208)(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; NLST in(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 550 Directory not found(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; PWD(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 257 '/in' is current directory.(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; CWD in ***** Current directory is already /in(002386)5/20/2011 17:07:03 PM - sftp-test (192.168.0.194)&gt; 550 CWD failed. '/in/in': directory not found.For the whole FTP server logs go here: http://pastie.org/private/kknnkxpbyzqmai7gsm8z5gFor the Servicemix/Camel(Trace) log: http://pastie.org/private/eulookxiepan3nkjyu41aA workaround that seems to work is to use the maxMessagesPerPoll=1 option.",
            "id": "4010"
        },
        "4014": {
            "ground_truth": "0",
            "bug_report": "cxf:rsServer requires class instead of interface in the serviceClass attribute\nHere are part of the conversation from the mailing list:1.Hi there I'm using apache-servicemix-4.3.1-fuse-01-09 and I need to consume RESTful requests.Here is the documentation I have used: http://camel.apache.org/cxfrs.htmlHere is my configuration file&lt;beans xmlns='http://www.springframework.org/schema/beans' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:jaxrs='http://cxf.apache.org/jaxrs' xmlns:cxf='http://camel.apache.org/schema/cxf' xsi:schemaLocation=' http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd '&gt; &lt;import resource='classpath:META-INF/cxf/cxf.xml' /&gt; &lt;import resource='classpath:META-INF/cxf/cxf-extension-jaxrs-binding.xml' /&gt; &lt;import resource='classpath:META-INF/cxf/cxf-extension-http.xml' /&gt; &lt;import resource='classpath:META-INF/cxf/osgi/cxf-extension-osgi.xml' /&gt; &lt;cxf:rsServer id='myServer' address='/' serviceClass='org.test.MyService' /&gt; &lt;camelContext id='camel' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;route&gt; &lt;from uri='cxfrs://bean:myServer?exchangePattern=InOut'/&gt; &lt;transform&gt; &lt;constant&gt;Hello World!!!&lt;/constant&gt; &lt;/transform&gt; &lt;/route&gt; &lt;/camelContext&gt;&lt;/beans&gt;Here is implementation of org.test.MyService@Path('/service')@Produces('application/json')public class MyService { @POST @Path('/resource') public Response add(@QueryParam('res') String res) { return Response.ok(new Status('The Resource has been processed')).build(); }}I'm wondering why we have to specify the serviceClass attribute and why this attribute should point at the real class. I'm asking because the response of such a service will always be 'Hello World!!!' and implementation of MyService.add method does not matter in that case.2.Hi Ben You are right  the serviceClass is just used to build up the JAXRS service module. And Camel CXF RS Consumer doesn't all serviceClass instance at the end  it just route the request to the camel route.3. Hi Willem  BenThanks for the information.I tried to use the interface instead of class in the serviceClass attribute and I didn't succeed because of an exception that told that the class is required.Here is the exception:Caused by: java.lang.RuntimeException: Resource class interface org.test.MyService has no valid constructor at org.apache.cxf.jaxrs.lifecycle.PerRequestResourceProvider.&lt;init&gt;(PerRequestResourceProvider.java:45) at org.apache.cxf.jaxrs.JAXRSServerFactoryBean.updateClassResourceProviders(JAXRSServerFactoryBean.java:338) at org.apache.cxf.jaxrs.JAXRSServerFactoryBean.create(JAXRSServerFactoryBean.java:119) ... 26 moreI think that using an interface would be better in that case.",
            "id": "4014"
        },
        "4019": {
            "ground_truth": "0",
            "bug_report": "Replace the NoCacheStorage Class\nThe NoCacheStorage class can safely be replaced by FreeMarker's NullCacheStorage class (created per my suggestion based on our needs in Camel) introduced in 2.3.16.",
            "id": "4019"
        },
        "4021": {
            "ground_truth": "0",
            "bug_report": "ConcurrentModificationException at DefaultCamelContext.getRouteDefinition()\nSimilar to CAMEL-3493 there is also a race in getRouteDefinition()java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)[:1.6.0_21] at java.util.AbstractList$Itr.next(AbstractList.java:343)[:1.6.0_21] at org.apache.camel.impl.DefaultCamelContext.getRouteDefinition(DefaultCamelContext.java:1098)[cih-core-1.0.jar:1.0] at com.tieto.cih.core.main.GatewayRouteSetup.startGatewayRoutes(GatewayRouteSetup.java:86)[cih-core-1.0.jar:1.0] at com.tieto.cih.core.main.GatewayRouteSetup.process(GatewayRouteSetup.java:73)[cih-core-1.0.jar:1.0]As route count could be quite large  it would be nice to have them stored in synchronized map or something like that instead of list.",
            "id": "4021"
        },
        "4022": {
            "ground_truth": "0",
            "bug_report": "Issue using errorBuilderRef with the xml dsl\nWhile fixing issues around the errorHandler I noticed that &lt;onException&gt; definitions defined in the camel context are ignored if a route specifies its own errorHandlerRef. The reason is that we set the onException definition on the default error handler. I have a fix for that  but I discovered a different issue (I think) for which I would like to discuss the solution.When we have an onException definition that looks kinda like this:&lt;onException&gt; &lt;exception&gt; java.lang.IllegalArgumentException&lt;/exception&gt; &lt;to uri='mock:illegalArgumentException'/&gt;&lt;/onException&gt;... something happens  the IAE exception is caught  we do something  but in that process another exception is thrown. Currently  that would be caught by the default error handler  which may not be what we want.What error handler (if any) should handle exceptions thrown while in onException?The onException mechanism is somewhat similar to a try/catch. I don't think the exceptions thrown while handling onException should be handled by the same error handler configured for the route  or even the context scoped one. The processing should be very simple  predictable and immutable. Since the default 'CamelDefaultErrorHandlerBuilder' can be replaced  it is not imho a solution and we need one global one that does as little as possible (the problem would be agreeing what that is: no redeliveries  logging or not  etc).Thoughts?",
            "id": "4022"
        },
        "4033": {
            "ground_truth": "0",
            "bug_report": "Loop EIP - Add copy option to let it start next loop with a copy of the original exchange\nThe Loop EIP will use pipes and filters. So if you loop 3 times  then on the 2nd and 3rd time its the output from the previous processing that is being used.We should add an option so people can use a copy of the original exchange instead  so its the same copy being looped on each iteration.The wiki documentation should be updated to describe the difference in these two modes.See nabblehttp://camel.465427.n5.nabble.com/Loop-usage-tp4432628p4432628.html",
            "id": "4033"
        },
        "4044": {
            "ground_truth": "0",
            "bug_report": "ChoiceProcessor : unable to find the mBeans processor\nUsing the jconsole  we are not able to locate some processors after a ChoiceProcessor.For example :from('direct:start').to('mock:test1').id('mock1').choice().when(predicate).to('mock:test2').id('test2').otherwise().to('mock:test3').id('test3').end().to('mock:outOfChoice').id('outOfChoice');The processors mock1 and outOfChoice are well found but not the processors test2 and test3.",
            "id": "4044"
        },
        "4047": {
            "ground_truth": "0",
            "bug_report": "javax.script dependency in camel-core\nThe OSGi imports for camel-core ends up with a non-optional dependency on javax.script due to it being used in the Activator. However  the karaf feature for camel-core doesn't have a dependency on org.apache.servicemix.specs.scripting-api-1.0 .One of two things should be done:1) mark javax.script as optional. This MAY require some updates to the Activator to work when it's not available.2) Update the karaf features file to add:&lt;bundle dependency='true'&gt;mvn:org.apache.servicemix.specs/org.apache.servicemix.specs.scripting-api-1.0/${servicemix-specs-version}&lt;/bundle&gt;",
            "id": "4047"
        },
        "4057": {
            "ground_truth": "0",
            "bug_report": "continued(true) doesn't work when is invoked for the second time in the Camel flow\nWhen Camel flow contains error handling as continued(true)  it is not invoked when the error occurs for the second time (even in different onException).What is more the exception is not handled even by global onException and Camel flow is interruped.",
            "id": "4057"
        },
        "4067": {
            "ground_truth": "0",
            "bug_report": "Test failures in camel-hdfs on windows as Streams are not closed correctly\nOn windows some hdfs tests fail as the streams are not correctly being closed. The first stacktrace looks like below. This is a bit misleading as in fact the problem is that not all exchanges could be processed. The reason is that the file component cant rename the file as it is still open. This is because an inputStream is opened for the file but never closed.junit.framework.AssertionFailedError: expected:&lt;40&gt; but was:&lt;12&gt; at junit.framework.Assert.fail(Assert.java:47) at junit.framework.Assert.failNotEquals(Assert.java:283) at junit.framework.Assert.assertEquals(Assert.java:64) at junit.framework.Assert.assertEquals(Assert.java:195) at junit.framework.Assert.assertEquals(Assert.java:201) at org.apache.camel.component.hdfs.HdfsProducerFileWriteTest.testSimpleWriteFile(HdfsProducerFileWriteTest.java:72) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.rules.TestWatchman$1.evaluate(TestWatchman.java:48) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)",
            "id": "4067"
        },
        "4075": {
            "ground_truth": "0",
            "bug_report": "Create camel-quartz2 component to support Quartz 2.1.x\nQuartz 2.0.1 has been released. We should upgrade the camel-quartz to use that version.There is an OSGi bundle in the works  to be pushed to central repo:http://repo2.maven.org/maven2/org/apache/servicemix/bundles/org.apache.servicemix.bundles.quartz/Also there is a SMX tickethttps://issues.apache.org/jira/browse/SMXCOMP-884",
            "id": "4075"
        },
        "4076": {
            "ground_truth": "0",
            "bug_report": "FileIdempotentRepository fileStore does not get loaded on bootrapping  therefore files are processed again\nI am using JVM based initialization of Camel using Spring.I use the documented Camel initialization procedure of main.setApplicationContext('my-spring-camel-config.xml');main.start()I also use the documented FileIdempotentRepository that points to a FileStore.However  when Camel initializes this filestore is not loaded up. Hence  the LRU cache contained within this is empty.As a result  all my files are FTPed again from the remote server.This happens everytime I start my JVM resulting in expensive FTP of files.",
            "id": "4076"
        },
        "4092": {
            "ground_truth": "0",
            "bug_report": "XML DSL having attributes that is a Class type should be a String type instead and use ClassResolver to lookup the class\nIn the XML DSL  some of the EIPs etc. have an attribute where you can configure a Class&lt;?&gt; type. For example &lt;xpath&gt; has a resultType attribute. The XSD type is a xs:string.The problem is JAXB can only convert the xs:string to a Class&lt;?&gt; if the class can be loaded by JAXB/JDK. This may not work to well with custom types in OSGi / JBoss etc. Instead we should use ClassResolver from CamelContext to lookup those classes  as it works in OSGI/blueprint/JBoss etc.",
            "id": "4092"
        },
        "4103": {
            "ground_truth": "0",
            "bug_report": "In doTry .. doCatch .. doFinally the FAILURE_ENDPOINT details should be available as well in case an exception was thrown\nIn doCatch you have access to the caught exception using the exchange property CAUGHT_EXCEPTION. But we should also make FAILURE_ENDPOINT available as well. This information is present when you use onException / errorHandler. So we should make this consistent  and be avail in doCatch / doFinally as well.",
            "id": "4103"
        },
        "4107": {
            "ground_truth": "0",
            "bug_report": "Error using multiple error handlers and onException (java.lang.IllegalStateException: SendProcessor has not been started)\nWhen we use more than one errorHandler in our routes and onException  we face test failures with the following exception:java.lang.IllegalStateException: SendProcessor has not been started: sendTo(Endpoint&#91;mock://custom&#93;) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:94)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.RedeliveryErrorHandler.deliverToFailureProcessor(RedeliveryErrorHandler.java:621)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:242)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:189)&#91;camel-core-2.7.2.jar:2.7.2&#93; at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:121)&#91;camel-core-2.7.2.jar:2.7.2&#93; at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)&#91;:1.6.0_20&#93; at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)&#91;:1.6.0_20&#93;",
            "id": "4107"
        },
        "4114": {
            "ground_truth": "0",
            "bug_report": "Refactorings in camel-cxf\nThere are some dependency cycles between packages in camel-cxf. Also some classes could need a bit internal cleanup. I open this ticket so my different commits around this can be seen in context.",
            "id": "4114"
        },
        "4116": {
            "ground_truth": "0",
            "bug_report": "SpringWebserviceConsumer should check if there is an Exception connected to the exchange and throw that one if it exists so that the default Errorhandling in spring-ws can take place\nIf an Exception is thrown in the camel flow then that exception is not propagated to spring-web-services.Example: &lt;camel:from uri='spring-ws:rootqname:{foo.com}BarRequest?endpointMapping=#endpointMapping'/&gt; &lt;camel:to uri='bean:exceptionThrower?method=throwException'/&gt;This would result in an empty response from spring web-services with a status code of 202 (accepted).If the check was made on the Exchange to see if there was an Exception thrown then that one could be rethrown and the Exception-handling in spring web services could do its magic.In SpringWebserviceConsumer add this to the invoke method: if(exchange.getException() != null){ throw exchange.getException(); }",
            "id": "4116"
        },
        "4120": {
            "ground_truth": "0",
            "bug_report": "camel-sql - JDBC aggregation repository - Should use ClassResolver from Camel to load classes\nThe ClassLoadingAwareObjectInputStream should use the classResolver from CamelContext  which ensures better class loading on various platforms and OSGi etc.",
            "id": "4120"
        },
        "4122": {
            "ground_truth": "0",
            "bug_report": "JMX API to create/delete endpoint\nwe can create endpoints on the fly via the camel-web REST API; or by just sending a message to a new endpoint URI or consuming from a URI. But there is currently no JMX way to do so which is a bit of an omission.Something like...createEndpoint(String uri);would be a nice addition to the MBeans API on a ManagedCamelContext. Maybe a removeEndpoint(String uri) too would be handy.",
            "id": "4122"
        },
        "4140": {
            "ground_truth": "0",
            "bug_report": "Improve pom.xml for camel-jibx - use maven-jibx-plugin\nI have a patch attached that updates the pom.xml in the camel-jibx component.1. The maven-jibx-plugin has fixed http://jira.codehaus.org/browse/JIBX-3552. Using a profile to allow a user to skip the unit tests using -Dmaven.test.skip=true. The plugin will run even if unit tests are skipped  so using a profile to correct that.",
            "id": "4140"
        },
        "4149": {
            "ground_truth": "0",
            "bug_report": "ThrottlingInflightRoutePolicy can deadlock\nUsing ThrottlingInflightRoutePolicy can deadlock a route in some situations. The unit test pasted in below shows one such situation.What happens is that the bottom route processes its first exchange  then suspends. Since it is suspended it will not take the next exchange from the seda queue  and so it will never check whether it should re-enable the route.Perhaps it will work by putting the check to re-enable the route in the onExchangeBegin method  if that is called even when the route is suspended?import org.apache.camel.Exchange;import org.apache.camel.Produce;import org.apache.camel.ProducerTemplate;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.impl.DefaultInflightRepository;import org.apache.camel.impl.ThrottlingInflightRoutePolicy;import org.apache.camel.impl.ThrottlingInflightRoutePolicy.ThrottlingScope;import org.apache.camel.test.CamelTestSupport;public class ThrottleTest extends CamelTestSupport { @Produce(uri = 'direct:input') protected ProducerTemplate input; protected MockEndpoint resultEndpoint; @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { public void configure() { resultEndpoint = new MockEndpoint('mock:result'); resultEndpoint.setCamelContext(getContext()); getContext().setInflightRepository(new DefaultInflightRepository() { @Override public void add(Exchange exchange) { super.add(exchange); System.out.println(' add ' + this.size()); } @Override public void remove(Exchange exchange) { super.remove(exchange); System.out.println(' remove ' + this.size()); } }); ThrottlingInflightRoutePolicy throttler = new ThrottlingInflightRoutePolicy(); throttler.setMaxInflightExchanges(1); throttler.setScope(ThrottlingScope.Context); from('direct:input') .inOnly('seda:hey'  'seda:hey'  'seda:hey'  'seda:hey'  'seda:hey') .delay(1000) .inOnly('log:inputDone'); from('seda:hey') .routePolicy(throttler) .inOut('log:outputDone') .to(resultEndpoint); } }; } public void testThatAllExchangesAreReceived() throws Exception { input.sendBody('hello'); resultEndpoint.expectedMessageCount(5); resultEndpoint.assertIsSatisfied(); }}",
            "id": "4149"
        },
        "4159": {
            "ground_truth": "0",
            "bug_report": "MockEndpoint.expectedHeaderReceived checks only one header\nThe method MockEndpoint.expectedHeaderReceived sets one header key and one header value to check. Subsequent calls to the same method overwrites the key and value. As a (non-expert) user of the MockEndpoint  I would expect this method to work somewhat along the lines of Map.put  so that multiple headers can be expected. Alternatively  replace it with MockEndpoint.expectedHeadersReceived(Map&lt;String  Object&gt; headers) or something like that.MockEndpoint.expectedPropertyReceived has the same issue.The unit test below demonstrates the bug. Have fun import java.util.HashMap;import org.apache.camel.Produce;import org.apache.camel.ProducerTemplate;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.CamelTestSupport;public class MockEndpointTest extends CamelTestSupport { @Produce(uri = 'direct:input') protected ProducerTemplate input; protected MockEndpoint resultEndpoint; @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { public void configure() { resultEndpoint = new MockEndpoint('mock:result'); resultEndpoint.setCamelContext(getContext()); from('direct:input') .inOnly('log:output?showHeaders=true') .to(resultEndpoint); } }; } public void testStuff() throws Exception { HashMap&lt;String  Object&gt; headers = new HashMap&lt;String  Object&gt;();// headers.put('h1'  'hello'); headers.put('h2'  'world'); resultEndpoint.expectedHeaderReceived('h1'  'hello'); resultEndpoint.expectedHeaderReceived('h2'  'world'); input.sendBodyAndHeaders(null  headers); resultEndpoint.expectedMessageCount(1); resultEndpoint.assertIsNotSatisfied(); }}",
            "id": "4159"
        },
        "4165": {
            "ground_truth": "0",
            "bug_report": "LoanBroker example have some issues when it is deployed into osgi container like ServiceMix\nWhen you deploy the camel-example-loanbroker bundle into OSGi container  the osgi container only load the WebService route because there are some confliction of the bean ids.",
            "id": "4165"
        },
        "4167": {
            "ground_truth": "0",
            "bug_report": "Label of marshal and unmarshal processors do not appear in trace output\nMy route is defined as following: from(mqIn) .routeId(Helper.getRouteId(this.getClass().getName())) .errorHandler(deadLetterChannel('log:DEAD').maximumRedeliveries(1).retryAttemptedLogLevel(LoggingLevel.WARN)) .onException(EAIException.class).maximumRedeliveries(0).handled(true).to('bean:AuditBO?method=handleException').end() //.transacted('PROPAGATION_REQUIRES_NEW') .setHeader('UBS_ID' new AuditId()) .wireTap('seda:auditNew') .unmarshal('SwiftDataFormat') .setHeader('MT'  getMT) .setHeader('SWIFTAddress'  getSwiftAddress) .to(mqOut);The tracing output is the following[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.in.IcgToCore) wireTap(seda://auditNew) --&gt; &lt;&lt;&lt; Pattern:InOnly  Headers:{UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7}  BodyType:String  ...[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.in.IcgToCore) --&gt; setHeader&#91;MT&#93; &lt;&lt;&lt; Pattern:InOnly  Headers:{UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7}  BodyType:com.ubs.eai.wmswift.SwiftDataMessage  Body:com.ubs.eai.wmswift.SwiftDataMessage@91b9b0[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.in.IcgToCore) setHeader&#91;MT&#93; --&gt; setHeader&#91;SWIFTAddress&#93; &lt;&lt;&lt; Pattern:InOnly  Headers:{MT=502  UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7}  BodyType:com.ubs.eai.wmswift.SwiftDataMessage  Body:com.ubs.eai.wmswift.SwiftDataMessage@91b9b0[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.in.IcgToCore) setHeader&#91;SWIFTAddress&#93; --&gt; direct://core &lt;&lt;&lt; Pattern:InOnly  Headers:{SWIFTAddress=ZYAMCHZ0XXXX  MT=502  UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7}  BodyType:com.ubs.eai.wmswift.SwiftDataMessage  Body:com.ubs.eai.wmswift.SwiftDataMessage@91b9b0[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.core.CoreToMQ) direct://core --&gt; &lt;&lt;&lt; Pattern:InOnly  Headers:{SWIFTAddress=ZYAMCHZ0XXXX  MT=502  UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7}  BodyType:com.ubs.eai.wmswift.SwiftDataMessage  Body:com.ubs.eai.wmswift.SwiftDataMessage@91b9b0[ main] Tracer INFO ID-w01b2bc3-3197-1309192772128-0-2 &gt;&gt;&gt; (wmswift.core.CoreToMQ) --&gt; choice &lt;&lt;&lt; Pattern:InOnly  Headers:{MT=502  UBS_ID=5932bc56-2f7e-45cf-a2b4-ef851ff661d7  SWIFTAddress=ZYAMCHZ0XXXX}  The bug I found is the missing label of the unmarshal processor.",
            "id": "4167"
        },
        "4168": {
            "ground_truth": "0",
            "bug_report": "Add getRouteId() to TraceEventMessage\nIt would be good to find the routeId from the TraceEventMessage  in the case that the trace information is sent to a route.In my example  extracts from XML: &lt;bean id='CamelTracer' class='org.apache.camel.processor.interceptor.Tracer'&gt; &lt;property name='destination' ref='traced'/&gt; &lt;property name='logLevel' value='OFF'/&gt; &lt;/bean&gt; &lt;endpoint id='traced' uri='seda:auditrace?waitForTaskToComplete=Never'/&gt;And my route is: @EndpointInject(ref='traced') Endpoint traced;  @Override public void configure() throws Exception { from(traced) .routeId('util.AuditTrace') .noTracing() .to('bean:AuditBO?method=trace'); }An instance object of TraceEventMessage is sent down this route and there is no getRouteId() defined. This would make the TraceEventMessage even more helpful.",
            "id": "4168"
        },
        "4171": {
            "ground_truth": "0",
            "bug_report": "Groovy language - classNotFoundException in OSGi environment\nThe problem is in the following method of the GroovyLanguage@SuppressWarnings('unchecked')protected Class&lt;Script&gt; parseExpression(String expression) { return new GroovyClassLoader().parseClass(expression);}It uses the default constructor to create GroovyClassLoader  which uses Thread context classloader  which may not be equal to the classloader of the bundle where the camel context is defined.Caused by: java.lang.NoClassDefFoundError: groovy/lang/Script at java.lang.ClassLoader.defineClass1(Native Method)&#91;:1.6.0_24&#93; at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)&#91;:1.6.0_24&#93; at java.lang.ClassLoader.defineClass(ClassLoader.java:616)&#91;:1.6.0_24&#93; at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)&#91;:1.6.0_24&#93; at groovy.lang.GroovyClassLoader.access$300(GroovyClassLoader.java:55) at groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:519) at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:536) at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:540) at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:747) at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:932) at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:509) at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:487) at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:464) at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306) at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287) at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267) at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:214) at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:224) at org.apache.camel.language.groovy.GroovyLanguage.parseExpression(GroovyLanguage.java:44) at org.apache.camel.language.groovy.GroovyLanguage.createExpression(GroovyLanguage.java:38) at org.apache.camel.language.groovy.GroovyLanguage.createExpression(GroovyLanguage.java:27) at org.apache.camel.component.language.LanguageProducer.process(LanguageProducer.java:41)&#91;68:org.apache.camel.camel-core:2.6.0.fuse-01-09&#93; at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50)&#91;68:org.apache.camel.camel-core:2.6.0.fuse-01-09&#93; ... 92 moreCaused by: java.lang.ClassNotFoundException: groovy.lang.Script at java.net.URLClassLoader$1.run(URLClassLoader.java:202)&#91;:1.6.0_24&#93; at java.security.AccessController.doPrivileged(Native Method)&#91;:1.6.0_24&#93; at java.net.URLClassLoader.findClass(URLClassLoader.java:190)&#91;:1.6.0_24&#93; at java.lang.ClassLoader.loadClass(ClassLoader.java:307)&#91;:1.6.0_24&#93; at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)&#91;134:groovy-all:1.7.5&#93; at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449) at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)&#91;134:groovy-all:1.7.5&#93; at java.lang.ClassLoader.loadClass(ClassLoader.java:248)&#91;:1.6.0_24&#93; ... 115 more",
            "id": "4171"
        },
        "4173": {
            "ground_truth": "1",
            "bug_report": "Nullpointer in camel-mail when body is null\nWhen trying to send a mail with an empty body (null) then we get the following NullPointer exception.We should instead either complain about the null body or send the mail with an empty body.13:27:27 010 | INFO | tp1062262230-101 | ache.camel.processor.CamelLogger 87 | 55 - org.apache.camel.camel-core - 2.7.1 | Exchange[ExchangePattern:InOut  BodyType:org.apache.cxf.message.MessageContentsList  Body:&#91;com.ier.ebo_servicerequest.ServiceRequestType@10e07658&#93;]13:27:27 013 | ERROR | tp1062262230-101 | ache.camel.processor.CamelLogger 232 | 55 - org.apache.camel.camel-core - 2.7.1 | Failed delivery for exchangeId: ID-MacBook-Pro-de-bahaaldine-local-51035-1309771358240-2-6. Exhausted after delivery attempt: 1 caught: org.springframework.mail.MailPreparationException: Could not prepare mail; nested exception is java.lang.NullPointerExceptionorg.springframework.mail.MailPreparationException: Could not prepare mail; nested exception is java.lang.NullPointerException at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:367)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:344)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; at org.apache.camel.component.mail.MailProducer.process(MailProducer.java:44)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:104)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:272)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:125)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:139)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:61)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:582)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:511)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:211)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RecipientList.sendToRecipientList(RecipientList.java:134)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RecipientList.process(RecipientList.java:102)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:103)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:135)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:77)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)&#91;:1.6.0_24&#93; at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)&#91;:1.6.0_24&#93; at java.util.concurrent.FutureTask.run(FutureTask.java:138)&#91;:1.6.0_24&#93; at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:106)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:263)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:118)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:208)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:223)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:205)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:113)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:184)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doPost(AbstractHTTPServlet.java:107)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at javax.servlet.http.HttpServlet.service(HttpServlet.java:713)&#91;72:org.apache.geronimo.specs.geronimo-servlet_2.5_spec:1.1.2&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:163)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:534)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:476)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.HttpServiceServletHandler.doHandle(HttpServiceServletHandler.java:70)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:517)&#91;78:org.eclipse.jetty.security:7.3.1.v20110307&#93; at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:934)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.HttpServiceContext.doHandle(HttpServiceContext.java:116)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:404)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:184)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:869)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.JettyServerHandlerCollection.handle(JettyServerHandlerCollection.java:72)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.Server.handle(Server.java:346)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:581)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection$RequestHandler.content(HttpConnection.java:1057)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:807)&#91;75:org.eclipse.jetty.http:7.3.1.v20110307&#93; at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:220)&#91;75:org.eclipse.jetty.http:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:411)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:526)&#91;74:org.eclipse.jetty.io:7.3.1.v20110307&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:41)&#91;74:org.eclipse.jetty.io:7.3.1.v20110307&#93; at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:528)&#91;73:org.eclipse.jetty.util:7.3.1.v20110307&#93; at java.lang.Thread.run(Thread.java:680)&#91;:1.6.0_24&#93;Caused by: java.lang.NullPointerException at javax.mail.util.ByteArrayDataSource.&lt;init&gt;(ByteArrayDataSource.java:137)&#91;69:javax.mail:1.4.3&#93; at org.apache.camel.component.mail.MailBinding.populateContentOnMimeMessage(MailBinding.java:205)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.component.mail.MailBinding.populateMailMessage(MailBinding.java:114)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.component.mail.MailProducer$1.prepare(MailProducer.java:46)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:352)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; ... 98 more13:27:27 023 | WARN | tp1062262230-101 | ache.cxf.common.logging.LogUtils 371 | - - | Interceptor for {http://www.ier.com/WS_ServiceRequest}WSServiceRequestService#{http://www.ier.com/WS_ServiceRequest}createServiceRequest has thrown exception  unwinding noworg.apache.cxf.interceptor.Fault: Could not prepare mail; nested exception is java.lang.NullPointerException at org.apache.camel.component.cxf.CxfConsumer$1.checkFailure(CxfConsumer.java:218)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.setResponseBack(CxfConsumer.java:195)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:142)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:77)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)&#91;:1.6.0_24&#93; at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)&#91;:1.6.0_24&#93; at java.util.concurrent.FutureTask.run(FutureTask.java:138)&#91;:1.6.0_24&#93; at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:106)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:263)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:118)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:208)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:223)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:205)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:113)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:184)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doPost(AbstractHTTPServlet.java:107)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at javax.servlet.http.HttpServlet.service(HttpServlet.java:713)&#91;72:org.apache.geronimo.specs.geronimo-servlet_2.5_spec:1.1.2&#93; at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:163)&#91;124:org.apache.cxf.bundle:2.4.0&#93; at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:534)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:476)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.HttpServiceServletHandler.doHandle(HttpServiceServletHandler.java:70)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:517)&#91;78:org.eclipse.jetty.security:7.3.1.v20110307&#93; at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:934)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.HttpServiceContext.doHandle(HttpServiceContext.java:116)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:404)&#91;79:org.eclipse.jetty.servlet:7.3.1.v20110307&#93; at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:184)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:869)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.ops4j.pax.web.service.jetty.internal.JettyServerHandlerCollection.handle(JettyServerHandlerCollection.java:72)&#91;84:org.ops4j.pax.web.pax-web-jetty:1.0.1&#93; at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.Server.handle(Server.java:346)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:581)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection$RequestHandler.content(HttpConnection.java:1057)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:807)&#91;75:org.eclipse.jetty.http:7.3.1.v20110307&#93; at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:220)&#91;75:org.eclipse.jetty.http:7.3.1.v20110307&#93; at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:411)&#91;77:org.eclipse.jetty.server:7.3.1.v20110307&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:526)&#91;74:org.eclipse.jetty.io:7.3.1.v20110307&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:41)&#91;74:org.eclipse.jetty.io:7.3.1.v20110307&#93; at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:528)&#91;73:org.eclipse.jetty.util:7.3.1.v20110307&#93; at java.lang.Thread.run(Thread.java:680)&#91;:1.6.0_24&#93;Caused by: org.springframework.mail.MailPreparationException: Could not prepare mail; nested exception is java.lang.NullPointerException at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:367)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:344)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; at org.apache.camel.component.mail.MailProducer.process(MailProducer.java:44)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:104)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:272)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:125)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:139)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:61)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:299)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:582)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:511)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:211)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RecipientList.sendToRecipientList(RecipientList.java:134)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.RecipientList.process(RecipientList.java:102)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:269)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:77)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:103)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85)&#91;55:org.apache.camel.camel-core:2.7.1&#93; at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:135)&#91;125:org.apache.camel.camel-cxf:2.7.1&#93; ... 41 moreCaused by: java.lang.NullPointerException at javax.mail.util.ByteArrayDataSource.&lt;init&gt;(ByteArrayDataSource.java:137)&#91;69:javax.mail:1.4.3&#93; at org.apache.camel.component.mail.MailBinding.populateContentOnMimeMessage(MailBinding.java:205)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.component.mail.MailBinding.populateMailMessage(MailBinding.java:114)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.apache.camel.component.mail.MailProducer$1.prepare(MailProducer.java:46)&#91;281:org.apache.camel.camel-mail:2.7.1&#93; at org.springframework.mail.javamail.JavaMailSenderImpl.send(JavaMailSenderImpl.java:352)&#91;49:org.springframework.context.support:3.0.5.RELEASE&#93; ... 98 more",
            "id": "4173"
        },
        "4184": {
            "ground_truth": "0",
            "bug_report": "Using adviceWith 2 times or more in Java DSL with a context scoped onException causing the 1st advised route to not work as expected\nSee nabblehttp://camel.465427.n5.nabble.com/intercept-using-adviceWith-tp4520468p4520468.html",
            "id": "4184"
        },
        "4214": {
            "ground_truth": "0",
            "bug_report": "A name should be specified in the karaf features-file\nWhen doing a features:list in karaf  the repository for camel is listed as repo-0  which looks ugly to me. It would be better if it were given a name on the form camel-${pom.version}  similar to the names used by other projects such as Karaf and ActiveMQ.",
            "id": "4214"
        },
        "4224": {
            "ground_truth": "0",
            "bug_report": "Add Lazy Connection to XMPP\nWe are trying to use XMPP as an endpoint but we have a serious problem.If the XMPP server is inaccessible  we cannot start Camel - it just issues a FailedToCreateProducerException exception and shuts itself down.Given we are running Camel from an ActiveMQ instance this prevents critical infrastructure from being restarted when our XMPP server is offline.",
            "id": "4224"
        },
        "4229": {
            "ground_truth": "0",
            "bug_report": "Added wrap method for template  consumer and context in org.apache.camel.test.junit4.CamelContextSupport\nUser complain about the change of CAMEL-3960 causes some issue when using the CamelTestSupport in scala.A simple solution is add some wrap method to get the value protected static member.Here is the mail thread&#91;1&#93; of it.&#91;1&#93;http://camel.465427.n5.nabble.com/CamelTestSupport-template-variable-missing-changed-in-2-8-0-td4587700.html",
            "id": "4229"
        },
        "4233": {
            "ground_truth": "0",
            "bug_report": "avoid runtime package scanning to discover TypeConverters\nPackage scanning to discover classes annotated with @Converter is slow. Plus on many containers (especially commercial JEE containers) its not even possible; since ClassLoader.getResource() doesn't often return file system based URIs you can easily convert to a java.io.File so you can list files in a directory.Finding known resources/classes in class loaders generally works; scanning packages is generally more problematic - as well as being slow.So it would be better if Camel could use a text file per jar containing all the fully qualified class names of the converters to use. Then no package scanning is required. Or rather we only need to use package scanning if a text file contains packages (rather than fully qualified classes). i.e. do the package scanning at build time (when you have full access to the file system  rather than at runtime when you generally don't have access to the files - and expanding jars to look inside them is awfully slow.In addition it'd be great if we added a maven plugin - or Java compiler AnnotationProcessor we can use with the compile step - to generate the META-INF/services/org/apache/camel/TypeConverter file automatically as part of the build. Then users don't even have to think about it; they just add @Converter to a class and the plugin generates the text file as part of the build.  using fully qualified class names - so no package scanning required at runtime - and much faster startup times too",
            "id": "4233"
        },
        "4236": {
            "ground_truth": "0",
            "bug_report": "When performing lookup in registry and having expected type as parameter  then report better failure if ClassCastException\nWhen Camel lookup in the registry  it may lookup in different runtime registries  such as OSGi blueprint. If an explicit type has been provided as a parameter you will get a ClassCastException if the type does not match. But you cannot see which types was a stake. So we should provide a better exception.Caused by: java.lang.ClassCastException at java.lang.Class.cast(Class.java:2990)&#91;:1.6.0_24&#93; at org.apache.camel.blueprint.BlueprintContainerRegistry.lookup(BlueprintContainerRegistry.java:43) at org.apache.camel.impl.CompositeRegistry.lookup(CompositeRegistry.java:47) at org.apache.camel.impl.PropertyPlaceholderDelegateRegistry.lookup(PropertyPlaceholderDelegateRegistry.java:54) ... 42 more",
            "id": "4236"
        },
        "4237": {
            "ground_truth": "0",
            "bug_report": "Archetypes fail to build in offline mode\nIf build tooling/archetypes with the --offline Maven argument you may see an error like&#91;ERROR&#93; Unresolveable build extension: Error resolving version for plugin 'org.apache.maven.archetype:archetype-packaging'Seems the version for archetype-packaging in the dependencyManagement section defined in the parent pom is not propagating down to build extension... when Maven is not in offline mode it can simply grab the latest version from the metadata at central. I'm committing a simple fix shortly.",
            "id": "4237"
        },
        "4246": {
            "ground_truth": "0",
            "bug_report": "TraceInterceptor does not work correctly for AsyncProcessing\nTraceEventHandlers are not called correctly when a node is processed asynchronously.From org.apache.camel.processor.interceptor.TraceInterceptor: try { // special for interceptor where we need to keep booking how far we have routed in the intercepted processors if (node.getParent() instanceof InterceptDefinition &amp;&amp; exchange.getUnitOfWork() != null) { TracedRouteNodes traced = exchange.getUnitOfWork().getTracedRouteNodes(); traceIntercept((InterceptDefinition) node.getParent()  traced  exchange); } // process the exchange try { sync = super.process(exchange  callback); } catch (Throwable e) { exchange.setException(e); } } finally { // after (trace out) if (shouldLog &amp;&amp; tracer.isTraceOutExchanges()) { logExchange(exchange); traceExchangeOut(exchange  traceState); } }As it is this results in traceExchangeOut being called before the callback  which is wrong.The call to super.process needs to wrap the callback to call traceExchangeOut (and the finally block shouldn't run if the process is asynch).This isn't a regression  but the change to make more routes asynchronous makes it more noticeable.",
            "id": "4246"
        },
        "4252": {
            "ground_truth": "0",
            "bug_report": "camel-ftp - Using tempFileName option should use the separator option to allow control of path separators in the generated file name\nSee nabblehttp://camel.465427.n5.nabble.com/FTP-temp-file-not-being-created-correctly-on-Windows-Camel-2-7-2-tp4591581p4591581.html",
            "id": "4252"
        },
        "4254": {
            "ground_truth": "0",
            "bug_report": "Missing setter or constructor-argument for elementNameStrategyRef in SoapJaxbDataFormat\nBecause the variable 'elementNameStrategyRef' in org.apache.camel.dataformat.soap.SoapJaxbDataFormat can't be set  it is always null. Therefore declaring the data format with spring-dsl leads to an automatic fallback to the default strategy 'TypeNameStrategy' in org.apache.camel.dataformat.soap.SoapJaxbDataFormat.checkElementNameStrategy(Exchange exchange). This further leads to wrong results when marshalling.So the following declararion does not work correctly:... &lt;bean id='myStrategy' class='org.apache.camel.dataformat.soap.name.ServiceInterfaceStrategy'&gt; &lt;constructor-arg value='my.package.MyServiceInterface'/&gt; &lt;constructor-arg value='true'/&gt; &lt;/bean&gt;... &lt;camelContext xmlns='http://camel.apache.org/schema/spring'&gt;... &lt;dataFormats&gt; &lt;soapjaxb id='mySoap'  contextPath='my.package'  elementNameStrategyRef='myStrategy'/&gt; &lt;/dataFormats&gt;... &lt;route&gt; &lt;from uri='cxf:/MyService?serviceClass=my.package.MyServiceInterface' /&gt;... &lt;convertBodyTo type='my.package.MyType'/&gt; &lt;marshal ref='mySoap'/&gt;...",
            "id": "4254"
        },
        "4257": {
            "ground_truth": "0",
            "bug_report": "Expose setDeliveryMode property in org.apache.camel.component.jms.JmsComponent\nIt would be beneficial if org.apache.camel.component.jms.JmsComponent would allow to specify JMS deliveryMode explicitly. Currently  from what I can tell  there is only boolean deliveryPersistent property which is not enough if JMS provider supports additional non-standard delivery modes. Example is Tibco EMS RELIABLE_DELIVERY mode.",
            "id": "4257"
        },
        "4261": {
            "ground_truth": "1",
            "bug_report": "Properties component - Cached locations may add duplicates\nSee nabblehttp://camel.465427.n5.nabble.com/LRUCache-memory-leak-when-using-camel-properties-file-tp4621357p4621357.htmlThe internal cache should be a soft cache and we should use a key holder to ensure equals/hashCode",
            "id": "4261"
        },
        "4264": {
            "ground_truth": "0",
            "bug_report": "The routeContext stack of DefaultUnitOfWork should be thread safe\nHere is the stack tracejava.util.EmptyStackException at java.util.Stack.peek(Stack.java:85) at java.util.Stack.pop(Stack.java:67) at org.apache.camel.impl.DefaultUnitOfWork.popRouteContext(DefaultUnitOfWork.java:226) at org.apache.camel.processor.DefaultChannel$1.done(DefaultChannel.java:260) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:330) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:208) at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:256) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70) at org.apache.camel.processor.Pipeline.process(Pipeline.java:143) at org.apache.camel.processor.Pipeline.process(Pipeline.java:78) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:113) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:91) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85) at org.apache.camel.processor.aggregate.AggregateProcessor$1.run(AggregateProcessor.java:397) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619)You can find more information in this mail thread&#91;1&#93;&#91;1&#93;http://camel.465427.n5.nabble.com/EmptyStackException-in-DefaultUnitOfWork-popRouteContext-td4630106.html",
            "id": "4264"
        },
        "4268": {
            "ground_truth": "0",
            "bug_report": "Camel-AWS: Add support for adding CacheControl and ContentDisposition metadata support when uploading file\nAdd support for setting the CacheControl and ContentDisposition metadata information for the object.Proposed Implementation:1) Add two new headers: CamelAwsS3CacheControl and CamcelAwsS3ContentDisposition. 2) Add corresponding enumerations in S3Constants3) Set the corresponding data into PutObjectRequest in S3Producer.",
            "id": "4268"
        },
        "4269": {
            "ground_truth": "0",
            "bug_report": "Connection to sftp server occasionally don't want to come back\nProblem appear if somebody kill logged on user on sftp server while you are connected with consumer.Camel is not able to reconnect on next poll even if it says that it will do this.RemoteFileConsumer is not connected but it thinks that it is still logged in.I think 'loggedIn' flag should be down after each disconnecting action like in attached patch.2011-07-24 22:35:14 848 WARN &#91;RemoteFilePollingConsumerPollStrategy:37&#93; Trying to recover by disconnecting from remote server forcing a re-connect at next poll: sftp://test@host 2011-07-24 22:35:14 849 WARN &#91;RemoteFilePollingConsumerPollStrategy:52&#93; Consumer Consumer&#91;sftp://test@host/test?delay=60000&amp;delete=true&amp;localWorkDirectory=%2Fvar%2Ftest%2Ftemp&amp;password=xxxx&amp;throwExceptionOnConnectFailed=true&#93; could not poll endpoint: sftp://test@host/test?delay=60000&amp;delete=true&amp;localWorkDirectory=%2Fvar%2Ftest%2Ftemp&amp;password=xxxx&amp;throwExceptionOnConnectFailed=true caused by: Cannot change directory to: test org.apache.camel.component.file.GenericFileOperationFailedException: Cannot change directory to: test at org.apache.camel.component.file.remote.SftpOperations.doChangeDirectory(SftpOperations.java:408) at org.apache.camel.component.file.remote.SftpOperations.changeCurrentDirectory(SftpOperations.java:393) at org.apache.camel.component.file.remote.SftpConsumer.doPollDirectory(SftpConsumer.java:77) at org.apache.camel.component.file.remote.SftpConsumer.pollDirectory(SftpConsumer.java:49) at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:83) at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:97) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:204) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662)Caused by: 4:  at com.jcraft.jsch.ChannelSftp.cd(ChannelSftp.java:285) at org.apache.camel.component.file.remote.SftpOperations.doChangeDirectory(SftpOperations.java:406) ... 14 moreCaused by: java.io.IOException: Pipe closed at java.io.PipedInputStream.read(PipedInputStream.java:291) at java.io.PipedInputStream.read(PipedInputStream.java:361) at com.jcraft.jsch.ChannelSftp.fill(ChannelSftp.java:2333) at com.jcraft.jsch.ChannelSftp.header(ChannelSftp.java:2359) at com.jcraft.jsch.ChannelSftp._realpath(ChannelSftp.java:1819) at com.jcraft.jsch.ChannelSftp.cd(ChannelSftp.java:268) ... 15 more",
            "id": "4269"
        },
        "4272": {
            "ground_truth": "0",
            "bug_report": "camel-jdbc should provide a option not set the autoCommit flag\nWhen the jdbc connection is work as XA resource  the connection autoCommit flag doesn't support to be reset.So we should provide an option in the camel-jdbc endpont not to set the autoCommit flag on the connection.",
            "id": "4272"
        },
        "4274": {
            "ground_truth": "0",
            "bug_report": "MDCUnitOfWork behaviour incorrect with nested routes\nMDCUnitOfWork.clear() removes any content set by MDCUnitOfWork from MDC.If there are two separate exchange running at the same time in the same thread  as happens when a ProduceTemplate is used from Java  this is incorrect because the MDC of the parent is cleared after the child completes.Conceptually the MDC should be a stack  but MDC only accepts strings so the simplest thing to do is for MDCUnitOfWork to replace the previous values in clear().",
            "id": "4274"
        },
        "4282": {
            "ground_truth": "0",
            "bug_report": "Camel archetypes and examples should enable JMX for ActiveMQ\nThe camel-activemq archetype setup an embedded AMQ broker which has JMX disabled.We should check all our examples and archetypes that JMX is enabled for AMQ when its embedded.As it may confuse end users that they can see Camel in JMX  but not AMQ.",
            "id": "4282"
        },
        "4283": {
            "ground_truth": "0",
            "bug_report": "dump as xml fails if message body is already xml\nMessageHelper.dumpAsXml has a problem if the message body is already xml.",
            "id": "4283"
        },
        "4287": {
            "ground_truth": "0",
            "bug_report": "camel-aws won't build offline\nIf you build camel-aws in Maven's offline mode (-o)  you may get the following error:No versions available for org.codehaus.jackson:jackson-core-asl:jar:[1.4 ) within specified rangeThis will occur even if you have the libs locally. This is happening because Maven cannot download the remote metadata to get a list of versions for jackson-core-asl. Specifying a hard version for this (not a range) gets around the issue. Committing a fix shortly.",
            "id": "4287"
        },
        "4293": {
            "ground_truth": "0",
            "bug_report": "@Bean method name is ignored\nSince 2.8.0 Exchange.BEAN_METHOD_NAME is always used instead of @Bean method name (see BeanInfo.createInvocation(Object pojo  Exchange exchange)). As a consequence  the wrong method is choosen when I use a beanref invokation on a method that uses @Bean parameter binding.I built a simple test case as a zip file containing an Eclipse Helios maven project (see attachment). The test fails with camel 2.8.0 and succeeds with 2.7.3 and earlier (at least until 2.6.0).regards Vincent MATHON",
            "id": "4293"
        },
        "4294": {
            "ground_truth": "0",
            "bug_report": "Camel CXF Endpoint creates incomplete WSDL\nThe dynamically created WSDL for a cxf:cxfEndpoint declaration is malformed when using a complex type as parameter.Please see as well the discussion here.http://camel.465427.n5.nabble.com/Camel-CXF-Endpoint-creating-incomplete-WSDL-td4642433.htmlUse attached test project to run mvn test with version 2.8.0 and 2.7.2  this should show the error.",
            "id": "4294"
        },
        "4297": {
            "ground_truth": "0",
            "bug_report": "Add errorHandler option for DMLC to camel-jms\nIn Spring 3 a org.springframework.util.ErrorHandler can be used to react to unhandled exceptions (unlike JMSExceptions handled by an javax.jms.ExceptionListenerSee http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html#setErrorHandler(org.springframework.util.ErrorHandler)I'm going to add an option for this to camel-jms shortly.",
            "id": "4297"
        },
        "4305": {
            "ground_truth": "0",
            "bug_report": "xslt component - Cannot load xslt file from file system\nSee nabblehttp://camel.465427.n5.nabble.com/Custom-URIResolver-for-Camel-tp4665485p4665485.htmlThe Spring IO resource is a bit pants  as you ask for it to give an input stream  and then it fails doing that for a plain file url.Instead it gives you an URL connection  and you get a unknown host exception.",
            "id": "4305"
        },
        "4311": {
            "ground_truth": "0",
            "bug_report": "Camel Bindy Parser One to Many KvP Unmarshall Issue\nBindy KvP unmarshall issue. While unmarshalling FIX messages  camel-bindy causing inconsistencies if the incoming fix messages are defined to map using 'OneToMany' annotations.In a given route for eg: BindyKeyValuePairDataFormat kvpBindyDataFormat = new BindyKeyValuePairDataFormat('org.apache.camel.dataformat.bindy.model.fix.complex.onetomany'); public void configure() { from(URI_DIRECT_START).unmarshal(kvpBindyDataFormat).to(URI_MOCK_RESULT); }kvpBindyDataFormat is single instance for multiple threads and with in 'BindyKeyValuePairFactory' class instance varialbe below is shared across multiple threads causing data inconsistencies.private Map&lt;String  List&lt;Object&gt;&gt; lists = new HashMap&lt;String  List&lt;Object&gt;&gt;(); Values from previous thread/messages are retained in the current thread causing issues.For eg in the test case: public class BindyComplexOneToManyKeyValuePairUnMarshallTest extends CommonBindyTest if we send another message with no repeating groups are sent.String message2 = '8=FIX 4.19=2034=135=049=INVMGR56=BRKR' + '1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test'  + '10=220';The output message has repeating group data from message processed in earlier thread are pouplated causing data inconsistencies.Please suggest the fix considering multi-threading scenario. I am willing to volunteer for the fix.Regards Surya",
            "id": "4311"
        },
        "4319": {
            "ground_truth": "0",
            "bug_report": "Example feature: wrong spring version\nFeatureapache-camel-2.8.0.zip/apache-camel-2.8.0/examples/camel-example-etl/src/main/resources/features.xml contains &lt;bundle&gt;mvn:org.springframework/spring-jdbc/2.5.6.SEC01&lt;/bundle&gt; &lt;bundle&gt;mvn:org.springframework/spring-orm/2.5.6.SEC01&lt;/bundle&gt; Exception during 'hibernate-feauture' feature installation:12:23:21 337 | INFO | l Console Thread | araf.shell.console.jline.Console 258 | 36 - org.apache.karaf.shell.console - 2.2.1 | Exception caught while executing command java.lang.Exception: Could not start bundle mvn:org.springframework/spring-jdbc/2.5.6.SEC01 in feature(s) hibernate-feauture-0.0.0: The bundle 'org.springframework.jdbc_2.5.6.SEC01 &#91;332&#93;' could not be resolved. Reason: Missing Constraint: Import-Package: org.springframework.dao; version='&#91;2.5.6.SEC01 2.5.6.SEC01&#93;' at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeatures(FeaturesServiceImpl.java:353)&#91;38:org.apache.karaf.features.core:2.2.1&#93;...Caused by: org.osgi.framework.BundleException: The bundle 'org.springframework.jdbc_2.5.6.SEC01 &#91;332&#93;' could not be resolved. Reason: Missing Constraint: Import-Package: org.springframework.dao; version='&#91;2.5.6.SEC01 2.5.6.SEC01&#93;' at org.eclipse.osgi.framework.internal.core.AbstractBundle.getResolverError(AbstractBundle.java:1317)&#91;osgi-3.6.0.v20100517.jar:&#93; at org.eclipse.osgi.framework.internal.core.AbstractBundle.getResolutionFailureException(AbstractBundle.java:1301)&#91;osgi-3.6.0.v20100517.jar:&#93; at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:319)&#91;osgi-3.6.0.v20100517.jar:&#93; at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)&#91;osgi-3.6.0.v20100517.jar:&#93; at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)&#91;osgi-3.6.0.v20100517.jar:&#93; at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeatures(FeaturesServiceImpl.java:350)&#91;38:org.apache.karaf.features.core:2.2.1&#93; ... 15 moreSolution:Change version for bundles org.springframework/spring-jdbc and org.springframework/spring-orm to 3.0.5.RELEASE instead 2.5.6.SEC01.",
            "id": "4319"
        },
        "4325": {
            "ground_truth": "0",
            "bug_report": "Wrong exception uri when an HTTP error code is returned\nWhen a REST service returns an HTTP error code (e.g. 404)  the URI property of the exception is incorrect.The URI is the URI of the origin endpoint of the route.It should be instead the URI of the endpoint that threw the exception.For instance  in the following route :&lt;route id='restproxy'&gt; &lt;from uri='restlet:http://localhost:9080/oe/ws/offre/{id}'/&gt; &lt;doTry&gt; &lt;to uri='restlet:http://bla.dot.com:8080/oe/ws/offre/{id}'/&gt; &lt;doCatch&gt; &lt;exception&gt;org.apache.camel.CamelException&lt;/exception&gt; &lt;log message='URI=${exception.uri}'/&gt; &lt;/doCatch&gt; &lt;/doTry&gt;&lt;/route&gt;The logged URI is 'restlet:http://localhost:9080/oe/ws/offre/{id}' but should be instead the real URI used  e.g. 'restlet:http://bla.dot.com:8080/oe/ws/offre/1'.This bug might be fixed by the following code change in class org.apache.camel.component.restlet.RestletProducer  method populateRestletProducerException() : String uri = exchange.getFromEndpoint().getEndpointUri(); + String uri = response.getRequest().getResourceRef()",
            "id": "4325"
        },
        "4342": {
            "ground_truth": "0",
            "bug_report": "Validator component - Should be able to validate from a File payload\nThe validator component should be able to validate a message which is from a java.io.File.What is needed is a couple of type converters to ensure this.",
            "id": "4342"
        },
        "4348": {
            "ground_truth": "0",
            "bug_report": "Add String->TimeZone converter so that time zone can be specified for camel-quartz\nIt is possible to specify a time zone for Quartz  however  in order for that to work Camel needs a String to TimeZone type converter since Quartz requires a TimeZone.Attached is a patch containing a type converter that works. By setting the type converter explicitly on the context like this context.getTypeConverterRegistry().addTypeConverter(TimeZone.class  String.class  new String2TimeZoneConverter());it is possible to create an endpoint URI looking like this:quartz://groupName/timerName?cron=&lt;cronExpression&gt;&amp;trigger.timeZone=Europe/StockholmHowever  it would be really useful if this type converter could be included in camel-core. This has been discussed on the camel user list:http://camel.465427.n5.nabble.com/How-to-specify-a-time-zone-for-camel-quartz-td4700077.html",
            "id": "4348"
        },
        "4351": {
            "ground_truth": "0",
            "bug_report": "Impossible to use placeholders in endpointName and serviceName attributes of cxf:cxfEndpoint\nHere is how endpointName and serviceName are declared in XSD.&lt;xsd:attribute name='endpointName' type='xsd:QName' /&gt; &lt;xsd:attribute name='serviceName' type='xsd:QName' /&gt; So the xml parser fails to parse the following element&lt;cxf:cxfEndpoint id='service' address='${http.service.endpoint.path}' wsdlURL='${http.service.wsdl.path}' serviceName='${http.service.serviceName}' endpointName='${http.service.portName}'&gt;&lt;/cxf:cxfEndpoint&gt;",
            "id": "4351"
        },
        "4352": {
            "ground_truth": "0",
            "bug_report": "Ftp consumer using done file should cater for if stepwise has been enabled  and thus the done file path is to be calculated differently\nThe workaround is to use ${file:onlyname} or not using stepwise.",
            "id": "4352"
        },
        "4353": {
            "ground_truth": "0",
            "bug_report": "Using transacted in Java DSL without Spring XML setting up TX manager should report better error when not able to find a TX manager in the registry\nSee nabblehttp://camel.465427.n5.nabble.com/Transaction-configuration-in-Java-DSL-tp4711625p4711625.htmlYou will see an error likeException in thread 'main' org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: &gt;&gt;&gt; Policy&#91;ref:null&#93; &lt;&lt;&lt; We should improve that and report a more details error.",
            "id": "4353"
        },
        "4356": {
            "ground_truth": "0",
            "bug_report": "faster way of testing for file existence\nwhen storing a file the ftp component checks if the file exists in the endpoint  this is done by listing the content of the destination folder and looping through all files listed. the list operation takes a long time when the destination folder contains hundreds of files. instead of listing for all files the component can simply list for the file it is interested on  this way the number of files contained in destination folder won't affect the time it takes the producer to process the exchange. I currently have a case where delivering to an endpoint is taking more than a minute because of this issue. Both ftp and sftp libraries used supports listing for a single file so the changes would be the following: FtpOperations.javapublic boolean existsFile(String name) throws GenericFileOperationFailedException { String[] names = client.listNames(name); if (names == null) { return false; } return (names.lenght &gt;= 1); } SftpOperations.javapublic boolean existsFile(String name) throws GenericFileOperationFailedException { Vector files = channel.ls(name); if (names == null) { return false; } return (names.size &gt;= 1); }",
            "id": "4356"
        },
        "4357": {
            "ground_truth": "0",
            "bug_report": "Move org.apache.camel.Main to org.apache.camel.main.Main\nI am currently looking into the dependencies betwen packages in camel-core. The packages org.apache.camel and org.apache.camel.spi form the camel api.So I am trying to make them not depend on other packages from camel-core. One problem there is the starter class Main. It needs access to impl packages as it needs to start camel. So it should not live in org.apache.camel.I propose to move it to org.apache.camel.main. To not break anything right now I will create a deprecated class Main in org.apache.camel that extends the moved Main. We can remove the deprecated version in camel 3.0",
            "id": "4357"
        },
        "4358": {
            "ground_truth": "0",
            "bug_report": "Refactoring of management code to remove cycles and clearly separate between API and impl\nCurrently the management code (org.apache.camel.management.*) contains a mix of implementation code and APIs. This leads to cycle in the management code as well as to bigger cycles involving all of camel-core.So I propose to do several changes: move interfaces and annotations that form the API to camel.spi.management. As these are probably not used by external components or user code no compatibility classes are created create new package camel.suppport for classes that implement API or SPI classes and are expected to be extended by many impl classes. classes in support may only access the camel API and SPI Move EventNotifierSupport and ServiceSupport to this package. Create deprecate dummys in the old locations to avoid breaking older code Move DefaultEventFactory from management to management.eventI will post a patch shortly for review",
            "id": "4358"
        },
        "4360": {
            "ground_truth": "0",
            "bug_report": "Camel test - Debugger should be explicit enabled if end user want to leverage it\nThe debugger adds a little overhead and silently enables tracer as well. We should have the end user to explicit enable the debugger if he need to use it from his unit tests.",
            "id": "4360"
        },
        "4362": {
            "ground_truth": "0",
            "bug_report": "Bug in parsing of JPA uri\nAccording to http://camel.apache.org/jpa.html entityName is optional.When configuring with the following uri (e.g. w/o entityName):&lt;camel:endpoint id='jpaEndpoint' uri='jpa:?persistenceUnit=journalPersistenceUnit&amp;usePersist=true' /&gt;the following warning will be displayed2011-08-21 18:57:11 381 &#91;main&#93;[][][][][][][] WARN org.apache.camel.util.ObjectHelper - Cannot find class: persistenceUnitjournalPersistenceUnitusePersisttruepersistenceUnitjournalPersistenceUnitusePersisttruedue to the incorrect if test in the JpaComponent:// lets interpret the next string as a class if (path != null) { // provide the class loader of this component to work in OSGi environments as camel-jpa must be able // to resolve the entity classes Class&lt;?&gt; type = getCamelContext().getClassResolver().resolveClass(path  JpaComponent.class.getClassLoader()); if (type != null) { endpoint.setEntityType(type); } }path is not null  but it is the rest of the string and not the entityname. e.g it should not start with ? if it is an entityname - else it is the options.",
            "id": "4362"
        },
        "4365": {
            "ground_truth": "0",
            "bug_report": "Freemarker - Loading template from file system fails\nThis only affects Camel 2.9.",
            "id": "4365"
        },
        "4367": {
            "ground_truth": "0",
            "bug_report": "Camel-netty option 'encoder' and 'decoder' does not work\nContrary to the documentation  the 'encoder' and 'decoder' option is unusable as it's value is taken as-is instead of resolving the references using the registry.This bug was introduced in the revision 960621 as part of CAMEL-2907.Patch can be found at https://github.com/szabolcsberecz/camel/commit/b3bcc8dd284575c931048ea410c44577474e25dd",
            "id": "4367"
        },
        "4370": {
            "ground_truth": "0",
            "bug_report": "It's hardly possible to use all expression of the Simple language to create file names in the file component\nSometimes it can be necessary to use custom headers to create a file name.For example  I declare my file endpoint in the following manner:&lt;route id='fileReader'&gt; &lt;from uri='file://rootFolder?move=.backup&amp;amp;moveFailed=.error/${header.CustomHeader}' /&gt; &lt;to uri='file://out'/&gt;&lt;/route&gt;The header 'CustomHeader' cannot be read because of the following snippets of code in the org.apache.camel.component.file.GenericFile/** * Bind this GenericFile to an Exchange */public void bindToExchange(Exchange exchange) { exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE  this); GenericFileMessage&lt;T&gt; in = new GenericFileMessage&lt;T&gt;(this); exchange.setIn(in); populateHeaders(in);}/** * Populates the {@link GenericFileMessage} relevant headers * * @param message the message to populate with headers */public void populateHeaders(GenericFileMessage&lt;T&gt; message) { if (message != null) { message.setHeader(Exchange.FILE_NAME_ONLY  getFileNameOnly()); message.setHeader(Exchange.FILE_NAME  getFileName()); message.setHeader('CamelFileAbsolute'  isAbsolute()); message.setHeader('CamelFileAbsolutePath'  getAbsoluteFilePath()); if (isAbsolute()) { message.setHeader(Exchange.FILE_PATH  getAbsoluteFilePath()); } else { // we must normalize path according to protocol if we build our own paths String path = normalizePathToProtocol(getEndpointPath() + File.separator + getRelativeFilePath()); message.setHeader(Exchange.FILE_PATH  path); } message.setHeader('CamelFileRelativePath'  getRelativeFilePath()); message.setHeader(Exchange.FILE_PARENT  getParent()); if (getFileLength() &gt;= 0) { message.setHeader('CamelFileLength'  getFileLength()); } if (getLastModified() &gt; 0) { message.setHeader(Exchange.FILE_LAST_MODIFIED  new Date(getLastModified())); } }}As you can see a new 'in' message is created and not all the headers from the original message are copied to it.",
            "id": "4370"
        },
        "4374": {
            "ground_truth": "0",
            "bug_report": "The debugger doesn't work in the CamelSpringTestSupport with route defined in XML\nThe debugger doesn't work in the CamelSpringTestSupport with route defined in XML. This issue is related to CAMEL-4368 (closed and I cannot re-open).I've created a patch with 2 new tests that show the problem and a solution (check the doSetup() method in the tests). However I think this could be improved by moving the SpringCamelContext.setNoStart(true); to CamelSpringTestSupport).",
            "id": "4374"
        },
        "4382": {
            "ground_truth": "1",
            "bug_report": "add support to set the cipher used for SFTP\nRight now a user has to manually configure a JSch instance to set the cipher used. We should have an option for that.",
            "id": "4382"
        },
        "4388": {
            "ground_truth": "0",
            "bug_report": "Exeptions cannot be propagated to the parent route when using LogEIP\nHere is unit test that demonstrates the problem.For the unit test pass successfully it's necessary to delete LogEIP from the route.package org.apache.camel.impl;import org.apache.camel.Exchange;import org.apache.camel.Processor;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class PropagateExceptionTest extends CamelTestSupport { @Test public void failure() throws Exception { getMockEndpoint('mock:handleFailure').whenAnyExchangeReceived(new Processor() { @Override public void process(Exchange exchange) throws Exception { throw new RuntimeException('TEST EXCEPTION'); } }); getMockEndpoint('mock:exceptionFailure').expectedMessageCount(1); sendBody('direct:startFailure'  'Hello World'); assertMockEndpointsSatisfied(); } @Test public void success() throws Exception { getMockEndpoint('mock:handleSuccess').whenAnyExchangeReceived(new Processor() { @Override public void process(Exchange exchange) throws Exception { throw new RuntimeException('TEST EXCEPTION'); } }); getMockEndpoint('mock:exceptionSuccess').expectedMessageCount(1); sendBody('direct:startSuccess'  'Hello World'); assertMockEndpointsSatisfied(); } @Override protected RouteBuilder[] createRouteBuilders() throws Exception { return new RouteBuilder[] { new RouteBuilder() { public void configure() throws Exception { from('direct:startFailure') .onException(Throwable.class) .to('mock:exceptionFailure') .end() .to('direct:handleFailure') .to('mock:resultFailure'); from('direct:handleFailure') .errorHandler(noErrorHandler()) .log('FAULTY LOG') .to('mock:handleFailure'); } }  new RouteBuilder() { public void configure() throws Exception { from('direct:startSuccess') .onException(Throwable.class) .to('mock:exceptionSuccess') .end() .to('direct:handleSuccess') .to('mock:resultSuccess'); from('direct:handleSuccess') .errorHandler(noErrorHandler()) .to('mock:handleSuccess'); } } }; }}",
            "id": "4388"
        },
        "4408": {
            "ground_truth": "0",
            "bug_report": "Fix OSGi-exports of camel-soap\nThe OSGi exports of camel-soap is not correct. If I run exports in karaf I get the following output.  karaf@localhost&gt; exports 135 ID Packages 135 org.apache.camel.dataformat.soap; version='0.0.0' 135 org.apache.camel.dataformat.soap.name; version='0.0.0' 135 org.xmlsoap.schemas.soap.envelope; version='2.8.1.SNAPSHOT' I think org.apache.camel.dataformat.soap and org.apache.camel.dataformat.soap.name should be exported with version='2.8.1.SNAPSHOT' ???? (The same issue is on trunk).",
            "id": "4408"
        },
        "4410": {
            "ground_truth": "0",
            "bug_report": "The URI of the ServletEndpoint exposed to the JMX is not accurate\nAs an example a ServletEndpoint with the URI 'servlet:///test?matchOnUriPrefix=true&amp;servletName=test' is exposed as '/test' on the JMX-MBeanServer! For details see:http://camel.465427.n5.nabble.com/backslashes-on-Endpoint-URI-by-JConsole-td4757427.html",
            "id": "4410"
        },
        "4414": {
            "ground_truth": "0",
            "bug_report": "CamelLogger should not be a Processor and a log class at the same time and it should not have ServiceSupport\nCamelLogger currently does too many things.1. It is a log class that stores a log level and a slf4j logger. It suppports some methods for logging with the set level2. It is a processor for logging exchanges3. It extends ServiceSupport even though it has no services (is apparently needed fro ThroughputLoggerSo what I propose is: Leave the current class as is but mark as @Deprecated Introduce a new CamelLogger that only supports 1. Introduce a CamelLogProcessor in processor that only supports 2. Make ThroughputLogger not extend CamelLogger but instead delegate to the new CamelLogger",
            "id": "4414"
        },
        "4418": {
            "ground_truth": "0",
            "bug_report": "camel-hazelcast should allow the user to provide an existing instance to the component\nThe camel-hazelcast component currently is using Hazelcast default instance. It should allow the user to specify an existing HazelcastInstance and fall back to the default instance if none is provided. Finally  in the case that the component is using the default instance it should shut it down when the component is stopped.",
            "id": "4418"
        },
        "4439": {
            "ground_truth": "0",
            "bug_report": "Error in camel-restlet feature definition\nThe current contents of the camel-features.xml file reads:&lt;feature name='camel-restlet' version='2.7.1-fuse-00-43' resolver='(obr)'&gt; &lt;feature version='2.7.1-fuse-00-43'&gt;camel-core&lt;/feature&gt; &lt;bundle dependency='true'&gt;mvn:org.apache.camel/camel-restlet/2.7.1-fuse-00-43&lt;/bundle&gt; &lt;bundle&gt;mvn:http://maven.restlet.org!org.restlet.jse/org.restlet/2.0.5&lt;/bundle&gt;&lt;/feature&gt;It actually should read http://fernandoribeiro.eti.br/2011/09/12/bug-in-fuse-4-4/ (Thanks to Fernando Ribeiro for the heads up!)",
            "id": "4439"
        },
        "4440": {
            "ground_truth": "0",
            "bug_report": "camel-csv - Make it consistent what unmarshal returns as object  so its the same for 1 or more rows\nSee nabblehttp://camel.465427.n5.nabble.com/unmarshal-CsvDataFormat-different-behavior-for-one-or-multiples-lines-tp4778814p4778814.htmlThe camel-csv should always return the same List&lt;List&gt;&gt; regardless if there is 0  1 or 2+ rows returned. That makes it consistent and easier for end users who need to work with this data.",
            "id": "4440"
        },
        "4444": {
            "ground_truth": "0",
            "bug_report": "Wrong slash in FTP component for doneFile\nI tried to use the doneFile with FTP component.When I used it to my FTP on my windows machine everything goes fine.When I tried to act the same with a FTP host on a Linux machine  I got an issue.I sniff the packet to see what goes wrong and I see this :the doneFile DELE public/Test/in/myFile.txt the file to processDELE public/Test/in/myFile.xmlAfter a Quick look on the code:org.apache.camel.component.file.GenericFileEndpoint line 682 String answer = pattern; if (ObjectHelper.isNotEmpty(path) &amp;&amp; ObjectHelper.isNotEmpty(pattern)) { // done file must always be in same directory as the real file name answer = path + File.separator + pattern; } if (getConfiguration().needToNormalize()) { // must normalize path to cater for Windows and other OS answer = FileUtil.normalizePath(answer); }We use the 'File.Separator' but in this case  it should get a kind of 'FTP.Separator' or the FTP component should return true to the needToNormalize method and change the narmalizePath method to manage this case.",
            "id": "4444"
        },
        "4446": {
            "ground_truth": "0",
            "bug_report": "camel-bindy - Marshaling using CSV will insert wrong char separator if using an escaped separator char such as a pipe\nWhen using bindy in CSV format with a separator in the model as '|' to denote a pipe character  then it does not work consistent for marshal and unmarshal. In marshal it will insert / as separator  but it should use | instead.See nabblehttp://camel.465427.n5.nabble.com/bindy-different-behavior-between-marshal-and-unmarshal-with-pipe-separator-tp4798488p4798488.html",
            "id": "4446"
        },
        "4449": {
            "ground_truth": "1",
            "bug_report": "NullPointerException when unmarshalling using serialization data format\nSpring configuration: &lt;!-- A custom CamelContext --&gt; &lt;camel:camelContext id='camel'&gt; &lt;!-- JSON data format marshalling --&gt; &lt;camel:dataFormats&gt; &lt;camel:serialization id='serialization'/&gt; &lt;/camel:dataFormats&gt; &lt;!-- RawOffer input route --&gt; &lt;camel:route&gt; &lt;camel:from uri='kestrel://etl01f/feeds'/&gt; &lt;camel:unmarshal ref='serialization'/&gt; &lt;camel:to uri='bean:shard?method=consume'/&gt; &lt;/camel:route&gt; &lt;/camel:camelContext&gt;Exception:run: [java] log4j:WARN No appenders could be found for logger (org.springframework.context.support.ClassPathXmlApplicationContext). [java] log4j:WARN Please initialize the log4j system properly. [java] log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. [java] 13:28:07.587 [main] INFO o.a.c.s.h.CamelNamespaceHandler - OSGi environment not detected. [java] 13:28:09.028 [main] INFO o.a.camel.spring.SpringCamelContext - Apache Camel 2.8.0 (CamelContext: camel) is starting [java] 13:28:09.028 [main] INFO o.a.camel.spring.SpringCamelContext - JMX enabled. Using ManagedManagementStrategy. [java] 13:28:09.415 [main] INFO o.a.c.i.c.AnnotationTypeConverterLoader - Found 3 packages with 14 @Converter classes to load [java] 13:28:09.489 [main] INFO o.a.c.i.c.DefaultTypeConverter - Loaded 153 core type converters (total 153 type converters) [java] 13:28:09.528 [main] INFO o.a.c.i.c.DefaultTypeConverter - Loaded additional 0 type converters (total 153 type converters) in 0.003 seconds [java] 13:28:09.730 [main] INFO o.a.c.c.kestrel.KestrelComponent - Creating endpoint for queue 'feeds' on etl01f  parameters={} [java] 13:28:09.967 [main] INFO o.a.c.c.kestrel.KestrelComponent - Creating MemcachedClient for etl01f/feeds [java] 2011-09-14 13:28:10.073 INFO net.spy.memcached.MemcachedConnection: Added {QA sa=etl01f/95.108.229.218:22133  #Rops=0  #Wops=0  #iq=0  topRop=null  topWop=null  toWrite=0  interested=0} to connect queue [java] 2011-09-14 13:28:10.084 INFO net.spy.memcached.MemcachedConnection: Connection state changed for sun.nio.ch.SelectionKeyImpl@711b50a1 [java] 13:28:10.293 [main] INFO o.a.c.c.kestrel.KestrelConsumer - Starting consumer for kestrel://etl01f/feeds [java] 13:28:10.302 [main] INFO o.a.camel.spring.SpringCamelContext - Route: route1 started and consuming from: Endpoint[kestrel://etl01f/feeds] [java] 13:28:10.318 [main] INFO o.a.camel.spring.SpringCamelContext - Total 1 routes  of which 1 is started. [java] 13:28:10.318 [main] INFO o.a.camel.spring.SpringCamelContext - Apache Camel 2.8.0 (CamelContext: camel) started in 1.291 seconds [java] 13:28:12.858 [Camel (camel) thread #0 - Poller-kestrel://etl01f/feeds] ERROR o.a.c.processor.DefaultErrorHandler - Failed delivery for exchangeId: ID-incubos-osx-local-51787-1315992488896-0-1. Exhausted after delivery attempt: 1 caught: java.lang.NullPointerException [java] java.lang.NullPointerException: null [java] at org.apache.camel.impl.SerializationDataFormat.unmarshal(SerializationDataFormat.java:57) ~[camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.UnmarshalProcessor.process(UnmarshalProcessor.java:56) ~[camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:50) ~[camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:69) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:99) ~[camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:318) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:209) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:305) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.Pipeline.process(Pipeline.java:116) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.Pipeline.process(Pipeline.java:79) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:102) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:69) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:104) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85) [camel-core-2.8.0.jar:2.8.0] [java] at org.apache.camel.component.kestrel.KestrelConsumer$Poller.run(KestrelConsumer.java:230) [camel-kestrel-2.8.0.jar:2.8.0] [java] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) [na:1.6.0_26] [java] at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) [na:1.6.0_26] [java] at java.util.concurrent.FutureTask.run(FutureTask.java:138) [na:1.6.0_26] [java] at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [na:1.6.0_26] [java] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [na:1.6.0_26] [java] at java.lang.Thread.run(Thread.java:680) [na:1.6.0_26]It seems that ExchangeHelper.convertToType() method returned null because camelContext.getTypeConverter() returned null.",
            "id": "4449"
        },
        "4457": {
            "ground_truth": "0",
            "bug_report": "Resolve cycle between language.simple and language.simple.ast\nCurrently we have a big dpendency cycle between language.simple and language.simple.ast.As simple creates the ast this dependency is necessary. In the other direction ast needs types and exceptions that are inside simple.So I propose to nove these classes into a package simple.types. As I think these types and exceptions are not used outside the camel-core I will not create compatibility measures.",
            "id": "4457"
        },
        "4473": {
            "ground_truth": "0",
            "bug_report": "Unable to use cxf:binding configuration for the endpoint\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'service': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'bindingConfig' of bean class [org.apache.camel.component.cxf.CxfSpringEndpoint]: Bean property 'bindingConfig' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter? at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1361) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1086) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:84) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:1) at org.springframework.test.context.TestContext.loadApplicationContext(TestContext.java:280) at org.springframework.test.context.TestContext.getApplicationContext(TestContext.java:304) ... 30 moreCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'bindingConfig' of bean class [org.apache.camel.component.cxf.CxfSpringEndpoint]: Bean property 'bindingConfig' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter? at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:1024) at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:900) at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:76) at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:58) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1358) ... 44 more",
            "id": "4473"
        },
        "4474": {
            "ground_truth": "0",
            "bug_report": "file: consumer does not create directory\nAccording to http://camel.apache.org/file2.html autoCreate is true by default and should for a consumer create the directory.autoCreate true Automatically create missing directories in the file's pathname. For the file consumer  that means creating the starting directory. For the file producer  it means the directory the files should be written to. This does not happen and thus a route startup would fail.",
            "id": "4474"
        },
        "4478": {
            "ground_truth": "0",
            "bug_report": "Because local PrintService objects on Windows have a name which is not their UNC path  the PrinterProducer can never find them.\nIn org.apache.camel.component.printer.PrinterProducer  the line:setPrinter('////' + config.getHostname() + '' + config.getPrintername());reconstructs a UNC path which is expected to match the name of a PrintService on the system. For local printers on Windows  the name of the PrintService is simply the name of the printer without the host and any backslashes  so the PrinterProducer is never able to find them.So when config.getHostname() is 'localhost'  at least on Windows  the line should be simply:setPrinter(config.getPrintername())so that we'd have code like:if ('localhost'.equalsIgnoreCase(config.getHostname())) { setPrinter(config.getPrintername());} else { setPrinter('////' + config.getHostname() + '//' + config.getPrintername());}This can only work if issue CAMEL-4477 about the error in parseURI() in PrinterConfiguration is also fixed.",
            "id": "4478"
        },
        "4486": {
            "ground_truth": "0",
            "bug_report": "Exceptions are not propagated to the parent route when endpoint cannot be resolved in the RoutingSlip EIP\nHere is the unit test to reproduce the issuepackage org.test;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class RecipientListTest extends CamelTestSupport { public static class Router { public String findEndpoint() { return 'unresolved://endpoint'; } } @Test public void recipientList() throws Exception { MockEndpoint endpoint = getMockEndpoint('mock://error'); endpoint.expectedMessageCount(1); sendBody('direct://parent'  'Hello World!'); assertMockEndpointsSatisfied(); } @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { @Override public void configure() throws Exception { from('direct://parent') .onException(Throwable.class) .to('mock://error') .end() .to('direct://child'); from('direct://child') .errorHandler(noErrorHandler()) .routingSlip(bean(Router.class)); } }; }}",
            "id": "4486"
        },
        "4492": {
            "ground_truth": "0",
            "bug_report": "Be able to check classtype through simple language\nSee http://camel.465427.n5.nabble.com/How-do-I-access-the-message-class-name-from-Simple-td4842269.html for the full context.In short be able to access Object.getClass() for usage in Camel's simple language.",
            "id": "4492"
        },
        "4500": {
            "ground_truth": "0",
            "bug_report": "Add a Tracer that uses JMX Notifications and provides full details of Camel Messages\nWe should create a base for Camel Trace toolings so these can trace the full message content.The trace event should contain: all Exchange Data including properties all Message Data including headersThere should be a setting to truncate the message body as it can be quite long and often in tracing not all details are needed.One question is if this tracing should be combined with the current Notifications or should be a separate thing.",
            "id": "4500"
        },
        "4503": {
            "ground_truth": "0",
            "bug_report": "Recipient List cannot vary destination by changing property in an expression\nThis is probably due to producers being cached based on unresolved endpoint URI  rather than the resolved endpoint URI. Haven't tested this theory out though.See message on user list http://markmail.org/message/sdysp6sspq5lomf4",
            "id": "4503"
        },
        "4506": {
            "ground_truth": "1",
            "bug_report": "The SFTP component: the keyboard-interactive auth method support\nAs it was discussed in this topic http://camel.465427.n5.nabble.com/The-SFTP-component-the-keyboard-interactive-auth-method-support-td4853523.htmlThe SFTP component may be slightly improved to support the keyboard-interactive auth method and the compression Preamble:It appeared that our sftp share we get files from doesn't support the ssh password auth method and we're not allowed to put the public key to there. So the only ssh auth method we can use is the keyboard-interactive. Unfortunately the SFTP camel component doesn't support this.However this can be easily fixed simply by providing the Jsch session with both the com.jcraft.jsch.UserInfo and com.jcraft.jsch.UIKeyboardInteractive interfaces. The UIKeyboardInteractive has the only one promptKeyboardInteractive method which returns String[] containing the password entered by user interactively. In our case I simply return a password.The implementation example is attached.Also it's sometime required to set the ssh compression to be able to process longsize files. The compression fix is also implemented in the attached file. Compression requires the zlib jar to be in the pom.This was tested with the 0.1.44-1 version of the jsch and the 1.0.7 version of the jzlib.",
            "id": "4506"
        },
        "4515": {
            "ground_truth": "0",
            "bug_report": "Spring-WS should populate Camel Header with the SOAP Header\nCurrently the Camel-Spring-WS component does not support the setting of SOAP Headers and has issues getting them. The current issue getting the SOAP Headers when receiving a message is that the resulting header key includes the namespace.Change the component so that a Camel header 'CamelSpringWebserviceSoapHeader' can be populated with an intended SOAP Header for a request  and that this Header is also populated from the SOAP Header on a response.",
            "id": "4515"
        },
        "4540": {
            "ground_truth": "0",
            "bug_report": "Unable to convert jms textmessage to bytemessage\nWhen receiving a jms textmessage and just forward it to a another queue as a jms bytemessage the original textmessage is sendt without being converted to a jms bytemessage. JmsBinding.makeJmsMessage seems to use the exchange headers to determine of a new jms message should be created or the original send.Exchange headers seems to be populated if you do routing or set a dummy header.See http://camel.465427.n5.nabble.com/Convert-jms-message-from-textmessage-to-bytemessage-tc4895362.html/preben",
            "id": "4540"
        },
        "4542": {
            "ground_truth": "0",
            "bug_report": "Can't find splitter bean in registry using multiple camel contexts with 'vm' endpoint\nThe splitter component can use a bean with a 'split method'. It seems that this 'split bean' is handled as expression and resolved lately using Camel Context from current exchange.If I send an exchange using a separate CamelContext ('client')&lt;camelContext id='client' xmlns='http://camel.apache.org/schema/spring'&gt;&lt;/camelContext&gt;to a route defined in another CamelContext ('server') using in-memory transport like 'direct' or 'vm'&lt;camelContext id='server' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;route id='route02' trace='false' streamCache='false'&gt; &lt;from uri='vm:route02'/&gt; &lt;split&gt; &lt;method bean ='stringLineSplitter' method='split'/&gt; &lt;log message='before sending: ${body}'/&gt; &lt;inOut uri ='vm:route04'/&gt; &lt;log message='after sending'/&gt; &lt;/split&gt; &lt;to uri='mock:route02'/&gt; &lt;/route&gt;&lt;/camelContext&gt;the test fails with 'Cannot find class: stringLineSplitter' (Camel 2.8.0). 'org.apache.camel.NoSuchBeanException - No bean could be found in the registry for: stringLineSplitter' (Camel 2.9-SNAPSHOT)If I understood Camel right it failsbecause it tries to resolve this bean based on client Camel Contextwhich is still set at the current exchange send from 'client' to 'server' but itdoesn't contain the bean.If I send an exchange using same 'client' CamelContext to another route in'server' CamelContext involving 'external' components like 'jms' (ActiveMQ)&lt;camelContext id='server' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;route id='route03' trace='false' streamCache='false'&gt; &lt;from uri='jms:queue:route03'/&gt; &lt;split&gt; &lt;method bean ='stringLineSplitter' method='split'/&gt; &lt;log message='before sending: ${body}'/&gt; &lt;inOut uri ='vm:route04'/&gt; &lt;log message='after sending'/&gt; &lt;/split&gt; &lt;to uri='mock:route03'/&gt; &lt;/route&gt;&lt;/camelContext&gt;the test passed successfully. It seems that 'jms' component creates anew exchange using 'server' CamelContext.",
            "id": "4542"
        },
        "4551": {
            "ground_truth": "0",
            "bug_report": "NotifyBuilder wereSentTo condition fires too eagerly\nProblem is:NotifyBuilder notify = new NotifyBuilder(context)  .whenDone(2).wereSentTo('mock:bar');The wereSentTo condition will fire after first message gets to endpoint 'mock:bar'  so either needs to take preceding whenDone into account  or wereSentTo needs to have a count condition added to it's method signature.See nabble trail for full details:http://camel.465427.n5.nabble.com/NotifyBuilder-condition-fails-to-match-on-an-out-activemq-endpoint-tp4689038p4867857.html",
            "id": "4551"
        },
        "4555": {
            "ground_truth": "0",
            "bug_report": "Support nested directories with multiple segment files in the HDFS endpoint consumer\nA common pattern in HDFS is for multiple segment files underneath a given directory  representing the fragments of data. Lots of tools understand to automatically merge these segment files (ie hadoop fs -getmerge  pig script loaders). This patch does the same for the HDFS consumer  using a temporary local directory for the merging.Additionally  tools like pig and oozie understand to look for a _SUCCESS file in one of these directories containing segments. This file indicates that the segments have been completely written. This patch additionally skips the directory if a _SUCCESS file is not present.",
            "id": "4555"
        },
        "4556": {
            "ground_truth": "0",
            "bug_report": "NettyProducer creating new connection on every message\nUsing a NettyProducer without the disconnect=true configuration is causing the route to block after 10 messages on the to('netty://tcp....') call.It appears that a new socket connection is created for every message  and then after 10 connections no new connection is allowed (must be a default thread pool limit?).Using the disconnect=true option fixes the problem as a socket is connected  message sent  then disconnected. But this does not seem viable for implementations where that overhead is undesirable or where more than one response is expected on a channel.&#8211;This is a small Unit Test that shows the problem (http://camel.465427.n5.nabble.com/Camel-Netty-Producer-creating-new-connection-on-every-message-td4844805.html#none) package netty; import java.util.Arrays; import java.util.Collection; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicInteger; import junit.framework.TestCase; import org.apache.camel.CamelContext; import org.apache.camel.Exchange; import org.apache.camel.ExchangePattern; import org.apache.camel.Processor; import org.apache.camel.builder.RouteBuilder; import org.apache.camel.impl.DefaultCamelContext; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; import org.slf4j.Logger; import org.slf4j.LoggerFactory; @RunWith(Parameterized.class) public class NettyTest extends TestCase {  private final static Logger logger = LoggerFactory.getLogger(NettyTest.class);  private final static CamelContext serverContext = new DefaultCamelContext();  private final CamelContext clientContext = new DefaultCamelContext();  private final AtomicInteger responseCounter = new AtomicInteger(0);  private final AtomicBoolean passedTen = new AtomicBoolean(false);  private Boolean disconnectClient;  public NettyTest(Boolean disconnectClient)  { this.disconnectClient = disconnectClient; }  @Parameters  public static Collection&lt;Object[]&gt; configs()  {  return Arrays.asList(new Object[][] { { true }  { false } });  }  @BeforeClass  public static void createServer() throws Exception  {  serverContext.addRoutes(new RouteBuilder()  {  @Override  public void configure() throws Exception  {  from('netty:tcp://localhost:9000?sync=true&amp;disconnectOnNoReply=false&amp;allowDefaultCodec=true&amp;tcpNoDelay=true&amp;reuseAddress=true&amp;keepAlive=false')  .setExchangePattern(ExchangePattern.InOut)  .process(new Processor() {  @Override  public void process(Exchange exchange) throws Exception  {  Object body = exchange.getIn().getBody();  logger.info('Request received : Value = {}'  body);  }  })  .transform(constant(3)).stop();  }  });  serverContext.start();  }  @Before  public void createClient() throws Exception  {  clientContext.addRoutes(new RouteBuilder()  {  @Override  public void configure() throws Exception  {  // Generate an Echo message and ensure a Response is sent  from('timer://echoTimer?delay=1s&amp;fixedRate=true&amp;period=1s')  .setExchangePattern(ExchangePattern.InOut)  .transform()  .constant(2)  .to(ExchangePattern.InOut  'netty:tcp://localhost:9000?allowDefaultCodec=true&amp;tcpNoDelay=true&amp;reuseAddress=true&amp;keepAlive=false&amp;sync=true&amp;disconnect=' + disconnectClient.toString())  .process(new Processor()  {  @Override  public void process(Exchange exchange) throws Exception  {  Object body = exchange.getIn().getBody();  logger.info('Response number {} : Value = {}'   responseCounter.incrementAndGet()  body);  if (responseCounter.get() &gt; 10) { passedTen.set(true); }  }  }).stop();  }  });  }  @Test  public void test() throws Exception  {  clientContext.getShutdownStrategy().setTimeout(1);  clientContext.start();  logger.info('Disconnect = {}'  this.disconnectClient);  Thread.sleep(TimeUnit.SECONDS.toMillis(15));  clientContext.stop();  assertTrue('More than 10 responses have been received'  passedTen.get());  } }",
            "id": "4556"
        },
        "4559": {
            "ground_truth": "0",
            "bug_report": "Need to specify the sl4j-api version in the camel maven archetypes\nThere are some third part dependencies will introduce other version of sl4j-api as CAMEL-4545 shows  we need to specify the sl4j-api in the pom.xml resource.",
            "id": "4559"
        },
        "4560": {
            "ground_truth": "0",
            "bug_report": "camel-file component does not close a file when it's used with camel-xslt\nHere are the steps to reproduce: Create the directory target/in. Put the file 'file.xml' into the directory target/in. Note: the end tag in this file is not closed properly. Run the test. The test should fail. The file 'file.xml' remains in the target/in but it should not.FileLockedTest.javapackage org.apache.camel;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.component.mock.MockEndpoint;import org.apache.camel.test.junit4.CamelTestSupport;import org.junit.Test;public class FileLockedTest extends CamelTestSupport { @Test public void testFileLocked() throws Exception { MockEndpoint result = getMockEndpoint('mock:result'); result.setAssertPeriod(10000); result.expectedMessageCount(1); result.assertIsSatisfied(); } @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { @Override public void configure() throws Exception { from('file:target/in?delay=100&amp;moveFailed=.error') .onException(Throwable.class) .to('mock:result') .end() .to('xslt:FileLockedTest.xsl'); } }; }}FileLockedTest.xsl&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns='http://schemas.computershare.ru/codex/2011/08/' version='1.0'&gt; &lt;xsl:output method='xml' encoding='UTF-8' omit-xml-declaration='yes' /&gt; &lt;xsl:preserve-space elements='*'/&gt; &lt;xsl:template match='/'&gt; &lt;xsl:apply-templates /&gt; &lt;/xsl:template&gt; &lt;xsl:template match='@* | node()'&gt; &lt;xsl:copy&gt; &lt;xsl:apply-templates select='@* | node()' /&gt; &lt;/xsl:copy&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;file.xml; Note: the end tag is not closed properly&lt;root&gt;&lt;/root",
            "id": "4560"
        },
        "4568": {
            "ground_truth": "0",
            "bug_report": "SLF4JLog does not work with JdbcDriver for Quickfix/J\nI discovered that to use SLF4J log  JdbcDriver cannot be present in the Quickfix/J config file. Otherwise  the default LogFactory - ScreenLogFactory will be used. We need JdbcDriver setting as it is used for persisting FIX messages into database for FIX session management.After debugging the code  I found out that this could be fixed by swapping those two lines in QuickfixjEngine.java298: isJdbcLog(settings  impliedLogFactories);299: isSL4JLog(settings  impliedLogFactories);Can we please have this fixed for the next release?",
            "id": "4568"
        },
        "4579": {
            "ground_truth": "0",
            "bug_report": "Add option on XSLT to allow StAX\nWith the new StAX converters you may convert to a StAXSource which is not supported by the XSLT transformer  and you get this exceptionCaused by: org.apache.xml.dtm.DTMException: Not supported: javax.xml.transform.stax.StAXSource@14d556e at org.apache.xml.dtm.ref.DTMManagerDefault.getDTM(DTMManagerDefault.java:477) at org.apache.xalan.transformer.TransformerImpl.transform(TransformerImpl.java:699) at org.apache.xalan.transformer.TransformerImpl.transform(TransformerImpl.java:1273) at org.apache.xalan.transformer.TransformerImpl.transform(TransformerImpl.java:1251) at org.apache.camel.builder.xml.XsltBuilder.process(XsltBuilder.java:107)We should add option on XSLT component to explicit enable StAX if the end user wants it.",
            "id": "4579"
        },
        "4584": {
            "ground_truth": "1",
            "bug_report": "XQuery component does not work with StAXSource out of the box\nThe new STaXSource type converters cause camel-saxon to fail unit tests as reported by CI serversCaused by: net.sf.saxon.trans.XPathException: Unknown source class at net.sf.saxon.Configuration.buildDocument(Configuration.java:2892) at net.sf.saxon.query.StaticQueryContext.buildDocument(StaticQueryContext.java:211) at org.apache.camel.component.xquery.XQueryBuilder.createDynamicContext(XQueryBuilder.java:474)We should implement the same optimized logic as we did today in XSLT to convert to Source if StAX is allowed  as well to avoid leaking resources we need to ensure if InputStream is in use  we should ensure it gets closed.",
            "id": "4584"
        },
        "4591": {
            "ground_truth": "0",
            "bug_report": "XPath will lock File input in case of an exception during xpath evaluation\nWe have a similar issue with XPath  as we had with XSLT and XQuery.If the message is a java.io.File and an exception occurs during evaluation  then that file is locked on Windows platforms.We need to close the FileInputStream to unlock the file  and allow Windows to access the file.",
            "id": "4591"
        },
        "4599": {
            "ground_truth": "0",
            "bug_report": "Add default for transactionName in camel-jms\nSay you have a simple transacted route like:from('activemq:queue:foo') .transacted() .to(...);on new messages you get logs like:DEBUG JmsTransactionManager - Creating new transaction with name [null]: PROPAGATION_REQUIRED ISOLATION_DEFAULTwhich isn't very helpful. It would be good to actual give the TX a name with some context. Thinking of something like the following would be better:DEBUG JmsTransactionManager - Creating new transaction with name [JmsConsumer[foo]]: PROPAGATION_REQUIRED ISOLATION_DEFAULT",
            "id": "4599"
        },
        "4600": {
            "ground_truth": "1",
            "bug_report": "Improve URISupport.sanitizeUri and apply it in additional places\nIn this issue  I propose that URISupport.sanitizeUri method sanitizes the password token in URIs that contain it (i.e.  URIs in the form scheme://user:password@host). JT400 component URIs directly benefit from this improvement.Additionally  I suggest that this method be invoked in additional sensitive places (in much the same way as DefaultEndpoint.toString()).Proposed patch attached.",
            "id": "4600"
        },
        "4618": {
            "ground_truth": "0",
            "bug_report": "Add support for PGP data format in Java and XML DSLs\nThe new PGP data format from CAMEL-4549requires to create it from Java code.We should add some syntax sugar and have it in the DSL directly like the other data formats.We may also want to look into how to configure a public and private key file  and have it load the PGPPublicKey and PGPPrivateKey for you automatic.Instead of using the PGPDataFormatUtil class.",
            "id": "4618"
        },
        "4619": {
            "ground_truth": "0",
            "bug_report": "Stop or shutdown a route with a custom timeout value  will still log using the default timeout in the logs\nIf you stop a route with a custom time out value  then the graceful shutdown strategy will still use the default timeout value in the logs  so that information is not correct. For example if you have a short default value  but provide a higher timeout value  then you can have the log show negative timeout values.INFO DefaultShutdownStrategy - Waiting as there are still 2 inflight and pending exchanges to complete  timeout in -14 seconds.",
            "id": "4619"
        },
        "4642": {
            "ground_truth": "0",
            "bug_report": "Do not print javax.jms.Message in toString in camel-jms\nSee nabblehttp://camel.465427.n5.nabble.com/ExchangeTimedOutException-not-properly-constructed-by-Camel-2-7-1-exposing-exchange-data-tp4971556p4971556.htmlThere may be details in the JMS message you do not want to show in logs unintended.",
            "id": "4642"
        },
        "4647": {
            "ground_truth": "0",
            "bug_report": "Simple expression does not find method toString()\nIn a route builder  we have a log definition: from('direct:testSimple') .log('${body.toString}');The body contains an object  that implements a public toString() method. But the problem is  that the simple-expression does not find the method toString() and route processing stops without throwing an exception.The funny thing is  that when we just rename the method  e.g. toInfoString()  then it works:from('direct:testSimple') .log('${body.toInfoString}');Why does simple expression have a problem with a method named 'toString'?",
            "id": "4647"
        },
        "4649": {
            "ground_truth": "1",
            "bug_report": "NPE from DefaultCxfBinding when  is null\nwhen got soap message from CXF component like this:&lt;soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;soap:Header&gt;......&lt;/soap:Header&gt;&lt;soap:Body/&gt;&lt;/soap:Envelope&gt;the NPE will be thrown: 18:04:51 255 | WARN | tp1212500935-153 | ache.cxf.common.logging.LogUtils 372 | - - | Interceptor for {http://airportsoap.sopera.de}airport#{http://airportsoap.sopera.de}getAirportInformationByISOCountryCode has thrown exception  unwinding nowjava.lang.NullPointerException at org.apache.camel.component.cxf.DefaultCxfBinding.getResponsePayloadList(DefaultCxfBinding.java:395)&#91;163:org.apache.camel.camel-cxf:2.8.2&#93; at org.apache.camel.component.cxf.DefaultCxfBinding.populateCxfResponseFromExchange(DefaultCxfBinding.java:318)&#91;163:org.apache.camel.camel-cxf:2.8.2&#93; at org.apache.camel.component.cxf.CxfConsumer$1.setResponseBack(CxfConsumer.java:176)&#91;163:org.apache.camel.camel-cxf:2.8.2&#93; at org.apache.camel.component.cxf.CxfConsumer$1.asyncInvoke(CxfConsumer.java:103)&#91;163:org.apache.camel.camel-cxf:2.8.2&#93; at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:68)&#91;163:org.apache.camel.camel-cxf:2.8.2&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:93)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:263)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.phase.PhaseInterceptorChain.resume(PhaseInterceptorChain.java:232)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:80)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:323)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:289)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:72)&#91;141:org.apache.cxf.bundle:2.5.0&#93; at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:939)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:875)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:117)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:185)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:110)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.Server.handleAsync(Server.java:391)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.HttpConnection.handleRequest(HttpConnection.java:594)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.server.HttpConnection.handle(HttpConnection.java:393)&#91;59:org.eclipse.jetty.server:7.4.5.v20110725&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:535)&#91;54:org.eclipse.jetty.io:7.4.5.v20110725&#93; at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:40)&#91;54:org.eclipse.jetty.io:7.4.5.v20110725&#93; at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:529)&#91;53:org.eclipse.jetty.util:7.4.5.v20110725&#93; at java.lang.Thread.run(Thread.java:662)&#91;:1.6.0_24&#93;Looking into the source codes  before the line 395 of DefaultCxfBinding  the elements variable shoulde be checked if it's null.",
            "id": "4649"
        },
        "4650": {
            "ground_truth": "1",
            "bug_report": "NPE when using SEDA route and attaching an extra consumer\nI'm trying to construct a system for moving some seda queues over toActiveMQ during system shutdown. What I did was create a Route thatconnects to some of my seda queues and then drains the queue to activemq.Basicly I got two routes  the drainer:from('seda:' + sedaId + '?size=1000') .routeId(routeName +sedaIs).noAutoStartup().to(activeMQFailuresQueue);And the main route:from('seda:' + sedaId + '?size=1000') .routeId(routeName + sedaIs).to(SomeProcessor);Now  sometimes the main route stalls for various reasons I need torestart the jvm process it is running in  so I start the first route.But when trying this in production  I got: java.lang.NullPointerException atorg.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:78) atorg.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:210) atorg.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:155) atorg.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:129) atjava.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) atjava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619)Bvahdat added a comment:just a very tiny pointer:Looking at the source it seems that theSedaEndpoint.getConsumerMulticastProcessor() method returns 'null' causingthe NPE  as the condition:multicastStarted == false || consumerMulticastProcessor == nullis true.",
            "id": "4650"
        },
        "4655": {
            "ground_truth": "0",
            "bug_report": "Bindy does not support quoted value with separator char in CSV datasource\ni'm currently writing a tuto on Camel (2.8.2).Showing HTTP4 component usage by downloading US Gov public data  i found a problem : from('quartz://dataTimer?cron=0+?').to('direct:datas'); from('direct:datas') .to('http4://earthquake.usgs.gov/earthquakes/catalogs/eqs7day-M1.txt') .unmarshal(new BindyCsvDataFormat('net.thejeearchitectcookbook.camel.earthquake')) .process(new Processor() { public void process(Exchange exchange) throws Exception { Message message = exchange.getIn(); // ... } });The data format is like and my separator char is ' ':nc 71678421 0 'Wednesday  November 9  2011 14:53:13 UTC' 37.5727 -118.8170 1.3 6.60 14 'Central California'I want to get all datas as java.lang.String but the date value raises exception :java.lang.IllegalArgumentException: No position 11 defined for the field: 14  line: 2 must be specified]My separator is ' ' but some values are nested inside ' '. Unfortunately there are ' ' inside the ' '.Bindy get lost !How can i get String values nested inside ' ' and containing ' ' ?I can note that Camel CSV component deals with it without any problems.Here is my pojo :package net.thejeearchitectcookbook.camel.earthquake;import java.io.Serializable;import org.apache.camel.dataformat.bindy.annotation.CsvRecord;import org.apache.camel.dataformat.bindy.annotation.DataField;@CsvRecord( separator = ' ')public class EarthquakeInfos implements Serializable { @DataField(pos = 1) private String src; @DataField(pos = 2) private String eqid; @DataField(pos = 3) private String version; @DataField(pos = 4) private String datetime; @DataField(pos = 5) private String lat; @DataField(pos = 6) private String lon; @DataField(pos = 7) private String magnitude; @DataField(pos = 8) private String depth; @DataField(pos = 9) private String nst; @DataField(pos = 10) private String place; public String getSrc() { return src; } public void setSrc(String src) { this.src = src; } public String getEqid() { return eqid; } public void setEqid(String eqid) { this.eqid = eqid; } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } public String getLat() { return lat; } public void setLat(String lat) { this.lat = lat; } public String getLon() { return lon; } public void setLon(String lon) { this.lon = lon; } public String getDepth() { return depth; } public void setDepth(String depth) { this.depth = depth; } public String getNst() { return nst; } public void setNst(String nst) { this.nst = nst; } public String getDatetime() { return datetime; } public void setDatetime(String datetime) { this.datetime = datetime; } public String getMagnitude() { return magnitude; } public void setMagnitude(String magnitude) { this.magnitude = magnitude; } public String getPlace() { return place; } public void setPlace(String place) { this.place = place; }} I can find that CSV Camel component performs well with the same datasource :from('direct:datas').to('http4://earthquake.usgs.gov/earthquakes/catalogs/eqs7day-M1.txt').unmarshal().csv().process(new Processor() { public void process(Exchange exchange) throws Exception { Message message = exchange.getIn(); List&lt;List&lt;String&gt;&gt; datas = (List&lt;List&lt;String&gt;&gt;) message.getBody(); // Skip header datas = datas.subList(1  datas.size() - 1); // Process my data for (List&lt;String&gt; row : datas) { // Process Row String datetime = row.get(3); String region = row.get(9); String magnitude = row.get(6); } }});",
            "id": "4655"
        },
        "4672": {
            "ground_truth": "0",
            "bug_report": "Bindy - CSV format - Should be able to marshal with quotes\nSee nabblehttp://camel.465427.n5.nabble.com/Bindy-CSV-marshal-does-not-properly-quote-values-defined-by-the-CsvRecord-separator-td4809017.htmlIts fairly common to marshal to/from with quotes in CSV format.We should make this easier by adding an attribute to @CsvRecord where you can define a quote char to use  either single or double etc.",
            "id": "4672"
        },
        "4689": {
            "ground_truth": "0",
            "bug_report": "Add option to override XSLT stylesheet used via header\nSimilar to 'dynamic templates' in velocity component http://camel.apache.org/velocity",
            "id": "4689"
        },
        "4694": {
            "ground_truth": "0",
            "bug_report": "Text improvements to camel-example-cxf-proxy.\nAttachment has improvements to README and the camel-config.xml file shown in the online description of this sample: https://cwiki.apache.org/confluence/display/CAMEL/CXF+Proxy+Example (a web page I just updated).",
            "id": "4694"
        },
        "4696": {
            "ground_truth": "0",
            "bug_report": "When a route is removed from camel  LifecycleStrategy is called twice\nDefaultCamelContext.removeRoute method has these lines among others if (getRouteStatus(routeId).isStopped()) { routeService.setRemovingRoutes(true); shutdownRouteService(routeService); removeRouteDefinition(routeId); ServiceHelper.stopAndShutdownServices(routeService);I think the last line from this snippet is not needed  because the route should be already stopped in order to pass the IF statement and then it is shutdown through this call shutdownRouteService(routeService); ServiceHelper.stopAndShutdownServices(routeService) tries to stops again the route if not stopped  but the worse is it shutdown the rout again.It seems to me like a bug  other thoughts?",
            "id": "4696"
        },
        "4698": {
            "ground_truth": "0",
            "bug_report": "Scala DSL does not support defining route-scoped error handlers\nThe Scala DSL does not allow for defining error handlers at the route scope. The 'errorHandler' method only sets the context-scoped error handler.",
            "id": "4698"
        },
        "4705": {
            "ground_truth": "0",
            "bug_report": "file endpoint to raise a warning msgs if unable to auto-create the starting directory\nThe file component tries to auto-create any non-existing starting directories however it does not raise any warnings if its unable to create the directory (e.g. due to file permission or due to unmounted file systems). It should at least log a warning msg if it cannot auto-create the starting directory.",
            "id": "4705"
        },
        "4730": {
            "ground_truth": "0",
            "bug_report": "Change cometd SslSocketConnetor to use SslSelectChannelConnector\nCurrently cometd uses SslSocketConnector for cometds connections. In its current configuration it can only support about 35 connections as SslSocketConnector is a blocking connector. Switching this to use the SslSelectChannelConnector in the same way it uses the SelectChannelConnector will fix this and allow the cometds to perform as the non ssl version.",
            "id": "4730"
        },
        "4742": {
            "ground_truth": "0",
            "bug_report": "Tokenize pair - evaluated as predicate should close input stream\nIf you read from a file and use the tokenize pair in a predicate such as a filter / content based router  then the input stream should be closed. Otherwise OS such as Windows keep a lock on the stream  and the file cannot be moved/deleted after processing is done.See nabblehttp://camel.465427.n5.nabble.com/Riding-on-org-apache-camel-language-TokenPairPredicateTest-tp5041981p5041981.htmlNote that using tokenizePair as a predicate is must likely very unusual  as its meant for splitting a stream into tokens  and thus most often only used with the splitter EIP.",
            "id": "4742"
        },
        "4760": {
            "ground_truth": "0",
            "bug_report": "Unable to set logName on DefaultErrorHandler as well as executorService on LoggingErrorHandler\nThe following snippets do not work  although each of the specified error handlers supports logName and executorServiceRef. The issue is actual for the DeadLetterChannel error handler too.LoggingErrorHandler&lt;errorHandler id='errorHandler' type='LoggingErrorHandler' logName='${router.logger.name}' executorServiceRef='redeliveryExecutor'/&gt;DefaultErrorHandler&lt;errorHandler id='errorHandler' type='DefaultErrorHandler' logName='${router.logger.name}' executorServiceRef='redeliveryExecutor'/&gt;StackTraceCaused by: org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource [META-INF/spring/camel-context.xml]; nested exception is java.lang.IllegalArgumentException: Attribute executorServiceRef is not supported by error handler type: LoggingErrorHandler  in error handler with id: errorHandler at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:412) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:143) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:178) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.importBeanDefinitionResource(DefaultBeanDefinitionDocumentReader.java:186) ... 42 moreCaused by: java.lang.IllegalArgumentException: Attribute executorServiceRef is not supported by error handler type: LoggingErrorHandler  in error handler with id: errorHandler",
            "id": "4760"
        },
        "4765": {
            "ground_truth": "0",
            "bug_report": "Avoid explicit cast while using the CamelContext.getEndpoint() or ApplicationContext.getBean() API and better rely on the overloaded counterpart of them taking a class type as the second argument (implicit cast)\nSome simple change examples on the trunk are:From:jpaTemplate = (JpaTemplate)applicationContext.getBean('jpaTemplate');To:jpaTemplate = applicationContext.getBean('jpaTemplate'  JpaTemplate.class);OrFrom:HttpEndpoint epOut = (HttpEndpoint) getContext().getEndpoint('http://localhost:' + port1 + '?bridgeEndpoint=true&amp;throwExceptionOnFailure=false');To:HttpEndpoint epOut = getContext().getEndpoint('http://localhost:' + port1 + '?bridgeEndpoint=true&amp;throwExceptionOnFailure=false'  HttpEndpoint.class);Here another one with the removal of @SuppressWarnings as a side effect:From: @SuppressWarnings('unchecked') public &lt;T&gt; T lookup(Class&lt;T&gt; type) { ApplicationContext context = getApplicationContext(); String[] names = context.getBeanNamesForType(type  true  true); if (names != null) { int count = names.length; if (count == 1) { // lets instantiate the single bean return (T)context.getBean(names[0]); } else if (count &gt; 1) { throw new IllegalArgumentException('Too many beans in the application context of type: ' + type + '. Found: ' + count); } } throw new IllegalArgumentException('No bean available in the application context of type: ' + type); }To: public &lt;T&gt; T lookup(Class&lt;T&gt; type) { ApplicationContext context = getApplicationContext(); String[] names = context.getBeanNamesForType(type  true  true); if (names != null) { int count = names.length; if (count == 1) { // lets instantiate the single bean return context.getBean(names[0]  type); } else if (count &gt; 1) { throw new IllegalArgumentException('Too many beans in the application context of type: ' + type + '. Found: ' + count); } } throw new IllegalArgumentException('No bean available in the application context of type: ' + type); }There're also cases where we could make a huge benefit of this so that the following code: public &lt;T&gt; T getMandatoryBean(Class&lt;T&gt; type  String name) { Object value = applicationContext.getBean(name); assertNotNull('No spring bean found for name &lt;' + name + '&gt;'  value); if (type.isInstance(value)) { return type.cast(value); } else { fail('Spring bean &lt;' + name + '&gt; is not an instanceof ' + type.getName() + ' but is of type ' + ObjectHelper.className(value)); return null; } }became just a one liner as: public &lt;T&gt; T getMandatoryBean(Class&lt;T&gt; type  String name) { return applicationContext.getBean(name  type); }I also came across the cases where the prefered API indeed was used but there were unneccessary casts around it:From:// must type cast to work with Spring 2.5.xSpringCamelContext context = (SpringCamelContext) applicationContext.getBeansOfType(SpringCamelContext.class).values().iterator().next();To:SpringCamelContext context = applicationContext.getBeansOfType(SpringCamelContext.class).values().iterator().next();Another benefit of this patch is a better test code coverage  because as one would intuitively expect DefaultCamelContext.getEndpoint(String name  Class&lt;T&gt; endpointType) makes use of DefaultCamelContext.getEndpoint(String uri) before casting and returning the answer. So that now through the usage of the first method API (expecting two parameters) we do call both of them while testing (one explicitly and the other one implicitly) There're 147 sources affected by the provided patch (one source change is just because of an already pre-existing checkstyle violation by HtmlToPdfMojo.java on the trunk).I did verify only the tests on camel-core but not the rest with the following test result (Windows-Vista):Results :Failed tests: testConcurrentAppend(org.apache.camel.component.file.FileConcurrentWriteAppendSameFileTest): mock://result Received message count. Expected: &lt;5000&gt; but was: &lt;2655&gt;Tests run: 3969  Failures: 1  Errors: 0  Skipped: 0&#91;INFO&#93; ------------------------------------------------------------------------&#91;INFO&#93; BUILD FAILURE&#91;INFO&#93; ------------------------------------------------------------------------&#91;INFO&#93; Total time: 25:49.095s&#91;INFO&#93; Finished at: Sun Dec 11 00:45:35 CET 2011&#91;INFO&#93; Final Memory: 20M/494M&#91;INFO&#93; ------------------------------------------------------------------------&#91;ERROR&#93; Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.8:test (default-test) on project camel-core: There are test failures.",
            "id": "4765"
        },
        "4768": {
            "ground_truth": "0",
            "bug_report": "Extra request parameters sent by the camel-http4 component\nDescribed in http://camel.465427.n5.nabble.com/Extra-Request-Params-sent-in-camel-HTTP-component-GET-request-td5042808.htmlRoute from('jetty:http://0.0.0.0:8080/myapp/myservice') .to('http4://www.google.com/?q=camel&amp;bridgeEndpoint=true&amp;throwExceptionOnFailure=false'); sends to the server the bridgeEndpoint=true&amp;throwExceptionOnFailure=false parameters while route from('jetty:http://0.0.0.0:8080/myapp/myservice') .to('http://www.google.com/?q=camel&amp;bridgeEndpoint=true&amp;throwExceptionOnFailure=false'); behaves properly and removes them",
            "id": "4768"
        },
        "4769": {
            "ground_truth": "0",
            "bug_report": "camel-quartz - Using underscore in group name does not work\nThe group name is not properly resolved if people specify a invalid host name  such as with underscores.If so we should fallback and grab the group name by grabbing the string until the first path separator char.See nabblehttp://camel.465427.n5.nabble.com/Camel-Quartz-consumer-doesn-t-allow-underscores-tp5063734p5063734.html",
            "id": "4769"
        },
        "4779": {
            "ground_truth": "0",
            "bug_report": "Make Ant path matching in file / FTP component easier to use\nThe existing codebase has an implicit optional dependency from camel-core to camel-spring; camel-core contains the class AntPathMatcherGenericFileFilter  which internally uses camel-spring's SpringAntPathMatcherFileFilter class via runtime classpath checks and reflection. The reason that SpringAntPathMatcherFileFilter is in camel-spring is that it uses Spring's AntPathMatcher class internally. Interestingly  there is already an AntPathMatcher class with an API very similar to Spring's class in the camel-core-xml module.This patch moves camel-core-xml's AntPathMatcher into camel-core  removes the classpath and reflection magic in camel-core's AntPathMatcherGenericFileFilter class  and adds a new class to camel-core named GenericFileFilterConverter  which automagically converts strings to ant path file filters. The patch also adds some unit tests.The end result is that Camel users can now use ant path matching with the file and FTP components without having to add a dependency on camel-spring  and Camel users can specify the ant path expression to use directly in the component querystring  rather than having to go through the work of registering an additional file filter instance in the registry (although this is only true when the user only needs to specify a single include path  which is a very common use case). For example:from('file://target/blah?recursive=true&amp;filter=*/.txt') .to(...);Instead of:from('file://target/blah?recursive=true&amp;filter=#myTxtFilter') .to(...);",
            "id": "4779"
        },
        "4785": {
            "ground_truth": "0",
            "bug_report": "camel-aws can allow SNAPSHOT transitive dependencies\nThe camel-aws component depends on aws-java-sdk which has several dependencies defined using version ranges. The problem with version ranges is that they can introduce SNAPSHOT versions if they are available on your system which is not so good... in my case I had this http://download.java.net/maven/2/com/sun/mail/javax.mail/1.4.5-SNAPSHOT/javax.mail-1.4.5-SNAPSHOT.jar jar in my local repo so camel-aws promptly used that SNAPSHOT lib.",
            "id": "4785"
        },
        "4793": {
            "ground_truth": "0",
            "bug_report": "Improve Camel aws-sdb component\nI would like to improve the aws-sdb component in the following places: Using the Amazon operation names instead of CamelAwsSdbXXX -&gt; With this we can easily support more operations (in the future) and the users are more familiar with this names Add OSGI integration testsI would like to resolve this issue for Camel 2.9.0 because renaming of the operation names are not backwards compatible. I will resolve this issue today.",
            "id": "4793"
        },
        "4794": {
            "ground_truth": "0",
            "bug_report": "After restarting route a camel-quartz component fires right away (and it shouldn't)\nI am adding a new QuartzRouteRestartTest that demonstrates this issue. Not only a message is fired right after restart  but the scheduled times are messed up as well. I tried to keep the fire interval as low as possible  but it has to be large enough to demonstrate the problem. So I went down to 0/5 (fire every five sec)  but it's more obvious with 0/10 or 0/15  the trigger starts firing at the wrong time.",
            "id": "4794"
        },
        "4800": {
            "ground_truth": "0",
            "bug_report": "camel-jms - Include details about correlation id in exchange timeout exception if a reply message did not come back\nThis helps make it easier to spot situations when doing request/reply over JMS and the reply message is not received within the timeout period.And then the reply messages comes later.Then it should be easier to spot in the logs when the timeout occurred  and the correlation ID should be in the logs  so you can correlate these two situations.",
            "id": "4800"
        },
        "4804": {
            "ground_truth": "0",
            "bug_report": "Add replyTo option to camel mail component\nAdd replyTo option to camel mail component",
            "id": "4804"
        },
        "4809": {
            "ground_truth": "0",
            "bug_report": "interceptSendToEndpoint with predicate and skip\nThe &lt;when&gt; clause in the interceptors behave like filters. This is okay with intercept and interceptFrom  where the only possible route manipulation is &lt;stop /&gt;  which is expressed inside the routing block.However  with interceptSendToEndpoint there is one edge case that could cause ambiguity. When skipSendToEndpoint=true  along with a &lt;when&gt; clause  the user might expect that the skipping will only occur if the condition is met. However  it occurs always. The &lt;when /&gt; only determines whether the routing logic contained inside the body of the intercept block will occur or not.I propose to add a new attribute onlySkipWhenConditionMet  so that when this is true  the &lt;when&gt; clause will be evaluated to determine if the originally intended endpoint is actually skipped or not.",
            "id": "4809"
        },
        "4810": {
            "ground_truth": "0",
            "bug_report": "camel-eventadmin do not work\nChristian-Muellers-MacBook-Pro:bin cmueller$ ./karaf cleankaraf@root&gt; features:addurl mvn:org.apache.camel.karaf/apache-camel/2.9.0/xml/featureskaraf@root&gt; features:install camel-eventadminError executing command: Could not start bundle mvn:org.apache.camel/camel-eventadmin/2.9.0 in feature(s) camel-eventadmin-2.9.0: Unresolved constraint in bundle org.apache.camel.camel-eventadmin &#91;59&#93;: Unable to resolve 59.0: missing requirement &#91;59.0&#93; package; (&amp;(package=org.osgi.service.event)(version&gt;=1.2.0)(!(version&gt;=2.0.0)))We have to install the feature eventadmin (from Karaf) first",
            "id": "4810"
        },
        "4823": {
            "ground_truth": "0",
            "bug_report": "Log EIP - Check if it should log first before evaluating exchange\nIn the log EIP only evaluate the log message if really needed  eg shouldLog returns true",
            "id": "4823"
        },
        "4826": {
            "ground_truth": "0",
            "bug_report": "Tech edits of JavaDoc and other code comments -- lets -> (let's  allow  {})\nPartial conversion of 'lets do...' to 'let's do...'  'allows for doing'  or 'do...' as appropriate  and associated other nitpicks found. 'Let's' retained more where the code is part of an example or tutorial or if it's a matter-of-opinion on how to implement.",
            "id": "4826"
        },
        "4839": {
            "ground_truth": "0",
            "bug_report": "Ability to specify the cache level on JMS reply to queue\nI'm trying to use Camel (v 2.6.0) JMS Request/Reply with Websphere 7 using Websphere MQ. I'm successfully able to put the request message onto the queue using the following URI: jms:queue:inboundQueue?connectionFactory=#connectionFactory&amp;taskExecutor=#taskExecutor&amp;transactionManager=#transactionManager&amp;cacheLevelName=CACHE_NONE&amp;replyTo=outboundQueue&amp;requestTimeout=120000 Note: I have to use cacheLevelName=CACHE_NONE in order for this to work on Websphere. However  when Camel creates the PersistentQueueMessageListenerContainer to read the reply message  it is hard coding the cache level to CACHE_SESSION (see PersistentQueueReplyManager.java line 192). What happens is that Camel is successfully able to read the reply off the queue  but then spits out the following error repeatedly: 23 Dec 2011 09:23:32 427|||WorkManager.DefaultWorkManager : 3||WARN |org.springframework.jms.listener.DefaultMessageListenerContainer|Setup of JMS message listener invoker failed for destination 'outboundQueue' - trying to recover. Cause: Connection closed I believe this is due to the PersistentQueueMessageListenerContainer using a cache level of CACHE_SESSION instead of CACHE_NONE. Can Camel be enhanced to have the ability to set the cache level on the reply queue?",
            "id": "4839"
        },
        "4842": {
            "ground_truth": "0",
            "bug_report": "Remove ProducerCache from CamelContext service list when shutting down a route\nIf people add routes dynamic and remove the routes later on  we need to remove services which may have been added to the CamelContext services list. For example the ProducerCache by SendProcessor etc.This will ensure that the ProducerCache can be GC'ed.",
            "id": "4842"
        },
        "4853": {
            "ground_truth": "0",
            "bug_report": "camel-mina - Make it easier to use a custom thread pool for the consumer\nIt should be easier to use a custom thread pool for the mina consumer  in case you use it in sync mode  where the consumer thread would then be synchronous  and thus take up a thread. So in case you put load on the mina consumer  it will use up the default thread pool size of 10 threads.We should add documentation in the wiki  how to use a custom thread pool / and pool profile.See nabblehttp://camel.465427.n5.nabble.com/inflight-exchange-and-queue-of-apache-camel-tp5112396p5112396.html",
            "id": "4853"
        },
        "4854": {
            "ground_truth": "0",
            "bug_report": "BAM - database constraint violation when restaring application\nTake BAM example from http://camel.apache.org/bam-example.html (or any other one  it doesn't matter).Here is the one I'm using: ActivityBuilder request = activity('eaiBroker:topic:SOME_TOPIC?concurrentConsumers=1').name('Request') .correlate(xpath('/MessageRequest/@Id').stringResult()); ActivityBuilder response = activity('eaiBroker:topic:SOME_OTHER_TOPIC?concurrentConsumers=1').name('Response') .correlate(xpath('MessageResponse/@Id').stringResult()); response .starts().after(request.completes()) .expectWithin(seconds(15)) .errorIfOver(seconds(30)) .to('log:com.eai?level=error'); First run of the application and everything works. Restart application and try to activate one of BAM rules  there will be an exception that database constraint has been violated. Every time application is started  Camel tries to do following sql insertinsert into CAMEL_ACTIVITYDEFINITION (name  processDefinition_id  id) values (?  ?  ?)but name columne must be unique in CAMEL_ACTIVITYDEFINITION .Workaround for this is to purge BAM tables every time you want to restart the application  but it's not a solution.",
            "id": "4854"
        },
        "4858": {
            "ground_truth": "0",
            "bug_report": "xpath expression with $header with saxon may throw exception if header did not exist\nSee CAMEL-747We should return an empty String instead of a Void.class  as this works with both JDK + Saxon XPathEngine.Saxon does not work with the Void.class.",
            "id": "4858"
        },
        "4868": {
            "ground_truth": "0",
            "bug_report": "add feature for camel-context component\nWorkaround until this makes it into a release is of course justosgi:install -s mvn:org.apache.camel/camel-context/2.9.0",
            "id": "4868"
        },
        "4882": {
            "ground_truth": "0",
            "bug_report": "Timed out Exchanges should be removed from seda queues\nWhen the SedaProducer times out and stops waiting for an Exchange to be processed it should remove it from the queue as well. Same applies to the vm: component.",
            "id": "4882"
        },
        "4892": {
            "ground_truth": "0",
            "bug_report": "CamelContext autoStartup=false and starting context programmatically doesnt work\nIf a &lt;camelContext&gt; is set to autoStartup=false and then later tried to start it via code or JMX doesn't start routes associated with it.",
            "id": "4892"
        },
        "4894": {
            "ground_truth": "0",
            "bug_report": "Parameter binding not working with BeanExpression\nThe parameter binding options available in camel-2.9.0 do not work for BeanExpression. The reason is the fake ognl parser that gets confused about the syntax. We need to align the two scenarios and probably replace the ognl like parsing.",
            "id": "4894"
        },
        "4911": {
            "ground_truth": "0",
            "bug_report": "SedaConsumer - Should not poll if CamelContext is starting\nIf you startup Camel with many routes  which mean starting Camel may take some seconds or whatnot  and then SedaConsumer may poll messages  while CamelContext is starting. It should avoid polling until CamelContext is fully started.",
            "id": "4911"
        },
        "4913": {
            "ground_truth": "0",
            "bug_report": "camel-blueprint - Using namespaces with xpath does not work as the namesapces is not parsed and injected into the camel model\nUsing xpath predicates in a blueprint xml file does not work if you use custom namespaces  as the camel-blueprint component does not detect the custom namespaces  as camel-spring does.",
            "id": "4913"
        },
        "4919": {
            "ground_truth": "0",
            "bug_report": "Testing headers in multiple messages\nThe need is something similar to expectedBodiesReceivedInAnyOrder applied to headers :I know that a given endpoint will receive 3 messages in any order  and I need to test ONE header in each of these messages.I wrote :getMockEndpoint('mock:zipSHP').expectedHeaderReceived('zippedFile'  '001.zip');getMockEndpoint('mock:zipSHP').expectedHeaderReceived('zippedFile'  '002.zip');getMockEndpoint('mock:zipSHP').expectedHeaderReceived('zippedFile'  '003.zip');for the route :for('file://filesToBeZipped/').to('bean:my.bean.ZipperBean').log('Zipped : ...');The endpoint effectively received the three messages (the results of three ZIP operations) but the test failed saying that the first message header was '003.zip' and not the expected '001.zip'.",
            "id": "4919"
        },
        "4938": {
            "ground_truth": "0",
            "bug_report": "ManagedBrowsableEndpoint are broken\nManagedeBrowsableEndpoint are broken which means any component that inherit ManagedBrowsableEndpoint have errors as well. Please see the link below which will have error screen shot of queueSize JMX operations.http://camel.465427.n5.nabble.com/JMX-queue-size-operation-fails-Camel-2-9-0-td5233089.html",
            "id": "4938"
        },
        "4942": {
            "ground_truth": "0",
            "bug_report": "exchange.getIn().getBody(.class) throws an exception for Jaxb model objects\nexchange.getIn().getBody(Foo.class);should return a Foo instance or null  if no suitable type converter is available. The java doc says: 'return the body of the message as the specified type  or &lt;tt&gt;null&lt;/tt&gt; if not possible to convert'If Foo is an Jaxb object model  this method call: throws an org.xml.sax.SAXParseException if the body content is a string throws a javax.xml.bind.UnmarshalException if the body content is another Jaxb model objectPlease have a look on the attached sample eclipse project.",
            "id": "4942"
        },
        "4954": {
            "ground_truth": "0",
            "bug_report": "Camel 2.9.0 incapable of working with % in endpoint URIs\nIn the class org.apache.camel.util.URISupport which will be used to resolve endpoints (DefaultCamelContext#normalizeEndpointUri) the method parseParameters will be called.At first the java.net.Uri#getQuery will be called with according to the javadoc 'Returns the decoded query component of this URI' returns a decoded URI. If that fails the java.net.Uri#getSchemeSpecificPart method will be called which according to the javadoc 'Returns the decoded scheme-specific part of this URI.' returns a decoded URI.So to summarize we get in any case a decoded URI.This URI will then be than in the method org.apache.camel.util.URISupport#parseQuery(String) again decoded with java.net.URLDecoder#decode(String String).This code leads to the following behaviour: If a % is properly encoded with %25test the %25test will be substituted by the first call to %test and the decoded again which leads to an Exception.In the http://svn.apache.org/viewvc?view=revision&amp;revision=1166508 commit you can see that the % was uncommented from org.apache.camel.util#UnsafeUriCharactersEncoder. Maybe this is related.However... Double encoding of URIs seems quite odd. With any URI char there is no issue with that. But with % the % will be decoded again  which makes a % unusable in Camel.",
            "id": "4954"
        },
        "4963": {
            "ground_truth": "0",
            "bug_report": "antInclude support for case insensitive patterns\nantIncude patterns are case sensitive. I need a case insensitive file matching pattern with file and ftp components.note: custom filters is not applicable since I read patterns from database there is no way to correlate the filters with the routes.",
            "id": "4963"
        },
        "4970": {
            "ground_truth": "0",
            "bug_report": "Cannot use xquery predicate in filter after an xpath splitter.\nAfter upgrading from 2.5.0 to 2.9.0 using xqury predicate after an xpath filter throws java.lang.ClassCastException: net.sf.saxon.tinytree.TinyElementImpl cannot be cast to net.sf.saxon.om.DocumentInfo . Attached unit test doesn't fail in camel 2.5.0.from('direct:xpath') .split(xpathsplitter) .filter().xquery('//record&#91;type=2&#93;') .to('mock:result'); See nabble discussion http://camel.465427.n5.nabble.com/Unit-test-fails-after-upgrading-to-2-7-1-Cannot-use-xquery-expression-after-xpath-td4422582.html",
            "id": "4970"
        },
        "4976": {
            "ground_truth": "1",
            "bug_report": "Problem Removing Endpoints\n(see context on the users@ list)When using removeEndpoints(String) with a pattern  some endpoints (like jms topics) are reported as removed but they are not.",
            "id": "4976"
        },
        "4985": {
            "ground_truth": "1",
            "bug_report": "Spring security example does not work\nWhen you try to run the spring security example and access it from a browser you get 404. I debugged into it and the reason is that the camel context does not attach to the camel http servlet.",
            "id": "4985"
        },
        "4986": {
            "ground_truth": "0",
            "bug_report": "ManagedPerformanceCounterMBean should extend ManagedCounterMBean\nManagedPerformanceCounterMBean does not extend ManagedCounterMBean  while ManagedPerformanceCounter does extend ManagedCounter.",
            "id": "4986"
        },
        "4989": {
            "ground_truth": "0",
            "bug_report": "BindyDataFormat should not use the default encoding\nHere is the mail thread&#91;1&#93; which discuss about it.&#91;1&#93;http://camel.465427.n5.nabble.com/Bindy-CSV-parser-uses-default-encoding-tp5456136p5456136.html",
            "id": "4989"
        },
        "4993": {
            "ground_truth": "1",
            "bug_report": "Add session information from cometd to camel message headers\nThe cometd component has the ability to authenticate a connection with a custom SecurityPolicy.&#91;1&#93; This information can then be added to the cometd session for further calls. Unfortunately  session attributes aren't passed to the camel message for processing by endpoints and processors further down the line. 1. http://cometd.org/documentation/2.x/howtos/authentication",
            "id": "4993"
        },
        "4994": {
            "ground_truth": "0",
            "bug_report": "UnsupportedOperationException thrown if @Consume method is not public\nIf the org.apache.camel.Consume annotation is used on a method that is not public (e.g. default visibility)  then the following exception will be thrown every time a message is delivered to that consumer and the message will roll-back with the consumer never invoked.2012-02-08 16:29:37 298 [Camel Thread 0 - JmsConsumer&#91;paula.inprogress&#93; WARN org.apache.camel.component.jms.JmsMessageListenerContainer - Execution of JMS message listener failed  and no ErrorHandler has been set.org.apache.camel.RuntimeCamelException: java.lang.UnsupportedOperationException at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1139) at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:115) at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:560) at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:498) at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:467) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:243) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1058) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1050) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:947) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:680)Caused by: java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1285) at org.apache.camel.component.bean.BeanInfo.introspect(BeanInfo.java:256) at org.apache.camel.component.bean.BeanInfo.createInvocation(BeanInfo.java:136) at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:142) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:109) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:103) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85) at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:92) ... 11 moreI appreacate that this not specifically a bug  so I am filing this as an improvement. However this is a REALLY misleading error message. A more specific error message would be greaty appreaceated and save a lot of time. Thanks.",
            "id": "4994"
        },
        "4996": {
            "ground_truth": "0",
            "bug_report": "DigitalSignatureEndpoint not clearing headers after verify\nThe DigitalSignatureEndpoint has a clearHeaders option that is supposed to clear headers after a verify operation. However that is not working because the headers cleared are not the actual header values  but the name of the java String fields  which is irrelevant at runtime.The default value of the clearHeaders should also be true  so that Camel does not leave debris in the Exchange after a verify operation.",
            "id": "4996"
        },
        "5000": {
            "ground_truth": "0",
            "bug_report": "Error handler not called when recipient list has non existing endpoint\nGiven this route onException(Exception.class) .handled(true) .to('mock:dead'); from('direct:start') .recipientList(constant('fail:endpoint')) .to('mock:result');You would assume the on exception will handle the exception from the recipient list with the non existing endpoint.This is not the case. We should let recipient list detect and let the error handler handle it.",
            "id": "5000"
        },
        "5004": {
            "ground_truth": "0",
            "bug_report": "Camel simple language wrong working with real number\nI compute real number in route: &lt;setBody&gt;0.02&lt;/setBody&gt;After that I want to filter: &lt;filter&gt;&lt;simple&gt;${body} &gt; 0 &lt;/simple&gt; ... &lt;/filter&gt;This expression return false for value in body = 0.02",
            "id": "5004"
        },
        "5005": {
            "ground_truth": "0",
            "bug_report": "simple without embedded text results in an NPE\nAfter switching to 2.9 the following results in a NPE&lt;camel:setBody&gt; &lt;camel:simple&gt;&lt;/camel:simple&gt;&lt;/camel:setBody&gt;I'm not sure if it is now required to have something in the content of the simple element. I used it for setting the body element to an empty string before (worked with 2.8.1)",
            "id": "5005"
        },
        "5018": {
            "ground_truth": "0",
            "bug_report": "Support unmarshall of CSV files that does not contain all fields described in the annotated POJO.\nActually when trying to unmarshall a CSV that does not contain all the fields described via @DataField annotation  an IllegalArgumentException is thrown. Would be better to define a default value for non required fields via @DataField annotation and therefore  not fail.",
            "id": "5018"
        },
        "5024": {
            "ground_truth": "0",
            "bug_report": "Streaming splitter ignores exception handling\nIf an exception occurs on the next() call of an Iterator in a streaming splitter  the exception is never propagated to the exception or the error handler. This will lead to improper route termination  and inifite rollback/retry cycles.I attached the minimal test case demonstrating the issue.",
            "id": "5024"
        },
        "5035": {
            "ground_truth": "1",
            "bug_report": "CxfProducer should release the CXF when the Producer is stopped.\nCXF ClientImpl has the requestContext need to be cleaned when the CxfProducer is stopped.If we don't call the Client.destory() method  the requestContext will cause the memory leak.",
            "id": "5035"
        },
        "5036": {
            "ground_truth": "0",
            "bug_report": "Camel route with bean element sends on startup invalid message to target route that is represented by a proxy who exposes route\nI expose a Camel route with a direct endpoint defined in an OSGi bundle with the &lt;camel:proxy&gt; and &lt;osgi:service&gt; tags. The reason for this is to be able to call this direct-route in other routes (defined in other bundles) as a 'sub-route' directly as bean &#91;.bean(routeproxy  &quot;method&quot;)&#93;. This works as expected.But on route startup the toString method is called on the route (for a description) which is propagated to the elements of the route. Therefore my bean-element (which is the direct-route-proxy) receives the toString call and the CamelInvocationHandler converts this toString call to a message and sends it to the direct-route. This more or less empty message is of course not valid for the target route and produces an error on bundle startup. Shouldn't the toString call be suppressed by the proxy  since toString is not part of the Interface the proxy represents? Or is my approach a not recommended or problematic approach?Parts of stacktrace to show the way from route startup to the produced message=&gt; route receives 'empty' message&#91;omitted&#93; at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:45) at org.apache.camel.component.bean.CamelInvocationHandler.invoke(CamelInvocationHandler.java:65) at $Proxy568.toString(Unknown Source) at sun.reflect.GeneratedMethodAccessor406.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597)=&gt; toString call is converted to message and sent to route&#91;omitted&#93; at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204) at $Proxy583.toString(Unknown Source) at org.apache.camel.component.bean.ConstantBeanHolder.toString(ConstantBeanHolder.java:48)=&gt; toString called on bean-element in route (bean is a proxy for a route) &#91;omitted&#93; at java.lang.String.valueOf(String.java:2826) at java.lang.StringBuilder.append(StringBuilder.java:115) at org.apache.camel.impl.EventDrivenConsumerRoute.toString(EventDrivenConsumerRoute.java:46) at org.apache.camel.management.mbean.ManagedRoute.&lt;init&gt;(ManagedRoute.java:41) at org.apache.camel.management.DefaultManagementLifecycleStrategy.onRoutesAdd(DefaultManagementLifecycleStrategy.java:368) at org.apache.camel.impl.RouteService.doStart(RouteService.java:109)=&gt; Route startup",
            "id": "5036"
        },
        "5048": {
            "ground_truth": "1",
            "bug_report": "Memory leak in SedaComponent if adding and removing a lot of seda endpoints with different queue names\nIf you add and remove a lot of seda endpoints with different queue names  then the seda component may keep references to non used queues.",
            "id": "5048"
        },
        "5049": {
            "ground_truth": "1",
            "bug_report": "Memory leak in TimerListener if JMX enabled\nIf adding and removing a lot of routes  and you have JMX enabled with load statistics  then it may leak memory  as the route listener is not properly removed when the route is removed  due invalid equals/hashCode.",
            "id": "5049"
        },
        "5052": {
            "ground_truth": "0",
            "bug_report": "DefaultUnitOfWork should copy headers from the original message if it's a JmsMessage\nsee Nabble for details",
            "id": "5052"
        },
        "5055": {
            "ground_truth": "0",
            "bug_report": "Offer a way to not set a transaction manager in camel-jms\nThe following sample Spring config sets up a camel-activemq component&lt;bean id='activemq' class='org.apache.activemq.camel.component.ActiveMQComponent'&gt; &lt;property name='configuration' ref='jmsConfigAmq' /&gt; &lt;/bean&gt; &lt;bean id='jmsConfigAmq' class='org.apache.activemq.camel.component.ActiveMQConfiguration' &gt; &lt;property name='connectionFactory' ref='jmsPooledConnectionFactory' /&gt; &lt;property name='transacted' value='true'/&gt; &lt;!-- &lt;property name='transactionManager' ref='jmsTransactionManager' /&gt; --&gt; &lt;property name='cacheLevelName' value='CACHE_CONSUMER'/&gt; &lt;/bean&gt; &lt;bean id='jmsTransactionManager' class='org.springframework.jms.connection.JmsTransactionManager'&gt; &lt;property name='connectionFactory' ref='jmsPooledConnectionFactory' /&gt; &lt;/bean&gt; &lt;bean id='jmsConnectionFactory' class='org.apache.activemq.ActiveMQConnectionFactory'&gt; &lt;property name='brokerURL' value='tcp://localhost:61617' /&gt; &lt;property name='watchTopicAdvisories' value='false' /&gt; &lt;/bean&gt; &lt;bean id='jmsPooledConnectionFactory' class='org.apache.activemq.pool.PooledConnectionFactory' &gt; &lt;property name='maxConnections' value='1'/&gt; &lt;property name='connectionFactory' ref='jmsConnectionFactory'/&gt; &lt;/bean&gt;The ActiveMQConfiguration sets transacted=true and configures for a JmsTransactionManager. Also  a PooledConnectionFactory is used. The config for a camel-jms component would be similar.The Spring JMS javadoc on AbstractPollingMessageListenerContainer.setTransactionManager states:Note: Consider the use of local JMS transactions instead. Simply switch the 'sessionTransacted' flag to 'true' in order to use a locally transacted JMS Session for the entire receive processing  including any Session operations performed by a SessionAwareMessageListener (e.g. sending a response message).It basically advises to only set transacted=true and don't specify a TX manager. The benefit of doing so is that the cacheLevel setting will be honored when using local transactions without a configured TX manager. When a TX manager is configured  no caching happens at DMLC level and its necessary to rely on a pooled connection factory. This is discussed here.However right now its not possible to configure the cameljms or camel-activemq component to not use an external TX manager when transacted=true is set.Even when setting lazyCreateTransactionManager=false.In case of camel-activemq  it still creates a default JmsTransactionManager:ActiveMQConfiguration.javapublic PlatformTransactionManager getTransactionManager() { PlatformTransactionManager answer = super.getTransactionManager(); if (isTransacted() &amp;&amp; answer == null) { // lets auto-default the transaction manager if its not specified answer = createTransactionManager(); setTransactionManager(answer); answer = getTransactionManager(); } return answer;}In case of camel-jms it throws an exception:JmsConfiguration.javaPlatformTransactionManager tm = getTransactionManager();if (tm != null) { container.setTransactionManager(tm);} else if (transacted) { throw new IllegalArgumentException('Property transacted is enabled but a transactionManager was not injected!');}We should allow for using transactions in camel-jms and camel-activemq without setting an external TX manager.",
            "id": "5055"
        },
        "5058": {
            "ground_truth": "1",
            "bug_report": "Bug: Unique Endpoints Leaking in DefaultInflightRepository\nIf you have an endpoint protocol which uses unique URIs you will leak Strings in the HashMap stored in the DefaultInflightRepository (org.apache.camel.impl.DefaultInflightRepository)It seems there is a reference counting scheme in place  but it doesn't do a remove until the 'stop' method is called to shut the system down. We are running XMPP endpoints  which use a protocol like xmpp://someaccount@domain/password?to=someOtherAccountWhen there are 10 million accounts  not all of which are active  but all of which may message at some time or another  no references are removed to the endpointCount.When the count becomes 0  the reference should be removed and the size method will still return the appropriate result.Please be careful in the implementation to synchronize on some object (perhaps the AtomicInteger) reflecting a read/write lock on the endpoint count modification.",
            "id": "5058"
        },
        "5063": {
            "ground_truth": "0",
            "bug_report": "npe in camel 2.9.1 validator\nvalidator component seems broken in 2.9.1. Gives you a npe when loading xsd from classpath during unittesting.See http://camel.465427.n5.nabble.com/npe-in-camel-2-9-1-validator-tc5540894.htmlprefixing with classpath eg. &lt;to uri='validator:classpath:BroadcastMonitor.xsd' /&gt; doesn't help.",
            "id": "5063"
        },
        "5080": {
            "ground_truth": "0",
            "bug_report": "camel-jt400 - Parameter length when doing Program Call issue\nWhen the length of each parameter of a program.PGM is greater than the length of his values  the parameters are setted incorrectly.Example:Input of program.pgm:param1 -&gt; A5 (alphanumeric with length 5) param2 -&gt; A5 (alphanumeric with length 5) When the String array is {'123'  '456'} the values are setted on each parameter as:param1 = 12345param2 = 6",
            "id": "5080"
        },
        "5081": {
            "ground_truth": "0",
            "bug_report": "org.apache.camel.component.mybatis.MyBatisBatchConsumerTest.testBatchConsumer() fails unpredictable\nI assume we see this failure when we inserted the first test into the database (and only the first one) when the mybatis consumer starts to poll the database. See build failure: https://builds.apache.org/job/Camel.2.8.x.fulltest/org.apache.camel$camel-mybatis/149/",
            "id": "5081"
        },
        "5097": {
            "ground_truth": "0",
            "bug_report": "Incorrect feature definition for camel-fop\nIncorrect feature definition for camel-fop",
            "id": "5097"
        },
        "5099": {
            "ground_truth": "0",
            "bug_report": "Timer component - Should use thread name pattern so the thread name is aligned with the Camel threads\nWhen using the timer component  the thread name will just be the timer name.Before2012-03-16 09:28:42 857 [foo ] INFO route1 - Fired timerAfter2012-03-16 09:28:18 611 [Camel (camel-1) thread #0 - foo ] INFO route1 - Fired timer",
            "id": "5099"
        },
        "5100": {
            "ground_truth": "0",
            "bug_report": "Add option autogenColumns to csv data format in XML DSL\nSee nabblehttp://camel.465427.n5.nabble.com/CSV-dateformat-bug-Attribute-AutogenColumns-is-not-allowed-to-appear-in-element-camel-csv-tp5570066p5570066.htmlThis option is not exposed in the &lt;csv&gt; data format in the XML DSLs",
            "id": "5100"
        },
        "5102": {
            "ground_truth": "0",
            "bug_report": "Timer endpoint getState does not work in JMX\nThe getState attribute does not work.",
            "id": "5102"
        },
        "5105": {
            "ground_truth": "0",
            "bug_report": "Add the options configRef and strategyRef to csv data format in XML DSL\nCAMEL-5100 provided the autogenColumns option which doesn't bring much on it's own (default is true)  which with an explicit value set to false nothing will be appended into the output other than '/n''s.So using the configRef and strategyRef options we could then bring the same power of expression inside XML DSL like inside Java. Following a sample where the user can customize the used CSVConfig and/or CSVStrategy being used: &lt;camelContext id='camel' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;route&gt; &lt;from uri='direct:start' /&gt; &lt;marshal&gt; &lt;csv autogenColumns='false' delimiter='|' configRef='csvConfig1' /&gt; &lt;/marshal&gt; &lt;convertBodyTo type='java.lang.String' /&gt; &lt;to uri='mock:result' /&gt; &lt;/route&gt; &lt;route&gt; &lt;from uri='direct:start2' /&gt; &lt;marshal&gt; &lt;!-- make use of a strategy other than the default one which is 'org.apache.commons.csv.CSVStrategy.DEFAULT_STRATEGY' --&gt; &lt;csv autogenColumns='false' delimiter='|' configRef='csvConfig2' strategyRef='excelStrategy' /&gt; &lt;/marshal&gt; &lt;convertBodyTo type='java.lang.String' /&gt; &lt;to uri='mock:result2' /&gt; &lt;/route&gt; &lt;/camelContext&gt; &lt;bean id='csvConfig1' class='org.apache.commons.csv.writer.CSVConfig'&gt; &lt;property name='fields'&gt; &lt;list&gt; &lt;!-- here we're only interested in 'item' but not in 'orderId' or 'amount' --&gt; &lt;bean class='org.apache.commons.csv.writer.CSVField'&gt; &lt;property name='name' value='item' /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id='csvConfig2' class='org.apache.commons.csv.writer.CSVConfig'&gt; &lt;property name='fields'&gt; &lt;list&gt; &lt;!-- here we're interested in both 'orderId' and 'amount' but not in 'item' --&gt; &lt;bean class='org.apache.commons.csv.writer.CSVField'&gt; &lt;property name='name' value='orderId' /&gt; &lt;/bean&gt; &lt;bean class='org.apache.commons.csv.writer.CSVField'&gt; &lt;property name='name' value='amount' /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id='excelStrategy' class='org.springframework.beans.factory.config.FieldRetrievingFactoryBean'&gt; &lt;property name='staticField' value='org.apache.commons.csv.CSVStrategy.EXCEL_STRATEGY' /&gt; &lt;/bean&gt;",
            "id": "5105"
        },
        "5108": {
            "ground_truth": "0",
            "bug_report": "Set Restlet Server Options and Return HTTP Headers Set in Exchange\nThe underlying Restlet server options can now be set via an Endpoint option.HTTP headers (e.g. Expires or Last Modified) are returned properly from the exchange to the Restlet.",
            "id": "5108"
        },
        "5115": {
            "ground_truth": "0",
            "bug_report": "CxfBeanDestination should copy the in message header to the out message\nUser complains about can not access any other headers after the cxfbean in this mail thread&#91;1&#93;.We should let the CxfBeanDestination copy the in message header before it sends the message back.&#91;1&#93;http://camel.465427.n5.nabble.com/Camel-CXF-Drops-Headers-tt5590792.html",
            "id": "5115"
        },
        "5122": {
            "ground_truth": "0",
            "bug_report": "RMI endpoint doesn't handle nested exception and raise CamelRuntimeException instead of RemoteException\nWhen we have a route looking like:&lt;from uri='rmi:...'/&gt;&lt;to uri='myBean'/&gt;if an exception is raised on myBean  the RMI endpoint ignores the exception described in the RemoteInterface and always raises a RuntimeCamelException nesting the original exceptions.More over  RuntimeCamalException should not be raised by the RMI endpoint. It would make more sense to raise a RemoteException  as we are on a RMI endpoint.",
            "id": "5122"
        },
        "5140": {
            "ground_truth": "0",
            "bug_report": "bean component - @Handler should take precedence in a bean that implements Predicate\nIf you use a bean in a Camel route  and have not specified the method name to invoke. Then Camel has to scan for suitable methods to use. And for that we have the @Handler annotation which should take precedence in this process. However if the bean implements Predicate  or Processor  then Camel will use that. However the @Handler should be used instead  as this is what the end-user expects. And also what we tell in the docs.",
            "id": "5140"
        },
        "5162": {
            "ground_truth": "0",
            "bug_report": "OnException - Handler or Continued predicate is invoked twice per exception\nSee CAMEL-5139When using handled(predicate) or continued(predicate) those is evaluated twice per exception. We should only do this once  which is what the end user would normally except.",
            "id": "5162"
        },
        "5167": {
            "ground_truth": "1",
            "bug_report": "onException policy within global context lost when error handler redefined within route context.\nThis may as well be Camel feature (limitation of Java DSL)  but I found no indications/warning that this is a feature in Camel book or web documentation. The route is somewhat ill defined as local errorHandler should be placed before bean part  but maybe for those types of mistakes it should not have this nasty side effects of loosing global onException policy  but at least complain during route creation . Moreover  the route works properly if I remove global error handler  so it is rather nasty effect if route definition correctness depends on the existence of the global error handler definition.If I move local errorHandler before bean part then the my test passes as the onException policy is triggered and works properly. As soon as I redefine the error handler within a route the onException policy is no longer applicable for the route and the route propagates the exception back to the caller.  errorHandler(defaultErrorHandler().maximumRedeliveries(1)); onException(NullPointerException.class).setOnRedelivery(new NullRegistrationDateProcessor()); from('direct:toPropertyFile').routeId('registrationEntryToPropertyFile') .setHeader(Exchange.FILE_NAME  simple('${body.firstname}.${body.surname}')) .bean(RegistrationToPropertiesBean.class  'convert') // Potential bug in Camel  if the same error handler like global is turned on then onException defined in global context will not be picked up. .errorHandler(defaultErrorHandler().maximumRedeliveries(1)) // the code above is working if no default handler was created for a global context. .to('file://' + outFolder);",
            "id": "5167"
        },
        "5177": {
            "ground_truth": "0",
            "bug_report": "Avoid parsing URI each time when getting uri from endpoint\nIn Camel 2.9  a new EndpointConfiguration was introduced  which has more fine grained details about an URI.However the getEndpointUri method on Endpoint is now parsing the uri on each call  this is not needed  and is also unnecessary overhead.We should parse this once.Also Camel's built-in type converter should be used during the parsing  and not just the hardcoded PropertyEditorTypeConverter which is to be considered removed as its not thread safe causes unforeseen side effects when 3rd party projects register property converter",
            "id": "5177"
        },
        "5178": {
            "ground_truth": "0",
            "bug_report": "'IOException: No space left on device' exception swallowed by camel\nWhen routing a file using the GenericFileConsumer object an exception is swallowed if the lock file cant be created (i.e there is no harddrive space).GenericFileConsumer.javaprotected void processExchange(final Exchange exchange) { GenericFile&lt;T&gt; file = getExchangeFileProperty(exchange); log.trace('Processing file: {}'  file); // must extract the absolute name before the begin strategy as the file could potentially be pre moved // and then the file name would be changed String absoluteFileName = file.getAbsoluteFilePath(); // check if we can begin processing the file try { final GenericFileProcessStrategy&lt;T&gt; processStrategy = endpoint.getGenericFileProcessStrategy(); boolean begin = processStrategy.begin(operations  endpoint  exchange  file); if (!begin) { log.debug(endpoint + ' cannot begin processing file: {}'  file); // begin returned false  so remove file from the in progress list as its no longer in progress endpoint.getInProgressRepository().remove(absoluteFileName); return; } } catch (Exception e) { if (log.isDebugEnabled()) { log.debug(endpoint + ' cannot begin processing file: ' + file + ' due to: ' + e.getMessage()  e); } endpoint.getInProgressRepository().remove(absoluteFileName); return; }....}When processStrategy.begin(operations  endpoint  exchange  file); throws an java.io.IOException this is swallowed in the catch method and never propagated to the error handling of camel. Output from log is: 11:33:44.290 [Camel (camel-2) thread #1 - file:/Users/xxxx/yyyy/Files/] DEBUG o.a.c.component.file.FileConsumer - Endpoint[file:/Users/xxxx/yyyy/Files/] cannot begin processing file: GenericFile[//Users/xxxx/yyyy/Files/file01] due to: No space left on devicejava.io.IOException: No space left on device at java.io.UnixFileSystem.createFileExclusively(Native Method) ~[na:1.6.0_31] at java.io.File.createNewFile(File.java:883) ~[na:1.6.0_31] at org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.acquireExclusiveReadLock(MarkerFileExclusiveReadLockStrategy.java:54) ~[camel-core-2.9.0.jar:2.9.0] at org.apache.camel.component.file.strategy.GenericFileProcessStrategySupport.begin(GenericFileProcessStrategySupport.java:46) ~[camel-core-2.9.0.jar:2.9.0] at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.begin(GenericFileRenameProcessStrategy.java:46) ~[camel-core-2.9.0.jar:2.9.0] at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:308) [camel-core-2.9.0.jar:2.9.0] at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:175) [camel-core-2.9.0.jar:2.9.0] at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:136) [camel-core-2.9.0.jar:2.9.0] at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:140) [camel-core-2.9.0.jar:2.9.0] at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:92) [camel-core-2.9.0.jar:2.9.0] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) [na:1.6.0_31] at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317) [na:1.6.0_31] at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150) [na:1.6.0_31] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98) [na:1.6.0_31] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:180) [na:1.6.0_31] at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:204) [na:1.6.0_31] at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) [na:1.6.0_31] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) [na:1.6.0_31] at java.lang.Thread.run(Thread.java:680) [na:1.6.0_31]I have tried both tried error handling on the route and the DefaultErrorHandler way but this exception is never handled by the methods  ie Camel log them and then swallow them.",
            "id": "5178"
        },
        "5180": {
            "ground_truth": "0",
            "bug_report": "Backmerge CAMEL-5018 to the Bindy component for non-required fields\nThe issue  originally reported via CAMEL-5133  is to backmerge the CAMEL-5018 fix into the 2.9.x branch.I merged revision 1292164 into my local 2.9.x branch that I had updated with two new test cases.Before merge one test failed  after merge all tests were successfull.Attaching the updated model and tabtest.&#8212; Revision: 1292164Author: ningjiangDate: den 22 februari 2012 08:49:40Message:CAMEL-5018 support the set the default value on the field of bindy CVSModified : /camel/trunk/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.javaModified : /camel/trunk/components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.javaModified : /camel/trunk/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvUnmarshallTest.javaModified : /camel/trunk/components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/model/simple/oneclass/Order.java",
            "id": "5180"
        },
        "5187": {
            "ground_truth": "0",
            "bug_report": "JMX issues on WebSphere\nWhile setting up a Camel web application for WebSphere (7) I encountered two issues1. Documentation: the Camel JMX docs proposes the following settings for WebSphere:&lt;camel:jmxAgent id='agent' createConnector='true' mbeanObjectDomainName='org.yourname' mbeanServerDefaultDomain='WebSphere'/&gt;This registers the beans with the PlatformMbeanServer instead of the WebSphere MBean server. The following setup works better:&lt;camel:jmxAgent id='agent' createConnector='false' mbeanObjectDomainName='org.yourname' usePlatformMBeanServer='false' mbeanServerDefaultDomain='WebSphere'/&gt;2. For each Camel route  the same Tracer and DefaultErrorHandler MBeans are tried to be registered over and over again. Because WebSphere changes the ObjectNames on registration  server.isRegistered(name); in DefaultManagementAgent#registerMBeanWithServer always returns false  which causes the MBean to be re-registered  which again cause Exceptions  e.g.14:35:48 198 [WebContainer : 4] [] WARN - DefaultManagementLifecycleStrategy.onErrorHandlerAdd(485) | Could not register error handler builder: ErrorHandlerBuilderRef[CamelDefaultErrorHandlerBuilder] as ErrorHandler MBean.javax.management.InstanceAlreadyExistsException: org.apache.camel:cell=wdf-lap-0319Node01Cell name='DefaultErrorHandlerBuilder(ref:CamelDefaultErrorHandlerBuilder)' context=wdf-lap-0319/camelContext type=errorhandlers node=wdf-lap-0319Node01 process=server1 at com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:465) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.internal_addObject(DefaultMBeanServerInterceptor.java:1496) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:975) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:929) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:324) at com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:494) at com.ibm.ws.management.PlatformMBeanServer.registerMBean(PlatformMBeanServer.java:484) at org.apache.camel.management.DefaultManagementAgent.registerMBeanWithServer(DefaultManagementAgent.java:320) at org.apache.camel.management.DefaultManagementAgent.register(DefaultManagementAgent.java:236)...The web application starts up  but with a lot of exceptions in the log.Proposal:Instead of using a Set&lt;ObjectName&gt; for mbeansRegistered  use a Map&lt;ObjectName  ObjectName&gt; where the key is the 'Camel' ObjectName and the value is the actually deployed ObjectName.I will provide a patch that illustrates the idea.",
            "id": "5187"
        },
        "5189": {
            "ground_truth": "0",
            "bug_report": "Bean component - Should preserver properties from exchange to allow to transfer state\nSee nabblehttp://camel.465427.n5.nabble.com/Stateful-Dynamic-Router-tp5647070p5647070.htmlThis allows other EIPs such as the dynamic route to use state when using a bean as its expression.",
            "id": "5189"
        },
        "5192": {
            "ground_truth": "0",
            "bug_report": "spring.schema is not up to date\nThe URI of the Spring schema has been updated in Camel 2.9.1 and 2.8.4:http://camel.apache.org/schema/cxf/We can see that starting from 2.9.1 and 2.8.4  we suffix the schema with -spring or -blueprint.However  the spring.schema resource file has not been updated with this suffix.",
            "id": "5192"
        },
        "5193": {
            "ground_truth": "0",
            "bug_report": "Strange warning appears: WARN  org.apache.camel.processor.DeadLetterChannel - Cannot determine current route from Exchange with id\nThe warning gets printed but other than that  everything seems to work. (I hope)12.04.19 10:34:26:463 [drisCamelContext JmsConsumer[dispatchHttpQueue] #4] WARN org.apache.camel.processor.DeadLetterChannel - Cannot determine current route from Exchange with id: ID-dris-ixor-be-42350-1334569164986-0-1052464  will fallback and use first error handler.12.04.19 10:34:26:463 [drisCamelContext JmsConsumer[dispatchHttpQueue] #4] WARN distribution.kv78.dispatch - Failed delivery (attempt = 199) : org.apache.http.conn.HttpHostConnectException: Connection to http://81.82.232.183:9292 refused - 0299c1d9 - KV8passtimes - 81.82.232.183:9292 - queue_dispatchHttpQueue_ID_dris.ixor.be-36583-1334569163882-4_1_24_1_1007When looking up the log statement in RedeliveryErrorHandler  I find this:else if (!exceptionPolicy.getErrorHandlers().isEmpty()) { // note this should really not happen  but we have this code as a fail safe // to be backwards compatible with the old behavior log.warn('Cannot determine current route from Exchange with id: {}  will fallback and use first error handler.'  exchange.getExchangeId()); processor = exceptionPolicy.getErrorHandlers().iterator().next(); }So it shouldn't happen but it happens after all...Here is the route causing the warning. I think it started when I made the route transacted. As shown in the log snippet above  the warning is printed when the HTTP endpoint throws an IOException (route ENDPOINT_DISPATCH) from(ENDPOINT_DISPATCH_QUEUE + '?cacheLevelName=CACHE_CONSUMER&amp;' + // necessary for message groups to work 'concurrentConsumers={{hermes.dris.distribution.kv78.concurrentOutgoingHttpDispatchers}}&amp;' + 'maxConcurrentConsumers={{hermes.dris.distribution.kv78.maxConcurrentOutgoingHttpDispatchers}}') .routeId(ROUTE_ID_DISPATCH_QUEUE) .onException(Throwable.class) // transacted routes override the default error handler // to avoid the message going to the the ActiveMQ DLQ  forward to our DLQ here .to(ENDPOINT_DLQ) .handled(true) .end() .transacted() // determine action // the timingPointSequencer will check what needs to happen with the message .beanRef('timingPointSequencer'  'handleDispatch') .choice() // normal situation  the message can be sent .when(header(TimingPointSequencer.HEADER_ACTION).isEqualTo(constant(TimingPointSequencer.ACTION_PROCEED))) .to(ENDPOINT_DISPATCH) // delay message  usually because of previous errors for this destination .when(header(TimingPointSequencer.HEADER_ACTION).isEqualTo(constant(TimingPointSequencer.ACTION_REENQUEUE))) .log(LoggingLevel.INFO  'Re-enqueuing' + MESSAGE_LOG_FORMAT) .to(ENDPOINT_DISPATCH_QUEUE) .otherwise() .log(LoggingLevel.ERROR  'No action header set ???' + MESSAGE_LOG_FORMAT) .to(ENDPOINT_DLQ) .end() .end(); from(ENDPOINT_DISPATCH) .routeId(ROUTE_ID_DISPATCH) .onException(IOException.class) // in case of IO exceptions  the message is always re-enqueued // reschedule parameters are set by the timingPointSequencer .beanRef('timingPointSequencer'  'handleFailure') .log(LoggingLevel.WARN  'Failed delivery (attempt = ${in.header.tpSecAttempt}) : ${in.header.CamelExceptionCaught}' + MESSAGE_LOG_FORMAT) .to(ENDPOINT_DISPATCH_QUEUE) .handled(true) .end() // clear http headers to avoid interference from other http endpoints .removeHeaders('CamelHttp*') .setHeader(Exchange.HTTP_URI  simple('http://${header.' + HEADER_DESTINATION_ADDRESS + '}')) .setHeader(Exchange.HTTP_PATH  simple('${properties:hermes.dris.distribution.kv78.controller.urlpath}')) .setHeader(Exchange.CONTENT_TYPE  constant('application/xml')) .setHeader(Exchange.CONTENT_ENCODING  constant('gzip')) // use gzip compression .log(verboseLoggingLevel  'Sending request to ${in.header.CamelHttpUri}/${in.header.CamelHttpPath}' + MESSAGE_LOG_FORMAT) // use multicast instead of a pipeline  or the audit log will contain the http response! .multicast() .stopOnException() .to(ENDPOINT_TIMINGPOINT_HTTP + '?httpClientConfigurerRef=timingPointHttpClientConfigurer&amp;headerFilterStrategy=#distributionHttpHeaderFilterStrategy'  ENDPOINT_AUDIT_OUTGOING) .end() .beanRef('timingPointSequencer'  'handleSuccess');",
            "id": "5193"
        },
        "5196": {
            "ground_truth": "0",
            "bug_report": "SftpChangedExclusiveReadLockStrategy does not check the correct field to determine if a file is changing\nI have recently upgraded from Camel 2.7 to a more recent version. I can confirm that the bug is still in trunk. In Camel 2.7  there was a generic FileChangedExclusiveReadLockStrategy. This checked the modification time of the file using GenericFile.lastModified. This field was set by SftpComponent#asRemoteFile as file.getAttrs().getMTime() * 1000. In Camel 2.8 onwards  this behaviour is implemented by SftpChangedExclusiveReadLockStrategy. This incorrectly (to my mind) retrieves the timestamp on line 67 using: newLastModified = f.getAttrs().getATime();Taking the atime of the file doesn't make a great deal of sense to me; on a POSIX compliant filesystem  the atime will be incremented every time the file is polled  meaning that this strategy will never be able to mark a file as unchanged. While some filesystems are mounted nowadays as noatime or relatime  the mtime is still absolutely the safest mechanism to determine if something is writing to a target file. The impact of this bug is that we cannot reliably poll files from a remote SFTP server.",
            "id": "5196"
        },
        "5198": {
            "ground_truth": "0",
            "bug_report": "Implement connection pooling in jt400 component\nInstead of eagerly obtaining a new connection to the AS/400 system  Endpoint instances request one from a connection pool. Users can specify that their own connection pool be used  or let Camel provide one (default behaviour).Functionally speaking  this feature does not introduce any change (it can be viewed as an optimization in advanced usage scenarios).Thread safety: the producers/consumers  which were inherently thread-safe  became not thread-safe in regard to their start/stop lifecycle.The following text can be used as the documentation for the new URI option:NameconnectionPoolDefault valueAS400ConnectionPool instanceDescriptionCamel 2.10: Reference to an com.ibm.as400.access.AS400ConnectionPool instance in the Registry. This is used for obtaining connections to the AS/400 system. The look up notation ('#' character) should be used.",
            "id": "5198"
        },
        "5199": {
            "ground_truth": "0",
            "bug_report": "initialDelay and idempotentRepository Endpoint URI parameters fail to be read from Camel context when Turkish language is set in host operating system.\norg.apache.camel.util.ObjectHelper.capitalize() method uses native JAVA String.toUpperCase() method (without parameters)  which performs capitalization according to operating system current language and regional settings configuration. When these are set to Turkish  a call to capitalize() method  with a String starting with 'i' as parameter  returns Turkish dotted 'I' as capitalized 'i'  which is wrong according to programmatic language and expected behavior.This behaviour impacts  at least  in Endpoint URI parameters which names start with char 'i'  such as 'idempotentRepository' and 'initialDelay' URI parameters. When setter/getter methods lookup is performed for these parameters  wrong method names are returned due to ObjectHelper.capitalize() method. This method uses standard Java String.toUpperCase() function which returns a dotted 'I' instead of dotless 'I' for idempotentRepository and initialDelay parameters.To solve this  the attached patch consists of refactoring ObjectHelper.capitalize() method. Instead of calling toUpperCase() method  it is called toUpperCase(Locale.ENGLISH) to enforce 'I' character (dotless) return.",
            "id": "5199"
        },
        "5200": {
            "ground_truth": "0",
            "bug_report": "Potential dead-lock when shutting down Camel with NotifyBuilder doing notication\nSee nabblehttp://camel.465427.n5.nabble.com/Gracefull-shutdown-timeouts-due-to-NotifyBuilder-blocks-on-context-tp5654048p5654048.htmlWe should avoid the synchronized getRoutes method which is really not needed.",
            "id": "5200"
        },
        "5210": {
            "ground_truth": "1",
            "bug_report": "Loop causes NullPointerException on error\nThe following context will cause NullPointerException. &lt;routeContext id='myCamelContext' xmlns='http://camel.apache.org/schema/spring'&gt;  &lt;route&gt; &lt;from uri='jms:myQueue'/&gt; &lt;onException&gt; &lt;exception&gt;org.xml.sax.SAXParseException&lt;/exception&gt; &lt;redeliveryPolicy maximumRedeliveries='2'/&gt; &lt;handled&gt;&lt;constant&gt;true&lt;/constant&gt;&lt;/handled&gt; &lt;to uri='log:camelfatal?showAll=true&amp;multiline=true&amp;level=ERROR'/&gt;  &lt;/onException&gt; &lt;loop copy='true'&gt; &lt;constant&gt;3&lt;/constant&gt; &lt;inOnly uri='smtp://you_can_leave_this_unchanged'/&gt; &lt;/loop&gt; &lt;/route&gt; &lt;/routeContext&gt;The callstack on the NullPointerException:Daemon Thread [Camel (appServerCamelContext) thread #1 - JmsConsumer&#91;emailOutbox&#93;] (Suspended (exception NullPointerException))  DefaultErrorHandler(RedeliveryErrorHandler).processErrorHandler(Exchange  AsyncCallback  RedeliveryErrorHandler$RedeliveryData) line: 262  DefaultErrorHandler(RedeliveryErrorHandler).process(Exchange  AsyncCallback) line: 223  RouteContextProcessor.processNext(Exchange  AsyncCallback) line: 45  RouteContextProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  DefaultChannel.process(Exchange  AsyncCallback) line: 304  AsyncProcessorHelper.process(AsyncProcessor  Exchange  AsyncCallback) line: 73  LoopProcessor(DelegateAsyncProcessor).processNext(Exchange  AsyncCallback) line: 99  LoopProcessor.process(Exchange  AsyncCallback  AtomicInteger  AtomicInteger) line: 103  LoopProcessor.process(Exchange  AsyncCallback) line: 74  AsyncProcessorHelper.process(AsyncProcessor  Exchange  AsyncCallback) line: 73  InstrumentationProcessor(DelegateAsyncProcessor).processNext(Exchange  AsyncCallback) line: 99  InstrumentationProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  InstrumentationProcessor.process(Exchange  AsyncCallback) line: 71  AsyncProcessorHelper.process(AsyncProcessor  Exchange  AsyncCallback) line: 73  TraceInterceptor(DelegateAsyncProcessor).processNext(Exchange  AsyncCallback) line: 99  TraceInterceptor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  TraceInterceptor.process(Exchange  AsyncCallback) line: 91  AsyncProcessorHelper.process(AsyncProcessor  Exchange  AsyncCallback) line: 73  DefaultErrorHandler(RedeliveryErrorHandler).processErrorHandler(Exchange  AsyncCallback  RedeliveryErrorHandler$RedeliveryData) line: 333  DefaultErrorHandler(RedeliveryErrorHandler).process(Exchange  AsyncCallback) line: 223  RouteContextProcessor.processNext(Exchange  AsyncCallback) line: 45  RouteContextProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  DefaultChannel.process(Exchange  AsyncCallback) line: 304  RouteContextProcessor.processNext(Exchange  AsyncCallback) line: 45  RouteContextProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  UnitOfWorkProcessor.processAsync(Exchange  AsyncCallback  UnitOfWork) line: 150  UnitOfWorkProcessor.process(Exchange  AsyncCallback) line: 117  RouteInflightRepositoryProcessor.processNext(Exchange  AsyncCallback) line: 50  RouteInflightRepositoryProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  AsyncProcessorHelper.process(AsyncProcessor  Exchange  AsyncCallback) line: 73  InstrumentationProcessor(DelegateAsyncProcessor).processNext(Exchange  AsyncCallback) line: 99  InstrumentationProcessor(DelegateAsyncProcessor).process(Exchange  AsyncCallback) line: 90  InstrumentationProcessor.process(Exchange  AsyncCallback) line: 71  AsyncProcessorHelper.process(AsyncProcessor  Exchange) line: 99  InstrumentationProcessor(DelegateAsyncProcessor).process(Exchange) line: 86  EndpointMessageListener.onMessage(Message) line: 104  DefaultJmsMessageListenerContainer(AbstractMessageListenerContainer).doInvokeListener(MessageListener  Message) line: 560  DefaultJmsMessageListenerContainer(AbstractMessageListenerContainer).invokeListener(Session  Message) line: 498  DefaultJmsMessageListenerContainer(AbstractMessageListenerContainer).doExecuteListener(Session  Message) line: 467  DefaultJmsMessageListenerContainer(AbstractPollingMessageListenerContainer).doReceiveAndExecute(Object  Session  MessageConsumer  TransactionStatus) line: 325  DefaultJmsMessageListenerContainer(AbstractPollingMessageListenerContainer).receiveAndExecute(Object  Session  MessageConsumer) line: 263  DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener() line: 1058  DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop() line: 1050  DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run() line: 947  ThreadPoolExecutor$Worker.runTask(Runnable) line: 886  ThreadPoolExecutor$Worker.run() line: 908  Thread.run() line: 662",
            "id": "5210"
        },
        "5218": {
            "ground_truth": "1",
            "bug_report": "HazelcastComponent.doStop bombing out\nI am setting up an own hazelcast instance on HazelcastComponent  it is created by Spring the problem is when HazelcastComponent.doStop is called  a NullPointerException is throw  becausecreateOwnInstance is null.",
            "id": "5218"
        },
        "5225": {
            "ground_truth": "0",
            "bug_report": "camel-netty can't distinguish between Sharable and Unsharable codecs\nCamel-netty uses general configuration model for referenced encoders/decoders for channel pipelines  see DefaultServerPipelineFactory. That is  create encoder/decoder objects at configuration parsing time and store them in a list  then use them when a pipeline is established. However  this will make encoder/decoder objects shared among different pipelines  that may cause data conflicts  when the encoder/decoder is not Sharable(has object status/not annotated as @Sharable)  e.g. a LengthFieldBasedFrameDecoder.Although we can avoid the problem by totally writing a new serverpipelinefactory for our apps  several problem still remains  please see detailed description and testcase for this bug at:http://camel.465427.n5.nabble.com/camel-netty-bug-and-the-need-of-best-practice-for-creating-referenced-parameter-object-on-looking-up-td5627926.html",
            "id": "5225"
        },
        "5227": {
            "ground_truth": "0",
            "bug_report": "Camel 2.9.2 jetty component no longer works with Jetty 7\nWhen attempting to create a camel-jetty endpoint in Camel 2.9.2  the following exception is thrown:java.lang.NoSuchMethodError: org.eclipse.jetty.servlet.ServletContextHandler.addFilter(Lorg/eclipse/jetty/servlet/FilterHolder;Ljava/lang/String;Ljava/util/EnumSet;)Vat org.apache.camel.component.jetty.JettyHttpComponent.enableMultipartFilter(JettyHttpComponent.java:407) at org.apache.camel.component.jetty.JettyHttpComponent.connect(JettyHttpComponent.java:325) at org.apache.camel.component.http.HttpEndpoint.connect(HttpEndpoint.java:148) at org.apache.camel.component.http.HttpConsumer.doStart(HttpConsumer.java:56) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.startService(DefaultCamelContext.java:1707) at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRouteConsumers(DefaultCamelContext.java:1979) at org.apache.camel.impl.DefaultCamelContext.doStartRouteConsumers(DefaultCamelContext.java:1934) at org.apache.camel.impl.DefaultCamelContext.safelyStartRouteServices(DefaultCamelContext.java:1862) at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRoutes(DefaultCamelContext.java:1646) at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1533) at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1420) at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:179) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1388)...This appears to be a regression of a caused by the this merge from trunk  which I suspect requires Jetty 8 to be used.Creating the endpoint under 2.9.1 works fine.",
            "id": "5227"
        },
        "5243": {
            "ground_truth": "0",
            "bug_report": "jt400: program call should support binary format\nData queue message exchange supports both text and binary formats and so should the remote program call exchange. The specification is the same as the one for the data queue.Additionally  this patch supports the concept of ommiting a parameter. This is achieved by passing null as the parameter value.Implementation note:Since I don't know Camel's policy regarding API breaking  I opted to refer to Jt400DataQueueEndpoint.Format; but Format should now be a top-level class  since the concept is the same for data queues and programs.",
            "id": "5243"
        },
        "5260": {
            "ground_truth": "0",
            "bug_report": "LDAP Component lose headers\nWhen we call to a LDAP endpoint  the result is returned in the Out body and we lose the IN headers (see http://camel.465427.n5.nabble.com/LDAP-Component-lose-headers-td5696602.html). A fix seems relatively easy. The solution could be add this line inside the process() method in LdapProducer.java exchange.getOut().setHeaders(exchange.getIn().getHeaders());",
            "id": "5260"
        },
        "5262": {
            "ground_truth": "0",
            "bug_report": "Relax simple language checking for function start/end tokens  to only validate start tokens has appropriate end token\nSee nabblehttp://camel.465427.n5.nabble.com/Translating-route-exceptions-to-JSON-with-Simple-Expression-Language-or-SPEL-tp5696933.html",
            "id": "5262"
        },
        "5265": {
            "ground_truth": "0",
            "bug_report": "Incorrect Content-Length returned for converted result objects with Unicode characters\nThe camel-servlet component responds with an incorrect http Content-Length header  causing the HTTP client to retreive a incomplete response  when the body of the out message is of a POJO type and is converted into a string that contains unicode characters.For example  the following route returns 'B?e W?r'  but should return 'B?e W?rld'.from('servlet:///testUnicodeWithObjectResponse?matchOnUriPrefix=true')  .process(new Processor() { public void process(Exchange exchange) throws Exception {  String contentType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE  String.class); exchange.getOut().setHeader(Exchange.CONTENT_TYPE  contentType + '; charset=UTF-8');  }}) .transform(constant( new Object(){ @Override public String toString() Unknown macro: { return &quot;B?e W?rld&quot;; }  } ));The attached patch contains a fix for the problem and a test to reproduce the problem.",
            "id": "5265"
        },
        "5269": {
            "ground_truth": "0",
            "bug_report": "Make it possible to change the remote file name without changing the local file name\nCurrently  if you change the remote file name by changing the message header Exchange.FILE_NAME  this will not only change the remote file name but also the local file name. This is often undesirable. Instead it is a common requirement to archive the files that you process locally with their original file names unchanged.This has been discussed on the user mailing list:http://camel.465427.n5.nabble.com/how-to-specify-remote-file-name-when-using-FTP-endpoint-td5697227.html",
            "id": "5269"
        },
        "5270": {
            "ground_truth": "0",
            "bug_report": "Add community and peer address of SNMP TRAP PDUs to camel-snmp header\nA patch is included to add the community and peer address of SNMP traps that are received by camel. This is useful to determine where a trap originated from  as not all SNMPv2 traps include an OID that identifies the sender.The information is placed in the message header as strings with names:securityNamepeerAddressThese names correspond to the accessor names in the snmp4j API for the CommandResponderEvent class. securityName is not the correct name for SNMP v1/2 traps  but it's probably better to stick with a name that can be consistant between SNMP versions.",
            "id": "5270"
        },
        "5274": {
            "ground_truth": "0",
            "bug_report": "Jetty client can corrupt streams if used in a bridge mode (proxy)\nThe jetty http producer should favor streams over Strings  which otherwise could cause the payload to be corrupted if doing a bridge mode  eg from jetty to jetty.",
            "id": "5274"
        },
        "5275": {
            "ground_truth": "0",
            "bug_report": "Dependencies with inconsitant paths in repository\nArtifactory doesn't by default serve artifacts that have a path inconsistancy in it's repository. The used maven-shade-plugin version 1.4 used by camel 2.10.0-SNAPSHOT depends on such a component. this is fixed in version 1.6I was unable to add an attachement  so here is the patch inline:      Eclipse Workspace Patch 1.0#P camelIndex: parent/pom.xml===================================================================   parent/pom.xml (revision 1338042)+++ parent/pom.xml (working copy)@@ -1684 7 +1684 7 @@ &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;     &lt;version&gt;1.4&lt;/version&gt;+ &lt;version&gt;1.6&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt;",
            "id": "5275"
        },
        "5279": {
            "ground_truth": "0",
            "bug_report": "camel-stream overwrites files instead of appending\nWhen a file stream is used with camel-stream  the file is not opened in append mode  therefore the file is overwritten with every message  ending up with just the last message  all others are lost.This contrasts with the documented behavior.",
            "id": "5279"
        },
        "5284": {
            "ground_truth": "0",
            "bug_report": "camel-stream should not close stream after each write\nThe StreamProducer in camel-stream closes the stream after every write  which significantly affects performance.",
            "id": "5284"
        },
        "5299": {
            "ground_truth": "0",
            "bug_report": "EventNotifiers don't work under Blueprint\nEventNotifiers don't work with Blueprint Camel Contexts. Testing on latest 2.10-SNAPSHOT  updated on 22 May 16:45 GMT.After some debugging  it looks like the bean lookup performed on line 202 of AbstractCamelContextFactoryBean.afterPropertiesSet() triggers the initialization of the CamelContext as part of the lookup. As part of the init  all services are started  including the ManagementContext and its EventNotifiers (which we were just looking up).EventNotifiers are then added but never started because they came in late.",
            "id": "5299"
        },
        "5308": {
            "ground_truth": "0",
            "bug_report": "Main is bound to DefaultCamelContext\nWe are using our own CamelContext  which is extending the DefaultCamelContext. Using Main is impossible in this case  since the getCamelContextMap()-method creates statically a DefaultCamelContext. Overriding this method doesn't works either  since the field registery is final  and no other accessors are defined.The given path doesn't breaks existing code bases  and gives an easy possiblity to override the context-creation  as well as access to the registry.",
            "id": "5308"
        },
        "5320": {
            "ground_truth": "0",
            "bug_report": "camel-ftp - Add option to check files without downloading\ndownload=false could be an option to stop poll consumers from downloading files when all you need is to check for file attributes.The need was generated from ftp component but it could potentially apply to any file consumer. For more info see the original thread http://camel.465427.n5.nabble.com/Camel-FTP-SFTP-check-instead-of-download-td5713363.html",
            "id": "5320"
        },
        "5326": {
            "ground_truth": "0",
            "bug_report": "camel-bindy - Do not use locale if not explicit configured\nBindy should newer use locale if not explicit configured to use one  as they will format numbers and whatnot in unexpected ways.For example an integer with an US locale will have comma as thousand separator  and that dont go well when marshalling to a CSV file  as the comma is also often a separator there.",
            "id": "5326"
        },
        "5347": {
            "ground_truth": "0",
            "bug_report": "Add a Camel Component to support MQTT\nMQTT is a light weight messaging protocol for small sensors and mobile devices - see http://mqtt.org",
            "id": "5347"
        },
        "5355": {
            "ground_truth": "0",
            "bug_report": "camel-sql - Should support % sign in query\nSee nabbleWe should look into supporting the % sign in the sql component.It should possible be less strict in uri validation as people can enter SQL queries. And to make it easy  they should just be able to dump in the SQL as is.We should also consider adding an option to refer to a SQL that is enlisted in the registry.Also people should be able to externalize their SQL in a .properties file and have Camel lookup that using the {{ }} notation",
            "id": "5355"
        },
        "5360": {
            "ground_truth": "0",
            "bug_report": "Camel features file doesn't validate\nIf you execute$camel/platforms/karaf&gt;mvn clean install -Pvalidateit fails in the feature definition validation for the following components:camel-quickfixcamel-cxfcamel-cdi",
            "id": "5360"
        },
        "5363": {
            "ground_truth": "0",
            "bug_report": "camel-jms - Exception thrown from destination resolver should trigger Camel exception handling\nSee nabblehttp://camel.465427.n5.nabble.com/Camel-Error-handling-throwing-exception-not-moving-to-error-queue-tp5714076.htmlThe jms producer should catch unhandled exceptions from the Spring JMS  such as its destination resolver. And ensure the callback is invoked  to let Camel error handler be triggered.",
            "id": "5363"
        },
        "5365": {
            "ground_truth": "0",
            "bug_report": "SOAPMessage to InputStream conversion needed for some CXF SOAPMessage Provider scenarios\nWhen you have a SOAPMessage Provider based CXF endpoint in your Camel route and the message is forwarded to an input stream based processor or producer (e.g.  File)  it is necessary to have a converter that converts SOAPMessage into InputStream.It would be practical to have this conversion method included in CxfConverter.I am attaching a test case and a possible implementation. This implementation uses CachedOutputStream to make an InputStream from a SOAPMessage. There might be a better way to get an InputStream  but I don't know a simple one.Thanks.",
            "id": "5365"
        },
        "5372": {
            "ground_truth": "0",
            "bug_report": "Shutting down one of the contexts breaks async redeliveries in others: RedeliveryErrorHandler has static reference to a thread pool\nErrorRedeliveryHandler has static reference to a thread pool used for scheduling retries  thus when it's stopped it stops a pool used by other handler instances(e.g. from other contexts)  thus they now can't redeliver.",
            "id": "5372"
        },
        "5376": {
            "ground_truth": "1",
            "bug_report": "Mail component does not work as expected (Email Deletion is partially broken et Disconnect does not work well)\nThe way disconnect is implemented causes issues with some other options of the consumer. For instance 'disconnect' option is not compatible with 'delete' option.The delete action is done in completion action (processCommit: line 185). On line 305  processCommit method checks if folder is open  but 'disconnect' option force folder at null value at the end of poll method (Line 149).I guess disconnect method should be called on completion after any other completion actions occured: It is not possible to make completion actions if connection to mail server is closed.The result of the usage of disconnect option and delete option is a NullPointerException on test: 'if (!folder.isOpen())' statement on line 308.Issue should be always reproductible.I let you fix the priority of the issue  but it is an annoying issue even if there is a workaround by disabling disconnect option ...",
            "id": "5376"
        },
        "5396": {
            "ground_truth": "0",
            "bug_report": "Improve performance of DefaultJmsKeyFormatStrategy\nThe current default implementation uses String.replace/replaceAll to escape the illegal characters in the header key. This is unfortunate because replace/replaceAll are implemented in terms of regular expressions which makes the escaping quite costly for something that is executed for every single message. Also it's quite likely that the headers will be identical for every single message that's published via JMS. The attached patch makes two changes; Use Commons Lang StringUtil.replaceEach which using a StringBuilder internally to do the replacement. This adds a dependency on Commons Lang. Cache the output of StringUtil.replaceEach in a ConcurrentHashMap. This could be moved to a separate class if caching every key is a concern. Or this could be changed to use an LRUCache",
            "id": "5396"
        },
        "5405": {
            "ground_truth": "0",
            "bug_report": "CXF Transport loses HTTP Matrix parameters\nDefaultCxfMesssageMapper (note the typo - to be fixed in a follow-up JIRA) wrongly initializes CXF Message Message.REQUEST_URI property with the value of Camel Exchange.HTTP_PATH  even though Camel Exchange.HTTP_URI is available.The net effect is that the HTTP matrix parameters if any attached to the last HTTP path segment are lost. Another side-effect is that Exchange.HTTP_PATH will contain the decoded value (done at HTTPServletRequest level) which can lead to the matching issues at the JAX-RS level.A simple patch is attached",
            "id": "5405"
        },
        "5406": {
            "ground_truth": "0",
            "bug_report": "Threads EIP hangs Junit4 tests using adviceWith\nIf the  threds()  DSL keyword is used in a route and a Junit4 test is performed  the test hangs indefenitely.The issue is descibed here:http://camel.465427.n5.nabble.com/Threads-EIP-hangs-Unit-Tests-JUnit4-td5715031.htmlplease find attached a self-consistent sample project to reproduce it.",
            "id": "5406"
        },
        "5407": {
            "ground_truth": "0",
            "bug_report": "Better error message when trying to write a null body as file\nSee nabblehttp://camel.465427.n5.nabble.com/Can-t-route-wsdl-request-into-file-tp5715201.htmlWe should have a better error message instead of something about no type converter exception.We could also consider an option to the file producer  to silently ignore writing files if there is no message body.Finding a good name for this option is a challenge  skipNullBody ignoreWritingNullBody",
            "id": "5407"
        },
        "5411": {
            "ground_truth": "0",
            "bug_report": "MQTT Endpoint does not correctly return the MQTT-Payload\nMQTT Endpoint does not correctly return the MQTT-Payload. It returns the whole MQTT Message (header + payload).The bug is in line 89 of MQTTEndpoint.java (version 2.11  but also in 2.10) exchange.getIn().setBody(body.getData());must become exchange.getIn().setBody(body.toByteArray()); because getData() ignores the offset (to skip the MQTT header) set in the body byte array.",
            "id": "5411"
        },
        "5412": {
            "ground_truth": "1",
            "bug_report": "ObjectAlreadyExistsException when 'redeploying' routes that uses CronScheduledRoutePolicy\nWhen a route that has a CronScheduledRoutePolicy is removed it does not properly clean up the quartz jobs. The result (apart from possible memory leak) is that if the route is removed from the context and then readded with the same route id a ObjectAlreadyExistsException.This is done using the following steps.1. Stop the route2. Remove the route (and it's endpoints) from the context.3. (Re)add the route to the context using the same name.Attached is a testcase that shows the problem.I've solved this by adding my own implementation of onRemove (that calls doStop()) to CronScheduledRoutePolicy.",
            "id": "5412"
        },
        "5415": {
            "ground_truth": "0",
            "bug_report": "Simple does not handle empty values in predicates properly\nExample code:...&lt;choice&gt; &lt;when&gt; &lt;simple&gt;${property.someProperty} == ''&lt;/simple&gt; ... &lt;/when&gt;...Error message: right must be specified",
            "id": "5415"
        },
        "5444": {
            "ground_truth": "0",
            "bug_report": "camel-jms - Log at INFO level if shared replyTo queues are in use  as they are not as fast as temporary or exclusive queues\nSee nabblehttp://camel.465427.n5.nabble.com/fyi-SI-tp5716049.htmlWe should log at INFO (maybe even WARN level) if shared reply queues are in use as they are not as fast. They have their purposes though  such as a shared clustered queue  or if a queue is used by other apps too (not ideally thought). Temporary and Exclusive reply queues are faster.See the JMS docs at the request reply section  for much more details.",
            "id": "5444"
        },
        "5459": {
            "ground_truth": "0",
            "bug_report": "Folder closed too early when working asynchronously\nWhen using a MailConsumer connected with IMAP to a mailserver and routing the messages to SEDA or any other asynchronous endpoint  it can cause a com.sun.mail.util.FolderClosedIOException or javax.mail.FolderClosedException to happen if you are trying to process the mails/messages attachments.This is because the IMAP folder gets closed at the end of each MailConsumer.poll()I propose to add a new MailConfiguration option 'closeFolder'  which can override this behaviour.Here's an example on how to reproduce the problem. (Scala code  sorry! But it should be self-explanatory)You need a couple of mails with attachments in your mailbox to test this. ~10 mails should be enough to cause the exceptions.import javax.mail.internet.MimeMultipartimport org.apache.camel.impl.DefaultCamelContextimport org.apache.camel.scala.dsl.builder.RouteBuilderimport scala.io.Sourceobject Main {  def main(args: Array&#91;String&#93;): Unit = { val camelContext = new DefaultCamelContext val host = 'imap.gmail.com' val username = '*****@gmail.com' val password = '*****' // this will cause com.sun.mail.util.FolderClosedIOException or javax.mail.FolderClosedException val endpoint = 'imaps://'host'?password='password'&amp;username='username'&amp;folderName=INBOX&amp;unseen=false&amp;disconnect=false&amp;mapMailMessage=true&amp;connectionTimeout=60000' // with fix / new feature 'closeFolder' set to false //val endpoint = 'imaps://'host'?password='password'&amp;username='username'&amp;folderName=INBOX&amp;unseen=false&amp;disconnect=false&amp;mapMailMessage=true&amp;connectionTimeout=60000&amp;closeFolder=false' camelContext.addRoutes( new RouteBuilder { endpoint .to('seda:process') from('seda:process?concurrentConsumers=5') ==&gt; { process { ex =&gt; val att = ex.getIn.getBody.asInstanceOf[MimeMultipart].getBodyPart(1) println('Attachment Name:' + att.getFileName) println('Attachment Content:' + att.getDataHandler.getContent) println('Attachment Content:' + Source.fromInputStream(att.getDataHandler.getInputStream).mkString) Thread.sleep(2500) // simulate some work being done here with the attachment  takes time.. } } } ) camelContext.start() Thread.sleep(45 * 1000) camelContext.stop() }}",
            "id": "5459"
        },
        "5461": {
            "ground_truth": "0",
            "bug_report": "IOConverter.toInputStream opens a BufferReader which will never be closed\nIf called with a non-null charset IOConvert.toInputStream returns a InputStream which will never close the opened BufferedReader.",
            "id": "5461"
        },
        "5464": {
            "ground_truth": "0",
            "bug_report": "camel-jms consumer doesn't send back a reply in all cases\nIn a very simple route consuming from a Camel JMS endpoint receiving InOut exchanges (i.e. JMSReplyTo header present)  the endpoint will not send back replies.This happens because Camel JMS only returns a reply if the OUT message is set. But if the route looks like: consumer =&gt; processor  and Camel doesn't find the need to 'weave in' an implicit Pipeline processor  no one will implicitly take care of mapping the IN message to an OUT message (unless the user knows about these internal aspects - but we shouldn't expect them too).As a result  these routes DON'T WORK...&lt;route&gt; &lt;from uri='timer:foo?fixedRate=true&amp;amp;period=10000' /&gt; &lt;setBody&gt;&lt;constant&gt;Hello Raul&lt;/constant&gt;&lt;/setBody&gt; &lt;to uri='log:SendingRequest?showAll=true' /&gt; &lt;inOut uri='activemq:queue:test1?requestTimeout=1000' /&gt; &lt;to uri='log:ReceivedReply?showAll=true' /&gt;&lt;/route&gt; &lt;route&gt; &lt;from uri='activemq:queue:test1' /&gt; &lt;to uri='log:ReceivedRequest?showAll=true' /&gt;&lt;/route&gt;... but just by adding an additional log endpoint to the second route (or any other thing  for that matter)  it starts to work because Camel weaves in the Pipeline processor.Other workarounds that work: explicitly wrapping the log endpoint in a &lt;pipeline&gt; DSL &lt;setBody&gt;&lt;simple&gt;${in.body}&lt;/simple&gt;&lt;/setBody&gt;Or simply introducing anything that will force Camel to insert a Pipeline processor.IMHO  there are two solutions to avoid this issue: Always weave in a Pipeline processor (adds overhead in simple routes and may cause regressions) Adapt EndpointMessageListener to pick the IN message when the exchange is out capable and expectation of a reply existsI'm happy to work on a patch for Camel 2.10.1.EDIT: Just wrapping the single endpoint in &lt;pipeline /&gt; doesn't function as a workaround.",
            "id": "5464"
        },
        "5474": {
            "ground_truth": "0",
            "bug_report": "Support to build the camel-soap offline\ncamel-soap introduce soap12.xsd which has the import from the internet  it will cause some trouble when you build the camel-soap offline.",
            "id": "5474"
        },
        "5485": {
            "ground_truth": "1",
            "bug_report": "camel-mybatis should do a proper transaction demarcation while reading/writing from/to database.\nSee http://camel.465427.n5.nabble.com/MyBatis-Component-Bug-consumer-onConsume-hits-error-transactions-are-committed-instead-of-rollback-td5716774.htmlOther than DefaultMyBatisProcessingStrategy the same issue exists by MyBatisProducer as well.Another thing which is currently missing completley is that there's no transaction demarcation by the Producer at all while reading from the database  e.g. by SelectOne or SelectList statement types.",
            "id": "5485"
        },
        "5492": {
            "ground_truth": "0",
            "bug_report": "Add option to restrict HTTP method in camel-jetty and camel-servlet\nSee http://camel.465427.n5.nabble.com/Jetty-consumer-restricting-methods-td5716938.html",
            "id": "5492"
        },
        "5495": {
            "ground_truth": "0",
            "bug_report": "file endpoints on windows without volume name in the path url not working in some cases\nI am using file endpoints on Windows without the volume name just like the normal unix based paths look.That means  I have something like file:///tmp/file-in and file:///tmp/file-outThe funny thing that I noticed is that each endpoint itself works fine  but when a route is set up from one to the other  it fails because there seems to be an inconsistency in the way the windows path is handled in the camel-core's file component.As mentioned  each file endpoint itself is working fine. For example  the consumer file endpoint configured in a routefrom('file:///tmp/file-in').to('mock:test')works fine.Similarly  the produce file endpoint configured in a routefrom('direct:test').to('file:///tmp/file-out')works fine.But when a route is setup to connect these two file endpoints  the producer endpoint fails to create the output file.Concretely  there is the following code in GenericFileEndpoint.configureMessage that determines the file name. String name = file.isAbsolute() ? file.getAbsoluteFilePath() : file.getRelativeFilePath(); // skip leading endpoint configured directory String endpointPath = getConfiguration().getDirectory() + getFileSeparator();In this particular case  the name variable is set to 'C:/tmp/file-in/sample.xml' while the endpointPath variable is set to '/tmp/file-in'.So  the subsequent code to extract the file name part  shown below  fails to match the path. if (ObjectHelper.isNotEmpty(endpointPath) &amp;&amp; name.startsWith(endpointPath)) { name = ObjectHelper.after(name  endpointPath); }As a result  the file name is not extracted as 'sample.xml' but remain unchanged as 'C:/tmp/file-in/sample.xml'.Consequently  when the file producer endpoint tries to write this file in the file system  it tries to write a file as '/tmp/file-out/C:/tmp/file-in/sample.xml'  resulting in an error.I modified FileComponent and FileEndpoint so that the endpoint path is stored correctly in this case to make the above extraction code find the file name part correctly.Attached is this proposed patch and a test case which runs on windows and on non-windows but this issue can only be demonstrated under windows.testRouteToFileOnly and testRouteFromFileOnly work without this patch while testRouteFileToFile fails without this patch on windows.Thanks for looking into this issue.Regards  Aki",
            "id": "5495"
        },
        "5500": {
            "ground_truth": "0",
            "bug_report": "camel-testng - The spring base test class should use @AfterMethod on teardown as its parent does\nSee nabblehttp://camel.465427.n5.nabble.com/Problem-with-testng-CamelSpringTestSupport-several-contexts-runs-simultaneously-tp5716447.html",
            "id": "5500"
        },
        "5513": {
            "ground_truth": "0",
            "bug_report": "Add option to changed readLock to denote whether a zero file size is accepted or not\nSome people may write zero files and want them to be accepted.",
            "id": "5513"
        },
        "5526": {
            "ground_truth": "0",
            "bug_report": "'ThreadID is already used' exception under heavy load\nIn situations with heavy load or under load tests we rarely got exception: 2012-08-21 12:28:02 620 [ool-26-thread-7] ERROR DefaultErrorHandler - Failed delivery for (MessageId: ID-atitov-pc-60956-1345537671897-2-143205 on ExchangeId: ID-atitov-pc-60956-1345537671897-2-143206). Exhausted after delivery attempt: 1 caught: java.lang.IllegalArgumentException: ThreadID is already usedjava.lang.IllegalArgumentException: ThreadID is already used at org.jivesoftware.smack.ChatManager.createChat(ChatManager.java:163) at org.apache.camel.component.xmpp.XmppPrivateChatProducer.getOrCreateChat(XmppPrivateChatProducer.java:97) at org.apache.camel.component.xmpp.XmppPrivateChatProducer.process(XmppPrivateChatProducer.java:65) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:120) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:292) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:115) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:330) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:117) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:122) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:61) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:86) at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:63) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:360) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:1) at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:227) at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:331) at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:169) at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:111) at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:124) at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:131) at org.apache.camel.component.xmpp.XmppProducerConcurrentTest$1.call(XmppProducerConcurrentTest.java:79) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662)2012-08-21 12:28:02 621 [ool-26-thread-5] ERROR DefaultErrorHandler - Failed delivery for (MessageId: ID-atitov-pc-60956-1345537671897-2-143207 on ExchangeId: ID-atitov-pc-60956-1345537671897-2-143208). Exhausted after delivery attempt: 1 caught: java.lang.IllegalArgumentException: ThreadID is already usedjava.lang.IllegalArgumentException: ThreadID is already used at org.jivesoftware.smack.ChatManager.createChat(ChatManager.java:163) at org.apache.camel.component.xmpp.XmppPrivateChatProducer.getOrCreateChat(XmppPrivateChatProducer.java:97) at org.apache.camel.component.xmpp.XmppPrivateChatProducer.process(XmppPrivateChatProducer.java:65) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:120) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:292) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:115) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:330) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:117) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:122) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:61) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:86) at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:63) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:360) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:1) at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:227) at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:331) at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:169) at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:111) at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:124) at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:131) at org.apache.camel.component.xmpp.XmppProducerConcurrentTest$1.call(XmppProducerConcurrentTest.java:79) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) After debugging and looking at source code we figured out  that smack use some sort of map with week references for chat cache. When memory is low java GC discards chat instances  but in Process() method they instantiated over and over again without synchronization:XmppPrivateChatProducer.java public void process(Exchange exchange) { ......................... Chat chat = chatManager.getThreadChat(endpoint.getChatId()); if (chat == null) { LOG.trace('Creating new chat instance with thread ID {}'  endpoint.getChatId()); chat = chatManager.createChat(getParticipant()  endpoint.getChatId()  new MessageListener() { public void processMessage(Chat chat  Message message) { // not here to do conversation if (LOG.isDebugEnabled()) { LOG.debug('Received and discarding message from {} : {}'  getParticipant()  message.getBody()); } } }); } .........................} But smack implementation prohibits chat instances with same chatId.",
            "id": "5526"
        },
        "5527": {
            "ground_truth": "0",
            "bug_report": "Maven archetype - Generates wrong plugin for surefire plugin\nThe blueprint archetype creates wrong pom.xml. The groupId for the surefire plugin is wrong.",
            "id": "5527"
        },
        "5528": {
            "ground_truth": "0",
            "bug_report": "Improve how the AWS-SQS component create a new queue with additional attributes\nImprove how the AWS-SQS component create a new queue with additional attributes",
            "id": "5528"
        },
        "5535": {
            "ground_truth": "0",
            "bug_report": "Multiple restlet routes of the same restlet URI but different VERBs does not work in Apache Camel 2.10.0   both routes work in Apache Camel 2.9.1.\nMultiple restlet routes of the same restlet URI but different VERBs does not work in Apache Camel 2.10.0   both routes work in Apache Camel 2.9.1. Reproduce Steps:-----------------1) Add a restlet route with a from uri of restlet:///nimbus/hello.restlet/1.0?restletMethods=get&lt;route xmlns='http://camel.apache.org/schema/spring' trace='true' &gt; &lt;from uri='restlet:///nimbus/hello.restlet/1.0?restletMethods=get'/&gt; &lt;transform&gt; &lt;simple&gt;Hello Restlet Method: ${header.CamelHttpMethod} ID:${header.id}&lt;/simple&gt; &lt;/transform&gt; &lt;/route&gt;2) Add a restlet route with a from uri of restlet:///nimbus/hello.restlet/1.0?restletMethods=post &lt;route xmlns='http://camel.apache.org/schema/spring' trace='true' &gt; &lt;from uri='restlet:///nimbus/hello.restlet/1.0?restletMethods=post'/&gt; &lt;transform&gt; &lt;simple&gt;Hello Restlet Method: ${header.CamelHttpMethod} ID:${header.id}&lt;/simple&gt; &lt;/transform&gt; &lt;/route&gt;3) route 1work fine  but #2 results in the following exception. both route work fine in Camel 2.9.1.Exception:012-07-27 10:29:20 646-0400 ERROR grails.app.service.nimbus.ComputeService localhost addRoute for hello.restletpost failed - Failed to start route nimbus.hello.restletpost.1.0 because of Multiple consumers for the same endpoint is not allowed: Endpoint&#91;/nimbus/hello.restlet/1.0&#93; Caused by: org.apache.camel.FailedToStartRouteException: Failed to start route nimbus.hello.restletpost.1.0 because of Multiple consumers for the same endpoint is not allowed: Endpoint&#91;/nimbus/hello.restlet/1.0&#93; at org.apache.camel.impl.DefaultCamelContext(doStartOrResumeRouteConsumers:1993) I've already posted on http://camel.465427.n5.nabble.com/Apache-Camel-2-10-0-multiple-restlet-routes-of-the-same-restlet-URI-but-different-VERBs-does-not-work-td5716556.html",
            "id": "5535"
        },
        "5536": {
            "ground_truth": "0",
            "bug_report": "Possible issue in camel-apns - Reported on user forum\nSee nabblehttp://camel.465427.n5.nabble.com/Issue-with-ApnsServiceFactory-tp5717573.html",
            "id": "5536"
        },
        "5537": {
            "ground_truth": "0",
            "bug_report": "Mina2 Consumer doesn't reliably work with SSL\nI've been trying to write a service using Camel 2.10.0 which uses the mina2 component to expose a service  and which uses SSL  using an endpoint of:mina2:tcp://localhost:6500?sync=true&amp;filters=#hl7SslFilterFactory #hl7CodecFilter&amp;allowDefaultCodec=falsehowever  what I found was that the SSL handshake was failing quite often for no apparent reason. Investigating further  it appeared that messages sent during the handshake were being processed out of order - specifically  when the client (which uses a standard java SSLSocket) sent a 'TLSv1 Change Cipher Spec' followed by a 'TLSv1 Handshake'  the 'TLSv1 Handshake' was being processed before the 'TLSv1 Change Cipher Spec'  breaking the process.This appears to have been caused because when the the Mina2Consumer configures MINA for tcp (in Mina2Consumer.setupSocketProtocol)  it is using a UnorderedThreadPoolExecutor - which allows messages to be processed in any order. Switching this to use a OrderedThreadPoolExecutor instead has fixed the issue.May I request that the use of UnorderedThreadPoolExecutor vs OrderedThreadPoolExecutor be configurable via endpoint parameters? (or OrderedThreadPoolExecutor is used when SSL if configured). I'm assuming the reason for the use of UnorderedThreadPoolExecutor is simply for performance.",
            "id": "5537"
        },
        "5540": {
            "ground_truth": "0",
            "bug_report": "File consumer - NPE if configured to consume from root directory\nSee nabblehttp://camel.465427.n5.nabble.com/Setting-root-folder-as-endpoint-Could-not-poll-endpoint-NPE-tp5717845.html",
            "id": "5540"
        },
        "5545": {
            "ground_truth": "1",
            "bug_report": "Support key password for private key access in XMLSecurity\nEnhance the XMLSecurity component to enable access of a private key (for decryption) from a Java key store using a password that is unique to the key  and different than the key store password.The likely solution is to allow an optional 'keyPassword' parameter in the XMLSecurity data format.A description of the issue in context is here :http://camel.465427.n5.nabble.com/XMLSecurity-key-recovery-fails-when-keystore-and-key-use-different-passwords-td5718094.html",
            "id": "5545"
        },
        "5555": {
            "ground_truth": "0",
            "bug_report": "In ScheduledRoutePolicy a suspended route cannot be started\nIf a route is suspended using the ScheduledRoutePolicy and its subclasses (CronScheduledRoutePolicy)  it cannot be resumed or started.Looking at the code in ScheduledRoutePolicy.onJobExecute()  on start/resume actions  the route status is first checked and must be stopped or suspended before any actions is taken.Suspension of a route  only suspends the consumer and not the route  and hence the start/resume after a suspend does nothing.One solution could be to also check the status of the consumer on start/resume. This would require adding a isSuspended() to serviceHelper and should be relatively straightforward.",
            "id": "5555"
        },
        "5562": {
            "ground_truth": "0",
            "bug_report": "camel-beanio using beanio 2.0 should be using the 2012/03 beanio namespace\ncamel-beanio which uses beanio-2.0.x library should use the beanio 2.0's namepsace (http://www.beanio.org/2012/03) and not the 1.2 namespace ( http://www.beanio.org/2011/01) in its test cases.The background to this is described in this mail thread.http://camel.465427.n5.nabble.com/issue-with-camel-beanio-s-version-used-in-trunk-td5718596.html",
            "id": "5562"
        },
        "5569": {
            "ground_truth": "0",
            "bug_report": "Make Spring Optional Bundle Import for CXF Transport\nThe camel-cxf-transport component should define the Spring import packages as optional given they are only required if using the Spring DSL namespaces. If you are using Java DSL Spring is not required.Best Regards Scott ES",
            "id": "5569"
        },
        "5574": {
            "ground_truth": "0",
            "bug_report": "camel-sftp's stepwise behavior to walk up and down relatively to avoid potential traversal issues\nI am having a directory traversal problem using the stepwise mode of camel-sftp at the producer side. Basically  it can walk down the path from the starting directory to the walking directory  but it cannot go back correctly to the original starting directly. The server is SSH-2.0-Cleo VLProxy/3.0.1 SSH FTP server.I saw a related JIRA issue CAMEL-3309 that describes some issues in the stepwise traversal and some background to this related problem.My question is on the part that changes the working directory back to the original starting folder. I am wondering why we are using stepwise traversal from the ancestor directory towards the starting child directory  instead of moving upwards relatively from the working directory back to the starting directory. This reverse traversal does not require accessing the ancestry path above the staring directory (hence  not affected by the accessing problem). And in fact  I think this reverse stepwise traversal seems more natural order than doing stepwise traversal each time from top down. How do you think?I have made a change that implements this reverse stepwise traversal in SftpOperations and also made a few minor improvement changes.This changed version passes all the existing tests and works also against the above server.I am attaching a patch file for this change. I would appreciate if you can comment on it.Thanks.regards  aki",
            "id": "5574"
        },
        "5592": {
            "ground_truth": "0",
            "bug_report": "Logger Level is always at default level('ERROR') when error handler is LoggingErrorHandler\nwhen logger level is set to other level (WARN  DEBUG or INFO) except for ERROR  but actually the log is always at ERROR level (it's the default level).",
            "id": "5592"
        },
        "5604": {
            "ground_truth": "0",
            "bug_report": "camel-jackson - Make it easier to support List as output out of the box\nSee nabblehttp://camel.465427.n5.nabble.com/JSON-Jackson-return-list-rather-than-POJO-tp5717341.htmlWe should look into making it easier to output a List as output with jackson json. On the nabble link there is an example and pseduo code how to do that.We should find a way to make that easy in Camel. Either as some new option  or somehow auto detect its a List etc.",
            "id": "5604"
        },
        "5610": {
            "ground_truth": "0",
            "bug_report": "camel-hl7 bundle should specify the mina version\nAs there could be different version of mina or mina2 exist in the OSGi platform  we need to specify the right version rang on camel-hl7 which has the dependency on the mina.",
            "id": "5610"
        },
        "5624": {
            "ground_truth": "1",
            "bug_report": "An exception when constructing JT400 endpoints should not leak the password\nSanitize the endpoint URI in the message of the runtime exception thrown in the constructors for Jt400DataQueueEndpoint and Jt400PgmEndpoint.",
            "id": "5624"
        },
        "5626": {
            "ground_truth": "0",
            "bug_report": "JmsToJmsTransactedSecurityTest in camel-jms fails every now and then\nTest JmsToJmsTransactedSecurityTest fails every now and then because of JMS message redelivery. When the entire test class is executed  it sometimes happens that the message that failed at testJmsSecurityFailure test method pops up in the assertions of testJmsSecurityOK.",
            "id": "5626"
        },
        "5631": {
            "ground_truth": "0",
            "bug_report": "EventHelper.notifyRouteStarted skips all remaining notifiers if one if the notifiers ignores route events\nHaving two or more notifiers registered at the management strategy of a camel context  where one of the notifiers (not the last one) is set up to ignore route events  results in all remaining notifiers to be skipped when notifying a RouteStartedEvent.Look at http://svn.apache.org/viewvc/camel/branches/camel-2.10.x/camel-core/src/main/java/org/apache/camel/util/EventHelper.java?revision=1340446&amp;view=markup  line 237: There's a 'return' which actually should be a 'continue'.Note: CamelContextStoppingEvents are also affected.",
            "id": "5631"
        },
        "5632": {
            "ground_truth": "0",
            "bug_report": "ObjectHelper.resolveUriPath is broken  can not handle:  '../../' correctly\nIn my xsl-files I have imports and includes that resides in folders a few levels up.Ex: &lt;xsl:include href='../../common/myfunctions.xsl'/&gt;When camel starts up and tries to resolve the paths it crashes because of the current implementation in ObjectHelper.resolveUriPath(..)Made a simple testcase that demonstrates my problem.public void testResolveUriPath() throws Exception { assertEquals('xslt/'  ObjectHelper.resolveUriPath('xslt/one/../')); // OK assertEquals('xslt/'  ObjectHelper.resolveUriPath('xslt/one/../two/../')); // OK assertEquals('xslt/'  ObjectHelper.resolveUriPath('xslt/')); // OK assertEquals(''  ObjectHelper.resolveUriPath('./')); // OK assertEquals('xslt/'  ObjectHelper.resolveUriPath('xslt/one/two/../../')); // Fails  gives 'xslt/one/.' assertEquals('xslt/'  ObjectHelper.resolveUriPath('xslt/one/two/../.././'));// Fails  gives 'xslt/one/.' }",
            "id": "5632"
        },
        "5636": {
            "ground_truth": "0",
            "bug_report": "Enricher with async routing not handling exceptions thrown from AggregationStrategy\nThe Enricher does not handle exceptions thrown from the AggregationStrategy when the async routing engine has kicked in. It leads to the following thread dump  callback thread remains blocked forever.'Camel (context) thread #10 - JmsConsumer[queue]' daemon prio=5 tid=103666000 nid=0x113c25000 waiting on condition [113c24000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;7fd4a8de0&gt; (a java.util.concurrent.CountDownLatch$Sync) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156) at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811) at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:969) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281) at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:207) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:120) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:85) at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:91) at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:560) at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:498) at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:467) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1058) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1050) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:947) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:680)",
            "id": "5636"
        },
        "5647": {
            "ground_truth": "0",
            "bug_report": "EIPs using custom aggregation strategy should fail if not possible to find in registry\nSome EIPs support using a custom aggregations strategy. And if you use XML DSL to refer to a custom strategy  then you may have typo  or the strategy do not implement the interface.What we should do is to ensure to fail if the custom strategy could not be looked up. Some EIPs such as the content enricher will fallback and use a default strategy. This is wrong.",
            "id": "5647"
        },
        "5655": {
            "ground_truth": "0",
            "bug_report": "Camel Endpoint ignores camelContextId property in Spring configuration\nCamel Endpoint  if configured outside camelContext element in Spring configuration  ignores camelContextId property. Steps to reproduce: Configure two contexts in spring configuration. Then in the same config file configure two endpoints outside camelContext  but with camelContextId specified. Both endpoints will be created pointing to the same (first) camel context  despite being configured to different contexts. Attempting to use them by reference results in failure  as endpoint camelContext doesn't match the expected one.",
            "id": "5655"
        },
        "5657": {
            "ground_truth": "0",
            "bug_report": "Recipient list EIP - Should shutdown thread pool if parallel mode enabled\nWe should shutdown the thread pool for recipient list if a pool was in use  and it can be shutdown.The logic in doShutdown is missing that.Camel would though have a fail-safe when it shutdown itself to shutdown that pool otherwise. But we should shutdown when the EIP is shutdown itself.",
            "id": "5657"
        },
        "5670": {
            "ground_truth": "1",
            "bug_report": "camel-mqtt - Nullpointer Exception when disconnected from broker\nHi  from time to time  we get the following exception when producing messages via camel-mqtt:Caused by: java.lang.NullPointerException at org.fusesource.mqtt.client.CallbackConnection.publish(CallbackConnection.java:551) at org.fusesource.mqtt.client.CallbackConnection.publish(CallbackConnection.java:545) at org.apache.camel.component.mqtt.MQTTEndpoint.publish(MQTTEndpoint.java:166) at org.apache.camel.component.mqtt.MQTTProducer.doProcess(MQTTProducer.java:66) at org.apache.camel.component.mqtt.MQTTProducer.process(MQTTProducer.java:38) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)[...]From looking at the source of both camel-mqtt and the fusesource mqtt client  it looks like that this is caused by the mqtt-client being disconnected and trying to invoke the onFailure method on the callback:CallbackConnection.javapublic void publish(UTF8Buffer topic  Buffer payload  QoS qos  boolean retain  Callback&lt;Void&gt; cb) { queue.assertExecuting(); if( disconnected ) { cb.onFailure(createDisconnectedError()); return; } PUBLISH command = new PUBLISH().qos(qos).retain(retain); command.topicName(topic).payload(payload); send(command  cb); }camel-mqtt passes in null for the callback though. Wouldn't it be better if a more fitting exception were thrown  or if camel passed in a Callback in order to receive the onFailure event when disconnected from the broker?",
            "id": "5670"
        },
        "5681": {
            "ground_truth": "0",
            "bug_report": "Using recipient list in a doTry ... doCatch situation dont work properly\nSee nabblehttp://camel.465427.n5.nabble.com/Issue-with-doTry-doCatch-not-routing-correctly-tp5720325.htmlThe end user would expect that doTry .. doCatch will overrule. However it gets a bit further more complicated if the try block routes to other routes and using EIPs such as recipient list.",
            "id": "5681"
        },
        "5689": {
            "ground_truth": "0",
            "bug_report": "Netty - Should use ordered thread pool\nWe should favor using OrderedMemoryAwareThreadPoolExecutor andOrderedDownstreamThreadPoolExecutor to ensure ordering of events in a channel.See nabblehttp://camel.465427.n5.nabble.com/Netty-or-Mina-Async-in-the-same-socket-tp5720478.htmlWe can add an option so people can turn it off  like we did for mina2.",
            "id": "5689"
        },
        "5694": {
            "ground_truth": "0",
            "bug_report": "camel-jms - Should also allow multiple consumers from multiple routes from the same queue\nIf having 2+ routes that consumes from the same queue  then that should be allowed.Its a bit unusual though for queues in Camel as you most likely want to use the same route for the same queue. But there is nothing in the JMS spec that forbids this.",
            "id": "5694"
        },
        "5702": {
            "ground_truth": "0",
            "bug_report": "camel-netty - The ordered thread pool should be shared\nRelated to CAMEL-5689The ordered memory thread pool from Netty is intended to be shared per application. And not per consumer.",
            "id": "5702"
        },
        "5707": {
            "ground_truth": "0",
            "bug_report": "NotifyBuilder should be thread safe\nIn high concurrent tests the NotifyBuilder may miss a counter.",
            "id": "5707"
        },
        "5710": {
            "ground_truth": "0",
            "bug_report": "Rest route returns response with http Status code 500 Internal Server Error when response has Last-Modified or Header-expires in header as string.\nRest route returns Response with http Status code 500 Internal Server Error and expected response headers/body when response has Last-Modified or Header-expires in header as string. I found the issue in below code it try to convert string Wed  31 Dec 1969 18:00:00 CS to Date and it fails. Is it posible to convert String Date without knowing Date format?DefaultRestletBinding======================= if (header.equalsIgnoreCase(HeaderConstants.HEADER_LAST_MODIFIED)) { if (value instanceof Calendar) { message.getEntity().setModificationDate(((Calendar) value).getTime()); } else if (value instanceof Date) { message.getEntity().setModificationDate((Date) value); } else { Date date = exchange.getContext().getTypeConverter().mandatoryConvertTo(Date.class  value); // Here it try to convert String to Date it throws No type converter available to convert from type: java.lang.String to the required type: java.util.Date with value Wed  31 Dec 1969 18:00:00 CS message.getEntity().setModificationDate(date); } }Stack trace===========7 Oct 2012 08:28:06 010 WARN org.restlet.Component.StatusFilter - Exception or error caught in status serviceorg.apache.camel.RuntimeCamelException: Cannot process request at org.apache.camel.component.restlet.RestletConsumer$1.handle(RestletConsumer.java:62) at org.apache.camel.component.restlet.MethodBasedRouter.handle(MethodBasedRouter.java:54) at org.restlet.routing.Filter.doHandle(Filter.java:159) at org.restlet.routing.Filter.handle(Filter.java:206) at org.restlet.routing.Router.doHandle(Router.java:500) at org.restlet.routing.Router.handle(Router.java:740) at org.restlet.routing.Filter.doHandle(Filter.java:159) at org.restlet.routing.Filter.handle(Filter.java:206) at org.restlet.routing.Router.doHandle(Router.java:500) at org.restlet.routing.Router.handle(Router.java:740) at org.restlet.routing.Filter.doHandle(Filter.java:159) at org.restlet.engine.application.StatusFilter.doHandle(StatusFilter.java:154) at org.restlet.routing.Filter.handle(Filter.java:206) at org.restlet.routing.Filter.doHandle(Filter.java:159) at org.restlet.routing.Filter.handle(Filter.java:206) at org.restlet.engine.ChainHelper.handle(ChainHelper.java:114) at org.restlet.Component.handle(Component.java:391) at org.restlet.Server.handle(Server.java:491) at org.restlet.engine.ServerHelper.handle(ServerHelper.java:75) at org.restlet.engine.http.HttpServerHelper.handle(HttpServerHelper.java:153) at org.restlet.ext.servlet.ServerServlet.service(ServerServlet.java:1031) at org.apache.shiro.grails.SavedRequestFilter.doFilter(SavedRequestFilter.java:56) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:360) at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:276) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:344) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:272) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:81) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:909) at java.lang.Thread.run(Thread.java:662)Caused by: org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: java.lang.String to the required type: java.util.Date with value Wed  31 Dec 1969 18:00:00 CST at org.apache.camel.impl.converter.BaseTypeConverterRegistry.mandatoryConvertTo(BaseTypeConverterRegistry.java:169)",
            "id": "5710"
        },
        "5712": {
            "ground_truth": "0",
            "bug_report": "BlueprintCamelContext should not get started in the init() method but later when the blueprint container is fully initialized\nThe init() method in BlueprintCamelContext should not call maybeStart(). but instead should be started when the blueprint container is done doing all its dance and initialization.For example Spring sends on ContextRefreshedEvent when its done.We need something similar for blueprint to tell us when its done doing its initialization et all.The problem is that the CamelContext should not be started until all that other stuff is initialized as well.",
            "id": "5712"
        },
        "5722": {
            "ground_truth": "0",
            "bug_report": "Classloader mixup when consumers across bundles share the same camel-jetty port\nHappens in an OSGi environment; but it is also applicable in modular servers that build dynamic classloaders (e.g. JBoss AS) per deployed artifacts (WAR  module  EAR  etc.).If bundles A and B are both creating camel-jetty consumers on the same TCP port  the consumers will share the underlying Jetty connector. Moreover  the Jetty connector is indeed created by the first consumer that initialises on that TCP port.Since the Camel route executes on the Jetty Connector thread  all class resolutions will happen against the classloader of the bundle that initialises first.This makes class resolution absolutely undeterministic and erratic. Quite a nasty bug IMHO.Perhaps this can be fixed by adding a call to Thread.setContextClassLoader() passing the classloader of the JettyHttpEndpoint  as soon as a request comes in?",
            "id": "5722"
        },
        "5724": {
            "ground_truth": "0",
            "bug_report": "Spring-WS consumer and producer do not propagate some custome headers and attachements to a response message\nHi!I wanted to send back as response or as a request some soap messages with modified header.I found out that SpringWebserviceProducer and SpringWebserviceConsumer do not populate a soap header for any outgoing message from a camel exchange.In the attachments I am sending you a patch against camel-spring-ws 2.10.1 that solves this issue.Please let me know  what do you think about it.Best regards Andrej",
            "id": "5724"
        },
        "5757": {
            "ground_truth": "0",
            "bug_report": "HTTP 1.1 Host header not set correctly with camel-http4\nThe HTTP 1.1 Host header is not set correctly when using the camel-http4 component as a proxy with bridgeEnpoint=true.The original request Host header is set in the proxied request instead of the host of the service requested by the proxy (ref: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html section 14.23).This simple route shows the problem: &lt;route autoStartup='true' id='TestHost' xmlns:ns2='http://camel.apache.org/schema/web' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;from uri='jetty:http://0.0.0.0:8090/TestHost'/&gt; &lt;to uri='https4://www.google.com?bridgeEndpoint=true&amp;throwExceptionOnFailure=false'/&gt; &lt;/route&gt; This is what I get in the log:INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] DefaultClientConnection DEBUG Sending request: GET / HTTP/1.1INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'GET / HTTP/1.1&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'breadcrumbId: ID-localhost-1329-1351277552803-0-2&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:15.0) Gecko/20100101 Firefox/15.0&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'Accept-Encoding: gzip  deflate&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'Host: localhost:8090&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'Accept: text/html application/xhtml+xml application/xml;q=0.9 /;q=0.8&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'Accept-Language: en-us en;q=0.5&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; 'Connection: Keep-Alive&#91;/r&#93;&#91;/n&#93;'INFO | jvm 1 | 2012/10/26 14:52:48 | [ qtp31541880-35 - /TestHost] wire DEBUG &gt;&gt; '&#91;/r&#93;&#91;/n&#93;'",
            "id": "5757"
        },
        "5761": {
            "ground_truth": "0",
            "bug_report": "Update SqsConsumer to extend Visibility Timeout correctly\nCurrently SqsConsumer will scheduled a future to happen start occruing 1/2 the visibility timeout  and reoccur again at the visibility timeout period. Because of the way SQS works  when you request a ChangeMessageVisibility timeout it does not add that to the time remaining on the message visibility. Instead it will set the message visibility to the time out given. This means that what actually happens in the camel code is that: we request the ChangeMessageVisibility timeout to be set to X seconds from now after X/2 seconds then every X seconds after that we we request the ChangeMessageVisibility timeout to be set to X from nowThis means that our message will become visible every now and again as the ChangeMessageVisibility timeout is not updated in time as period between successive executions is the same as the timeout period we request.I've attached two patches which would fix this issue. 'aws_sqs_visibility_timeout_simple.patch' - This patch changes the way we set up the future. The delay and period are now the same so that we call ChangeMessageVisibility every X/2 after the message has been pulled. 'aws_sqs_visibility_timeout_phased_timeout.patch' - This one keeps the delay to 1/2 the period and requests ChangeMessageVisibility every period. This time though it requests the visibility to be 1.5 * the period. This means that it behaves as originally planned  as if it was adding duration to the visibility duration left. This means we call Amazon less times and still keep the message hidden as expected.This was looked at with Alex Hutter (both working on same project).",
            "id": "5761"
        },
        "5766": {
            "ground_truth": "0",
            "bug_report": "Configuring jetty component with a different name dont work with jetty consumer\nFor example if you do &lt;route&gt; &lt;from uri='jetty2:http://localhost:9090/myapp'/&gt; &lt;transform&gt; &lt;simple&gt;Hello ${body}&lt;/simple&gt; &lt;/transform&gt; &lt;/route&gt;Then it fails withjava.net.SocketException: Unresolved address at sun.nio.ch.Net.translateToSocketException(Net.java:58) at sun.nio.ch.Net.translateException(Net.java:84) at sun.nio.ch.Net.translateException(Net.java:90) at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:61) at org.eclipse.jetty.server.nio.SelectChannelConnector.open(SelectChannelConnector.java:187) at org.eclipse.jetty.server.AbstractConnector.doStart(AbstractConnector.java:316) at org.eclipse.jetty.server.nio.SelectChannelConnector.doStart(SelectChannelConnector.java:265) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.Server.doStart(Server.java:286) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.apache.camel.component.jetty.JettyHttpComponent.connect(JettyHttpComponent.java:315) at org.apache.camel.component.http.HttpEndpoint.connect(HttpEndpoint.java:149) at org.apache.camel.component.http.HttpConsumer.doStart(HttpConsumer.java:56) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60)...",
            "id": "5766"
        },
        "5767": {
            "ground_truth": "0",
            "bug_report": "Camel Splitter eat up exceptions recorded by the underlying Scanner\nSee http://camel.465427.n5.nabble.com/Trouble-with-split-tokenize-on-linux-td5721677.html for details",
            "id": "5767"
        },
        "5769": {
            "ground_truth": "1",
            "bug_report": "Camel JMS producer can block a thread under specific circumstances\nThis is an edge case  but when the following circumstances concur  the asynchronous routing engine in Camel become blocked: Sending an InOut exchange over JMS (request/reply)  where: Persistent messages are enabled (deliveryPersistent=true) useMessageIDasCorrelationID is enabled replyToType is Temporary queues (default) (using TemporaryQueueReplyManager) a timeout is setYou have to be really unlucky  but if the following condition is satisfied  a thread will become blocked:time the broker takes to ACK the produced message &gt; message timeoutHence  if we have a timeout of 3000ms  and the broker takes 4000ms to ACK the message (e.g. slow Disk I/O while the journal is rotating - it happened to us)  at some point we'll see this.2012-10-30 10:46:57 680 | WARN | CorrelationMap | 89 - org.apache.camel.camel-core - 2.8.0.fuse-06-11 | Exception occurred during purge task. This exception will be ignored.java.lang.NullPointerExceptionThe CorrelationMap is rendered useless  so if subsequent exchanges time out  the ReplyHandler may never get an onTimeout callback  thus leading to the waiting thread getting blocked forever if the async routing engine was in place.",
            "id": "5769"
        },
        "5770": {
            "ground_truth": "0",
            "bug_report": "RoutePolicySupport should provide some easy to use utility methods to suspend/resume routes as we have it already to start/stop routes\nRoutePolicySupport should provide some easy to use utility methods to suspend/resume routes as we have it already to start/stop routes",
            "id": "5770"
        },
        "5774": {
            "ground_truth": "0",
            "bug_report": "ActiveMQ target endpoint with transferExchange=true does not work together with source File endpoint with preMove option set\nGot failure on a simple route reading from file and sending to ActiveMQ queue.On source File endpoint set preMove option to some folder  and on target activemq endpoint set transferExchange=true.It fails with FileNotFound exception  trying to read file from original location  not from temporary preMoved one.Without preMove all works perfect.Simplified Spring application context with Camel routes looks like this:&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;beans xmlns='http://www.springframework.org/schema/beans' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation=' http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd'&gt; &lt;bean id='brokerService' class='org.apache.activemq.broker.BrokerService' init-method='start' destroy-method='stop'&gt; &lt;property name='brokerName' value='localhost' /&gt; &lt;property name='useJmx' value='false' /&gt; &lt;property name='transportConnectorURIs'&gt; &lt;list&gt; &lt;value&gt;vm://localhost&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id='jmsConnectionFactory' class='org.apache.activemq.ActiveMQConnectionFactory' depends-on='brokerService'&gt; &lt;property name='brokerURL' value='vm://localhost'/&gt; &lt;property name='redeliveryPolicy' ref='redeliveryPolicyConfigActiveMQ'/&gt; &lt;/bean&gt; &lt;bean id='pooledConnectionFactory' class='org.apache.activemq.pool.PooledConnectionFactory' init-method='start' destroy-method='stop'&gt; &lt;property name='maxConnections' value='8' /&gt; &lt;property name='maximumActive' value='500' /&gt; &lt;property name='connectionFactory' ref='jmsConnectionFactory' /&gt; &lt;/bean&gt; &lt;bean id='redeliveryPolicyConfigActiveMQ' class='org.apache.activemq.RedeliveryPolicy'&gt; &lt;property name='maximumRedeliveries' value='1'/&gt; &lt;property name='redeliveryDelay' value='5000'/&gt; &lt;/bean&gt; &lt;camelContext id='testCustomer' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;endpoint id='sourceEndpoint' uri='file:e:/work/ids/testCustomer/input/?preMove=.tmp&amp;delay=1000&amp;readLock=rename&amp;copyAndDeleteOnRenameFail=false&amp;move=.archive&amp;moveFailed=.failed' /&gt; &lt;endpoint id='destJms' uri='activemq:queue:source?transferExchange=true&amp;connectionFactory=#pooledConnectionFactory' /&gt; &lt;route id='testRoute'&gt; &lt;from ref='sourceEndpoint' /&gt; &lt;to ref='destJms' /&gt; &lt;/route&gt; &lt;/camelContext&gt;&lt;/beans&gt;Exception trace:org.apache.camel.TypeConversionException: Error during type conversion from type: java.io.File to the required type: byte[] with value e:/work/ids/testCustomer/input/payment.xml due java.io.FileNotFoundException: e:/work/ids/testCustomer/input/payment.xml (The system cannot find the file specified) at com.it.ids.exceptions.HandleException.process(HandleException.java:20) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:117) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.FatalFallbackErrorHandler.processNext(FatalFallbackErrorHandler.java:42) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.deliverToFailureProcessor(RedeliveryErrorHandler.java:766) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:273) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:336) at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:189) at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:155) at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:142) at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:92) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:204) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662)Caused by: org.apache.camel.RuntimeCamelException: java.io.FileNotFoundException: e:/work/ids/testCustomer/input/payment.xml (The system cannot find the file specified) at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1270) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:926) at org.apache.camel.impl.converter.StaticMethodTypeConverter.convertTo(StaticMethodTypeConverter.java:47) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:253) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.mandatoryConvertTo(BaseTypeConverterRegistry.java:155) at org.apache.camel.component.file.FileBinding.loadContent(FileBinding.java:57) at org.apache.camel.component.file.GenericFileConverter.genericFileToInputStream(GenericFileConverter.java:123) at org.apache.camel.component.file.GenericFileConverter.genericFileToSerializable(GenericFileConverter.java:152) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:922) at org.apache.camel.impl.converter.StaticMethodTypeConverter.convertTo(StaticMethodTypeConverter.java:47) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:253) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:111) at org.apache.camel.impl.DefaultExchangeHolder.checkMapSerializableObjects(DefaultExchangeHolder.java:209) at org.apache.camel.impl.DefaultExchangeHolder.safeSetProperties(DefaultExchangeHolder.java:177) at org.apache.camel.impl.DefaultExchangeHolder.marshal(DefaultExchangeHolder.java:93) at org.apache.camel.impl.DefaultExchangeHolder.marshal(DefaultExchangeHolder.java:71) at org.apache.camel.component.jms.JmsBinding.createJmsMessage(JmsBinding.java:439) at org.apache.camel.component.jms.JmsBinding.makeJmsMessage(JmsBinding.java:287) at org.apache.camel.component.jms.JmsProducer$2.createMessage(JmsProducer.java:266) at org.apache.camel.component.jms.JmsConfiguration$CamelJmsTemplate.doSendToDestination(JmsConfiguration.java:215) at org.apache.camel.component.jms.JmsConfiguration$CamelJmsTemplate.access$100(JmsConfiguration.java:158) at org.apache.camel.component.jms.JmsConfiguration$CamelJmsTemplate$3.doInJms(JmsConfiguration.java:192) at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:466) at org.apache.camel.component.jms.JmsConfiguration$CamelJmsTemplate.send(JmsConfiguration.java:189) at org.apache.camel.component.jms.JmsProducer.doSend(JmsProducer.java:398) at org.apache.camel.component.jms.JmsProducer.processInOnly(JmsProducer.java:352) at org.apache.camel.component.jms.JmsProducer.process(JmsProducer.java:132) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:122) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:298) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) ... 28 moreCaused by: java.io.FileNotFoundException: e:/work/ids/testCustomer/input/payment.xml (The system cannot find the file specified) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at org.apache.camel.converter.IOConverter.toInputStream(IOConverter.java:73) at org.apache.camel.converter.IOConverter.toByteArray(IOConverter.java:243) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:922) ... 71 more",
            "id": "5774"
        },
        "5781": {
            "ground_truth": "0",
            "bug_report": "limitaions on s3 component. no means to specify acl on created object. objects do not inherit acl from the bucket they belong to.\nWhen using s3 component to create new object on amazon bucket  there is no means to specify acl that will be applied to this newly created object. s3 objects do not inherit acl applied to the bucket they belong to. in s3 camel component (enpoint) we can specify bucket policy but not objects acl.the limitation is in s3producer.there is an attachment file (patch) to fix this quickly and whith little modifications to the existing code. but i think that we need to enhance the design of this component to be more flexible and rely on strategy that executes requests to interact with s3.for now there is no tests for s3producer in camel-aws thus i don't supply a unit test.if we enhance the design we can change or improve this layer with less effort. and we can do tests obviously.",
            "id": "5781"
        },
        "5782": {
            "ground_truth": "0",
            "bug_report": "regression : invalid SetQueueAttributesRequest created  works on 2.10.1\nIn org.apache.camel.component.aws.sqs.SqsEndpoint.updateQueueAttributes if I don't have any configuration  the created SetQueueAttributesRequest contains a null atttribute collection and AWS emit an error.In 2.10.1  no problem.Workaround in 2.10.2 : force the create SetQueueAttributesRequest to contain a valid attribute collection by defining a configuration in camel. For exemple: from('aws-sqs://'queue'?amazonSQSClient=#amazonSQSClient&amp;delay='pollCycle.getMillis()'&amp;maxMessagesPerPoll=10&amp;deleteAfterRead=false')  -&gt; works on 2.10.1  fail on 2.10.2if I add an argument to my URI'&amp;defaultVisibilityTimeout=30'  -&gt; works on 2.10.1  works on 2.10.2Exception : {{Caused by: org.apache.camel.FailedToCreateRouteException: Failed to create route SQS-to-MongoDB-EVENTS: Route[[From[aws-sqs://EVENTS?amazonSQSClient=#amazonSQSClien... because of Failed to resolve endpoint: aws-sqs://EVENTS?amazonSQSClient=%23amazonSQSClient&amp;delay=60000&amp;deleteAfterRead=false&amp;maxMessagesPerPoll=10 due to: The request must contain the parameter Attribute.Name. at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:176) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:722) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1789) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1575) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1444) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1412) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at com.netceler.iv5measure.contract.impl.sqs.CamelRoutesLauncher.start(CamelRoutesLauncher.java:55) ~&#91;webapp-0.1.2-SNAPSHOT.jar:0.1.2-SNAPSHOT&#93; at com.netceler.iv5measure.contract.impl.config.ConfiguredStreamInitializer.startStreams(ConfiguredStreamInitializer.java:39) ~&#91;webapp-0.1.2-SNAPSHOT.jar:0.1.2-SNAPSHOT&#93; ... 58 common frames omittedCaused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: aws-sqs://EVENTS?amazonSQSClient=%23amazonSQSClient&amp;delay=60000&amp;deleteAfterRead=false&amp;maxMessagesPerPoll=10 due to: The request must contain the parameter Attribute.Name. at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:479) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:50) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:186) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:114) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:90) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:851) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:171) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; ... 66 common frames omittedCaused by: com.amazonaws.AmazonServiceException: The request must contain the parameter Attribute.Name. at com.amazonaws.http.AmazonHttpClient.handleErrorResponse(AmazonHttpClient.java:614) ~&#91;aws-java-sdk-1.3.23.jar:na&#93; at com.amazonaws.http.AmazonHttpClient.executeHelper(AmazonHttpClient.java:312) ~&#91;aws-java-sdk-1.3.23.jar:na&#93; at com.amazonaws.http.AmazonHttpClient.execute(AmazonHttpClient.java:165) ~&#91;aws-java-sdk-1.3.23.jar:na&#93; at com.amazonaws.services.sqs.AmazonSQSClient.invoke(AmazonSQSClient.java:812) ~&#91;aws-java-sdk-1.3.23.jar:na&#93; at com.amazonaws.services.sqs.AmazonSQSClient.setQueueAttributes(AmazonSQSClient.java:246) ~&#91;aws-java-sdk-1.3.23.jar:na&#93; at com.netceler.infra.aws.sqs.JMXSQS.setQueueAttributes(JMXSQS.java:108) ~&#91;infra-sqs-0.0.3-SNAPSHOT.jar:0.0.3-SNAPSHOT&#93; at com.netceler.infra.aws.sqs.AmazonSQSClientProxy.setQueueAttributes(AmazonSQSClientProxy.java:63) ~&#91;infra-sqs-0.0.3-SNAPSHOT.jar:0.0.3-SNAPSHOT&#93; at org.apache.camel.component.aws.sqs.SqsEndpoint.updateQueueAttributes(SqsEndpoint.java:139) ~&#91;camel-aws-2.10.2.jar:2.10.2&#93; at org.apache.camel.component.aws.sqs.SqsEndpoint.doStart(SqsEndpoint.java:93) ~&#91;camel-aws-2.10.2.jar:2.10.2&#93; at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.startService(DefaultCamelContext.java:1763) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.doAddService(DefaultCamelContext.java:931) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.addService(DefaultCamelContext.java:892) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:475) ~&#91;camel-core-2.10.2.jar:2.10.2&#93; ... 74 common frames omitted}}",
            "id": "5782"
        },
        "5783": {
            "ground_truth": "0",
            "bug_report": "option to add bundle directives in the generated test bundles by camel-test-blueprint\nThe generated test bundle by camel-test-blueprint has the plain test class name as the bundle symbolic name in its manifest.Some test cases may require bundle directives to be added to the bundle symbolic name entry in the manifest.One such test case is for disabling xml validation.To support such blueprint test cases  I would like to add an option in CamelBlueprintTestSupport to customize the bundle directives.",
            "id": "5783"
        },
        "5791": {
            "ground_truth": "0",
            "bug_report": "Adding blueprint based camel-cxf tests using camel-test-blueprint\nAdding some blueprint scenario tests for camel-cxf using camel-test-blueprint.I put this in a separate test-only component under the tests folder. I can't put the test classes directly within camel-cxf because of the way how the bundle context is generated  namely the jars on the classpath are scanned and added to the context. Hence  the tests are in a separate component that refer to all the bundle jars that they need.I don't know if the tests folder is the the right location for this test component  though.",
            "id": "5791"
        },
        "5847": {
            "ground_truth": "0",
            "bug_report": "camel-mongodb - Add converters for files or inputstreams\nInserting files into MongoDB doesn't work like this:from('file:///tmp/test/apachecon?runLoggingLevel=TRACE') .to('mongodb:connectionBean?database=x&amp;collection=y&amp;operation=insert');It requires an explicit .convertBodyTo(String.class). The attached patch adds Converter}}s for File and InputStream object  detecting and supporting both {{JSON and BSON files/streams.The new String(input  'utf-8')) fragment seems a bit dodgy  but I don't really see a better way.",
            "id": "5847"
        },
        "5860": {
            "ground_truth": "1",
            "bug_report": "Regression in validator component in 2.10.3\nI get:CaughtExceptionType:java.lang.NullPointerException  CaughtExceptionMessage:null  StackTrace:java.lang.NullPointerException at org.apache.camel.converter.jaxp.XmlConverter.toStreamSource(XmlConverter.java:516) at org.apache.camel.converter.jaxp.XmlConverter.toSAXSource(XmlConverter.java:399) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:923) at org.apache.camel.impl.converter.InstanceMethodTypeConverter.convertTo(InstanceMethodTypeConverter.java:66) at org.apache.camel.support.TypeConverterSupport.convertTo(TypeConverterSupport.java:34) at org.apache.camel.processor.validation.ValidatingProcessor.getSource(ValidatingProcessor.java:343) at org.apache.camel.processor.validation.ValidatingProcessor.process(ValidatingProcessor.java:100) at org.apache.camel.impl.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:101) at org.apache.camel.impl.ProcessorEndpoint$1.process(ProcessorEndpoint.java:71) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) atorg.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:122) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:298) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) /when I upgrade camel to 2.10.3 and use the validator component:&lt;camel:to uri='validator:META-INF/xsd/transactiongatetransfertransaction.xsd' /&gt;this did not happen in 2.10.2 or versions before that.",
            "id": "5860"
        },
        "5864": {
            "ground_truth": "1",
            "bug_report": "Pre-XSLT and Validator Type Conversions from byte[] may easily fail\nXsltBuilder.getSource(Exchange e  Object o) tries to convert the payload to a Source. If you have a byte[] payload  then the following type converter will likely be picked:InstanceMethodTypeConverter: public javax.xml.transform.sax.SAXSource org.apache.camel.converter.jaxp.XmlConverter.toSAXSource(byte[] org.apache.camel.Exchange) throws java.io.IOException org.xml.sax.SAXException javax.xml.transform.TransformerExceptionThis type converter requires the Exchange (InstanceMethodTypeConverter.useExchange == true)  but line 461 of XsltBuilder doesn't pass it on.Therefore  a NullPointerException happens because the conversion method tries to access the Exchange.",
            "id": "5864"
        },
        "5880": {
            "ground_truth": "0",
            "bug_report": "camel-quickfix: QuickfixjEndpoint should adhere the InOut exchange pattern if you would ask for this MEP\nSee http://camel.465427.n5.nabble.com/camel-quickfix-RequestReplyExample-java-io-IOException-td5723769.html",
            "id": "5880"
        },
        "5881": {
            "ground_truth": "0",
            "bug_report": "FTP endpoints should support charset property like File endpoint does\nFTP endpoints should support charset property like the File endpoint does. Currently you have to remember to set the CamelCharsetName Exchange property if you want to have the message body transformed to another charset.See http://camel.465427.n5.nabble.com/Problem-w-FTP-producer-and-charset-td5723604.htmlI'll work on a patch and attach it later.",
            "id": "5881"
        },
        "5883": {
            "ground_truth": "0",
            "bug_report": "File consumer - When using done file name then delete the file when batch is complete\nWhen using doneFileName then the file is deleted on each completion of files in the batch. And you get WARN logs about the done file cannot be deleted  because the 1st already deleted the file.We should defer and only delete the done file on the last in the batch.",
            "id": "5883"
        },
        "5888": {
            "ground_truth": "1",
            "bug_report": "When call removeRouteDefinition the route doesn't removed from collection of route Definitions.\nWhen I call removeRouteDefinition for DefaultCamelContext  the route doesn't removed from collection of routes. public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception { String id = routeDefinition.idOrCreate(nodeIdFactory); stopRoute(id); removeRoute(id); }it is just remove it from running route service if context is running.When we do restart context this route started again. Workaround for this issue is call removeRouteDefinitions and wrap single route into collection.But when I call removeRouteDefinitions - it is process correctly: remove from collections of definitions and after removed from running route services. public synchronized void removeRouteDefinitions(Collection&lt;RouteDefinition&gt; routeDefinitions) throws Exception { this.routeDefinitions.removeAll(routeDefinitions); for (RouteDefinition routeDefinition : routeDefinitions) { removeRouteDefinition(routeDefinition); } }",
            "id": "5888"
        },
        "5889": {
            "ground_truth": "0",
            "bug_report": "Scala DSL: no tokenize('...') method\nThis is related to issue https://issues.apache.org/jira/browse/CAMEL-5803It looks like the fix included tokenizeXML() method  but there is still not tokenize()  I have a usecase where I have to split my in message body (text) by semi-colon character for downstream processing  so I need to be able to do something like the following in Scala DSL:split(_.in) tokenize(';')I fix would be very welcome  also  if there is a work around with TokenizeLanguage etc - please let me know  thank you!",
            "id": "5889"
        },
        "5890": {
            "ground_truth": "1",
            "bug_report": "NPE when jaxb fallback converter is used with RequestEntityConverter\nAs the RequestEntityConverter.toRequestEntity(String str  Exchange exchange) doesn't has check if the exchange is null  it caused the NPE as the user complain in camel user mailing list&#91;1&#93;&#91;1&#93;http://camel.465427.n5.nabble.com/Content-Enrich-Error-when-upgrading-Apache-Camel-from-2-9-2-to-any-higher-version-td5724244.htmlHere is the stack trace.CaughtExceptionType:org.apache.camel.TypeConversionException  CaughtExceptionMessage:Error during type conversion from type: com.ecc.DamBean to the required type: org.apache.commons.httpclient.methods.RequestEntity with value com.ecc.DamBean@8811a59 due Error during type conversion from type: java.lang.String to the required type: org.apache.commons.httpclient.methods.RequestEntity with value ... The complete Stack Trace : Exchange[ExchangePattern:InOnly  BodyType:String  Body:  CaughtExceptionType:org.apache.camel.TypeConversionException  CaughtExceptionMessage:Error during type conversion from type: com.ecc.DamBean to the required type: org.apache.commons.httpclient.methods.RequestEntity with value com.ecc.DamBean@8811a59 due Error during type conversion from type: java.lang.String to the required type: org.apache.commons.httpclient.methods.RequestEntity with value due java.lang.NullPointerException  StackTrace:org.apache.camel.TypeConversionException: Error during type conversion from type: com.ecc.DamBean to the required type: org.apache.commons.httpclient.methods.RequestEntity with value com.ecc.DamBean@8811a59 due Error during type conversion from type: java.lang.String to the required type: org.apache.commons.httpclient.methods.RequestEntity with value due java.lang.NullPointerException at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:98) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:289) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:111) at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:72) at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:47) at org.apache.camel.component.http.HttpProducer.createRequestEntity(HttpProducer.java:390) at org.apache.camel.component.http.HttpProducer.createMethod(HttpProducer.java:343) at org.apache.camel.component.http.HttpProducer.process(HttpProducer.java:91) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Enricher.process(Enricher.java:114) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:61) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:148) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:61) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:57) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:275) at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:185) at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:139) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:909) at java.lang.Thread.run(Thread.java:662)Caused by: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: org.apache.commons.httpclient.methods.RequestEntity with value due java.lang.NullPointerException at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:126) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:98) at org.apache.camel.converter.jaxb.FallbackTypeConverter.marshall(FallbackTypeConverter.java:222) at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:94) ... 44 moreCaused by: org.apache.camel.RuntimeCamelException: java.lang.NullPointerException at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1271) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:927) at org.apache.camel.impl.converter.StaticMethodTypeConverter.convertTo(StaticMethodTypeConverter.java:47) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:253) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:111) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:98) at org.apache.camel.converter.jaxb.FallbackTypeConverter.marshall(FallbackTypeConverter.java:222) at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:94) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:289) at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:111) at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:72) at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:47) at org.apache.camel.component.http.HttpProducer.createRequestEntity(HttpProducer.java:390) at org.apache.camel.component.http.HttpProducer.createMethod(HttpProducer.java:343) at org.apache.camel.component.http.HttpProducer.process(HttpProducer.java:91) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Enricher.process(Enricher.java:114) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:117) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:275) at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:183) at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:139) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) ... 1 moreCaused by: java.lang.NullPointerException at org.apache.camel.component.http.RequestEntityConverter.toRequestEntity(RequestEntityConverter.java:51) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:923) ... 50 more]",
            "id": "5890"
        },
        "5899": {
            "ground_truth": "0",
            "bug_report": "camel-netty - Producer should avoid blocking while waiting for connection\nWe should at most wait for the connection timeout to trigger.",
            "id": "5899"
        },
        "5917": {
            "ground_truth": "0",
            "bug_report": "camel-jms - JmsPollingConsumer use the constant fields from JmsTemplate for receiveNoWait etc\nSee nabblehttp://camel.465427.n5.nabble.com/JmsPollingConsumer-and-method-receiveNoWait-has-incorrect-timeout-value-tp5722817.html",
            "id": "5917"
        },
        "5926": {
            "ground_truth": "0",
            "bug_report": "SpringIntegrationConsumer should honor the 'inOut' instance variable by setting the MEP and sending back message headers\nSee http://camel.465427.n5.nabble.com/how-to-obtain-camel-smpp-submit-message-id-td5723868.html for details",
            "id": "5926"
        },
        "5928": {
            "ground_truth": "0",
            "bug_report": "SJMS component's pom.xml missing taskmanager package in camel.osgi.private.pkg\nHi I know it's not out in the wild yet but with this tiny patch SJMS is usable in my spike project.Sadly doesn't affect the number of passing/failing tests.The pom's &lt;camel.osgi.private.pkg&gt; section is missing an entry for the org.apache.camel.component.sjms.taskmanager package.thanks Caspar",
            "id": "5928"
        },
        "5950": {
            "ground_truth": "0",
            "bug_report": "Cache producer is not thread safe\nfrom('direct:causeFailure') .split().body().parallelProcessing() .setHeader(CacheConstants.CACHE_OPERATION  constant(CacheConstants.CACHE_OPERATION_DELETEALL)) .to('cache://MyTestCache');  String[] body = new String[] { 'a'  'b' }; template.sendBody(body); net.sf.ehcache.ObjectExistsException: Cache MyTestCache already exists at net.sf.ehcache.CacheManager.addCacheNoCheck(CacheManager.java:1294) at net.sf.ehcache.CacheManager.addCache(CacheManager.java:1184) at org.apache.camel.component.cache.CacheEndpoint.initializeCache(CacheEndpoint.java:137) at org.apache.camel.component.cache.CacheProducer.process(CacheProducer.java:56) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:122) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:298) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:303) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:45) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:99) at org.apache.camel.processor.MulticastProcessor.doProcessParallel(MulticastProcessor.java:709) at org.apache.camel.processor.MulticastProcessor.access$200(MulticastProcessor.java:80) at org.apache.camel.processor.MulticastProcessor$1.call(MulticastProcessor.java:290) at org.apache.camel.processor.MulticastProcessor$1.call(MulticastProcessor.java:275) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) at java.util.concurrent.FutureTask.run(FutureTask.java:166) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) at java.lang.Thread.run(Thread.java:722)",
            "id": "5950"
        },
        "5959": {
            "ground_truth": "0",
            "bug_report": "Dead Letter Channel - Store failed route id on Exchange\nSeehttp://camel.465427.n5.nabble.com/Retrieve-failed-Route-from-deadLetterChannel-tp5725420.htmlWe should store the route id where we failed  this allows end users to get that as a detail if they route to another route as part of DLC. You can get the current route  but if you let DLC be a route  then its that route you get  and not the route that failed.So we need to store this as part of the RedeliveryErrorHandler logic inside camel-core.We do have failed endpoint store already. eg if it failed sending a message to an endpoint. But we lack the route id.",
            "id": "5959"
        },
        "5968": {
            "ground_truth": "0",
            "bug_report": "ClassNotFoundException: weblogic.jndi.WLInitialContextFactory when starting the route via Karaf start-route(camel:route-start) command.\nWe have a simple camel route definied in Java DSL:from('wmq:queue:ESB_TEST_IN').routeId('IN').autoStartup(true).log('${body}');This route receives JMS messages from a WebLogicJMS queue with name ESB_TEST_IN and logs the body to the log file.The route works fine when autoStartup is set to true. But when autoStartup is set to false then the creation of the WebLogic InitialContext failed because of an ClassNotFoundException regarding weblogic.jndi.WLInitialContextFactory and the following message is written to the karaf log file:2012-12-07 12:03:21 502 WARN : DefaultJmsMessageListenerContainer | Setup of JMS message listener invoker failed for destination 'ESB_TEST_IN' - trying to recover. Cause: Destination &#91;ESB_TEST_IN&#93; not found in JNDI; nested exception is javax.naming.NoInitialContextException: Cannot instantiate class: weblogic.jndi.WLInitialContextFactory &#91;Root exception is java.lang.ClassNotFoundException: weblogic.jndi.WLInitialContextFactory&#93; [org.springframework.jms.listener.DefaultMessageListenerContainer | mer&#91;ESB_TEST_IN&#93; | org.springframework.jms.3.0.7.RELEASE(id=135)]This issue's related to https://jira.talendforge.org/browse/TESB-7884",
            "id": "5968"
        },
        "5969": {
            "ground_truth": "0",
            "bug_report": "OsgiServiceRegistry to lookup services with filter on name=blah\nOsgiServiceRegistry to lookup services with filter on name=blahWhen using the # bean resolver prefix in plain OSGi (not blueprint) the only way to lookup a service is by specifying the full registered class/interface name of that service.The OsgiServiceRegistry should also try and lookup a service like the OsgiComponentResolver does using a filter on a service property. I suggest that the filter be on a property called 'name'.This means the method public &lt;T&gt; T lookup(String name  Class&lt;T&gt; type) should try to lookup the service with the class from the type parameter and filter on '(name=' + name ')'...",
            "id": "5969"
        },
        "5987": {
            "ground_truth": "0",
            "bug_report": "Using annotations DSL in beans may cause async callback to be called twice\nThe bean processor and bean invocation logic may in cases when the EIP annotations is used on beans  cause the callback to be called twice.Noticed this problem during investigation of See CAMEL-5905",
            "id": "5987"
        },
        "5994": {
            "ground_truth": "0",
            "bug_report": "CamelJob implementation rely on some inconsistent endpoints LRU cache - Camel endpoints may not be called on quartz fire after some days of uptime\nCamelJobs rely on some endpoints LRU cache from camel context. If i'm not wrong  since LRU Cache relies on SoftReferences  Garbage Collector can decide to evict some entries and especially QuartzEndpoints.It happens that sometimes endpoints evicted from LRU Caches are QuartzEndpoints. Since QuartzEnpoints are searched from CamelJob in LRU cache  they are not reachable anymore.The side effect  is that CamelJob isntance initializes a new QuartzEndpoint  but loadbalancer is not initialized since it is initialized from QuartzConsumer.The result is that quartz triggers jobs that instanciate Quartz endpoints with unintialized load balancers which are unable to call processor from the routes associated.I have joined a fix that rely on the search of QuartzEndpoints from initalized routes of Camel context.Fundamentally  the search of endpoints should not rely on endpoints LRU cache. It is a broken design.Hope it helps.By the way  there are other issues related to QuartzEndpoint load balancer initalization: If quartz starts before startup of Camel routes you will have the same issue: Correctly initialized QuartzEndpoints are not in LRU cache since Camel has not started routes (and so endpoints and consumers). Quartz will trigger job  and camel job will search for QuartzEndpoint and put it in LRUCache with uninitialized load balancer.",
            "id": "5994"
        },
        "5999": {
            "ground_truth": "0",
            "bug_report": "RestletComponent component is not removing added route from routers list although route is removed from Context.\nIn RestletComponent class add entry to instance variable 'private final Map&lt;String  MethodBasedRouter&gt; routers = new HashMap&lt;String  MethodBasedRouter&gt;()' map while invoking getMethodRouter method  but it never remove in disconnect method  also disconnect method has local variable with same name as instance variable 'routes'.Camel Development Forums=========================http://camel.465427.n5.nabble.com/Camel-Restlet-2-10-3-RestletComponent-component-does-not-remove-added-route-form-routers-although-ro-td5726000.html",
            "id": "5999"
        },
        "6019": {
            "ground_truth": "1",
            "bug_report": "Add PGP signature and signature verification support to PGPDataFormat\nPGPDataFormat currently supports PGP encryption (equivalent to 'gpg -e') and decryption (equivalent to 'gpg -d')  but does not support simultaneously encrypting and signing (equivalent to 'gpg -e -s') or simultaneously decrypting and verifying (equivalent to 'gpg -v -d').This patch adds three new optional attributes to the PGPDataFormat class (signatureKeyUserid  signatureKeyFileName  signaturePassword)  which can be used to sign while encrypting  or to verify a signature while decrypting.",
            "id": "6019"
        },
        "6033": {
            "ground_truth": "0",
            "bug_report": "NoRedeliveryOnShutdown doesn't work for DeadLetterChannel\nSee http://camel.465427.n5.nabble.com/Wrong-test-for-allowRedeliveryWhileStopping-possible-bug-td5726184.html for details.The assumption is if we use 'allowRedeliveryWhileStopping(false)' in an error handler definition which use a dead letter channel  the message should be send to the configured dead letter channel if we are in a delivery by stopping Camel (instead of dropping the message).",
            "id": "6033"
        },
        "6039": {
            "ground_truth": "0",
            "bug_report": "camel-bindy fixed length record improvements\nThe attached patch provides the following improvements for the camel-bindy fixed length record data format: full support for fixed-length header and footer records allows delimited (variable length) fields to be defined within 'fixed-length' records enables the length of a data field to be defined dynamically by another field in the same record fixed-length records can be defined using ordinal / relative pos valuesNew annotation properties:------------------@DataField + lengthPos (int) &#8211; Optionally identifies a data field in the record that defines the fixed length for this field + delimiter (String) &#8211; Optional delimiter to be used if this field has a variable length@FixedLengthRecord + hasHeader (boolean) &#8211; Indicates that the record(s) of this type may be preceded by a single header record at the beginning of the file / stream + hasFooter (boolean) &#8211; Indicates that the record(s) of this type may be followed by a single footer record at the end of the file / stream + skipHeader (boolean) &#8211; Configures the data format to skip marshalling / unmarshalling of the header record + skipFooter (boolean) &#8211; Configures the data format to skip marshalling / unmarshalling of the footer record + isHeader (boolean) &#8211; Identifies this FixedLengthRecord as a header record + isFooter (boolean) &#8211; Identifies this FixedLengthRecord as a footer record",
            "id": "6039"
        },
        "6043": {
            "ground_truth": "0",
            "bug_report": "Improve the BeanInfo performance\nSee http://camel.465427.n5.nabble.com/BeanInfo-performance-issues-td5726912.html for details.",
            "id": "6043"
        },
        "6045": {
            "ground_truth": "0",
            "bug_report": "Camel Email Component Missing Attachments\nsee http://camel.465427.n5.nabble.com/Camel-Email-Component-Missing-Attachments-td3386382.html#a5727102The disposition field is optional(see RFC 2183)  so it is possible that camel misses attachments. if (disposition != null &amp;&amp; (disposition.equalsIgnoreCase(Part.ATTACHMENT) || disposition.equalsIgnoreCase(Part.INLINE))) { // only add named attachments String fileName = part.getFileName(); if (fileName != null) { LOG.debug('Mail contains file attachment: ' + fileName); // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments CollectionHelper.appendValue(map  fileName  part.getDataHandler()); } }Adding the fileName check to the if should resolve the issue.",
            "id": "6045"
        },
        "6057": {
            "ground_truth": "0",
            "bug_report": "Camel Spring registry does not look into parent contexts\ntrunk components/camel-spring/src/main/java/org/apache/camel/spring/spi/ApplicationContextRegistry.javahas next method: @Override public &lt;T&gt; Map&lt;String  T&gt; findByTypeWithName(Class&lt;T&gt; type) { return applicationContext.getBeansOfType(type); }but this method does not look into application context parent contexts.org.springframework.beans.factory.BeanFactoryUtils#beansOfTypeIncludingAncestors should be used instead.",
            "id": "6057"
        },
        "6059": {
            "ground_truth": "0",
            "bug_report": "camel-rss and camel-atom - Not installable in Karaf\nkaraf@root&gt; features:install camel-rssError executing command: Manifest not present in the first entry of the zip mvn:org.apache.ws.commons.axiom/axiom-impl/1.2.14I think we got a JAR that is flawed 1.2.14",
            "id": "6059"
        },
        "6063": {
            "ground_truth": "0",
            "bug_report": "Check if body is a MimeMessage and send it directly without create a MimeMessage from body and headers\nIn a route with a component which create a MimeMessage and set it in body  the mail producer ignores the type of body and create his own MimeMessage from body content and headers.The patch add the control of type and disable the override of MailProducer with his own message.The MimeMessage contained in body is sent directly.Patch contains test and fix",
            "id": "6063"
        },
        "6068": {
            "ground_truth": "0",
            "bug_report": "CamelBlueprintContext may be wrongly started and this may lead to a deadlock\nWe observed a deadlock situation that seems to be caused by the change that came in with CAMEL-5712  which changed the way how CamelBlueprintContext is started to solve another issue.The current code listens to the service registered event for org.osgi....BlueprintContainer (supposedly for its associated BP container) and decides to start itself if not started. From the description of the ticket  this change was intended to make sure the starting of the context occurs after its BP container is registered. In that case  should it be checking whether the received event belongs to the same bundle? This checking is missing in the current code and consequently  it may wrongly react to the event from another bundle's container registration event. When this happens under some specific timing situation  it may also lead to a deadlock.So  should we be checking the event source in CamelBlueprintContext's serviceChanged method?Regards  akiStack trace from 2.10.3========================================================================Name: Blueprint Extender: 3State: BLOCKED on java.lang.Object@9064b42 owned by: Blueprint Extender: 2Total blocked: 13 Total waited: 38Stack trace: org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:212)org.apache.aries.blueprint.container.BlueprintRepository.createInstance(BlueprintRepository.java:198)org.apache.aries.blueprint.container.BlueprintRepository.create(BlueprintRepository.java:137)org.apache.aries.blueprint.container.BlueprintContainerImpl.getComponentInstance(BlueprintContainerImpl.java:709)org.apache.camel.blueprint.BlueprintContainerRegistry.lookup(BlueprintContainerRegistry.java:41)org.apache.camel.impl.CompositeRegistry.lookup(CompositeRegistry.java:68)org.apache.camel.impl.PropertyPlaceholderDelegateRegistry.lookup(PropertyPlaceholderDelegateRegistry.java:49)org.apache.camel.blueprint.BlueprintComponentResolver.resolveComponent(BlueprintComponentResolver.java:39)org.apache.camel.impl.DefaultCamelContext.getComponent(DefaultCamelContext.java:314) locked java.util.HashMap@1660de94org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:456)org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:50)org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:186)org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108)org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:114)org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72)org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:90)org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:851)org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:171)org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:722)org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1789)org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1575)org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1444) locked org.apache.camel.blueprint.BlueprintCamelContext@5011bafaorg.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60)org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1412)org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:127)org.apache.camel.blueprint.BlueprintCamelContext.serviceChanged(BlueprintCamelContext.java:96)org.eclipse.osgi.internal.serviceregistry.FilteredServiceListener.serviceChanged(FilteredServiceListener.java:104)org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:861)org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEventPrivileged(ServiceRegistry.java:819)org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEvent(ServiceRegistry.java:771)org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.register(ServiceRegistrationImpl.java:130)org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.registerService(ServiceRegistry.java:214)org.eclipse.osgi.framework.internal.core.BundleContextImpl.registerService(BundleContextImpl.java:433)org.apache.aries.blueprint.container.BlueprintContainerImpl.registerService(BlueprintContainerImpl.java:410)org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:346)org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:230) locked java.util.concurrent.atomic.AtomicBoolean@3cb3ada locked java.util.concurrent.atomic.AtomicBoolean@31b4d206java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)java.util.concurrent.FutureTask.run(FutureTask.java:138)java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:98)java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:206)java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)java.lang.Thread.run(Thread.java:722)========================================================================Name: Blueprint Extender: 2State: BLOCKED onorg.apache.camel.blueprint.BlueprintCamelContext@5011bafa owned by: Blueprint Extender: 3Total blocked: 24 Total waited: 58Stack trace: org.apache.camel.impl.DefaultCamelContext.getTypeConverter(DefaultCamelContext.java:1053)org.apache.camel.util.EndpointHelper.setProperties(EndpointHelper.java:249)org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:222)org.apache.camel.component.file.GenericFileComponent.createEndpoint(GenericFileComponent.java:64)org.apache.camel.component.file.GenericFileComponent.createEndpoint(GenericFileComponent.java:36)org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:91)org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:461)org.apache.camel.core.xml.AbstractCamelEndpointFactoryBean.getObject(AbstractCamelEndpointFactoryBean.java:46)sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)java.lang.reflect.Method.invoke(Method.java:597)org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:226)org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:824)org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:234)org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:706)org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:64) locked java.lang.Object@9064b42org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:219) locked java.lang.Object@9064b42org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:147)org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:631)org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:337)org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:230) locked java.util.concurrent.atomic.AtomicBoolean@53b00227 locked java.util.concurrent.atomic.AtomicBoolean@5648a168java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)java.util.concurrent.FutureTask.run(FutureTask.java:138)java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:98)java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:206)java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)java.lang.Thread.run(Thread.java:722)",
            "id": "6068"
        },
        "6084": {
            "ground_truth": "0",
            "bug_report": "SOAP over JMS does not work with camel-cxf endpoint\nIf we would like to use SOAP over JMS using CXF &amp; Camel (2.10) that fails.The CXF endpoint receives well the incoming request from the JMS queue[aultMessageListenerContainer-1] HelloWorldServicePortType INFO Inbound Message----------------------------ID: 1Content-Type: text/xmlHeaders: {JMSMessageType=[text]}Payload: &lt;soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/' xmlns:hel='http://helloworld.mycompany.redhat.com'&gt; &lt;soapenv:Header/&gt; &lt;soapenv:Body&gt; &lt;hel:sayHello&gt; &lt;hel:name&gt;fred&lt;/hel:name&gt; &lt;/hel:sayHello&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;--------------------------------------[aultMessageListenerContainer-1] route1 INFO SOAP Request received message[aultMessageListenerContainer-1] route1 INFO Mock service repliedbut the response is not returned by CXF neither published in a (reply) queue.Here is the Camel Route @Override public void configure() throws Exception {from('cxf:bean:endpoint.service.worklist?dataFormat=MESSAGE') .convertBodyTo(String.class) .log('SOAP Request received message').setHeader('JMSReplyTo').constant('supervisorworklist.response') .transform().constant(response) // RESPONSE = SOAP MESSAGE .log('Mock service replied'); }&amp; Config&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;beans xmlns='http://www.springframework.org/schema/beans' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:camel='http://camel.apache.org/schema/spring' xmlns:osgi='http://www.springframework.org/schema/osgi' xmlns:cxf='http://camel.apache.org/schema/cxf' xmlns:jms='http://cxf.apache.org/transports/jms' xsi:schemaLocation=' http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/osgi http://www.springframework.org/schema/osgi/spring-osgi.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf-2.10.0-spring.xsd http://cxf.apache.org/transports/jms http://cxf.apache.org/schemas/configuration/jms.xsd'&gt; &lt;bean id='jms.connectionFactory' class='org.apache.activemq.ActiveMQConnectionFactory'&gt; &lt;!-- &lt;property name='brokerURL' value='vm://myEmbeddedBroker?broker.persistent=false' /&gt;--&gt; &lt;property name='brokerURL' value='tcp://localhost:61616'/&gt; &lt;/bean&gt; &lt;bean id='jms.config.service' class='org.apache.cxf.transport.jms.JMSConfiguration'&gt; &lt;property name='connectionFactory' ref='jms.connectionFactory' /&gt; &lt;property name='targetDestination' value='supervisorworklist' /&gt; &lt;property name='replyDestination' value='supervisorworklist.response'/&gt; &lt;/bean&gt; &lt;bean id='logginOutInterceptor' class='org.apache.cxf.interceptor.LoggingOutInterceptor'/&gt; &lt;bean id='logginInInterceptor' class='org.apache.cxf.interceptor.LoggingInInterceptor'/&gt; &lt;!-- Producer Endpoint --&gt; &lt;cxf:cxfEndpoint id='endpoint.service.worklist' address='jms://'serviceClass='com.redhat.mycompany.helloworld.HelloWorldService' serviceName='s:HelloWorldService' endpointName='s:HelloWorldOverJms' xmlns:s='http://helloworld.atos.redhat.com'&gt; &lt;cxf:features&gt; &lt;bean xmlns='http://www.springframework.org/schema/beans'class='org.apache.cxf.transport.jms.JMSConfigFeature'&gt; &lt;property name='jmsConfig' ref='jms.config.service' /&gt; &lt;/bean&gt; &lt;/cxf:features&gt; &lt;cxf:inInterceptors&gt; &lt;ref bean='logginInInterceptor'/&gt; &lt;/cxf:inInterceptors&gt; &lt;cxf:outInterceptors&gt; &lt;ref bean='logginOutInterceptor'/&gt; &lt;/cxf:outInterceptors&gt; &lt;/cxf:cxfEndpoint&gt; &lt;camelContext xmlns='http://camel.apache.org/schema/spring'&gt; &lt;package&gt;com.redhat.mycompany.cxf&lt;/package&gt; &lt;/camelContext&gt;&lt;/beans&gt;",
            "id": "6084"
        },
        "6089": {
            "ground_truth": "1",
            "bug_report": "CXFEndpoint blueprint config having binding element may lead to NPE\nThere seems to be an error in the EndpointpointDefinitionParser in parsing the binding element. Concretely speaking  that element is not parsed from the right element but wrongly from its parent element.So  when you have something like &lt;camel-cxf:cxfEndpoint id='routerEndpoint' ...&gt; ... &lt;camel-cxf:binding&gt; &lt;soap:soapBinding mtomEnabled='true' version='1.2'/&gt; &lt;/camel-cxf:binding&gt; &lt;/camel-cxf:cxfEndpoint&gt;you may get an NPE  as shown in:java.lang.NullPointerException: null at org.apache.aries.blueprint.container.RecipeBuilder.getValue(RecipeBuilder.java:335) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.RecipeBuilder.createBeanRecipe(RecipeBuilder.java:258) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.RecipeBuilder.createRecipe(RecipeBuilder.java:106) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.RecipeBuilder.createRepository(RecipeBuilder.java:89) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.BlueprintContainerImpl.getRepository(BlueprintContainerImpl.java:438) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:288) ~&#91;na:na&#93; at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:230) ~[na:naFixing this line in EndpointDefinitionParser will fix this issue.",
            "id": "6089"
        },
        "6091": {
            "ground_truth": "0",
            "bug_report": "Improvement to SqlProducer class\nI have came across a bug with the Microsoft SQL Server driver (4.0) in where the folowing line is problematic:int expected = ps.getParameterMetaData().getParameterCount();If I run the following query through the component:INSERT INTO &#91;NEW_TABLE&#93; SELECT * FROM &#91;OLD_TABLE&#93; WHERE ID = #expected is set to 0 which results in my value not being set.Caused by: com.microsoft.sqlserver.jdbc.SQLServerException: The value is not set for the parameter number 1.While this is a SQL Server issue  unfortunately the source is not available and an update is not likely any time soon to return the correct meta data. It would be handy if this Producer put the query preperation a little more into the hands of the user. I.e. let me say there are 5 parameters to be prepared along with the 5 values to use.If the user has manually put 5 items in a Map in the body  then can we not just use the map length to identify how many values and then iterate them.",
            "id": "6091"
        },
        "6097": {
            "ground_truth": "0",
            "bug_report": "Race condition in AggregatorProcessor recovery sometimes causes duplicates\nThere seems to be a race condition in org.apache.camel.processor.aggregate.AggregateProcessor's RecoverTask. That task calls recoverable.scan() to find Exchanges that may need to be recovered. Since scan() might return Exchanges that are actually just in progress  the RecoverTask then checks to see if the Exchange really is in progress. It does this by calling inProgressCompleteExchanges.contains(exchangeId). However  that collection may have been modified during the time between when scan() returned and when contains() is called. This would happen if the in-progress Exchange completes before contains() is called. In that situation  inProgress would evaluate to false  so the Exchange would be recovered. This results in a duplicate Exchange being output by the Aggregator component. One possible solution might be to prevent updating the inProgressCompleteExchanges during the critical section. Another possible solution might be to copy inProgressCompleteExchanges before calling scan(). I'm sure that there are other ways to deal with this also.",
            "id": "6097"
        },
        "6109": {
            "ground_truth": "0",
            "bug_report": "step in a  block runs when the  tag is closed in the wrong place\nExample route:&lt;doTry&gt; &lt;to ... &gt;&lt;/doTry&gt;&lt;doCatch&gt; &lt;exception&gt;java.lang.Exception&lt;/exception&gt; &lt;to uri='log.... '/&gt;&lt;/doCatch&gt;The &lt;to uri='log...'/&gt; line will execute every time  regardless if there is an exception or not.I believe the preferred behavior would be that the route should fails to load/validate. Alternatively  the &lt;to uri='log..' /&gt; should not run when there is not an exception.Thanks!",
            "id": "6109"
        },
        "6123": {
            "ground_truth": "0",
            "bug_report": "camel-jms: InOut exchange can time out even if response was received\nWhen performing an InOut JMS exchange with a certain requestTimeout  if the reply message is received in time  but the following formula stands true: T0 + T1 &gt;= T!  where:T0 = JMS response timeT1 = remaining route processing time following the replyT! = requestTimeoutThen camel-jms will throw an ExchangeTimedOutException regardless of the fact that the reply was truly received in time.I'm surprised this bug has gone unnoticed until now  as it's been present since mid-2010.Example unit test: @Test public void testTimeoutNotTriggered() throws Exception { getMockEndpoint('mock:exception').expectedMessageCount(0); template.requestBody('activemq:test'  '&lt;hello /&gt;'); assertMockEndpointsSatisfied(); } @Override protected RouteBuilder createRouteBuilder() throws Exception { return new RouteBuilder() { @Override public void configure() throws Exception { onException(ExchangeTimedOutException.class) .handled(true) .to('mock:exception'); from('activemq:test') .inOut('activemq:test?requestTimeout=500') .delay(constant(1000)); from('activemq:test') .log('test'); } }; }",
            "id": "6123"
        },
        "6129": {
            "ground_truth": "0",
            "bug_report": "Simple language - bean function - issue when parameter value has comma\nSee nabblehttp://camel.465427.n5.nabble.com/Prolems-with-parametrized-bean-method-call-via-simple-tp5728319.html",
            "id": "6129"
        },
        "6154": {
            "ground_truth": "0",
            "bug_report": "NPE when using the imap mail component with quartz or the timer and pollEnrich\nThere is a NPE when using the imap mail component with quartz or the timer and pollEnrich as dicussed here:http://camel.465427.n5.nabble.com/Schedule-file-mail-endpoint-td3356666.html#a3357538I reproduced it on version 2.10.3 and 2.10.4 with &lt;route id='myTest'&gt; &lt;from uri='timer://foo?fixedRate=true&amp;period=10000'/&gt; &lt;pollEnrich uri='imap://userName@hostName?password=***'/&gt;  &lt;to uri='log:testroute?showAll=true&amp;level=INFO'/&gt; &lt;/route&gt;We need to use it with the quartz component (so we can use a cron expression)  but get the same error &lt;route id='myTest'&gt; &lt;from uri='quartz://testTimer?cron=0+?'/&gt; &lt;pollEnrich uri='imap://userName@hostName?password=***'/&gt;  &lt;to uri='log:testroute?showAll=true&amp;level=INFO'/&gt; &lt;/route&gt;11/03/2013 10:32:04 &#91;DefaultQuartzScheduler-context_Worker-1&#93; ERROR org.apache.camel.processor.DefaultErrorHandler - Failed delivery for (MessageId: ID-W7-009430-52415-1362994261595-0-3 on ExchangeId: ID-W7-009430-52415-1362994261595-0-2). Exhausted after delivery attempt: 1 caught: org.apache.camel.CamelExchangeException: Error occurred during aggregation. Exchange[Message: &#91;Body is null&#93;]. Caused by: [org.apache.camel.RuntimeCamelException - Failed to extract body due to: null. Exchange: Exchange&#91;MailMessage: com.sun.mail.imap.IMAPMessage@411a3fe4&#93;. Message: com.sun.mail.imap.IMAPMessage@411a3fe4]org.apache.camel.CamelExchangeException: Error occurred during aggregation. Exchange[Message: &#91;Body is null&#93;]. Caused by: [org.apache.camel.RuntimeCamelException - Failed to extract body due to: null. Exchange: Exchange&#91;MailMessage: com.sun.mail.imap.IMAPMessage@411a3fe4&#93;. Message: com.sun.mail.imap.IMAPMessage@411a3fe4] at org.apache.camel.processor.PollEnricher.process(PollEnricher.java:194)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:308)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:117)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.loadbalancer.QueueLoadBalancer.process(QueueLoadBalancer.java:44)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:99)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.processor.loadbalancer.QueueLoadBalancer.process(QueueLoadBalancer.java:71)&#91;camel-core-2.10.4.jar:2.10.4&#93; at org.apache.camel.component.quartz.QuartzEndpoint.onJobExecute(QuartzEndpoint.java:113)&#91;camel-quartz-2.10.4.jar:2.10.4&#93; at org.apache.camel.component.quartz.CamelJob.execute(CamelJob.java:61)&#91;camel-quartz-2.10.4.jar:2.10.4&#93; at org.quartz.core.JobRunShell.run(JobRunShell.java:216)&#91;quartz-1.8.5.jar:&#93; at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:549)&#91;quartz-1.8.5.jar:&#93;",
            "id": "6154"
        },
        "6155": {
            "ground_truth": "0",
            "bug_report": "Camel stream producer never close the stream of file\nWhen I was working on CAMEL-6147  I found the file stream is never closed  even it met the close condition.",
            "id": "6155"
        },
        "6168": {
            "ground_truth": "0",
            "bug_report": "SQL component will not look for parameters in header when no body in message\nLine 60 in SqlProducer checks if the body is null. This will cause any parameters in header fields not to be populated into the prepared statement. Sample scenario is with a camel-jetty enriching a response using camel-sql.",
            "id": "6168"
        },
        "6172": {
            "ground_truth": "0",
            "bug_report": "Aggregate EIP - Completion from batch consumer should trigger first\nSee nabblehttp://camel.465427.n5.nabble.com/Issue-Aggregator2-BatchCompletion-disturbed-by-other-completions-and-fails-to-happen-when-it-probabl-tp5728850.html",
            "id": "6172"
        },
        "6173": {
            "ground_truth": "0",
            "bug_report": "camel-http - When bridging endpoints then there may be double parameter values if client sends uri parameters\nIf you have a jetty/http bridge endpoint  and the caller sends in a parameter with a value that has url encodings  then you may have double values when calling the bridge.eg callinghttp://localhost:23001/jettyTestRouteA?param1=%2B447777111222And having a jetty -&gt; http bridge  you can end up with double values.Caused by: java.lang.AssertionError: expected:&lt; 447777111222&gt; but was:&lt;[+447777111222  +447777111222]&gt;",
            "id": "6173"
        },
        "6176": {
            "ground_truth": "1",
            "bug_report": "Camel 2.10.1 incapable of working with + in endpoint URIs\nIn the class org.apache.camel.util.URISupport which will be used to resolve endpoints (DefaultCamelContext#normalizeEndpointUri) the method parseParameters will be called.At first the java.net.Uri#getQuery will be called with according to the javadoc 'Returns the decoded query component of this URI' returns a decoded URI. If that fails the java.net.Uri#getSchemeSpecificPart method will be called which according to the javadoc 'Returns the decoded scheme-specific part of this URI.' returns a decoded URI.So to summarize we get in any case a decoded URI.As workaround for CAMEL-4954 all % are encoded  i.e. replaced by %25.The URI will then be decoded again in the method org.apache.camel.util.URISupport#parseQuery(String) with java.net.URLDecoder#decode(String String).This code leads to the following behaviour: If a + is properly encoded with foo%2Bbar the foo%2Bbar will be substituted by the first call with foo+bar and then decoded again which leads to foo bar. If the + is not encoded at all foo+bar will be decoded to foo bar in the first step and not be changed again in the second step. If the + is double encoded to foo%252Bbar the first call will transform it to foo%2Bbar  then the workaround for CAMEL-4954 will change it back to foo%252Bbar and the final decode will change it again to foo%2Bbar.Thus  currently there is no way to use a + in passwords or similar parameter values if the parameter has to be supplied via endpoint URIs.",
            "id": "6176"
        },
        "6177": {
            "ground_truth": "0",
            "bug_report": "Camel-AWS should support any implementation of AmazonXXX (not only AmazonXXXClient)\nSee http://camel.465427.n5.nabble.com/camel-pull-request-making-change-so-that-we-can-use-camel-aws-integration-td5729038.html",
            "id": "6177"
        },
        "6187": {
            "ground_truth": "0",
            "bug_report": "http4 component should default to charset based on content type\nHttpProducer determines the charset of an outgoing StringEntity based on an Exchange property (Exchange.CHARSET_NAME)  using null if that property is not set. It also sets the content-type based on the content-type of the camel message (this may also contain a character encoding). If these two don't match the receiver of the http request will probably not be able to parse the message. It would be better if the charset of the StringEntity would by default match the charset specified in the content-type. Matching these two is done when receiving response messages (in HttpProducer.extractResponseBody())...Suggested fix (in HttpProducer.createRequestEntity())  you could of course also do something like org.apache.camel.component.http4.helper.HttpHelper.setCharsetFromContentType() but my approach uses org.apache.http.entity.ContentType and java.nio.charset.Charset instead of trying to determine the correct charset itself):// be a bit careful with String as any type can most likely be converted to String// so we only do an instanceof check and accept String if the body is really a String// do not fallback to use the default charset as it can influence the request// (for example application/x-www-form-urlencoded forms being sent)String charset = IOHelper.getCharsetName(exchange  false);if (charset == null &amp;&amp; contentType != null){ ContentType ct = ContentType.parse(contentType); if (ct != null) { Charset cs = ct.getCharset(); if (cs != null) { charset = cs.name(); } }}StringEntity entity = new StringEntity((String) data  charset);entity.setContentType(contentType);answer = entity;",
            "id": "6187"
        },
        "6218": {
            "ground_truth": "1",
            "bug_report": "TransferExchage InOut ActiveMQ Exception\nThe scnearios are : when using the transferExchange option only on the producer  I don't get the body back  but not the header. When I use the transferExchange option on both producer and consumer  I get the headers back  but not the body. And instead I get the following exception[ryQueueReplyManager[temporary]] TemporaryQueueReplyManager WARN Execution of JMS message listener failed. Caused by: [java.lang.NullPointerException - null]java.lang.NullPointerException at org.apache.camel.impl.DefaultExchangeHolder.unmarshal(DefaultExchangeHolder.java:107) at org.apache.camel.component.jms.JmsBinding.extractBodyFromJms(JmsBinding.java:128) at org.apache.camel.component.jms.JmsMessage.createBody(JmsMessage.java:214) at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:41) at org.apache.camel.component.jms.reply.ReplyManagerSupport.processReply(ReplyManagerSupport.java:136) at org.apache.camel.component.jms.reply.TemporaryQueueReplyHandler.onReply(TemporaryQueueReplyHandler.java:54) at org.apache.camel.component.jms.reply.TemporaryQueueReplyManager.handleReplyMessage(TemporaryQueueReplyManager.java:71) at org.apache.camel.component.jms.reply.ReplyManagerSupport.onMessage(ReplyManagerSupport.java:113) at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:560) at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:498) at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:467) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325) at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1058) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1050) at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:947) at java.lang.Thread.run(Thread.java:662)",
            "id": "6218"
        },
        "6227": {
            "ground_truth": "0",
            "bug_report": "json data format - Add support for configuring gson options\nSeehttp://stackoverflow.com/questions/15686032/apache-camel-gson-formatterWe should make it possible to configure those gson options in the DSL.",
            "id": "6227"
        },
        "6234": {
            "ground_truth": "0",
            "bug_report": "camel-bindy - Multiple models in the same package lead to unpredictable results\nBindyCsvDataFormat only holds one model. When multiple models are defined in the same package or field positions overlap  only one @DataField is kept (the last one) overwriting the previous mapping. This leads to unpredictable behavior  from the wrong field value being populated  to format mismatch exceptions for fields of different types.This behavior is by design  as camel supports deep models  spread over multiple files (see AnnotationModelLoader.loadModels() implementation where whole packages are scanned).The documentation is rather vague  but I believe supporting multiple models in the same package is not really feasible  and overkill at best. Therefore my preference would be to keep the functionality as is and document the limitation.Currently the BindyCVSFieldEndingWithSeparatorIssueTest fails due to a conflict between MyCsvRecord.class and BindyDoubleQuotesCsvUnmarshallTest.Order.class defined in the same package. Moving MyCsvRecord to a different package is a trivial fix. I will look into adding some model validation as well to WARN if the model is inconsistent (i.e. has overlaps or gaps).",
            "id": "6234"
        },
        "6240": {
            "ground_truth": "0",
            "bug_report": "Http4 component does not support PATCH\nIf I try to use PATCH  it gives me an error about it not being in an enum. However  the HttpClient does support it.http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/client/methods/HttpPatch.html",
            "id": "6240"
        },
        "6244": {
            "ground_truth": "0",
            "bug_report": "camel:run in blueprint is broken\nDue the Aries blueprint upgrade then the blueprint extenders may run 2+ due classpath issues.",
            "id": "6244"
        },
        "6252": {
            "ground_truth": "0",
            "bug_report": "camel-aws - Possible concurrent modification exception\nNoticed this from CI test serversStacktracejava.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:819) at java.util.ArrayList$Itr.next(ArrayList.java:791) at org.apache.camel.component.aws.sqs.SqsExtendMessageVisibilityTest.longReceiveExtendsMessageVisibility(SqsExtendMessageVisibilityTest.java:61) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30) at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:47) at org.junit.rules.RunRules.evaluate(RunRules.java:18) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30) at org.junit.runners.ParentRunner.run(ParentRunner.java:300) at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53) at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:119) at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:101) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103) at com.sun.proxy.$Proxy0.invoke(Unknown Source) at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150) at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91) at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)Standard Output@SLTests run: 1  Failures: 0  Errors: 0  Skipped: 0  Time elapsed: 2.032 sec@SLRunning org.apache.camel.component.aws.sqs.SqsExtendMessageVisibilityTest",
            "id": "6252"
        },
        "6258": {
            "ground_truth": "0",
            "bug_report": "Sql component - Add noop option to execute the query but dont change the message body afterwards\nSeehttp://blog.mgm-tp.com/2013/04/camel-router-part1/comment-page-1/#comment-4161Even if the query returns a result set  you may not want to grab that or change the message body.For that we can have a noop=true|false option. If there is a better name for the option then we can go for that  though noop was the first name that came to my mind.",
            "id": "6258"
        },
        "6259": {
            "ground_truth": "0",
            "bug_report": "Scheduled thread pools is not removed from JMX when shutting down\nFor example if a route use the aggragate eip with a completion timeout  then the scheduled thread pool is enlisted in JMX. But not removed when the route is removed. Though as fail-safe we always remove the JMX when camel is stopping.But for people doing dynamic add/remove routes this can become a problem.",
            "id": "6259"
        },
        "6261": {
            "ground_truth": "0",
            "bug_report": "Simple ognl expression - Possible NPE when using String replaceFirst and replacing with an empty string\nSee nabblehttp://camel.465427.n5.nabble.com/2-11-NPE-with-replaceFirst-tp5730321.html",
            "id": "6261"
        },
        "6262": {
            "ground_truth": "0",
            "bug_report": "org.apache.camel.support.ServiceSupport: InputStream not being explicitly closed\nIn method getVersion() of ServiceSupport there is an InputStream opened around line 284:InputStream is = getClass().getResourceAsStream('/META-INF/maven/org.apache.camel/camel-core/pom.properties');This stream is not closed explicitly.If you undeploy an application from a container like GlassFish you get a warning like this:[#|2013-04-11T18:02:00.783+0200|WARNING|glassfish3.1.2|javax.enterprise.system.core.classloading.com.sun.enterprise.loader|_ThreadID=137;_ThreadName=Thread-2;|Input stream has been finalized or forced closed without being explicitly closed; stream instantiation reported in following stack tracejava.lang.Throwable at com.sun.enterprise.loader.ASURLClassLoader$SentinelInputStream.&lt;init&gt;(ASURLClassLoader.java:1230) at com.sun.enterprise.loader.ASURLClassLoader$InternalJarURLConnection.getInputStream(ASURLClassLoader.java:1338) at java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:233) at com.sun.enterprise.loader.ASURLClassLoader.getResourceAsStream(ASURLClassLoader.java:872) at java.lang.Class.getResourceAsStream(Class.java:2049) at org.apache.camel.support.ServiceSupport.getVersion(ServiceSupport.java:284) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1439) at org.apache.camel.cdi.CdiCamelContext.start(CdiCamelContext.java:61) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&#91;...&#93;These were similar issues: XBEAN-190  JCR-2962",
            "id": "6262"
        },
        "6267": {
            "ground_truth": "0",
            "bug_report": "camel-cxfrs blueprint configure could not be installed if there are some subelement settings\nGot the OOM Exception when blueprint want to parser the setting like this.&lt;camelcxf:rsClient id='rsClient' address='http://localhost:9002/rest' serviceClass='org.apache.camel.itest.osgi.cxf.jaxrs.testbean.CustomerService'&gt; &lt;camelcxf:features&gt; &lt;bean class='org.apache.cxf.feature.LoggingFeature'/&gt; &lt;/camelcxf:features&gt; &lt;/camelcxf:rsClient&gt;",
            "id": "6267"
        },
        "6268": {
            "ground_truth": "0",
            "bug_report": "camel-stream - Shutdown thread pool on consumer should happen faster\nShould be faster to shutdown this pool as you may see WARN logs on stopping Camel[ Thread-1] DefaultShutdownStrategy INFO Starting to graceful shutdown 1 routes (timeout 300 seconds)el-1) thread #2 - ShutdownTask DefaultExecutorServiceManager INFO Waited 2.001 seconds for ExecutorService: org.apache.camel.util.concurrent.RejectableThreadPoolExecutor@48b4da9b&#91;Shutting down  pool size = 1  active threads = 1  queued tasks = 0  completed tasks = 0&#93;&#91;stream://in?promptMessage=Enter+something%3A+&#93; to terminate...el-1) thread #2 - ShutdownTask DefaultExecutorServiceManager INFO Waited 4.002 seconds for ExecutorService: org.apache.camel.util.concurrent.RejectableThreadPoolExecutor@48b4da9b&#91;Shutting down  pool size = 1  active threads = 1  queued tasks = 0  completed tasks = 0&#93;&#91;stream://in?promptMessage=Enter+something%3A+&#93; to terminate...",
            "id": "6268"
        },
        "6271": {
            "ground_truth": "0",
            "bug_report": "StringQuoteHelper - Should ignore whitespace between quoted parameters\nNeed to merge to 2.11 branch when created.",
            "id": "6271"
        },
        "6272": {
            "ground_truth": "0",
            "bug_report": "Bean - Improve choose method logic for no parameter methods\nWe should optimize the logic and if a method name with no parameters has been defined  eg.to('bean:myBean?method=foo()')Or in ognl's such as.when().simple('${body.foo()} != null').to('direct:foo')Then we should optimize the logic to filter out methods with methods  as foo has been declare with no methods explicit by ().",
            "id": "6272"
        },
        "6274": {
            "ground_truth": "0",
            "bug_report": "camel-example-reportincident failed\n2013-04-14 12:40:23 207 [main ] ERROR ContextLoader - Context initialization failedorg.apache.camel.RuntimeCamelException: org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[[From[cxf:/incident?bus=#cxf&amp;serviceClass=org.... because of Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1338) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:120) at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:285) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:327) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:941) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:475) at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:388) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111) at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:740) at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:238) at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1238) at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:683) at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:480) at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:256) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95) at org.eclipse.jetty.server.Server.doStart(Server.java:275) at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:511) at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:364) at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:521) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196) at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)Caused by: org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[[From[cxf:/incident?bus=#cxf&amp;serviceClass=org.... because of Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:181) at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:749) at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1828) at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1608) at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1477) at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:179) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1445) at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:228) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:118) ... 48 moreCaused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:507) at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:62) at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:191) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:114) at org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72) at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:90) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:861) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:176) ... 57 moreCaused by: java.lang.IllegalArgumentException: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:526) at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:536) at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:430) at org.apache.camel.util.EndpointHelper.setProperties(EndpointHelper.java:249) at org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:258) at org.apache.camel.component.cxf.CxfComponent.createEndpoint(CxfComponent.java:84) at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:119) at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:487) ... 65 more2013-04-14 12:40:23.217:WARN:oejw.WebAppContext:Failed startup of context o.m.j.p.JettyWebAppContext{/ file:/Users/cmueller/workspaceRelease/camel/examples/camel-example-reportincident/src/main/webapp/} file:/Users/cmueller/workspaceRelease/camel/examples/camel-example-reportincident/src/main/webapp/org.apache.camel.RuntimeCamelException: org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[[From[cxf:/incident?bus=#cxf&amp;serviceClass=org.... because of Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1338) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:120) at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:285) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:327) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:941) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:475) at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:388) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111) at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:740) at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:238) at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1238) at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:683) at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:480) at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:256) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95) at org.eclipse.jetty.server.Server.doStart(Server.java:275) at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:511) at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:364) at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:521) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196) at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)Caused by:org.apache.camel.FailedToCreateRouteException: Failed to create route route1: Route(route1)[[From[cxf:/incident?bus=#cxf&amp;serviceClass=org.... because of Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:181) at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:749) at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1828) at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1608) at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1477) at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:179) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1445) at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:228) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:118) at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:285) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:327) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:941) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:475) at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:388) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111) at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:740) at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:238) at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1238) at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:683) at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:480) at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:256) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95) at org.eclipse.jetty.server.Server.doStart(Server.java:275) at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:511) at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:364) at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:521) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196) at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)Caused by:org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: cxf:///incident?bus=%23cxf&amp;serviceClass=org.apache.camel.example.reportincident.ReportIncidentEndpoint&amp;wsdlURL=etc%2Freport_incident.wsdl due to: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:507) at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:62) at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:191) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:114) at org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72) at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:90) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:861) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:176) at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:749) at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1828) at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1608) at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1477) at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:179) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1445) at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:228) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:118) at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:285) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:327) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:941) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:475) at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:388) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111) at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:740) at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:238) at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1238) at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:683) at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:480) at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:256) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95) at org.eclipse.jetty.server.Server.doStart(Server.java:275) at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:511) at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:364) at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:521) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196) at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)Caused by:java.lang.IllegalArgumentException: Could not find a suitable setter for property: bus as there isn't a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: org.apache.cxf.Bus with value #cxf at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:526) at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:536) at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:430) at org.apache.camel.util.EndpointHelper.setProperties(EndpointHelper.java:249) at org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:258) at org.apache.camel.component.cxf.CxfComponent.createEndpoint(CxfComponent.java:84) at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:119) at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:487) at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:62) at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:191) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108) at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:114) at org.apache.camel.model.FromDefinition.resolveEndpoint(FromDefinition.java:72) at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:90) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:861) at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:176) at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:749) at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:1828) at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1608) at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1477) at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:179) at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:60) at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1445) at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:228) at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:118) at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:285) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:327) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:941) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:475) at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:388) at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:293) at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111) at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:740) at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:238) at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1238) at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:683) at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:480) at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:256) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95) at org.eclipse.jetty.server.Server.doStart(Server.java:275) at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64) at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:511) at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:364) at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:521) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59) at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196) at org.apache.maven.cli.MavenCli.main(MavenCli.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)2013-04-14 12:40:23.241:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:9080",
            "id": "6274"
        },
        "6281": {
            "ground_truth": "0",
            "bug_report": "camel-example-cxf-tomcat failed\nBy accessing 'http://localhost:8080/camel-example-cxf-tomcat/webservices/incident?wsdl' I get the following exception:Apr 14  2013 7:56:37 PM org.apache.catalina.core.StandardWrapperValve invokeSEVERE: Allocate exception for servlet CXFServletorg.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'cxf' is defined at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:549) at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1095) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:277) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1109) at org.apache.cxf.transport.servlet.CXFServlet.loadBus(CXFServlet.java:77) at org.apache.cxf.transport.servlet.CXFNonSpringServlet.init(CXFNonSpringServlet.java:71) at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1280) at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1193) at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:865) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:136) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:936) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918) at java.lang.Thread.run(Thread.java:680)",
            "id": "6281"
        },
        "6283": {
            "ground_truth": "0",
            "bug_report": "Restarting routes using sql aggregation repository may lead to Class loading issues\nIts the code in ClassLoadingAwareObjectInputStream in camel-sql that has the bug.",
            "id": "6283"
        },
        "6286": {
            "ground_truth": "0",
            "bug_report": "Make SqsConsumer support async processors\nSwitch SqsConsumer from using getProcessor().process() to getAsyncProcessor().process() with a callback to allow use of async processors.As I understand it is ok to always use the async processor call as its to show that 'the caller supports having the exchange asynchronously processed' rather than specifically always process it asynchronously.",
            "id": "6286"
        },
        "6292": {
            "ground_truth": "0",
            "bug_report": "Camel archetype component - Use bundle packaging so component is ready to install in OSGi\nThe component archetypes should have the pom.xml changed so they generate a project that use bundle packaging with the felix bundle plugin.Then the component is ready to install in OSGi.See nabblehttp://camel.465427.n5.nabble.com/Creating-new-processor-components-td5730919.html",
            "id": "6292"
        },
        "6300": {
            "ground_truth": "0",
            "bug_report": "AdviceWith doesn't work with doTry\nI have the following route definition: from('direct:billing_' + operation) .routeId(getRouteId(operation)) .errorHandler(noErrorHandler()) // propagate exceptions to the parent route .validate(body().isInstanceOf( com.cleverlance.cleverbss.integration.modules.in.customer.model.Customer.class)) .beanRef(BILLING_CUSTOMER_ROUTE_BEAN  'createRequestFor' + WordUtils.capitalize(operation)) // SetCustomer -&gt; XML .marshal(jaxbIn) .doTry() .to(uri + '?messageSender=#billingSender').id('toURI') .doCatch(AlreadyExistsException.class) .setProperty(exPropertyName  property(Exchange.EXCEPTION_CAUGHT)) .end() .choice() .when(property(exPropertyName).isNull()) // XML -&gt; SetCustomerResponse .unmarshal(jaxbOut) .endChoice();And I would like to replace TO in the tests: getCamelContext().getRouteDefinition(BillingCustomerRoutes.ROUTE_ID_UPDATE_CUSTOMER) .adviceWith(getCamelContext()  new AdviceWithRouteBuilder() { @Override public void configure() throws Exception { weaveByType(ToDefinition.class).replace().process(new Processor() { @Override public void process(Exchange exchange) throws Exception { throw new AlreadyExistsException('msg'  new AlreadyExists()); } }); } });When I use weaveById('toURI') or weaveByToString()  it doesn't work neither.",
            "id": "6300"
        },
        "6302": {
            "ground_truth": "0",
            "bug_report": "Mina UDP default codec should keep the data as byte[]\nThe MinaUdpProtocolCodecFactory on the consumer side decodes data from an udp datagram to a byte[]. byte[] bytes = context.getTypeConverter().convertTo(byte[].class  in);On the provider side where it gets back to the wire it gets converted to a string: String value = context.getTypeConverter().convertTo(String.class  message);and then set to the ByteBuffer with the given charset.The result is that the original datagram is not valid anymore. The default codec should the data convert to a byte array or keep the data as byte array.",
            "id": "6302"
        },
        "6305": {
            "ground_truth": "0",
            "bug_report": "debugBefore() and debugAfter() not called if unit test extends CamelBlueprintTestSupport\nA test that extends CamelBlueprintTestSupport does not get its debugBefore() and debugAfter() methods called.",
            "id": "6305"
        },
        "6313": {
            "ground_truth": "0",
            "bug_report": "Property placeholder optimization broke placeholders in Spring camelContext configuration\nWe are upgrading from 2.10.0 to 2.11.0  and are getting an error on startup.Example Spring configuration:&lt;camelContext id='camel' handleFault='true' autoStartup='{{autoStartup}}' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;contextScan /&gt; &lt;jmxAgent id='camelAgent' createConnector='true' registryPort='{{jmxPort}}' /&gt;&lt;/camelContext&gt;&lt;bean id='properties' class='org.apache.camel.component.properties.PropertiesComponent'&gt; &lt;property name='location' value='classpath:foo.properties'/&gt;&lt;/bean&gt;As you can see  we use the Camel properties component to configure Camel auto-startup  JMX port  etc.This is the error we're getting on startup:org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'properties' defined in class path resource [org/apache/camel/component/properties/SpringPropertiesComponentTest.xml]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camel-1': Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:527) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:607) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:472) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83) at org.apache.camel.component.properties.SpringPropertiesComponentTest.createApplicationContext(SpringPropertiesComponentTest.java:30) at org.apache.camel.spring.SpringTestSupport.setUp(SpringTestSupport.java:52) at junit.framework.TestCase.runBare(TestCase.java:139) at org.apache.camel.TestSupport.runBare(TestSupport.java:58) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:255) at junit.framework.TestSuite.run(TestSuite.java:250) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'camel-1': Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1455) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1109) at org.apache.camel.spring.CamelBeanPostProcessor$1.getOrLookupCamelContext(CamelBeanPostProcessor.java:69) at org.apache.camel.impl.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:85) at org.apache.camel.spring.CamelBeanPostProcessor.postProcessBeforeInitialization(CamelBeanPostProcessor.java:148) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:394) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1448) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519) ... 27 moreCaused by: java.lang.IllegalArgumentException: PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. at org.apache.camel.impl.DefaultCamelContext.resolvePropertyPlaceholders(DefaultCamelContext.java:1063) at org.apache.camel.util.CamelContextHelper.parseBoolean(CamelContextHelper.java:337) at org.apache.camel.core.xml.AbstractCamelContextFactoryBean.initCamelContext(AbstractCamelContextFactoryBean.java:543) at org.apache.camel.core.xml.AbstractCamelContextFactoryBean.afterPropertiesSet(AbstractCamelContextFactoryBean.java:266) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452) ... 40 moreI believe this is a side-effect of the optimization introduced in CAMEL-5508  which was incorporated into 2.10.1 and 2.11.0.I'll attach a small patch that modifies one of the unit tests in the camel-spring component to reproduce the issue.",
            "id": "6313"
        },
        "6317": {
            "ground_truth": "0",
            "bug_report": "Camel-validator not able to resolve schema when using useSharedSchema=false\nThis one works: &lt;to uri='validator:META-INF/xsd/fundscheckmaintainavailablebalance.xsd' /&gt;This one doesn't: &lt;to uri='validator:META-INF/xsd/fundscheckmaintainavailablebalance.xsd?useSharedSchema=false' /&gt;it fails with:org.xml.sax.SAXParseException: schema_reference.4: Failed to read schema document 'null'  because 1) could not find the document; 2) the document could not be read; 3) the root element of the document is not &lt;xsd:schema&gt;.The streamsource object in the validator is populated  but the buffered inputstream object has no content",
            "id": "6317"
        },
        "6321": {
            "ground_truth": "0",
            "bug_report": "Moving logic out of getTypeConverter\nTypeConverter is never added as a service if we use the method setTypeConverter(). Used through camel-guice you had expect this service to be active without additional instruction.See : http://camel.465427.n5.nabble.com/Ambiguity-in-DefaultCamelContext-with-TypeConverter-td5731480.html",
            "id": "6321"
        },
        "6330": {
            "ground_truth": "0",
            "bug_report": "Control Bus - Add suspend and resume actions\nWe have start and stop actions. But we need suspend and resume as well.",
            "id": "6330"
        },
        "6331": {
            "ground_truth": "0",
            "bug_report": "camel-netty - Loading key store and trust stores should support classpath as well\nThe options keyStoreFile and trustStoreFile is currently java.io.File based.We should use the resource loader API in Camel so we can load from classpath as well.",
            "id": "6331"
        },
        "6341": {
            "ground_truth": "1",
            "bug_report": "DefaultShutdownStrategy shutdown timeout of 0 will never timeout and go in negative time\nA timeout of 0 won't timeout in the instant  the time will go negative. camelcontext.stopRoute(routeId  0  TimeUnit.SECONDS  false); &#91;org.apache.camel.impl.DefaultShutdownStrategy&#93; : Waiting as there are still 3 inflight and pending exchanges to complete  timeout in -1 seconds.&#91;org.apache.camel.impl.DefaultShutdownStrategy&#93; : Waiting as there are still 3 inflight and pending exchanges to complete  timeout in -2 seconds.&#91;org.apache.camel.impl.DefaultShutdownStrategy&#93; : Waiting as there are still 3 inflight and pending exchanges to complete  timeout in -3 seconds. Found a post related to it there : http://camel.465427.n5.nabble.com/Forcefully-shutting-down-routes-td5722447.html",
            "id": "6341"
        },
        "6356": {
            "ground_truth": "0",
            "bug_report": "link to camel registry in camel-stax is missing\nlink to camel registry in camel-stax is missing",
            "id": "6356"
        },
        "6361": {
            "ground_truth": "0",
            "bug_report": "Validations exception should include line/column\nWhen a 'validator:' route step reports exceptions  they should include the line/column location.Here is a small patch that adds support for it.",
            "id": "6361"
        },
        "6362": {
            "ground_truth": "0",
            "bug_report": "camel-sjms - Consumers should always use dedicated Sessions\nIf you add more then one MessageListener to a Session then that session will use a single thread to notify each MessageListener in turn. Which defeats the purpose of using multiple MessageListeners  at least in my opinion.sessionCount in SjmsEndpoint should be ignored for Consumers  each Consumer (consumerCount) should instead use a dedicated Session  like what happens when transactions are enabled.",
            "id": "6362"
        },
        "6374": {
            "ground_truth": "0",
            "bug_report": "vm component - Stopping a route when using multipleConsumers should not stop MP if there is other routes using it\nSee nabblehttp://camel.465427.n5.nabble.com/Removing-route-stops-other-routes-from-the-same-producer-tp5732616.html",
            "id": "6374"
        },
        "6375": {
            "ground_truth": "0",
            "bug_report": "Headers are not set correctly in some situation\nIf I define a route like this: from('&lt;MyUrl&gt;/test') .setHeader(Exchange.HTTP_RESPONSE_CODE  simple('400')); my http client get a 200 response code. If a add something else on the route like: from('&lt;MyUrl&gt;/test') .setHeader(Exchange.HTTP_RESPONSE_CODE  simple('400')) .log('400').my http client get a 400 response code as expected. forum :http://camel.465427.n5.nabble.com/route-http-code-td5732728.html",
            "id": "6375"
        },
        "6385": {
            "ground_truth": "0",
            "bug_report": "New restlet endpoints don't work if route is created after restlet server is started.\nIf a route with restlet endponit is created after restlet server is started  restlet can't handle the endpoint correctly  because restlet translate all URI pattern of routes at server starting  but don't it for later attached routes. So we must translate the URI pattern before attach it to restlet after restlet server is started. See http://restlet.tigris.org/issues/show_bug.cgi?id=988.",
            "id": "6385"
        },
        "6390": {
            "ground_truth": "0",
            "bug_report": "Route with suspended SedaConsumer can't be stopped correctly\nRoute with suspended SedaConsumer can't be stopped correctly. Here is test: @Test public void testOriginalSedaShutdownSuspended() throws Exception { SedaEndpoint endpoint = context().getEndpoint('seda:test'  SedaEndpoint.class); context().addRouteDefinition(new RouteDefinition() .id('testRoute') .from(endpoint) .to('log:body') ); Set&lt;SedaConsumer&gt; consumers = endpoint.getConsumers(); Assert.assertFalse(consumers.isEmpty()); for (SedaConsumer sedaConsumer: consumers) { sedaConsumer.suspend(); } Assert.assertTrue(context().stopRoute('testRoute'  2  TimeUnit.SECONDS  true)); }",
            "id": "6390"
        },
        "6408": {
            "ground_truth": "0",
            "bug_report": "cxf endpoint's should log the parsing exception when failing to extract the root element name\nWhen the content is not xml and the root element is not correctly extracted by the CxfEndpoint's root element extraction method  the original exception is not logged but a subsequent exception (not the original one) will be thrown upwards. This behavior is confusing and could potentially lead to another issue depending on what the stax parser does on its getLocalName().Currently  when r.next() throws an exception  it's ignored and the subsequent call to r.getLocalName()'s exception is thrown.So I think it's preferable to log the original exception and simply return null as in the other cases for not finding the root element.Logging the original exception will provide a more helpful information in spotting the issue  as it will show up like:com.ctc.wstx.exc.WstxUnexpectedCharException: Unexpected character 'c' (code 99) in prolog; expected '&lt;'This is an action to the point raised in http://camel.465427.n5.nabble.com/Test-route-with-CXF-endpoint-td5733266.html",
            "id": "6408"
        },
        "6413": {
            "ground_truth": "0",
            "bug_report": "File consumer - Race condition for markerFile read lock strategy\nSee nabblehttp://camel.465427.n5.nabble.com/File-markerFile-strategy-race-condition-tp5733561.htmlWe should delete the .camelLock file last  as currently we move the processed file first. And there is a very tiny tiny window where another process could potential see the file and pickup it.",
            "id": "6413"
        },
        "6432": {
            "ground_truth": "0",
            "bug_report": "baseResource of Jetty ServletContextHandler does not work when project deployed as a bundle\nIf we package a camel websocket route ('websocket://0.0.0.0:9090/newsTopic?sendToAll=true&amp;staticResources=classpath:webapp') as a bundle and set the staticResources as parameter (classpath:webapp)  then the pages cannot be accessed from the browserCode should be  if (resources[0].equals('classpath')) { URL url = this.getCamelContext().getClassResolver().loadResourceAsURL(resources[1]); context.setBaseResource(Resource.newResource(url)); } else if (resources[0].equals('file')) { context.setBaseResource(Resource.newResource(resources[1])); }",
            "id": "6432"
        },
        "6447": {
            "ground_truth": "0",
            "bug_report": "endChoice() has no effect in nested choice definition\nI just upgraded from 2.10.4 to 2.11.0 and noticed that nested choice definitions started acting strangely. For example: .choice() .when(header(Exchange.EXCEPTION_CAUGHT).isNotNull()) // 1 .setBody(exceptionMessage().append(SystemUtils.LINE_SEPARATOR).append(exceptionStackTrace())) .choice() .when(header(HEADER_CONTROLLER_ID).isNotNull()) // 1a .setHeader(Exchange.FILE_NAME  simple(AUDIT_CONTROLLER_FAILED_FILENAME + '.error.log')) .to(ENDPOINT_AUDIT_DIR) .otherwise() // 1b .setHeader(Exchange.FILE_NAME  simple(AUDIT_FAILED_FILENAME + '.error.log')) .to(ENDPOINT_AUDIT_DIR) // INSERTING .end() here solves the issue .endChoice() .log(LoggingLevel.WARN  'DLQ written: ${in.header.CamelExceptionCaught}' .otherwise() // 2 .log(LoggingLevel.WARN  'DLQ written' + MESSAGE_LOG_FORMAT) .end()I have a test that is supposed to go through 1 and 1a. However it now passes through 1 and 2!It looks like the endChoice() in 1b has no effect and the otherwise() in 2 is executed instead of 1b. Inserting and end() statement as shown seems to solve the issue  but it looks suspicious.It's probably a regression introduced by the fix for CAMEL-5953  but I'm not 100% sure.",
            "id": "6447"
        },
        "6461": {
            "ground_truth": "0",
            "bug_report": "camel-quartz - Stateful job - Redeploying bundle/war and having changed endpoint uri issue\nSeehttp://camel.465427.n5.nabble.com/In-came-quartz-route-after-bundle-update-jobs-are-not-triggred-tp5734196.htmlIn these situations we should use job.name to name the job unique so when you change the endpoint uri and redeploy the apps/bundles  then camel-quartz can find the old job in the quartz persistent store.There may be logic needed to lookup using job.name as the unique name in these situations  and then allow endpoint uri options to change over time  such as the cron trigger etc. Which should be adjusted accordingly as well.",
            "id": "6461"
        },
        "6464": {
            "ground_truth": "0",
            "bug_report": "connectionTimeout property is ignored by JavaMail\nJavaMail ignores the timeout values set via the connectionTimeout property. Within MailConfiguration::createJavaMailProperties the mail.&lt;protocol&gt;.timeout and mail.&lt;protocol&gt;.connectionTimeout parameters are set as long values In com.sun.mail.util.PropUtil::getInt (line 141) the property is ignored since it is a long valueChanging the type of connectionTimeout from long to int would be the cleanest solution - another suggestion would be to downcast the connectionTimeout in MailConfiguration::createJavaMailProperties",
            "id": "6464"
        },
        "6473": {
            "ground_truth": "0",
            "bug_report": "NULL values are not supported in named parameters\nDue to the bug in the DefaultSqlPrepareStatementStrategy there no ability to use NULL values.Following query will be failed  if we try to use NULL as a parameter value:select a  b from foo where (:#param1 IS NOT NULL AND a &gt; 12 ) OR (:#param2 IS NOT NULL AND b &gt; 12)We'll get an error: Caused by: java.sql.SQLException: Number of parameters mismatch. Expected: 2  was:1at org.apache.camel.component.sql.DefaultSqlPrepareStatementStrategy.populateStatement(DefaultSqlPrepareStatementStrategy.java:132) ~&#91;camel-sql-2.11.0.jar:2.11.0&#93; at org.apache.camel.component.sql.SqlProducer$1.doInPreparedStatement(SqlProducer.java:74) ~&#91;camel-sql-2.11.0.jar:2.11.0&#93; at org.apache.camel.component.sql.SqlProducer$1.doInPreparedStatement(SqlProducer.java:57) ~&#91;camel-sql-2.11.0.jar:2.11.0&#93; at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:587) ~&#91;spring-jdbc-3.1.4.RELEASE.jar:3.1.4.RELEASE&#93;Fix is quite simple: iterator implementation (returned by DefaultSqlPrepareStatementStrategy.createPopulateIterator()) should be changed as follows: return new Iterator&lt;Object&gt;() { private NamedQueryParser parser = new NamedQueryParser(query); private String nextParam; private boolean done; @Override public boolean hasNext() { if (done) { return false; } if (nextParam == null) { nextParam = parser.next(); if (nextParam == null) { done = true; } } return nextParam != null; } @Override public Object next() { if(!hasNext()){ throw new NoSuchElementException(); } boolean contains = bodyMap != null ? bodyMap.containsKey(nextParam) : false; contains |= headerMap != null ? headerMap.containsKey(nextParam) : false; if (!contains) { throw new RuntimeExchangeException('Cannot find key [' + nextParam + '] in message body or headers to use when setting named parameter in query [' + query + ']'  exchange); } // get from body before header Object next = bodyMap != null ? bodyMap.get(nextParam) : null; if (next == null) { next = headerMap != null ? headerMap.get(nextParam) : null; } nextParam = null; return next; } @Override public void remove() { // noop } };",
            "id": "6473"
        },
        "6481": {
            "ground_truth": "0",
            "bug_report": "Can't access to length of Array (java) from simple language\nCannot evaluate length on java.lang.String[] in simpleI suspect this is because this is part of the language itself. But still  why not?repro steprun this: ?xml version='1.0' encoding='UTF-8'?&gt;&lt;routes xmlns='http://camel.apache.org/schema/spring' &gt; &lt;route&gt; &lt;from uri='timer:test?repeatCount=1'/&gt; &lt;setBody&gt; &lt;groovy&gt;[[2  'Chaine_avec_des_underscores'  12  'c']  ['d4'  'e5'  'f6']]&lt;/groovy&gt; &lt;/setBody&gt; &lt;split&gt; &lt;simple&gt;${body}&lt;/simple&gt; &lt;setHeader headerName='splittedColumn1'&gt; &lt;simple&gt;${body[1].split('_')}&lt;/simple&gt; &lt;/setHeader&gt; &lt;log message='${header.splittedColumn1.length}'/&gt; &lt;/split&gt; &lt;/route&gt;&lt;/routes&gt;errors with:org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: .length on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: length on null due to: org.apache.camel.component.bean.MethodNotFoundException: Method with name: length not found on bean: [Ljava.lang.String;@33318365 of type: [Ljava.lang.String;. Exchange[Message: [d4  e5  f6]]",
            "id": "6481"
        },
        "6504": {
            "ground_truth": "0",
            "bug_report": "org.apache.camel.main.Main#doStop() throws java.lang.IndexOutOfBoundsException\nWhen calling a Camel application with parameter -h all parameters are printed an the program exits.But it is no clean exit; it throws an java.lang.IndexOutOfBoundsException.The reason for this is the expression in doStop():+getCamelContexts().get(0).stop();get(0) returns null  if no context is initialized yet.See camel-users mailinglist  thread 'Bug in org.apache.camel.main.Main#doStop() ?'",
            "id": "6504"
        },
        "6514": {
            "ground_truth": "1",
            "bug_report": "SFTP: NPE if no private key file is supplied\nHi a NPE is thrown if no private key file is supplied in the configuration for SFTP. The error isCaused by: java.lang.NullPointerException: while trying to get the length of an array loaded from local variable 'foo'at com.jcraft.jsch.Buffer.putString(Buffer.java:59)I have analysed the code a bit and found that the problem is causedby the class SftpOperations. The method createSession sets the userInfo for the seesion by an inline class. Here the method promptKeyboardInteractive does not work correctly if no private key file is supplied. In that case JSCH switches to user/pw authorization and this method is called. But since there is no password maintained the configation object returns NULL. The present implementation adds it to the string array causing the error in JSCH. JSCH either wants a NULL string array or an empty string array (I have tested both). So the code should look e.g. as follows: public String[] promptKeyboardInteractive(String destination  String name  String instruction  String[] prompt  boolean[] echo) { String password = configuration.getPassword(); if (password == null) { return new String[0]; } else { return new String[] { password }; } }With that change JSCH returnsCaused by: java.io.FileNotFoundException: ./data/ssh/id_rsa (No such file or directory) at java.io.FileInputStream.open(Native Method)and that is the real cause of the error Best Regards J?rg",
            "id": "6514"
        },
        "6537": {
            "ground_truth": "0",
            "bug_report": "Routing slip EIP - Does not send ExchangeSentEvent notifications\nWhen using routing slip eip  then we only get the ExchangeSendingEvent  what we miss is the ExchangSentEvent.",
            "id": "6537"
        },
        "6551": {
            "ground_truth": "0",
            "bug_report": "FtpConsumer fills up log file with 'Cannot connect/login' WARN level messages\nIf the FTP server becomes unavailable  the container log gets flooded with WARN-level messages and gets filled with lines like:16:32:34 511 WARN &#91;org.apache.camel.component.file.remote.FtpConsumer&#93; Cannot connect/login to: ftp://adpt5@localhost:21. Will skip this poll.16:32:49 048 WARN &#91;org.apache.camel.component.file.remote.FtpConsumer&#93; Cannot connect/login to: ftp://adpt5@localhost:21. Will skip this poll.16:33:03 576 WARN &#91;org.apache.camel.component.file.remote.FtpConsumer&#93; Cannot connect/login to: ftp://adpt5@localhost:21. Will skip this poll.i.e. a WARN message gets added to the log every five seconds. We only need to be notified once per incidence.The issue is in org.apache.camel.component.file.remote.RemoteFileConsumer.prePollCheck().I recommend a table of latches  keyed by endpoint key. The latch is set when the initial warning is logged  then cleared upon any subsequent successful connection.",
            "id": "6551"
        },
        "6563": {
            "ground_truth": "0",
            "bug_report": "camel-netty - unable to consume on UDP multicast addresses\nWhen using a route to listen to UDP multicast address   no messages seem to get consumed. No exceptions are observed. Multicast address is defined as addresses in the range of 224.0.0.0 through 239.255.255.255 (http://en.wikipedia.org/wiki/Multicast_address)Input was simple string (e.g. 'Test String')Example Route:&lt;route&gt; &lt;from uri='netty:udp://225.1.1.1:8001?allowDefaultCodec=false&amp;sync=false&amp;broadcast=true'/&gt;&lt;/route&gt;Found an old topic in the user discussion forum that seems related. Did not find any unit tests in the Camel source code exercising this behavior. (http://camel.465427.n5.nabble.com/camel-netty-and-multicast-tt4638622.html)",
            "id": "6563"
        },
        "6571": {
            "ground_truth": "0",
            "bug_report": "Wrong InputStream reference is used in method storeFile of class ScpOperations\nIn method storeFile(String name  Exchange exchange) of class org.apache.camel.component.jsch.ScpOperations the wrong reference of the required input stream is used (line 131). Should be write(channel  file  is  cfg); instead of write(channel  file  exchange.getIn().getMandatoryBody(InputStream.class)  cfg);",
            "id": "6571"
        },
        "6585": {
            "ground_truth": "0",
            "bug_report": "camel-cxf should shutdown the bus when the endpoint is stopped.\nIf the bus is create by cxfEndpoint itself  cxfEndpoint should shutdown it when the endpoint is stopped.",
            "id": "6585"
        },
        "6586": {
            "ground_truth": "0",
            "bug_report": "JMX - browsable endpoints such as seda has some attributes listed as unavaiable\nSee screenshotThe problem is related to extending a ManagedEndpoint then some options is shown as unavaiable in JMX consoles.",
            "id": "6586"
        },
        "6591": {
            "ground_truth": "0",
            "bug_report": "SFTP endpoint fails if the server disconnected the socket\nIf the ssh server disconnects the socket held by an SFTP endpoint (and the disconnect option is not set to true) the next call to this endpoint will fail. A call after the failed call will reconnect (and succeed if the server is available again).The error message is as follows:SftpSimpleProduceDisconnectTestorg.apache.camel.component.file.remote.sftp.SftpSimpleProduceDisconnectTesttestSftpSimpleProduce(org.apache.camel.component.file.remote.sftp.SftpSimpleProduceDisconnectTest)org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange&#91;Message: Hello World&#93; at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1360) at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:619) at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:454) at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:450) at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:152) at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:146) at org.apache.camel.component.file.remote.sftp.SftpSimpleProduceDisconnectTest.testSftpSimpleProduce(SftpSimpleProduceDisconnectTest.java:50) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55) at org.junit.rules.RunRules.evaluate(RunRules.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) at org.junit.runners.ParentRunner.run(ParentRunner.java:309) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)Caused by: org.apache.camel.component.file.GenericFileOperationFailedException: Cannot change directory to: target at org.apache.camel.component.file.remote.SftpOperations.doChangeDirectory(SftpOperations.java:536) at org.apache.camel.component.file.remote.SftpOperations.changeCurrentDirectory(SftpOperations.java:524) at org.apache.camel.component.file.remote.SftpOperations.storeFile(SftpOperations.java:771) at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:278) at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:166) at org.apache.camel.component.file.remote.RemoteFileProducer.process(RemoteFileProducer.java:49) at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:192) at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:73) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:366) at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:1) at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:233) at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:337) at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:175) at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:111) at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:150) ... 31 moreCaused by: 4:  at com.jcraft.jsch.ChannelSftp.cd(ChannelSftp.java:332) at org.apache.camel.component.file.remote.SftpOperations.doChangeDirectory(SftpOperations.java:534) ... 46 moreCaused by: java.io.IOException: Pipe closed at java.io.PipedInputStream.read(Unknown Source) at java.io.PipedInputStream.read(Unknown Source) at com.jcraft.jsch.ChannelSftp.fill(ChannelSftp.java:2665) at com.jcraft.jsch.ChannelSftp.header(ChannelSftp.java:2691) at com.jcraft.jsch.ChannelSftp._realpath(ChannelSftp.java:2148) at com.jcraft.jsch.ChannelSftp.cd(ChannelSftp.java:315) ... 47 more",
            "id": "6591"
        },
        "6593": {
            "ground_truth": "0",
            "bug_report": "Predicates from java dsl are not dumped to xml correctly\nPredicates defined in the java dsl are not dumped to xml when using jmx.Eg  this java dsl route:from('seda:a').choice().when(header('test').isNotNull()).log('not null').end().to('mock:a');Will be dumped as this:&lt;?xml version='1.0' encoding='UTF-8' standalone='yes'?&gt;&lt;route group='com.example.TestRoute' id='route1' xmlns='http://camel.apache.org/schema/spring'&gt; &lt;from uri='seda:a'/&gt; &lt;choice id='choice23'&gt; &lt;when id='when24'&gt; &lt;expressionDefinition/&gt; &lt;log message='not null' id='log20'/&gt; &lt;/when&gt; &lt;/choice&gt; &lt;to uri='mock:a' id='to17'/&gt;&lt;/route&gt;The &lt;expressionDefinition&gt; element should contain the expression.This seems similar to CAMEL-4733.",
            "id": "6593"
        },
        "6595": {
            "ground_truth": "0",
            "bug_report": "camel-cmis component: test packages have the wrong name\nUnit tests for camel-cmis are under package org.apache.camel.componenet instead of org.apache.camel.componentActions:1) Rename folder src/test/java/org/apache/camel/componenet to src/test/java/org/apache/camel/component/2) Fix the package name in each unit testAffected version: 2.12-SNAPSHOT and before",
            "id": "6595"
        },
        "6602": {
            "ground_truth": "0",
            "bug_report": "camel-cxf ClassCastException when use cxf FailoverFeature\nWith PAYLOAD data format used  the first element in argument is casted to a CxfPayload instance and the argument is changed into a List&lt;DOMSource&gt; instance by the method 'setParameters' in class org.apache.camel.component.cxf.CxfEndpoint.Then FailoverFeature calls retry  the class-cast action throws a ClassCastException.btw: 'message.remove(DataFormat.class)' at the end of the method 'setParameters' dosn't work. The method 'remove' is inherited from Map  and a new message with data format PAYLOAD is created when retry.",
            "id": "6602"
        },
        "6621": {
            "ground_truth": "0",
            "bug_report": "Add ability to connect to SQS queue of different owner\nUnable to connect to Amazon SQS queue owned by a different account. In B2B scenario  would like to have different accounts for owner  writer  and reader of a queue.",
            "id": "6621"
        },
        "6623": {
            "ground_truth": "0",
            "bug_report": "Support attaching to SQS queues where the user doesn't have permission to list the queues (manually build URL)\nCurrently the code assume that the user either has permission to list all the queues on their account or run a query request to get the queue url. In situations where security is more controlled you might have permission to read/write to/from a queue but not have permission to query SQS for the URL. In these cases there needs to be a way to manually build the URL from the pieces in the configuration.",
            "id": "6623"
        },
        "6629": {
            "ground_truth": "0",
            "bug_report": "Add requestBufferSize and requestHeaderSize options for jetty\nAdd requestBufferSize and requestHeaderSize options for jetty server to allow configuration of allowable request header limitThis option is exposed by standalone jetty server but not exposed by camel-jetty.",
            "id": "6629"
        },
        "6639": {
            "ground_truth": "0",
            "bug_report": "SimpleLanguage.simple should detect if its a predicate and use that instead\nWhen using predicates with the simple language static methods  then ppl should use the correct method. We should improve the javadoc  and as well add methods for easy to create predicates.See nabblehttp://camel.465427.n5.nabble.com/How-to-check-that-a-file-is-empty-tp5737256.html",
            "id": "6639"
        },
        "6641": {
            "ground_truth": "0",
            "bug_report": "SJMS component throws class cast error when used with IBM Webshpere MQ\nWhen using the IBM MQ JMS classes and pub/sub over a TOPIC the JmsObjectFactory.createMessageConsumer method throws a cast class exception. The session is being cast to a TopicSession which for MQ it is not.Using pure jms this cast is not required as the session class is aware of the destination type.",
            "id": "6641"
        },
        "6671": {
            "ground_truth": "0",
            "bug_report": "FTP consumer - Add option to not use LIST command\nIf you want to download a single file  and you know the absolute name of the file  then you should be able to download the file  without using any LIST commands. As some use-cases have permissions disabled for this  so you can only download that file only.The ftp/sftp consumers should have an option to ?useList=false  so they do not use the list command.",
            "id": "6671"
        },
        "6674": {
            "ground_truth": "0",
            "bug_report": "Add allowNull option to @Converter to allow type converters to return null as valid response for special use-cases\nSee nabblehttp://camel.465427.n5.nabble.com/Xpath-parameter-binding-NodeList-vs-Node-tp5738067.htmlThis avoids the situation with the NodeList -&gt; Node converter that may return null the 1st time  and then its regarded as a misses for conversion in future attempts.Just be annotation the method from@Converterto:@Converter(allowNull = true)Should allow to fix this. As then the type converter registry knows that a null response is valid.",
            "id": "6674"
        },
        "6678": {
            "ground_truth": "0",
            "bug_report": "Throttler does not honor time slots after period expires\nCamel's Throttler eip uses time slots to calc what tasks need to be delayed and which don't. The time slots don't take into account period elapse. See from this mailing list question:http://camel.465427.n5.nabble.com/Camel-Throttler-not-throttling-as-expected-td5738158.htmlI can recreate  and working on a patch.",
            "id": "6678"
        },
        "6680": {
            "ground_truth": "0",
            "bug_report": "Simple language - Have singleton language for better performance\nWe can optimize the simple language using in eg bean ognl expressions and the likes.",
            "id": "6680"
        },
        "6683": {
            "ground_truth": "0",
            "bug_report": "camel-dozer - Does not work well in OSGi Blueprint\nDozer doesnt work to well in OSGi. It seems to work with spring  but fails with OSGi blueprint.2013-08-29 14:44:51 302 | ERROR | l Console Thread | BlueprintContainerImpl | container.BlueprintContainerImpl 393 | 7 - org.apache.aries.blueprint.core - 1.1.0 | Unable to start blueprint container for bundle blueorg.osgi.service.blueprint.container.ComponentDefinitionException: Error when instantiating bean dozerMapper of class class org.dozer.DozerBeanMapper at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:333)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BeanRecipe.internalCreate2(BeanRecipe.java:806)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:787)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.di.AbstractRecipe$1.call(AbstractRecipe.java:79)[7:org.apache.aries.blueprint.core:1.1.0] at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)[:1.7.0_25] at java.util.concurrent.FutureTask.run(FutureTask.java:166)[:1.7.0_25] at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:88)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:245)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:183)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:668)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:370)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:261)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:259)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintExtender.modifiedBundle(BlueprintExtender.java:222)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:500)[11:org.apache.aries.util:1.1.0] at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:433)[11:org.apache.aries.util:1.1.0] at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$AbstractTracked.track(BundleHookBundleTracker.java:725)[11:org.apache.aries.util:1.1.0] at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.bundleChanged(BundleHookBundleTracker.java:463)[11:org.apache.aries.util:1.1.0] at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$BundleEventHook.event(BundleHookBundleTracker.java:422)[11:org.apache.aries.util:1.1.0] at org.apache.felix.framework.util.SecureAction.invokeBundleEventHook(SecureAction.java:1103)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.util.EventDispatcher.createWhitelistFromHooks(EventDispatcher.java:695)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:483)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4244)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.Felix.startBundle(Felix.java:1923)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.Felix.updateBundle(Felix.java:2235)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.BundleImpl.update(BundleImpl.java:962)[org.apache.felix.framework-4.0.3.jar:] at org.apache.felix.framework.BundleImpl.update(BundleImpl.java:949)[org.apache.felix.framework-4.0.3.jar:] at org.apache.karaf.shell.osgi.UpdateBundle.doExecute(UpdateBundle.java:37)[43:org.apache.karaf.shell.osgi:2.3.2] at org.apache.karaf.shell.osgi.BundleCommand.doExecute(BundleCommand.java:42)[43:org.apache.karaf.shell.osgi:2.3.2] at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:38)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:35)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:474)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:400)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:89)[14:org.apache.karaf.shell.console:2.3.2] at org.apache.karaf.shell.console.jline.Console.run(Console.java:173)[14:org.apache.karaf.shell.console:2.3.2] at java.lang.Thread.run(Thread.java:724)[:1.7.0_25]Caused by: org.dozer.MappingException: java.lang.ClassNotFoundException: org.dozer.util.DefaultClassLoader at org.dozer.util.MappingUtils.throwMappingException(MappingUtils.java:82) at org.dozer.util.DefaultClassLoader.loadClass(DefaultClassLoader.java:38) at org.dozer.DozerInitializer.loadBeanType(DozerInitializer.java:115) at org.dozer.DozerInitializer.initialize(DozerInitializer.java:97) at org.dozer.DozerInitializer.init(DozerInitializer.java:74) at org.dozer.DozerBeanMapper.init(DozerBeanMapper.java:173) at org.dozer.DozerBeanMapper.&lt;init&gt;(DozerBeanMapper.java:99) at org.dozer.DozerBeanMapper.&lt;init&gt;(DozerBeanMapper.java:94) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)[:1.7.0_25] at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)[:1.7.0_25] at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)[:1.7.0_25] at java.lang.reflect.Constructor.newInstance(Constructor.java:526)[:1.7.0_25] at org.apache.aries.blueprint.utils.ReflectionUtils.newInstance(ReflectionUtils.java:329)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BeanRecipe.newInstance(BeanRecipe.java:962)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BeanRecipe.getInstance(BeanRecipe.java:331)[7:org.apache.aries.blueprint.core:1.1.0] ... 39 moreCaused by: java.lang.ClassNotFoundException: org.dozer.util.DefaultClassLoader at java.net.URLClassLoader$1.run(URLClassLoader.java:366)[:1.7.0_25] at java.net.URLClassLoader$1.run(URLClassLoader.java:355)[:1.7.0_25] at java.security.AccessController.doPrivileged(Native Method)[:1.7.0_25] at java.net.URLClassLoader.findClass(URLClassLoader.java:354)[:1.7.0_25] at java.lang.ClassLoader.loadClass(ClassLoader.java:424)[:1.7.0_25] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)[:1.7.0_25] at java.lang.ClassLoader.loadClass(ClassLoader.java:357)[:1.7.0_25] at java.lang.Class.forName0(Native Method)[:1.7.0_25] at java.lang.Class.forName(Class.java:270)[:1.7.0_25] at org.apache.commons.lang3.ClassUtils.getClass(ClassUtils.java:823) at org.apache.commons.lang3.ClassUtils.getClass(ClassUtils.java:889) at org.apache.commons.lang3.ClassUtils.getClass(ClassUtils.java:872) at org.dozer.util.DefaultClassLoader.loadClass(DefaultClassLoader.java:36) ... 52 more",
            "id": "6683"
        },
        "6687": {
            "ground_truth": "0",
            "bug_report": "Using simple language OGNL expressions doesn't work for Bean Binding when a field is null\nThe following functionality doesn't work  when one of the fields is null: http://camel.apache.org/bean-binding.htmlYou can also use the OGNL support of the Simple expression language. Now suppose the message body is an object which has a method named asXml. To invoke the asXml method we can do as follows:.bean(OrderService.class  'doSomething(${body.asXml}  ${header.high})')Instead of using .bean as shown in the examples above  you may want to use .to instead as shown:.to('bean:orderService?method=doSomething(${body.asXml}  ${header.high})')A test case is provided. Instead of getting values of fields 'foo' and 'bar' respectively  the first parameter (which should be null) receives value of pojo.toString()  while the second parameter receives the correct value.",
            "id": "6687"
        },
        "6690": {
            "ground_truth": "1",
            "bug_report": "Memory leak SoapOutInterceptor.writeSoapEnvelopeStart with security headers\nWhen proxying the WS-Security request through camel route with CXF_MESSAGE data format  we will get the endless loop that eat up the memory.'qtp967241364-210' prio=10 tid=0x00007f1de4306800 nid=0x1c9f runnable [0x00007f1d8d451000] java.lang.Thread.State: RUNNABLE at org.apache.cxf.staxutils.W3CDOMStreamWriter.writeCharacters(W3CDOMStreamWriter.java:292) at org.apache.cxf.staxutils.DelegatingXMLStreamWriter.writeCharacters(DelegatingXMLStreamWriter.java:91) at org.apache.cxf.staxutils.StaxUtils.copy(StaxUtils.java:588) at org.apache.cxf.staxutils.StaxUtils.copy(StaxUtils.java:564) at org.apache.cxf.staxutils.StaxUtils.copy(StaxUtils.java:542) at org.apache.cxf.binding.soap.interceptor.SoapOutInterceptor.writeSoapEnvelopeStart(SoapOutInterceptor.java:160) at org.apache.cxf.binding.soap.interceptor.SoapOutInterceptor.handleMessage(SoapOutInterceptor.java:81) at org.apache.cxf.binding.soap.interceptor.SoapOutInterceptor.handleMessage(SoapOutInterceptor.java:61) at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:262) - locked &lt;0x00000000e28af4a0&gt; (a org.apache.cxf.phase.PhaseInterceptorChain) at org.apache.cxf.endpoint.ClientImpl.doInvoke(ClientImpl.java:530) at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:456) at org.apache.camel.component.cxf.CxfProducer.process(CxfProducer.java:112) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:122) at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:298) at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:117) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:91) at org.apache.camel.processor.interceptor.HandleFaultInterceptor.process(HandleFaultInterceptor.java:41) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.fabric.FabricTraceProcessor.process(FabricTraceProcessor.java:81) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:334) at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:220) at org.apache.camel.processor.interceptor.StreamCachingInterceptor.process(StreamCachingInterceptor.java:52) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.interceptor.DefaultChannel.process(DefaultChannel.java:308) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.Pipeline.process(Pipeline.java:117) at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) at org.apache.camel.processor.RouteContextProcessor.processNext(RouteContextProcessor.java:46) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.processor.UnitOfWorkProcessor.processAsync(UnitOfWorkProcessor.java:150) at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:117) at org.apache.camel.processor.RouteInflightRepositoryProcessor.processNext(RouteInflightRepositoryProcessor.java:48) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:73) at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:99) at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:90) at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:73) at org.apache.camel.component.cxf.CxfConsumer$1.asyncInvoke(CxfConsumer.java:93) - locked &lt;0x00000000e2533d18&gt; (a org.apache.cxf.transport.http_jetty.continuations.JettyContinuationWrapper) at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:72) at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334) at java.util.concurrent.FutureTask.run(FutureTask.java:166) at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37) at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:107) - locked &lt;0x00000000e28af958&gt; (a org.apache.cxf.interceptor.ServiceInvokerInterceptor$2) at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:262) - locked &lt;0x00000000e26edb48&gt; (a org.apache.cxf.phase.PhaseInterceptorChain) at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121) at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:236) at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:214) at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:194) at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:130) at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:221) at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doPost(AbstractHTTPServlet.java:141) at javax.servlet.http.HttpServlet.service(HttpServlet.java:713) at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:197) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.ops4j.pax.web.service.internal.HttpServiceStarted$1.invoke(HttpServiceStarted.java:182) at org.ops4j.pax.web.service.internal.$Proxy6.service(Unknown Source) at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:652) at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:447) at org.ops4j.pax.web.service.jetty.internal.HttpServiceServletHandler.doHandle(HttpServiceServletHandler.java:70) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:137) at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:534) at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:227) at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1038) at org.ops4j.pax.web.service.jetty.internal.HttpServiceContext.doHandle(HttpServiceContext.java:117) at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:374) at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:189) at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:972) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135) at org.ops4j.pax.web.service.jetty.internal.JettyServerHandlerCollection.handle(JettyServerHandlerCollection.java:75) at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116) at org.eclipse.jetty.server.Server.handle(Server.java:363) at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:483) at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:931) at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:992) at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:856) at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:235) at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82) at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:627) at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:51) at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608) at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543) at java.lang.Thread.run(Thread.java:724)",
            "id": "6690"
        },
        "6691": {
            "ground_truth": "0",
            "bug_report": "seda - queue size compare should use equals\nSee nabblehttp://camel.465427.n5.nabble.com/Camel-2-11-1-SedaComponent-issues-with-Queue-size-tp5738258.html",
            "id": "6691"
        },
        "6695": {
            "ground_truth": "0",
            "bug_report": "mbeansRegistered in DefaultManagementAgent isn't ThreadSafe\nThis is more or less a 'corner-case' I stumbled upon  thoughthe HashSet/HashMap (2.5/2.10 camel versions) in the DefaultManagementAgent containing the registered Mbean mbeansRegistered isn't Thread-Safe. This has been an issue for us while using the ProducerTemplate in a wrongful way  by instantiating the ProducerTemplate during every Route run. As this might be a common mistake by users I'd suggest to improve the mbeansRegistered by using a Synchronized Map.",
            "id": "6695"
        },
        "6697": {
            "ground_truth": "0",
            "bug_report": "camel-test-blueprint - Allow to register custom services in OSGi registry before Camel starts\nIf you have some services your Camel apps uses during testing  then its not easy to enlist them before CamelContext starts.We should allow people to enlist services from the unit test class  so they can enlist mock services / shared services that are mocked or what  so they can do their unit tests.",
            "id": "6697"
        },
        "6700": {
            "ground_truth": "0",
            "bug_report": "camel-blueprint - Using  and referrring to SSLContextParameters with property placeholders can lead to CircularDependencyException\nConfiguring a blueprint xml file with &lt;endpoint id='myNettyServer' uri='netty-http:http://0.0.0.0:{{port}}/foo?ssl=true&amp;amp;sslContextParameters=#mySsl'/&gt;Can lead to ciruclar exceptionsCaused by: org.apache.aries.blueprint.di.CircularDependencyException: [BeanRecipe[name='mySsl']  BeanRecipe[name='.camelBlueprint.factory.mySsl']  BeanRecipe[name='camel-4']  BeanRecipe[name='myNettyServer']  BeanRecipe[name='mySsl']] at org.apache.aries.blueprint.container.BlueprintRepository.push(BlueprintRepository.java:343)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:71)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:245)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintRepository.createInstance(BlueprintRepository.java:230)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintRepository.create(BlueprintRepository.java:145)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.aries.blueprint.container.BlueprintContainerImpl.getComponentInstance(BlueprintContainerImpl.java:746)[7:org.apache.aries.blueprint.core:1.1.0] at org.apache.camel.blueprint.BlueprintContainerRegistry.lookupByNameAndType(BlueprintContainerRegistry.java:54) at org.apache.camel.impl.CompositeRegistry.lookupByNameAndType(CompositeRegistry.java:52) ... 125 more",
            "id": "6700"
        },
        "6705": {
            "ground_truth": "0",
            "bug_report": "DefaultStreamCachingStrategy - Check for enabled in shouldSpoolCache method\nIf stream caching is disabled then we should not spool to disk. This allows components and whatnot to safely use CachedOutputStream and not cause spool to disk  even if stream caching is disabled.",
            "id": "6705"
        },
        "6709": {
            "ground_truth": "0",
            "bug_report": "camel-yammer - Endpoint yammer:current throwns JsonMappingException exception\nGetting org.codehaus.jackson.map.JsonMappingException: Can not deserialize instance of java.util.ArrayList out of START_OBJECT tokenwhen trying to return the current user using yammer:current. Workaround is to just add ?useJson=true and do marshaling manually. Fixing on master shortly.",
            "id": "6709"
        },
        "6714": {
            "ground_truth": "0",
            "bug_report": "Installation of camel-stomp feature fails\nChristians-MacBook-Pro:bin cmueller$ ./karaf clean __ __ ____ / //_/____ __________ _/ __/ /  &lt; / __ '/ ___/ __ '/ /_ / /| |/ /_/ / / / /_/ / __/ /_/ |_|/__ _/_/ /__ _/_/ Apache Karaf (2.3.2)Hit '&lt;tab&gt;' for a list of available commandsand '[cmd] --help' for help on a specific command.Hit '&lt;ctrl-d&gt;' or type 'osgi:shutdown' or 'logout' to shutdown Karaf.karaf@root&gt; features:chooseurl camel 2.12.0adding feature url mvn:org.apache.camel.karaf/apache-camel/2.12.0/xml/featureskaraf@root&gt; features:install camel-stompError executing command: Could not start bundle mvn:org.apache.geronimo.specs/geronimo-jms_1.1_spec/1.1.1 in feature(s) spring-jms-3.1.4.RELEASE  camel-spring-ws-2.12.0  spring-jms-3.2.3.RELEASE  spring-jms-3.0.7.RELEASE  camel-jms-2.12.0  camel-bam-2.12.0  camel-stomp-2.12.0  camel-sjms-2.12.0  camel-jpa-2.12.0: Unresolved constraint in bundle org.apache.geronimo.specs.geronimo-jms_1.1_spec [62]: Unable to resolve 62.0: missing requirement [62.0] osgi.wiring.package; (osgi.wiring.package=javax.transaction.xa)",
            "id": "6714"
        },
        "6722": {
            "ground_truth": "0",
            "bug_report": "binding component - Should start/stop its child services\nWe should ensure all the child services the binding component create is also started/stopped so they can do initialization logic.",
            "id": "6722"
        },
        "6725": {
            "ground_truth": "0",
            "bug_report": "Add cache option to beanRef and  in the DSL\nAdded cache option to beanRef and &lt;bean&gt; in the DSL. This avoids looking up the Bean from the Registry on each usage; this can safely be done for singleton beans.",
            "id": "6725"
        },
        "6726": {
            "ground_truth": "0",
            "bug_report": "Camel-Redis: Serializer passed through URI is used only on consumer\nPlease add camel-redis componentThe serializer passed through URI is used only on consumer and not on producer. Beside been unexpected and undocumented I think it can cause problems on interacting with the Redis DB if the same serializer is not used in both ways.You can find the example and discussion of this problem on this thread on the forum:http://camel.465427.n5.nabble.com/camel-redis-strings-serialization-td5738994.htmlI put as minor because from the discussion it looks like it is possible to have a workaround using a RedisTemplate.",
            "id": "6726"
        },
        "6727": {
            "ground_truth": "0",
            "bug_report": "XML Signature Component: Stream not closed in XmlSignerHelper.getXslTransform(String path)\nComponent camel-xmlsecurity: InputStream is not closed after it is read in method XmlSignerHelper.getXslTransform(String path)",
            "id": "6727"
        },
        "6729": {
            "ground_truth": "0",
            "bug_report": "camel-jt400 - no longer able to configure a pollStrategy on Jt400DataQueueEndpoint\nWith camel 2.11.0 we were able to configure a pollStrategy in the URL of an endpoint consuming information from a data queue.After upgrading to 2.12.0 we get an exception during camel startup stating 'Unknown consumer parameters=[{pollStrategy=#jt400PollStrategy}]'. The application no longer starts.Downgrading to 2.11.0 allows the application to be started normally.The problem seems to originate from the fact that Camel (in DefaultPollingEndpoint.createConsumer()) creates a new DefaultScheduledPollConsumer  which gets the poll strategy (no problem). Then afterwards in Jt400DataQueueEndpoint.createPollingConsumer() a Jt400DataQueueConsumer is created and inside configureConsumer() normal flow is stopped because there is no pollStrategy property in a Jt400DataQueueConsumer  and there is an entry for this property in the endpoint's consumerProperties map.I suspect that the consumerProperty pollStrategy should be removed from the endpoint's consumerProperties after it has been set on the DefaultScheduledPollConsumer...",
            "id": "6729"
        },
        "6749": {
            "ground_truth": "0",
            "bug_report": "mustache component - Should use app class loader to load templates\nIt uses the TCCL to load the templates. We should use the App CL which then would allow to better load templates from OSGi.",
            "id": "6749"
        },
        "6752": {
            "ground_truth": "0",
            "bug_report": "Bean binding to covariant methods throws AmbiguousMethodCallException\nAttached is a patch and test case for an issue in the bean binding code which prevents binding to an overloaded method with a covariant return type from the base class. The fix is to check for method covariance at the last moment before throwing AmbiguousMethodCallException. If all methods remaining are covariant  any one of them can be called. Unfortunately this happens in 3 places in the code- if we pre-filtered the list of methods then we could lose annotations on either of the method signature which could be problematic depending on the resolution type.",
            "id": "6752"
        },
        "6754": {
            "ground_truth": "0",
            "bug_report": "UnitUtilsTest cant manage a locale different from US\nWhen locale is set to a language different from english (for example italian)  the unit test in org.apache.camel.util.UnitUtilsTest fail  because in the italian locale the decimal separator is the comma  not the dot.The test compare the results of printUnitFromBytes to static strings formatted with the dot  and in an italian locale fails because it espects '1.0' and get instead '1 0'.I have patched the test code to make it works in every locale (building the expected results with the current locale decimal separator)  and i have attached the patch to this issue.",
            "id": "6754"
        },
        "6757": {
            "ground_truth": "0",
            "bug_report": "scp task does not respect StrictHostKeyChecking option\nThe SCP component does not currently do anything with the StrictHostKeyChecking option  as documented. The attached patch fixes this (no test case I'm afraid).",
            "id": "6757"
        },
        "6758": {
            "ground_truth": "1",
            "bug_report": "Null Pointer exception when removing SjmsComponent\nNullPointer exception in SjmsComponent when trying to remove it from camel context:2013-09-16 11:51:54 201 &#91;WARN&#93; org.apache.camel.impl.DefaultCamelContext.removeComponent(DefaultCamelContext.java:388):org.apache.camel.spring.SpringCamelContext: Error stopping component org.apache.camel.component.sjms.SjmsComponent@232560ec. This exception will be ignored.java.lang.NullPointerException at org.apache.camel.component.sjms.SjmsComponent.doStop(SjmsComponent.java:143) at org.apache.camel.support.ServiceSupport.stop(ServiceSupport.java:102) at org.apache.camel.util.ServiceHelper.stopService(ServiceHelper.java:116) at org.apache.camel.impl.DefaultCamelContext.stopServices(DefaultCamelContext.java:1902) at org.apache.camel.impl.DefaultCamelContext.removeComponent(DefaultCamelContext.java:386)",
            "id": "6758"
        },
        "6762": {
            "ground_truth": "0",
            "bug_report": "HttpConnectionManagerParams doesn't take effect when it is set to HttpComponent\nHere is the user complain.It is caused by the patch of CAMEL-6296 which override the setting of HttpConnectionManagerParams.",
            "id": "6762"
        },
        "6766": {
            "ground_truth": "0",
            "bug_report": "InterceptFrom - Add support for using property placeholders\nInterceptFrom does not support property placeholders. We should add support for that.Seehttp://camel.465427.n5.nabble.com/Usage-of-property-placeholders-in-the-interceptFrom-String-method-calls-tp5739273.html",
            "id": "6766"
        },
        "6767": {
            "ground_truth": "0",
            "bug_report": "rabbitmq component sends basic ack after channel closed when endpoint is set to autoAck\nConsuming from a rabbitmq endpoint uri that is configured to autoAck generates errors and fails.Example URI: rabbitmq://localhost:5672/test?autoAck=true&amp;queue=test&amp;autoDelete=false&amp;username=guest&amp;password=guestHere's the relevant log output:12:19:03.746 - osis-ht TRACE o.a.c.c.rabbitmq.RabbitMQConsumer - Acknowleding receipt &#91;delivery_tag=10&#93;12:19:03.747 - osis-ht WARN o.a.c.c.rabbitmq.RabbitMQConsumer - Error processing exchange. Exchange&#91;Message: WTF-9-1379531943713&#93;. Caused by: &#91;com.rabbitmq.client.AlreadyClosedException - clean connection shutdown; reason: Attempt to use closed channel&#93;com.rabbitmq.client.AlreadyClosedException: clean connection shutdown; reason: Attempt to use closed channel at com.rabbitmq.client.impl.AMQChannel.ensureIsOpen(AMQChannel.java:190) ~&#91;amqp-client-3.1.3.jar:na&#93; at com.rabbitmq.client.impl.AMQChannel.transmit(AMQChannel.java:291) ~&#91;amqp-client-3.1.3.jar:na&#93; at com.rabbitmq.client.impl.AMQChannel.transmit(AMQChannel.java:285) ~&#91;amqp-client-3.1.3.jar:na&#93; at com.rabbitmq.client.impl.ChannelN.basicAck(ChannelN.java:907) ~&#91;amqp-client-3.1.3.jar:na&#93; at org.apache.camel.component.rabbitmq.RabbitMQConsumer$RabbitConsumer.handleDelivery(RabbitMQConsumer.java:126) ~&#91;camel-rabbitmq-2.12.0.jar:2.12.0&#93; at com.rabbitmq.client.impl.ConsumerDispatcher$4.run(ConsumerDispatcher.java:121) &#91;amqp-client-3.1.3.jar:na&#93; at com.rabbitmq.client.impl.ConsumerWorkService$WorkPoolRunnable.run(ConsumerWorkService.java:76) &#91;amqp-client-3.1.3.jar:na&#93; at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) &#91;na:1.7.0_21&#93; at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) &#91;na:1.7.0_21&#93; at java.lang.Thread.run(Thread.java:722) &#91;na:1.7.0_21&#93;",
            "id": "6767"
        }
    }
}