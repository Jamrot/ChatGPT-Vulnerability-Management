{"PR": {"nfsd_check_ignore_resizing": {"ground_truth": "1", "function": "nfsd_check_ignore_resizing", "description": "nfsd check ignore resizinghpux client sometimes creates file in mode and set size to setting size to may fail for some specific file system by the permission checking which requires write permission but the mode is we ignore the resizing to on the just new created file since the size is after file created call this only after vfs create is called", "id": "nfsd_check_ignore_resizing"}, "init_pci_cap_basic_perm": {"ground_truth": "1", "function": "init_pci_cap_basic_perm", "description": "init pci cap basic perm permissions for the basic pci header", "id": "init_pci_cap_basic_perm"}, "tomoyo_socket_listen": {"ground_truth": "1", "function": "tomoyo_socket_listen", "description": "tomoyo socket listen check permission for listen return on success negative value otherwise", "id": "tomoyo_socket_listen"}, "ceph_permission": {"ground_truth": "1", "function": "ceph_permission", "description": "ceph permission check inode permission we verify we have valid value for the auth cap then call the generic handler", "id": "ceph_permission"}, "b43legacy_validate_chipaccess": {"ground_truth": "1", "function": "b43legacy_validate_chipaccess", "description": "b43legacy validate chip access validate access to the chip shm", "id": "b43legacy_validate_chipaccess"}, "rio_mport_chk_dev_access": {"ground_truth": "1", "function": "rio_mport_chk_dev_access", "description": "rio mport chk dev access validate access to the specified device", "id": "rio_mport_chk_dev_access"}, "security_compute_av": {"ground_truth": "1", "function": "security_compute_av", "description": "security compute av compute access vector decision compute set of access vector decision based on the sid pair ssid tsid for the permission in tclass", "id": "security_compute_av"}, "apparmor_socket_setsockopt": {"ground_truth": "1", "function": "apparmor_socket_setsockopt", "description": "apparmor socket setsockopt check perm before setting socket option", "id": "apparmor_socket_setsockopt"}, "zonefs_check_zone_condition": {"ground_truth": "1", "function": "zonefs_check_zone_condition", "description": "zonefs check zone condition check zone condition and adjust it file inode access permission for offline and readonly zone return the inode size corresponding to the amount of readable data in the zone", "id": "zonefs_check_zone_condition"}, "cap_inode_need_killpriv": {"ground_truth": "1", "function": "cap_inode_need_killpriv", "description": "cap inode need killpriv determine if inode change affect privilege determine if an inode having change applied that is marked attr kill priv affect the security marking on that inode and if it is should inode killpriv be invoked or the change rejected return if security capability ha value meaning inode killpriv is required otherwise meaning inode killpriv is not required", "id": "cap_inode_need_killpriv"}, "devcgroup_update_access": {"ground_truth": "1", "function": "devcgroup_update_access", "description": "devcgroup update access modify the exception list using allow deny rule cap sys admin is needed for this it is at least separate from cap mknod so we can give container cap mknod to let it create device but not modify the exception list it seems likely we will want to add cap container capability to allow u to also grant cap sys admin to container without giving away the device exception list control but for now we will stick with cap sys admin taking rule away is always allowed given cap sys admin granting new access is only allowed if you are in the top level cgroup or your parent cgroup ha the access you are asking for", "id": "devcgroup_update_access"}, "igc_acquire_phy_base": {"ground_truth": "1", "function": "igc_acquire_phy_base", "description": "igc acquire phy base acquire right to access phy acquire access right to the correct phy this is function pointer entry point called by the api module", "id": "igc_acquire_phy_base"}, "cap_inode_getsecurity": {"ground_truth": "1", "function": "cap_inode_getsecurity", "description": "cap inode getsecurity getsecurity we are called for security before any attempt to read the xattr from the inode itself this give u chance to read the on disk value and convert it if we", "id": "cap_inode_getsecurity"}, "tomoyo_check_inet_acl": {"ground_truth": "1", "function": "tomoyo_check_inet_acl", "description": "tomoyo check inet acl check permission for inet domain socket operation return true if granted false otherwise", "id": "tomoyo_check_inet_acl"}, "services_compute_xperms_drivers": {"ground_truth": "1", "function": "services_compute_xperms_drivers", "description": "service compute xperms driver flag which driver have permission only looking for ioctl based extended permssions", "id": "services_compute_xperms_drivers"}, "ptracer_capable": {"ground_truth": "1", "function": "ptracer_capable", "description": "ptracer capable determine if the ptracer hold cap sys ptrace in the namespace return true if the task that is ptracing the current task had cap sys ptrace in the specified user namespace", "id": "ptracer_capable"}, "nfsacld_proc_access": {"ground_truth": "1", "function": "nfsacld_proc_access", "description": "nfsacld proc access check file access", "id": "nfsacld_proc_access"}, "security_netlbl_cache_add": {"ground_truth": "0", "function": "security_netlbl_cache_add", "description": "security netlbl cache add add an entry to the netlabel cache attempt to cache the context in ctx which wa derived from the packet in skb in the netlabel subsystem cache this function assumes secattr ha already been initialized", "id": "security_netlbl_cache_add"}, "has_ns_capability": {"ground_truth": "1", "function": "has_ns_capability", "description": "ha n capability doe task have capability in specific user n return true if the specified task ha the given superior capability currently in effect to the specified user namespace false if not note that this doe not set pf superpriv on the task", "id": "has_ns_capability"}, "aa_capable": {"ground_truth": "1", "function": "aa_capable", "description": "aa capable test permission to use capability look up capability in profile capability set", "id": "aa_capable"}, "handle_privileged_root": {"ground_truth": "1", "function": "handle_privileged_root", "description": "handle privileged root handle privileged root handle case of privileged root handle the case where root is privileged and ha not been neutered by secure noroot if file capability are set they will not be combined with set uid root and nothing is changed if we are root cap permitted is updated if we have become set uid root the effective bit is set", "id": "handle_privileged_root"}, "ns_capable_noaudit": {"ground_truth": "1", "function": "ns_capable_noaudit", "description": "n capable noaudit determine if the current task ha superior capability unaudited in effect return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used", "id": "ns_capable_noaudit"}, "__get_dumpable": {"ground_truth": "1", "function": "__get_dumpable", "description": "get dumpable this return the actual value of the suid dumpable flag for thing that are using this for checking for privilege transition it must test against suid dump user rather than treating it a boolean value", "id": "__get_dumpable"}, "rio_chk_dev_access": {"ground_truth": "1", "function": "rio_chk_dev_access", "description": "rio chk dev access validate access to the specified device", "id": "rio_chk_dev_access"}, "common_perm_cond": {"ground_truth": "1", "function": "common_perm_cond", "description": "common perm cond common permission wrapper around inode cond", "id": "common_perm_cond"}, "security_fs_use": {"ground_truth": "1", "function": "security_fs_use", "description": "security f use determine how to handle labeling for filesystem", "id": "security_fs_use"}, "keyctl_get_security": {"ground_truth": "1", "function": "keyctl_get_security", "description": "keyctl get security get key is the lsm security label the key must grant the caller view permission for this to work if there is buffer then up to buflen byte of data will be placed into it if successful the amount of information available will be returned irrespective of how much wa copied including the terminal nul", "id": "keyctl_get_security"}, "ns_capable_setid": {"ground_truth": "1", "function": "ns_capable_setid", "description": "n capable setid determine if the current task ha superior capability in effect while signalling that this check is being done from within setid or setgroups syscall return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used", "id": "ns_capable_setid"}, "tomoyo_mount_permission": {"ground_truth": "1", "function": "tomoyo_mount_permission", "description": "tomoyo mount permission check permission for mount operation return on success negative value otherwise", "id": "tomoyo_mount_permission"}, "proc_fd_access_allowed": {"ground_truth": "1", "function": "proc_fd_access_allowed", "description": "proc fd access allowedpermission check", "id": "proc_fd_access_allowed"}, "tomoyo_check_mount_acl": {"ground_truth": "1", "function": "tomoyo_check_mount_acl", "description": "tomoyo check mount acl check permission for path path path number operation return true if granted false otherwise", "id": "tomoyo_check_mount_acl"}, "fault_in_user_writeable": {"ground_truth": "1", "function": "fault_in_user_writeable", "description": "fault in user writeable fault in user address and verify rw access slow path to fixup the fault we just took in the atomic write access to uaddr we have no generic implementation of non destructive write to the user address we know that we faulted in the atomic pagefault disabled section so we can a well avoid the pf overhead by calling get user page right away", "id": "fault_in_user_writeable"}, "security_policycap_supported": {"ground_truth": "1", "function": "security_policycap_supported", "description": "security policycap supported check for specific policy capability this function query the currently loaded policy to see if it support the capability specified by req cap return true if the capability is supported false if it is not supported", "id": "security_policycap_supported"}, "tomoyo_env_perm": {"ground_truth": "1", "function": "tomoyo_env_perm", "description": "tomoyo env perm check permission for environment variable is name return on success negative value otherwise caller hold tomoyo read lock", "id": "tomoyo_env_perm"}, "__kcsan_check_write": {"ground_truth": "1", "function": "__kcsan_check_write", "description": "kcsan check write check regular write access for race", "id": "__kcsan_check_write"}, "security_netif_sid": {"ground_truth": "1", "function": "security_netif_sid", "description": "security netif sid obtain the sid for network interface", "id": "security_netif_sid"}, "smack_key_permission": {"ground_truth": "1", "function": "smack_key_permission", "description": "smack key permission smack access on key return if the task ha read and write to the object an error code otherwise", "id": "smack_key_permission"}, "siw_check_sgl_tx": {"ground_truth": "1", "function": "siw_check_sgl_tx", "description": "siw check sgl tx siw check sgl tx check permission for list of sge is sgl successful check will have all memory referenced for transmission resolved and assigned to the wqe", "id": "siw_check_sgl_tx"}, "permission_fault": {"ground_truth": "1", "function": "permission_fault", "description": "permission fault check if given access described through the and bit of page fault error code pfec cause permission fault with the given pte access right in acc format", "id": "permission_fault"}, "i40e_check_vf_permission": {"ground_truth": "1", "function": "i40e_check_vf_permission", "description": "i40e check vf permission check that the given list of mac address is allowed will return eperm if any address in the list is not valid check the following condition broadcast and zero address are never valid unicast address are not allowed if the vmm ha administratively set the vf mac address unless the vf is marked a privileged there is enough space to add all the address note that to guarantee consistency it is expected this function be called while holding the mac filter hash lock a otherwise the current number of address might not be accurate", "id": "i40e_check_vf_permission"}, "netlink_net_capable": {"ground_truth": "1", "function": "netlink_net_capable", "description": "netlink net capable netlink network namespace message capability test test to see if the opener of the socket we received the message from had when the netlink socket wa created and the sender of the message ha the capability cap over the network namespace of the socket we received the message from", "id": "netlink_net_capable"}, "vq_log_access_ok": {"ground_truth": "1", "function": "vq_log_access_ok", "description": "vq log access ok verify access for write logging", "id": "vq_log_access_ok"}, "netlbl_sock_getattr": {"ground_truth": "1", "function": "netlbl_sock_getattr", "description": "netlbl sock getattr determine the security attribute of sock examines the given sock to see if any netlabel style labeling ha been applied to the sock if so it par the socket label and return the security attribute in secattr return zero on success negative value on failure", "id": "netlbl_sock_getattr"}, "posix_acl_permission": {"ground_truth": "1", "function": "posix_acl_permission", "description": "posix acl permissionreturn if current is granted want access to the inode by the acl return otherwise", "id": "posix_acl_permission"}, "smack_ipc_permission": {"ground_truth": "1", "function": "smack_ipc_permission", "description": "smack ipc permission smack access for ipc permission return if current ha read and write access error code otherwise", "id": "smack_ipc_permission"}, "tomoyo_check_unix_address": {"ground_truth": "1", "function": "tomoyo_check_unix_address", "description": "tomoyo check unix address check permission for unix domain socket is operation return on success negative value otherwise", "id": "tomoyo_check_unix_address"}, "cachefiles_determine_cache_security": {"ground_truth": "1", "function": "cachefiles_determine_cache_security", "description": "cachefiles determine cache security check the security detail of the on disk cache must be called with security override in force must return with security override in force even in the case of an error", "id": "cachefiles_determine_cache_security"}, "hci_conn_check_link_mode": {"ground_truth": "1", "function": "hci_conn_check_link_mode", "description": "hci conn check link modecheck link security requirement", "id": "hci_conn_check_link_mode"}, "tomoyo_mkdev_perm": {"ground_truth": "1", "function": "tomoyo_mkdev_perm", "description": "tomoyo mkdev perm check permission for mkblock and mkchar return on success negative value otherwise", "id": "tomoyo_mkdev_perm"}, "smk_tskacc": {"ground_truth": "1", "function": "smk_tskacc", "description": "smk tskacc determine if task ha specific access to an object this function check the subject task is label object label pair in the access rule list and return if the access is permitted non zero otherwise it allows that the task may have the capability to override the rule", "id": "smk_tskacc"}, "netlink_capable": {"ground_truth": "1", "function": "netlink_capable", "description": "netlink capable netlink global message capability test test to see if the opener of the socket we received the message from had when the netlink socket wa created and the sender of the message ha the capability cap in all user namespaces", "id": "netlink_capable"}, "security_netlbl_secattr_to_sid": {"ground_truth": "1", "function": "security_netlbl_secattr_to_sid", "description": "security netlbl secattr to sid convert netlabel secattr to selinux sid convert the given netlabel security attribute in secattr into selinux sid if the secattr field doe not contain full selinux sid context then use secinitsid netmsg a the foundation if possible the cache field of secattr is set and the cache flag is set this is to allow the secattr to be used by netlabel to cache the secattr to sid conversion for future lookup return zero on success negative value on failure", "id": "security_netlbl_secattr_to_sid"}, "sk_ns_capable": {"ground_truth": "1", "function": "sk_ns_capable", "description": "sk n capable general socket capability test test to see if the opener of the socket had when the socket wa created and the current process ha the capability cap in the user namespace user n", "id": "sk_ns_capable"}, "_scsih_check_access_status": {"ground_truth": "1", "function": "_scsih_check_access_status", "description": "scsih check access status check access flag", "id": "_scsih_check_access_status"}, "netlbl_skbuff_getattr": {"ground_truth": "1", "function": "netlbl_skbuff_getattr", "description": "netlbl skbuff getattr determine the security attribute of packet examines the given packet to see if recognized form of packet labeling is present if so it par the packet label and return the security attribute in secattr return zero on success negative value on failure", "id": "netlbl_skbuff_getattr"}, "keyctl_setperm_key": {"ground_truth": "1", "function": "keyctl_setperm_key", "description": "keyctl setperm key change the permission mask on key the key must grant the caller setattr permission for this to work though the key need not be fully instantiated yet if the caller doe not have sysadmin capability it may only change the permission on key that it owns", "id": "keyctl_setperm_key"}, "apparmor_socket_getsockopt": {"ground_truth": "1", "function": "apparmor_socket_getsockopt", "description": "apparmor socket getsockopt check perm before getting socket option", "id": "apparmor_socket_getsockopt"}, "common_perm_rm": {"ground_truth": "1", "function": "common_perm_rm", "description": "common perm rm common permission wrapper for operation doing rm", "id": "common_perm_rm"}, "genwqe_is_privileged": {"ground_truth": "1", "function": "genwqe_is_privileged", "description": "genwqe is privileged genwqe is privileged determine operation mode for pci function on intel with sriov support we see pf is physfn is virtfn vf is physfn is virtfn on system with no sriov support and virtualized system we get is physfn is virtfn other vendor have individual pci device id to distinguish between virtual function driver and physical function driver genwqe unfortunately ha just on pci device id for both vfs and pf the following code is used to distinguish if the card is running in privileged mode either a true pf or in virtualized system with full register access currently on powerpc if pci dev is virtfn cd is privileged else cd is privileged genwqe readq cd io slu bitstream io illegal value", "id": "genwqe_is_privileged"}, "tomoyo_check_path_acl": {"ground_truth": "1", "function": "tomoyo_check_path_acl", "description": "tomoyo check path acl check permission for path operation return true if granted false otherwise to be able to use wildcard for domain transition this function set matching entry on success since the caller hold tomoyo read lock it is safe to set matching entry", "id": "tomoyo_check_path_acl"}, "may_linkat": {"ground_truth": "1", "function": "may_linkat", "description": "may linkat check permission for creating hardlink block hardlink when all of sysctl protected hardlinks enabled fsuid doe not match inode hardlink source is unsafe see safe hardlink source above not cap fowner in namespace with the inode owner uid mapped return if successful ve on error", "id": "may_linkat"}, "apparmor_socket_sendmsg": {"ground_truth": "1", "function": "apparmor_socket_sendmsg", "description": "apparmor socket sendmsg check perm before sending msg to another socket", "id": "apparmor_socket_sendmsg"}, "gasket_ioctl_check_permissions": {"ground_truth": "1", "function": "gasket_ioctl_check_permissions", "description": "gasket ioctl check permissionscheck permission for gasket ioctls", "id": "gasket_ioctl_check_permissions"}, "uvc_acquire_privileges": {"ground_truth": "1", "function": "uvc_acquire_privileges", "description": "uvc acquire privilege privilege management is the multiple open implementation basis the current implementation is completely transparent for the end user and doe not require explicit use of the vidioc priority and vidioc priority ioctls those ioctls enable finer control on the device by making possible for user to request exclusive access to device but are not mature yet switching to the v4l2 priority mechanism might be considered in the future if this situation change each open instance of uvc device can either be in privileged or unprivileged state only single instance can be in privileged state at given time trying to perform an operation that requires privilege will automatically acquire the required privilege if possible or return ebusy otherwise privilege are dismissed when closing the instance or when freeing the video buffer using vidioc reqbufs operation that require privilege are vidioc input vidioc parm vidioc fmt vidioc reqbufs", "id": "uvc_acquire_privileges"}, "apparmor_socket_sock_rcv_skb": {"ground_truth": "1", "function": "apparmor_socket_sock_rcv_skb", "description": "apparmor socket sock rcv skb check perm before associating skb to sk dont want protocol specific in skb recv datagram to deny an incoming connection socket sock rcv skb", "id": "apparmor_socket_sock_rcv_skb"}, "keyctl_restrict_keyring": {"ground_truth": "1", "function": "keyctl_restrict_keyring", "description": "keyctl restrict keyring apply restriction to given keyring the caller must have setattr permission to change keyring restriction the requested type name may be null pointer to reject all attempt to link to the keyring in this case restriction must also be null otherwise both type and restriction must be non null", "id": "keyctl_restrict_keyring"}, "tomoyo_check_task_acl": {"ground_truth": "1", "function": "tomoyo_check_task_acl", "description": "tomoyo check task acl check permission for task operation return true if granted false otherwise", "id": "tomoyo_check_task_acl"}, "keyctl_chown_key": {"ground_truth": "1", "function": "keyctl_chown_key", "description": "keyctl chown key change the ownership of key the key must grant the caller setattr permission for this to work though the key need not be fully instantiated yet for the uid to be changed or for the gid to be changed to group the caller is not member of the caller must have sysadmin capability if either uid or gid is then that attribute is not changed if the uid is to be changed the new user must have sufficient quota to accept the key the quota deduction will be removed from the old user to the new user should the attribute be changed if successful will be returned", "id": "keyctl_chown_key"}, "aa_path_perm": {"ground_truth": "1", "function": "aa_path_perm", "description": "aa path perm do permission check audit for path", "id": "aa_path_perm"}, "tomoyo_bprm_check_security": {"ground_truth": "1", "function": "tomoyo_bprm_check_security", "description": "tomoyo bprm check security target for security bprm check return on success negative value otherwise", "id": "tomoyo_bprm_check_security"}, "tomoyo_check_path2_acl": {"ground_truth": "1", "function": "tomoyo_check_path2_acl", "description": "tomoyo check path2 acl check permission for path path operation return true if granted false otherwise", "id": "tomoyo_check_path2_acl"}, "capable_wrt_inode_uidgid": {"ground_truth": "1", "function": "capable_wrt_inode_uidgid", "description": "capable wrt inode uidgid check nsown capable and uid and gid mapped return true if the current task ha the given capability targeted at it own user namespace and that the given inode is uid and gid are mapped into the current user namespace", "id": "capable_wrt_inode_uidgid"}, "aa_path_link": {"ground_truth": "1", "function": "aa_path_link", "description": "aa path link handle hard link permission check handle the permission test for link target pair permission is encoded a pair where the link permission is determined first and if allowed the target is tested the target test is done from the point of the link match not start of dfa making the target permission dependent on the link permission match the subset test if required force that permission granted on link are subset of the permission granted to target", "id": "aa_path_link"}, "atiixp_set_dma_mode": {"ground_truth": "0", "function": "atiixp_set_dma_mode", "description": "atiixp set dma mode set host controller for dma mode", "id": "atiixp_set_dma_mode"}, "e1000e_check_reset_block_generic": {"ground_truth": "0", "function": "e1000e_check_reset_block_generic", "description": "e1000e check reset block generic check if phy reset is blocked", "id": "e1000e_check_reset_block_generic"}, "dev_pm_opp_disable": {"ground_truth": "0", "function": "dev_pm_opp_disable", "description": "dev pm opp disable disable specific opp disables provided opp if the operation is valid this return else the corresponding error value it is meant to be temporary control by user to make this opp not available until the circumstance are right to make it available again with call to dev pm opp enable", "id": "dev_pm_opp_disable"}, "kernfs_enable_ns": {"ground_truth": "0", "function": "kernfs_enable_ns", "description": "kernfs enable n enable namespace under directory this is to be called right after kn is created to enable namespace under it all child of kn must have non null namespace tag and only the one which match the super block is tag will be visible", "id": "kernfs_enable_ns"}, "nfp_net_reconfig_post": {"ground_truth": "0", "function": "nfp_net_reconfig_post", "description": "nfp net reconfig post post async reconfig request record fw reconfiguration request reconfiguration will be kicked off whenever reconfiguration machinery is idle multiple request can be merged together", "id": "nfp_net_reconfig_post"}, "amdtp_am824_set_pcm_position": {"ground_truth": "0", "function": "amdtp_am824_set_pcm_position", "description": "amdtp am824 set pcm position set an index of data channel for channel of pcm frame", "id": "amdtp_am824_set_pcm_position"}, "wakeup_source_register": {"ground_truth": "0", "function": "wakeup_source_register", "description": "wakeup source register create wakeup source and add it to the list", "id": "wakeup_source_register"}, "ice_vsi_update_bridge_mode": {"ground_truth": "0", "function": "ice_vsi_update_bridge_mode", "description": "ice vsi update bridge mode update vsi for switching bridge mode veb vepa return on success negative on failure", "id": "ice_vsi_update_bridge_mode"}, "cros_ec_lpc_mec_in_range": {"ground_truth": "0", "function": "cros_ec_lpc_mec_in_range", "description": "cro ec lpc mec in range determine if address are in mec emi range", "id": "cros_ec_lpc_mec_in_range"}, "intel_cdclk_can_cd2x_update": {"ground_truth": "0", "function": "intel_cdclk_can_cd2x_update", "description": "intel cdclk can cd2x update determine if changing between the two cdclk configuration requires only cd2x divider update", "id": "intel_cdclk_can_cd2x_update"}, "aa_create_aafs": {"ground_truth": "1", "function": "aa_create_aafs", "description": "aa create aafs create the apparmor security filesystem dentries created here are released by aa destroy aafs", "id": "aa_create_aafs"}, "of_irq_to_resource": {"ground_truth": "0", "function": "of_irq_to_resource", "description": "of irq to resource decode node is irq and return it a resource", "id": "of_irq_to_resource"}, "__ice_set_coalesce": {"ground_truth": "0", "function": "__ice_set_coalesce", "description": "ice set coalesce set itr intrl value for the device if the caller pass in negative num then we set the coalesce setting for all tx rx queue else use the actual num passed in", "id": "__ice_set_coalesce"}, "nfs4_init_client": {"ground_truth": "0", "function": "nfs4_init_client", "description": "nfs4 init client initialise an nfs4 client record return pointer to an nfs client or an err ptr value", "id": "nfs4_init_client"}, "dax_get_by_host": {"ground_truth": "0", "function": "dax_get_by_host", "description": "dax get by host temporary lookup mechanism for filesystem dax", "id": "dax_get_by_host"}, "reg_is_init_pkt_pointer": {"ground_truth": "0", "function": "reg_is_init_pkt_pointer", "description": "reg is init pkt pointerunmodified ptr to packet meta end register from ctx access", "id": "reg_is_init_pkt_pointer"}, "iavf_client_virtchnl_send": {"ground_truth": "0", "function": "iavf_client_virtchnl_send", "description": "iavf client virtchnl send send message to the pf instance return on success or on error", "id": "iavf_client_virtchnl_send"}, "tb_switch_next_cap": {"ground_truth": "0", "function": "tb_switch_next_cap", "description": "tb switch next cap return next capability in the linked list find dword offset of the next capability in router config space capability list and return it passing return the first entry in the capability list if no next capability is found return in case of failure return negative errno", "id": "tb_switch_next_cap"}, "cpufreq_get_hardware_limits": {"ground_truth": "0", "function": "cpufreq_get_hardware_limits", "description": "cpufreq get hardware limitsdetermine hardware cpu frequency limit these may be limited further by thermal energy or other consideration by cpufreq policy notifiers in the kernel", "id": "cpufreq_get_hardware_limits"}, "current_clocksource_show": {"ground_truth": "0", "function": "current_clocksource_show", "description": "current clocksource show sysfs interface for current clocksource provides sysfs interface for listing current clocksource", "id": "current_clocksource_show"}, "pxa_ep_set_halt": {"ground_truth": "0", "function": "pxa_ep_set_halt", "description": "pxa ep set halt halt operation on one endpoint return if no error einval erofs eagain otherwise", "id": "pxa_ep_set_halt"}, "ieee80211_get_qos_ctl": {"ground_truth": "0", "function": "ieee80211_get_qos_ctl", "description": "ieee80211 get qos ctl get pointer to qos control byte the qos ctrl byte come after the frame control duration seq num and or address of length eth alen addr addr", "id": "ieee80211_get_qos_ctl"}, "pre_patch_callback": {"ground_truth": "0", "function": "pre_patch_callback", "description": "pre patch callbackexecuted on object patching ie patch enablement", "id": "pre_patch_callback"}, "rnbd_rerun_if_needed": {"ground_truth": "0", "function": "rnbd_rerun_if_needed", "description": "rnbd rerun if needed rerun next queue marked a stopped each cpu ha it is own list of hw queue which should be rerun function find such list with hw queue take list lock pick up the first hw queue out of the list and requeues it", "id": "rnbd_rerun_if_needed"}, "find_devfreq_governor": {"ground_truth": "0", "function": "find_devfreq_governor", "description": "find devfreq governor find devfreq governor from name search the list of devfreq governor and return the matched governor is pointer devfreq list lock should be held by the caller", "id": "find_devfreq_governor"}, "suspend_nvs_save": {"ground_truth": "0", "function": "suspend_nvs_save", "description": "suspend nv save save nv memory region", "id": "suspend_nvs_save"}, "make_field": {"ground_truth": "0", "function": "make_field", "description": "make field make subsequent field of repository node name return field value", "id": "make_field"}, "fm10k_mbx_pushed_tail_len": {"ground_truth": "0", "function": "fm10k_mbx_pushed_tail_len", "description": "fm10k mbx pushed tail len retrieve the length of message being pushed", "id": "fm10k_mbx_pushed_tail_len"}, "drm_mode_dirtyfb_ioctl": {"ground_truth": "0", "function": "drm_mode_dirtyfb_ioctl", "description": "drm mode dirtyfb ioctl flush frontbuffer rendering on an fb lookup the fb and flush out the damaged area supplied by userspace a clip rectangle list generic userspace which doe frontbuffer rendering must call this ioctl to flush out the change on manual update display output usb display link mipi manual update panel or edp panel self refresh mode modesetting driver which always update the frontbuffer do not need to implement the corresponding type drm framebuffer funcs dirty callback called by the user via ioctl", "id": "drm_mode_dirtyfb_ioctl"}, "pch_udc_activate_control_ep": {"ground_truth": "0", "function": "pch_udc_activate_control_ep", "description": "pch udc activate control ep this function enables the control endpoint for traffic after reset", "id": "pch_udc_activate_control_ep"}, "IIO_MOUNT_MATRIX": {"ground_truth": "0", "function": "IIO_MOUNT_MATRIX", "description": "iio mount matrix initialize mount matrix extended channel attribute", "id": "IIO_MOUNT_MATRIX"}, "init_p9": {"ground_truth": "0", "function": "init_p9", "description": "init p9 initialize module", "id": "init_p9"}, "devfreq_suspend_device": {"ground_truth": "0", "function": "devfreq_suspend_device", "description": "devfreq suspend device suspend devfreq of device this function is intended to be called by the pm callback runtime suspend suspend of the device driver that hold the devfreq", "id": "devfreq_suspend_device"}, "_scsih_sas_device_discovery_error_event": {"ground_truth": "0", "function": "_scsih_sas_device_discovery_error_event", "description": "scsih sa device discovery error event display sa device discovery error event", "id": "_scsih_sas_device_discovery_error_event"}, "qed_memset_task_ctx": {"ground_truth": "0", "function": "qed_memset_task_ctx", "description": "qed memset task ctxmemset task context to while preserving validation byte", "id": "qed_memset_task_ctx"}, "nmk_i2c_xfer_one": {"ground_truth": "0", "function": "nmk_i2c_xfer_one", "description": "nmk i2c xfer one transmit single i2c message", "id": "nmk_i2c_xfer_one"}, "gsm_print_packet": {"ground_truth": "0", "function": "gsm_print_packet", "description": "gsm print packet display frame for debug", "id": "gsm_print_packet"}, "soctherm_oc_intr_enable": {"ground_truth": "0", "function": "soctherm_oc_intr_enable", "description": "soctherm oc intr enable enables the soctherm over current interrupt enables specific over current pin alarm to raise an interrupt if the flag is set and the alarm corresponds to oc1 oc2 oc3 or oc4", "id": "soctherm_oc_intr_enable"}, "free_rx_buffers": {"ground_truth": "0", "function": "free_rx_buffers", "description": "free rx buffer free all rx buffer this function will free all rx buffer allocated by host return value none", "id": "free_rx_buffers"}, "fm10k_mbx_process_disconnect": {"ground_truth": "0", "function": "fm10k_mbx_process_disconnect", "description": "fm10k mbx process disconnect process disconnect header", "id": "fm10k_mbx_process_disconnect"}, "xa_for_each_marked": {"ground_truth": "0", "function": "xa_for_each_marked", "description": "xa for each marked iterate over marked entry in an xarray during the iteration entry will have the value of the entry stored in xa at index the iteration will skip all entry in the array which do not match filter you may modify index during the iteration if you want to skip or reprocess index it is safe to modify the array during the iteration at the end of the iteration entry will be set to null and index will have value le than or equal to max xa for each marked is log while xas for each marked is you have to handle your own locking with xas for each and if you have to unlock after each iteration it will also end up being log xa for each marked will spin if it hit retry entry if you intend to see retry entry you should use the xas for each marked iterator instead the xas for each marked iterator will expand into more inline code than xa for each marked", "id": "xa_for_each_marked"}, "i40e_aq_query_vsi_bw_config": {"ground_truth": "0", "function": "i40e_aq_query_vsi_bw_config", "description": "i40e aq query vsi bw config query vsi bw configuration", "id": "i40e_aq_query_vsi_bw_config"}, "siw_query_srq": {"ground_truth": "0", "function": "siw_query_srq", "description": "siw query srq siw query srq query srq attribute", "id": "siw_query_srq"}, "spi_split_transfers_maxsize": {"ground_truth": "0", "function": "spi_split_transfers_maxsize", "description": "spi split transfer maxsize split spi transfer into multiple transfer when an individual transfer exceeds certain size", "id": "spi_split_transfers_maxsize"}, "ipr_reset_freeze": {"ground_truth": "0", "function": "ipr_reset_freeze", "description": "ipr reset freeze hold off all activity if the pci slot is frozen hold off all activity then a soon a the slot is available again initiate an adapter reset", "id": "ipr_reset_freeze"}, "rio_route_add_entry": {"ground_truth": "0", "function": "rio_route_add_entry", "description": "rio route add entry add route entry to switch routing table if available call the switch specific add entry method to add route entry into switch routing table otherwise us standard rt update method a defined by rapidio specification specific routing table can be selected using the table argument if switch ha per port routing table or the standard or global table may be used by passing rio global table in table return on success or einval on failure", "id": "rio_route_add_entry"}, "ieee802154_be16_to_le16": {"ground_truth": "0", "function": "ieee802154_be16_to_le16", "description": "ieee802154 be16 to le16 copy and convert be16 to le16", "id": "ieee802154_be16_to_le16"}, "input_reset_device": {"ground_truth": "0", "function": "input_reset_device", "description": "input reset device reset restore the state of input device this function try to reset the state of an opened input device and bring internal state and state if the hardware in sync with each other we mark all key a released restore led state repeat rate etc", "id": "input_reset_device"}, "ixgbevf_close": {"ground_truth": "0", "function": "ixgbevf_close", "description": "ixgbevf close disables network interface return this is not allowed to fail the close entry point is called when an interface is de activated by the o the hardware is still under the driver control but need to be disabled global mac reset is issued to stop the hardware and all transmit and receive resource are freed", "id": "ixgbevf_close"}, "LZ4_compressBound": {"ground_truth": "0", "function": "LZ4_compressBound", "description": "lz4 compressbound max output size in worst case szenarios", "id": "LZ4_compressBound"}, "NFP_CPP_INTERFACE_TYPE_of": {"ground_truth": "0", "function": "NFP_CPP_INTERFACE_TYPE_of", "description": "nfp cpp interface type of get the interface type", "id": "NFP_CPP_INTERFACE_TYPE_of"}, "ib_port_register_module_stat": {"ground_truth": "0", "function": "ib_port_register_module_stat", "description": "ib port register module stat add module counter under relevant port of ib device", "id": "ib_port_register_module_stat"}, "generate_guest_id": {"ground_truth": "0", "function": "generate_guest_id", "description": "generate guest idgenerate the guest o identifier a described in the hyper tlfs", "id": "generate_guest_id"}, "ixgbe_identify_phy_82599": {"ground_truth": "0", "function": "ixgbe_identify_phy_82599", "description": "ixgbe identify phy get physical layer module", "id": "ixgbe_identify_phy_82599"}, "memblock_is_region_memory": {"ground_truth": "0", "function": "memblock_is_region_memory", "description": "memblock is region memory check if region is subset of memory check if the region base base size is subset of memory block", "id": "memblock_is_region_memory"}, "e1000e_check_downshift": {"ground_truth": "0", "function": "e1000e_check_downshift", "description": "e1000e check downshift check whether downshift in speed occurred", "id": "e1000e_check_downshift"}, "rvt_mmap_init": {"ground_truth": "0", "function": "rvt_mmap_init", "description": "rvt mmap init init link list and lock for mem map", "id": "rvt_mmap_init"}, "batadv_forw_packet_bcast_queue": {"ground_truth": "0", "function": "batadv_forw_packet_bcast_queue", "description": "batadv forw packet bcast queue try to queue broadcast packet this function try to re queue broadcast packet caller need to ensure that forw packet delayed work wa initialized", "id": "batadv_forw_packet_bcast_queue"}, "mei_cl_enqueue_ctrl_wr_cb": {"ground_truth": "0", "function": "mei_cl_enqueue_ctrl_wr_cb", "description": "mei cl enqueue ctrl wr cb convenient wrapper for allocating and enqueuing of the control command cb", "id": "mei_cl_enqueue_ctrl_wr_cb"}, "read_lsave": {"ground_truth": "0", "function": "read_lsave", "description": "read lsave read lpt is save table this function return on success and negative error code on failure", "id": "read_lsave"}, "pdc_adjust_pll": {"ground_truth": "0", "function": "pdc_adjust_pll", "description": "pdc adjust pll adjust the pll input clock in hz", "id": "pdc_adjust_pll"}, "iavf_client_get_params": {"ground_truth": "0", "function": "iavf_client_get_params", "description": "iavf client get params retrieve relevant client parameter", "id": "iavf_client_get_params"}, "dfl_fme_destroy_mgr": {"ground_truth": "0", "function": "dfl_fme_destroy_mgr", "description": "dfl fme destroy mgr destroy fpga mgr platform device", "id": "dfl_fme_destroy_mgr"}, "pcpu_chunk_refresh_hint": {"ground_truth": "0", "function": "pcpu_chunk_refresh_hint", "description": "pcpu chunk refresh hint update metadata about chunk iterates over the metadata block to find the largest contig area full scan can be avoided on the allocation path a this is triggered if we broke the contig hint in doing so the scan hint will be before the contig hint or after if the scan hint contig hint this cannot be prevented on freeing a we want to find the largest area possibly spanning block", "id": "pcpu_chunk_refresh_hint"}, "x86_virt_spec_ctrl": {"ground_truth": "0", "function": "x86_virt_spec_ctrl", "description": "x86 virt spec ctrl on vmenter we must preserve whatever view of the spec ctrl msr the guest ha while on vmexit we restore the host view this would be easier if spec ctrl were architecturally maskable or shadowable for guest but this is not currently the case take the guest view of spec ctrl msr a parameter and also the guest is version of virt spec ctrl if emulated", "id": "x86_virt_spec_ctrl"}, "inet_sk_state_store": {"ground_truth": "0", "function": "inet_sk_state_store", "description": "inet sk state store update sk sk state paired with inet sk state load should be used in context where state change might impact lockless reader", "id": "inet_sk_state_store"}, "gsm_encode_modem": {"ground_truth": "0", "function": "gsm_encode_modem", "description": "gsm encode modem encode modem data bit", "id": "gsm_encode_modem"}, "lpfc_debug_dump_hba_eq": {"ground_truth": "0", "function": "lpfc_debug_dump_hba_eq", "description": "lpfc debug dump hba eq dump all entry from fcp work queue is evt queue this function dump all entry from fcp event queue which is associated to the fcp work queue specified by the fcp wqidx", "id": "lpfc_debug_dump_hba_eq"}, "component_master_del": {"ground_truth": "0", "function": "component_master_del", "description": "component master del unregister an aggregate driver unregisters an aggregate driver registered with component master add with match if necessary the aggregate driver is first disassembled by calling type component master ops unbind from ops", "id": "component_master_del"}, "iavf_fill_default_direct_cmd_desc": {"ground_truth": "0", "function": "iavf_fill_default_direct_cmd_desc", "description": "iavf fill default direct cmd desc aq descriptor helper function", "id": "iavf_fill_default_direct_cmd_desc"}, "get_task_exe_file": {"ground_truth": "0", "function": "get_task_exe_file", "description": "get task exe file acquire reference to the task is executable file return null if task is mm if any ha no associated executable file or this is kernel thread with borrowed mm see the comment above get task mm user must release file via fput", "id": "get_task_exe_file"}, "mapping_writably_mapped": {"ground_truth": "0", "function": "mapping_writably_mapped", "description": "mapping writably mapped might page of this file have been modified in userspace note that mmap writable count all vm shared vmas do mmap mark vma a vm shared if it is shared and the file wa opened for writing vma may be mprotected writable even if now readonly if mmap writable is negative no new writable mapping are allowed you can only deny writable mapping if none exists right now", "id": "mapping_writably_mapped"}, "nitrox_write_csr": {"ground_truth": "0", "function": "nitrox_write_csr", "description": "nitrox write csr write to device register", "id": "nitrox_write_csr"}, "check_auxtrace_itrace": {"ground_truth": "0", "function": "check_auxtrace_itrace", "description": "check auxtrace itracecheck itrace option set on perf report command", "id": "check_auxtrace_itrace"}, "srp_parse_in": {"ground_truth": "0", "function": "srp_parse_in", "description": "srp parse in parse an ip address and port number combination parse the following address format ipv4 ipv6", "id": "srp_parse_in"}, "fw_devlink_pause": {"ground_truth": "0", "function": "fw_devlink_pause", "description": "fw devlink pause pause parsing of fwnode to create device link calling this function defers any fwnode parsing to create device link until fw devlink resume is called both these function are ref counted and the caller need to match the call while fw devlink is paused any device that is added will not have it fwnode parsed to create device link the probe of the device will also be deferred during this period any device that were already added but waiting for supplier will not be able to link to newly added device once fw devlink resume all the fwnodes that wa not parsed will be parsed all the device that were deferred probing will be reattempted if they are not waiting for any more supplier this pair of function is mainly meant to optimize the parsing of fwnodes when lot of device that need to link to each other are added in short interval of time for example adding all the top level device in system for example if device are added and all the consumer are added before their supplier all the supplier of the device are part of the device then with the use of fw devlink pause and fw devlink resume each device will only need one parsing of it fwnode because it is guaranteed to find all the supplier device already registered and ready to link to it will not have to do another pas later to find one or more supplier it could not find in the first parse of the fwnode so we will only need fwnode par without the use of fw devlink pause and fw devlink resume we would end up doing par of fwnodes because every device that is added is guaranteed to trigger parse of the fwnode of every device added before it this parse is made worse by the fact that when fwnode of device is parsed all it descendant device might need to have their fwnodes parsed too even if the device themselves are not added", "id": "fw_devlink_pause"}, "NCR5380_print": {"ground_truth": "0", "function": "NCR5380_print", "description": "ncr5380 print print scsi bus signal print the scsi bus signal for debugging purpose", "id": "NCR5380_print"}, "ixgbe_set_rar_generic": {"ground_truth": "0", "function": "ixgbe_set_rar_generic", "description": "ixgbe set rar generic set rx address register", "id": "ixgbe_set_rar_generic"}, "__dwc3_gadget_ep_disable": {"ground_truth": "0", "function": "__dwc3_gadget_ep_disable", "description": "dwc3 gadget ep disable disables hw endpoint this function undoes what dwc3 gadget ep enable did and also remove request which are currently being processed by the hardware and those which are not yet scheduled caller should take care of locking", "id": "__dwc3_gadget_ep_disable"}, "vmw_dx_streamoutput_remove": {"ground_truth": "0", "function": "vmw_dx_streamoutput_remove", "description": "vmw dx streamoutput remove stage streamoutput for removal", "id": "vmw_dx_streamoutput_remove"}, "try_then_request_governor": {"ground_truth": "0", "function": "try_then_request_governor", "description": "try then request governor try to find the governor and request the module if is not found search the list of devfreq governor and request the module and try again if is not found this can happen when both driver the governor driver and the driver that call devfreq add device are built a module devfreq list lock should be held by the caller return the matched governor is pointer or an error pointer", "id": "try_then_request_governor"}, "nand_op_parser_must_split_instr": {"ground_truth": "0", "function": "nand_op_parser_must_split_instr", "description": "nand op parser must split instr check if an instruction must be split some nand controller are limited and cannot send address cycle with unique operation or cannot read write more than byte at the same time in this case split the instruction that doe not fit in single controller operation into two or more chunk return true if the instruction must be split false otherwise the start offset parameter is also updated to the offset at which the next bundle of instruction must start if an address or data instruction", "id": "nand_op_parser_must_split_instr"}, "load_self2_seq_start": {"ground_truth": "0", "function": "load_self2_seq_start", "description": "load self2 seq start seq file read operation for smack load self2", "id": "load_self2_seq_start"}, "ti_sci_cmd_proc_release": {"ground_truth": "0", "function": "ti_sci_cmd_proc_release", "description": "ti sci cmd proc release command to release physical processor control", "id": "ti_sci_cmd_proc_release"}, "e1000_disable_ulp_lpt_lp": {"ground_truth": "0", "function": "e1000_disable_ulp_lpt_lp", "description": "e1000 disable ulp lpt lp unconfigure ultra low power mode for lynxpoint lp", "id": "e1000_disable_ulp_lpt_lp"}, "i40e_set_wol": {"ground_truth": "0", "function": "i40e_set_wol", "description": "i40e set wol set the wakeonlan configuration", "id": "i40e_set_wol"}, "mei_me_cl_is_active": {"ground_truth": "0", "function": "mei_me_cl_is_active", "description": "mei me cl is active check whether me client is active in the fw", "id": "mei_me_cl_is_active"}, "xilinx_dma_probe": {"ground_truth": "0", "function": "xilinx_dma_probe", "description": "xilinx dma probe driver probe function", "id": "xilinx_dma_probe"}, "fcoe_ctlr_vn_parse": {"ground_truth": "0", "function": "fcoe_ctlr_vn_parse", "description": "fcoe ctlr vn parse parse probe request or response return non zero error number on error doe not consume the packet", "id": "fcoe_ctlr_vn_parse"}, "_ish_ipc_reset": {"ground_truth": "0", "function": "_ish_ipc_reset", "description": "ish ipc reset ipc reset reset host and fw ipc and upper layer", "id": "_ish_ipc_reset"}, "irq_set_msi_desc_off": {"ground_truth": "0", "function": "irq_set_msi_desc_off", "description": "irq set msi desc off set msi descriptor data for an irq at offset", "id": "irq_set_msi_desc_off"}, "acpi_dev_pm_attach": {"ground_truth": "0", "function": "acpi_dev_pm_attach", "description": "acpi dev pm attach prepare device for acpi power management if dev ha valid acpi handle that ha valid struct acpi device object attached to it install wakeup notification handler for the device and add it to the general acpi pm domain if power on is set the device will be put into the acpi d0 state before the function return this assumes that the dev is bus type us generic power management callback or doe not use any power management callback at all caller must ensure proper synchronization of this function with power management callback", "id": "acpi_dev_pm_attach"}, "e1000_init_mac_params_80003es2lan": {"ground_truth": "0", "function": "e1000_init_mac_params_80003es2lan", "description": "e1000 init mac params 80003es2lan init esb2 mac func ptrs", "id": "e1000_init_mac_params_80003es2lan"}, "isci_request_process_response_iu": {"ground_truth": "0", "function": "isci_request_process_response_iu", "description": "isci request process response iu this function set the status and response iu in the task struct from the request object for the upper layer driver none", "id": "isci_request_process_response_iu"}, "b43_phy_set": {"ground_truth": "0", "function": "b43_phy_set", "description": "b43 phy set or phy register with bitmap", "id": "b43_phy_set"}, "cm32181_write_als_it": {"ground_truth": "0", "function": "cm32181_write_als_it", "description": "cm32181 write al it write sensor integration time convert integration time m to sensor value", "id": "cm32181_write_als_it"}, "pdc_mem_map_hpa": {"ground_truth": "0", "function": "pdc_mem_map_hpa", "description": "pdc mem map hpa find fixed module information this call wa developed for s700 workstation to allow the kernel to find the device core in the future kittyhawk and beyond this call will be replaced on workstation by the architected pdc system map call this call is supported by all existing s700 workstation up to gecko", "id": "pdc_mem_map_hpa"}, "qbman_result_SCN_ctx": {"ground_truth": "0", "function": "qbman_result_SCN_ctx", "description": "qbman result scn ctx get the context data in state change notification", "id": "qbman_result_SCN_ctx"}, "irq_domain_pop_irq": {"ground_truth": "0", "function": "irq_domain_pop_irq", "description": "irq domain pop irq remove domain from the top of hierarchy undo the effect of call to irq domain push irq must be called either before request irq or after free irq", "id": "irq_domain_pop_irq"}, "synth_event_trace_array": {"ground_truth": "0", "function": "synth_event_trace_array", "description": "synth event trace array trace synthetic event from an array trace synthetic event using the value passed in a vals the vals array is just an array of vals u64 the number of vals must match the number of field in the synthetic event and must be in the same order a the synthetic event field all vals should be cast to u64 and string vals are just pointer to string cast to u64 string will be copied into space reserved in the event for the string using these pointer", "id": "synth_event_trace_array"}, "ieee80211_sched_scan_stopped": {"ground_truth": "0", "function": "ieee80211_sched_scan_stopped", "description": "ieee80211 sched scan stopped inform that the scheduled scan ha stopped when scheduled scan is running this function can be called by the driver if it need to stop the scan to perform another task usual scenario are driver that cannot continue the scheduled scan while associating for instance", "id": "ieee80211_sched_scan_stopped"}, "mei_hbm_fw_add_cl_req": {"ground_truth": "0", "function": "mei_hbm_fw_add_cl_req", "description": "mei hbm fw add cl req request from the fw to add client", "id": "mei_hbm_fw_add_cl_req"}, "beiscsi_conn_get_stats": {"ground_truth": "0", "function": "beiscsi_conn_get_stats", "description": "beiscsi conn get stats get the iscsi stats return iscsi stats", "id": "beiscsi_conn_get_stats"}, "tracing_map_add_key_field": {"ground_truth": "0", "function": "tracing_map_add_key_field", "description": "tracing map add key field add field describing tracing map key let the map know there is key and that if it is used a sort key to use cmp fn key can be subset of compound key for that purpose the offset param is used to describe where within the compound key the key referenced by this key field resides", "id": "tracing_map_add_key_field"}, "dp_link_bit_depth_to_bpc": {"ground_truth": "0", "function": "dp_link_bit_depth_to_bpc", "description": "dp link bit depth to bpc convert test bit depth to bpc return the bit per comp bpc to be used corresponding to the bit depth value this function assumes that bit depth ha already been validated", "id": "dp_link_bit_depth_to_bpc"}, "hid_match_report": {"ground_truth": "0", "function": "hid_match_report", "description": "hid match report check if driver is raw event should be called compare hid driver report table report type to report type", "id": "hid_match_report"}, "boot_kstrtoul": {"ground_truth": "0", "function": "boot_kstrtoul", "description": "boot kstrtoul convert string to an unsigned long return on success erange on overflow and einval on parsing error used a replacement for the simple strtoull", "id": "boot_kstrtoul"}, "mei_wdt_stop": {"ground_truth": "0", "function": "mei_wdt_stop", "description": "mei wdt stop send wd stop command", "id": "mei_wdt_stop"}, "snd_hdac_acomp_get_eld": {"ground_truth": "0", "function": "snd_hdac_acomp_get_eld", "description": "snd hdac acomp get eld get the audio state and eld via component this function is supposed to be used only by hd audio controller driver that need the interaction with graphic driver this function query the current state of the audio on the given digital port and fetch the eld byte onto the given buffer it return the number of byte for the total eld data zero for invalid eld or negative error code the return size is the total byte required for the whole eld byte thus it may be over max byte if it is over max byte it implies that only part of eld byte have been fetched", "id": "snd_hdac_acomp_get_eld"}, "lpfc_els_retry": {"ground_truth": "0", "function": "lpfc_els_retry", "description": "lpfc el retry make retry decision on an el command iocb this routine make retry decision on an el command iocb which ha failed the following el iocbs use this function for retrying the command when previously issued command responsed with error status flogi plogi prli adisc logo and fdisc based on the el command type and the returned error status it make the decision whether retry shall be issued for the command and whether retry shall be made immediately or delayed in the former case the corresponding el command issuing function is called to retry the command in the later case the el command shall be posted to the ndlp delayed event and delayed function timer set to the ndlp for the delayed command issusing return code no retry of el command is made immediate or delayed retry of el command is made", "id": "lpfc_els_retry"}, "sev_guest_df_flush": {"ground_truth": "0", "function": "sev_guest_df_flush", "description": "sev guest df flush perform sev df flush command", "id": "sev_guest_df_flush"}, "komeda_plane_atomic_check": {"ground_truth": "0", "function": "komeda_plane_atomic_check", "description": "komeda plane atomic check build input data flow", "id": "komeda_plane_atomic_check"}, "test_cgcore_internal_process_constraint": {"ground_truth": "0", "function": "test_cgcore_internal_process_constraint", "description": "test cgcore internal process constraint test internal process constraint you can not add pid to domain parent if controller is enabled", "id": "test_cgcore_internal_process_constraint"}, "snd_hda_mixer_amp_volume_get": {"ground_truth": "0", "function": "snd_hda_mixer_amp_volume_get", "description": "snd hda mixer amp volume get get callback for standard amp mixer volume the control element is supposed to have the private value field set up via hda compose amp val or related macro", "id": "snd_hda_mixer_amp_volume_get"}, "iosf_mbi_punit_acquire": {"ground_truth": "1", "function": "iosf_mbi_punit_acquire", "description": "iosf mbi punit acquire acquire access to the unit one some system the unit access the pmic to change various voltage through the same bus a other kernel driver use for battery monitoring if driver sends request to the unit which require the unit to access the pmic bus while another driver is also accessing the pmic bus various bad thing happen call this function before sending request to the unit which may make it access the pmic be it through iosf mbi function or through other mean this function will block all kernel access to the pmic i2c bus so that the unit can safely access the pmic over the shared i2c bus note on these system the i2c bus driver will request sempahore from the unit for exclusive access to the pmic bus when i2c driver are accessing it but this doe not appear to be sufficient we still need to avoid making certain unit request during the access window to avoid problem this function lock mutex a such it may sleep", "id": "iosf_mbi_punit_acquire"}, "dpni_set_taildrop": {"ground_truth": "0", "function": "dpni_set_taildrop", "description": "dpni set taildrop set taildrop per queue or tc", "id": "dpni_set_taildrop"}, "batadv_nc_update_nc_node": {"ground_truth": "0", "function": "batadv_nc_update_nc_node", "description": "batadv nc update nc node update stored incoming and outgoing nc node structs best called on incoming ogms", "id": "batadv_nc_update_nc_node"}, "ath9k_dfs_process_phyerr": {"ground_truth": "0", "function": "ath9k_dfs_process_phyerr", "description": "ath9k dfs process phyerr process radar phy error this function is called whenever the hw dfs module detects radar pulse and report it a phy error the radar information provided a raw payload data is validated and filtered for false pulse event passing all test are forwarded to the dfs detector for pattern detection", "id": "ath9k_dfs_process_phyerr"}, "batadv_bla_claim_dump": {"ground_truth": "0", "function": "batadv_bla_claim_dump", "description": "batadv bla claim dump dump claim table to netlink socket", "id": "batadv_bla_claim_dump"}, "drm_plane_init": {"ground_truth": "0", "function": "drm_plane_init", "description": "drm plane init initialize legacy plane legacy api to initialize drm plane new driver should call drm universal plane init instead", "id": "drm_plane_init"}, "PCI_DEVICE_ID_NE": {"ground_truth": "0", "function": "PCI_DEVICE_ID_NE", "description": "pci device id ne nitro enclave pci device id", "id": "PCI_DEVICE_ID_NE"}, "reset_control_release": {"ground_truth": "1", "function": "reset_control_release", "description": "reset control release release exclusive access to reset control release exclusive access right to reset control previously obtained by call to reset control acquire until consumer call this function no other consumer will be granted exclusive access see also reset control acquire", "id": "reset_control_release"}, "profile_cmp": {"ground_truth": "0", "function": "profile_cmp", "description": "profile cmp profile comparison for set ordering", "id": "profile_cmp"}, "mei_me_cl_rm_by_uuid_id": {"ground_truth": "0", "function": "mei_me_cl_rm_by_uuid_id", "description": "mei me cl rm by uuid id remove all me client matching client id locking called under dev device lock lock", "id": "mei_me_cl_rm_by_uuid_id"}, "dev_dbg": {"ground_truth": "0", "function": "dev_dbg", "description": "dev dbgwe secure access to the primary", "id": "dev_dbg"}, "e1000_rar_set_pch_lpt": {"ground_truth": "0", "function": "e1000_rar_set_pch_lpt", "description": "e1000 rar set pch lpt set receive address register", "id": "e1000_rar_set_pch_lpt"}, "file_open_name": {"ground_truth": "0", "function": "file_open_name", "description": "file open name open file and return file pointer this is the helper to open file from kernelspace if you really have to but in generally you should not do this so please move along nothing to see here", "id": "file_open_name"}, "nfp_net_set_config_and_enable": {"ground_truth": "0", "function": "nfp_net_set_config_and_enable", "description": "nfp net set config and enable write control bar and enable nfp", "id": "nfp_net_set_config_and_enable"}, "fcoe_link_ok": {"ground_truth": "0", "function": "fcoe_link_ok", "description": "fcoe link ok check if the link is ok for local port", "id": "fcoe_link_ok"}, "i915_driver_hw_probe": {"ground_truth": "0", "function": "i915_driver_hw_probe", "description": "i915 driver hw probe setup state requiring device access setup state that requires accessing the device but doe not require exposing the driver via kernel internal or userspace interface", "id": "i915_driver_hw_probe"}, "netlbl_cfg_cipsov4_map_add": {"ground_truth": "0", "function": "netlbl_cfg_cipsov4_map_add", "description": "netlbl cfg cipsov4 map add add new cipsov4 doi mapping add new netlabel lsm domain mapping for the given cipso doi to the netlabel subsystem domain value of null add new default domain mapping return zero on success negative value on failure", "id": "netlbl_cfg_cipsov4_map_add"}, "free_clk": {"ground_truth": "0", "function": "free_clk", "description": "free clk free clk consumer note this assumes the clk ha been unlinked from the clk core consumer list", "id": "free_clk"}, "v4l2_ctrl_lock": {"ground_truth": "0", "function": "v4l2_ctrl_lock", "description": "v4l2 ctrl lock helper function to lock the handler associated with the control", "id": "v4l2_ctrl_lock"}, "tpm1_do_selftest": {"ground_truth": "0", "function": "tpm1_do_selftest", "description": "tpm1 do selftest have the tpm continue it selftest and wait until it can receive further command return on success in case of fatal error or value representing tpm error code", "id": "tpm1_do_selftest"}, "intel_vgpu_emulate_mmio_read": {"ground_truth": "0", "function": "intel_vgpu_emulate_mmio_read", "description": "intel vgpu emulate mmio read emulate mmio read", "id": "intel_vgpu_emulate_mmio_read"}, "ixgbe_stop_ipsec_offload": {"ground_truth": "0", "function": "ixgbe_stop_ipsec_offload", "description": "ixgbe stop ipsec offload tear down the ipsec offload", "id": "ixgbe_stop_ipsec_offload"}, "bnx2i_process_reject_mesg": {"ground_truth": "0", "function": "bnx2i_process_reject_mesg", "description": "bnx2i process reject mesg process iscsi reject pdu process iscsi reject message", "id": "bnx2i_process_reject_mesg"}, "arp_fwd_proxy": {"ground_truth": "0", "function": "arp_fwd_proxy", "description": "arp fwd proxy check if we can use proxy arp for this path", "id": "arp_fwd_proxy"}, "pre_unpatch_callback": {"ground_truth": "0", "function": "pre_unpatch_callback", "description": "pre unpatch callbackexecuted on object unpatching ie patch disablement", "id": "pre_unpatch_callback"}, "octeon_i2c_hlc_wait": {"ground_truth": "0", "function": "octeon_i2c_hlc_wait", "description": "octeon i2c hlc wait wait for an hlc operation to complete return on success otherwise etimedout", "id": "octeon_i2c_hlc_wait"}, "e1000_alloc_queues": {"ground_truth": "0", "function": "e1000_alloc_queues", "description": "e1000 alloc queue allocate memory for all ring we allocate one ring per queue at run time since we do not know the number of queue at compile time", "id": "e1000_alloc_queues"}, "scmi_bind_event_handler": {"ground_truth": "0", "function": "scmi_bind_event_handler", "description": "scmi bind event handler helper to attempt binding an handler to an event if an associated registered event is found move the handler from the pending into the registered table", "id": "scmi_bind_event_handler"}, "_scsih_check_pcie_topo_remove_events": {"ground_truth": "0", "function": "_scsih_check_pcie_topo_remove_events", "description": "scsih check pcie topo remove event sanity check on topo event this handle the case where driver receives multiple switch or device add and delete event in single shot when there is delete event the routine will void any pending add event waiting in the event queue", "id": "_scsih_check_pcie_topo_remove_events"}, "netdev_alloc_frag": {"ground_truth": "0", "function": "netdev_alloc_frag", "description": "netdev alloc frag allocate page fragment allocates frag from page for receive buffer us gfp atomic allocation", "id": "netdev_alloc_frag"}, "ixgbe_get_link_capabilities_X550em": {"ground_truth": "1", "function": "ixgbe_get_link_capabilities_X550em", "description": "ixgbe get link capability x550emixgbe get link capability x550em determines link capability", "id": "ixgbe_get_link_capabilities_X550em"}, "p9_pollwait": {"ground_truth": "0", "function": "p9_pollwait", "description": "p9 pollwait add poll task to the wait queue called by file poll operation to add v9fs poll task to file wait queue", "id": "p9_pollwait"}, "zynq_get_mtype": {"ground_truth": "0", "function": "zynq_get_mtype", "description": "zynq get mtype return the controller memory type get the edac memory type appropriate for the current controller configuration", "id": "zynq_get_mtype"}, "ti_msgmgr_queue_startup": {"ground_truth": "0", "function": "ti_msgmgr_queue_startup", "description": "ti msgmgr queue startup startup queue", "id": "ti_msgmgr_queue_startup"}, "bcm63xx_set_ctrl_irqs": {"ground_truth": "0", "function": "bcm63xx_set_ctrl_irqs", "description": "bcm63xx set ctrl irqs mask unmask control path interrupt", "id": "bcm63xx_set_ctrl_irqs"}, "verify_xattr_ref": {"ground_truth": "0", "function": "verify_xattr_ref", "description": "verify xattr ref xref related function verify xattr ref ref is used to load xref information from medium because summary data doe not contain xid ino it is necessary to verify once while mounting process save xattr ref ref is used to write xref to medium if delete marker is marked it write delete marker of xref into medium create xattr ref ic xd is used to create new xref and write to medium delete xattr ref ref is used to delete jffs2 xattr ref it mark xref xref delete marker and allows gc to reclaim those physical node jffs2 xattr delete inode ic is called to remove xrefs related to obsolete inode when inode is unlinked jffs2 xattr free inode ic is called to release xattr related object when unmounting check xattr ref inode ic is used to confirm inode doe not have duplicate xattr name value pair jffs2 xattr do crccheck inode ic is used to force xattr data integrity check during the initial gc scan", "id": "verify_xattr_ref"}, "initio_se2_update_all": {"ground_truth": "0", "function": "initio_se2_update_all", "description": "initio se2 update all update e2prom", "id": "initio_se2_update_all"}, "amdgpu_vm_bo_invalidate": {"ground_truth": "0", "function": "amdgpu_vm_bo_invalidate", "description": "amdgpu vm bo invalidate mark the bo a invalid mark bo a invalid", "id": "amdgpu_vm_bo_invalidate"}, "calipso_skbuff_setattr": {"ground_truth": "0", "function": "calipso_skbuff_setattr", "description": "calipso skbuff setattr set the calipso option on packet set the calipso option on the given packet based on the security attribute return pointer to the ip header on success and null on failure", "id": "calipso_skbuff_setattr"}, "parport_ip32_init": {"ground_truth": "0", "function": "parport_ip32_init", "description": "parport ip32 init module initialization function", "id": "parport_ip32_init"}, "mdiobus_write": {"ground_truth": "0", "function": "mdiobus_write", "description": "mdiobus write convenience function for writing given mii mgmt register", "id": "mdiobus_write"}, "__CRYPTO4XX_REG_DEF_H__": {"ground_truth": "1", "function": "__CRYPTO4XX_REG_DEF_H__", "description": "crypto4xx reg def copyright applied micro circuit corporation all right reserved james hsiao this filr defines the register set for security subsystem", "id": "__CRYPTO4XX_REG_DEF_H__"}, "ice_is_arfs_active": {"ground_truth": "0", "function": "ice_is_arfs_active", "description": "ice is arfs active helper to check is arfs is active", "id": "ice_is_arfs_active"}, "radeon_wb_init": {"ground_truth": "0", "function": "radeon_wb_init", "description": "radeon wb init init writeback driver info and allocate memory disables writeback and free the writeback memory all asics used at driver startup return on success or an error on failure", "id": "radeon_wb_init"}, "bus_for_each_drv": {"ground_truth": "0", "function": "bus_for_each_drv", "description": "bus for each drv driver iterator this is nearly identical to the device iterator above we iterate over each driver that belongs to bus and call fn for each if fn return anything but we break out and return it if start is not null we use it a the head of the list note we do not return the driver that return non zero value nor do we leave the reference count incremented for that driver if the caller need to know that info it must set it in the callback it must also be sure to increment the refcount so it doe not disappear before returning to the caller", "id": "bus_for_each_drv"}, "eth_skb_pad": {"ground_truth": "0", "function": "eth_skb_pad", "description": "eth skb pad pad buffer to mininum number of octet for ethernet frame an ethernet frame should have minimum size of byte this function take short frame and pad them with zero up to the byte limit", "id": "eth_skb_pad"}, "mesh_path_lookup_by_idx": {"ground_truth": "0", "function": "mesh_path_lookup_by_idx", "description": "mesh path lookup by idx look up path in the mesh path table by it index locking must be called within read rcu section", "id": "mesh_path_lookup_by_idx"}, "e1000_power_up_phy": {"ground_truth": "0", "function": "e1000_power_up_phy", "description": "e1000 power up phy restore link in case the phy wa powered down the phy may be powered down to save power and turn off link when the driver is unloaded and wake on lan is not enabled among others this routine must be followed by call to e1000 reset", "id": "e1000_power_up_phy"}, "stack_tracer_enable": {"ground_truth": "0", "function": "stack_tracer_enable", "description": "stack tracer enable re enable the stack tracer after stack tracer disable is called stack tracer enable must be called shortly afterward", "id": "stack_tracer_enable"}, "kvm_pmu_release_perf_event": {"ground_truth": "0", "function": "kvm_pmu_release_perf_event", "description": "kvm pmu release perf event remove the perf event", "id": "kvm_pmu_release_perf_event"}, "ntfs_attr_iget": {"ground_truth": "0", "function": "ntfs_attr_iget", "description": "ntfs attr iget obtain struct inode corresponding to an attribute obtain the fake struct inode corresponding to the attribute specified by type name and name len which is present in the base mft record specified by the vfs inode base vi if the attribute inode is in the cache it is just returned with an increased reference count otherwise new struct inode is allocated and initialized and finally ntfs read locked attr inode is called to read the attribute and fill in the inode structure note for index allocation attribute you need to use ntfs index iget instead of ntfs attr iget a working with index is lot more complex return the struct inode of the attribute inode on success check the return value with is err and if true the function failed and the error code is obtained from ptr err", "id": "ntfs_attr_iget"}, "beiscsi_adap_family_disp": {"ground_truth": "0", "function": "beiscsi_adap_family_disp", "description": "beiscsi adap family disp display adapter family return size of the formatted string", "id": "beiscsi_adap_family_disp"}, "alchemy_rdsys": {"ground_truth": "0", "function": "alchemy_rdsys", "description": "alchemy rdsyshelpers to access the sys register", "id": "alchemy_rdsys"}, "__add_badblock_range": {"ground_truth": "0", "function": "__add_badblock_range", "description": "add badblock range convert physical address range to bad sector this assumes that the range provided with n offset len is within the bound of physical address for this namespace lie in the interval n start n start n size", "id": "__add_badblock_range"}, "calipso_validate": {"ground_truth": "0", "function": "calipso_validate", "description": "calipso validate validate calipso option this routine is called to validate calipso option if the option is valid then true is returned otherwise false is returned the caller should have already checked that the length of the option including the tlv header is and that the catmap length is consistent with the option length we leave check on the level and category to the socket layer", "id": "calipso_validate"}, "ixgbe_disable_tx_laser_multispeed_fiber": {"ground_truth": "0", "function": "ixgbe_disable_tx_laser_multispeed_fiber", "description": "ixgbe disable tx laser multispeed fiber disable tx laser", "id": "ixgbe_disable_tx_laser_multispeed_fiber"}, "pmcraid_check_ioctl_buffer": {"ground_truth": "1", "function": "pmcraid_check_ioctl_buffer", "description": "pmcraid check ioctl buffer check for proper access to user buffer return value negetive error code if there are access issue otherwise zero upon success return ioctl header copied out of user buffer", "id": "pmcraid_check_ioctl_buffer"}, "smk_netlabel_audit_set": {"ground_truth": "1", "function": "smk_netlabel_audit_set", "description": "smk netlabel audit set fill netlbl audit struct", "id": "smk_netlabel_audit_set"}, "__bfq_activate_entity": {"ground_truth": "0", "function": "__bfq_activate_entity", "description": "bfq activate entity handle activation of entity called for notrue activation if entity is not active and one of it child receives new request basically this function update the timestamps of entity and insert entity into it active tree after possibly extracting it from it idle tree", "id": "__bfq_activate_entity"}, "ixgbevf_free_all_tx_resources": {"ground_truth": "0", "function": "ixgbevf_free_all_tx_resources", "description": "ixgbevf free all tx resource free tx resource for all queue free all transmit software resource", "id": "ixgbevf_free_all_tx_resources"}, "devm_phy_optional_get": {"ground_truth": "0", "function": "devm_phy_optional_get", "description": "devm phy optional get lookup and obtain reference to an optional phy get the phy using phy get and associate device with it using devres on driver detach release function is invoked on the devres data then devres data is freed this differs to devm phy get in that if the phy doe not exist it is not considered an error and enodev will not be returned instead the null phy is returned which can be passed to all other phy consumer call", "id": "devm_phy_optional_get"}, "fake_slot_get": {"ground_truth": "0", "function": "fake_slot_get", "description": "fake slot get determine geographical addressing", "id": "fake_slot_get"}, "cnstr_shdsc_gcm_decap": {"ground_truth": "0", "function": "cnstr_shdsc_gcm_decap", "description": "cnstr shdsc gcm decap gcm decapsulation shared descriptor", "id": "cnstr_shdsc_gcm_decap"}, "in_pq": {"ground_truth": "0", "function": "in_pq", "description": "in pq check if wear leveling entry is present in the protection queue this function return non zero if is in the protection queue and zero if it is not", "id": "in_pq"}, "igbvf_set_rlpml": {"ground_truth": "0", "function": "igbvf_set_rlpml", "description": "igbvf set rlpml set receive large packet maximum length configure the maximum size of packet that will be received", "id": "igbvf_set_rlpml"}, "iavf_alloc_rx_buffers": {"ground_truth": "0", "function": "iavf_alloc_rx_buffers", "description": "iavf alloc rx buffer replace used receive buffer return false if all allocation were successful true if any fail", "id": "iavf_alloc_rx_buffers"}, "handle_error_source": {"ground_truth": "0", "function": "handle_error_source", "description": "handle error source handle logging error into an event log invoked when an error being detected by root port", "id": "handle_error_source"}, "x509_check_for_self_signed": {"ground_truth": "1", "function": "x509_check_for_self_signed", "description": "x509 check for self signed check for self signedness in an cert and if found check the signature immediately if we can", "id": "x509_check_for_self_signed"}, "zfcp_fsf_close_port": {"ground_truth": "0", "function": "zfcp_fsf_close_port", "description": "zfcp fsf close port create and send close port request", "id": "zfcp_fsf_close_port"}, "binder_dec_node_tmpref": {"ground_truth": "0", "function": "binder_dec_node_tmpref", "description": "binder dec node tmpref remove temporary reference on node release temporary reference on node taken via binder inc node tmpref", "id": "binder_dec_node_tmpref"}, "ixgbevf_check_for_ack_vf": {"ground_truth": "0", "function": "ixgbevf_check_for_ack_vf", "description": "ixgbevf check for ack vf check to see if the pf ha ack would", "id": "ixgbevf_check_for_ack_vf"}, "res_get": {"ground_truth": "0", "function": "res_get", "description": "re getusage lock check function", "id": "res_get"}, "pci_rebar_get_current_size": {"ground_truth": "0", "function": "pci_rebar_get_current_size", "description": "pci rebar get current size get the current size of bar read the size of bar from the resizable bar config return size if found or negative error code", "id": "pci_rebar_get_current_size"}, "piix_set_piomode": {"ground_truth": "0", "function": "piix_set_piomode", "description": "piix set piomode initialize host controller pata pio timing", "id": "piix_set_piomode"}, "zfcp_ccw_shutdown": {"ground_truth": "0", "function": "zfcp_ccw_shutdown", "description": "zfcp ccw shutdown handle shutdown from cio", "id": "zfcp_ccw_shutdown"}, "of_thermal_get_trip_points": {"ground_truth": "0", "function": "of_thermal_get_trip_points", "description": "of thermal get trip point function to get access to globally exported trip point this function provides pointer to trip point table", "id": "of_thermal_get_trip_points"}, "lpfc_oas_lun_state_change": {"ground_truth": "0", "function": "lpfc_oas_lun_state_change", "description": "lpfc oas lun state change enable disable lun for oas operation this routine enables oas lun enable or disables oas lun disable lun for oas operation", "id": "lpfc_oas_lun_state_change"}, "usb_ep_align_maybe": {"ground_truth": "0", "function": "usb_ep_align_maybe", "description": "usb ep align maybe return len aligned to ep is maxpacketsize if gadget requires quirk ep out aligned size otherwise return len this helper is used in case it is required for any reason to check and maybe align buffer is size to an ep is maxpacketsize", "id": "usb_ep_align_maybe"}, "die_match_name": {"ground_truth": "0", "function": "die_match_name", "description": "die match name match diename linkage name and glob glob matching the name of dw die and glob return false if matching fail this also match linkage name", "id": "die_match_name"}, "wkup_m3_set_resume_address": {"ground_truth": "0", "function": "wkup_m3_set_resume_address", "description": "wkup m3 set resume address pas wkup m3 resume address", "id": "wkup_m3_set_resume_address"}, "ping_check_bind_addr": {"ground_truth": "0", "function": "ping_check_bind_addr", "description": "ping check bind addrchecks the bind address and possibly modifies sk sk bound dev if", "id": "ping_check_bind_addr"}, "dev_uc_add": {"ground_truth": "0", "function": "dev_uc_add", "description": "dev uc add add secondary unicast address", "id": "dev_uc_add"}, "pci_fixup_transparent_bridge": {"ground_truth": "0", "function": "pci_fixup_transparent_bridge", "description": "pci fixup transparent bridge for some reason intel decided that certain part of their and some other chipsets must look like pci to pci bridge while they are obviously not the family aa ab bam cam ba ca db and pci bridge are actually hub to pci one according to intel terminology these device do forward all address from system to pci bus no matter what are their window setting so they are transparent or subtractive decoding from programmer point of view", "id": "pci_fixup_transparent_bridge"}, "xcan_start_xmit": {"ground_truth": "0", "function": "xcan_start_xmit", "description": "xcan start xmit start the transmission this function is invoked from upper layer to initiate transmission", "id": "xcan_start_xmit"}, "fas216_find_command": {"ground_truth": "0", "function": "fas216_find_command", "description": "fas216 find command decide how to abort command decide how to abort command", "id": "fas216_find_command"}, "build_pte_modifiable": {"ground_truth": "0", "function": "build_pte_modifiable", "description": "build pte modifiable check if pte can be modified if not branch to label regardless restore pte with value from ptr when done", "id": "build_pte_modifiable"}, "wil6210_disconnect_complete": {"ground_truth": "0", "function": "wil6210_disconnect_complete", "description": "wil6210 disconnect complete handle disconnect event release associated resource and indicate upper layer the connection is terminated", "id": "wil6210_disconnect_complete"}, "v9fs_vfs_getattr": {"ground_truth": "0", "function": "v9fs_vfs_getattr", "description": "v9fs vfs getattr retrieve file metadata", "id": "v9fs_vfs_getattr"}, "snd_pcm_rate_to_rate_bit": {"ground_truth": "0", "function": "snd_pcm_rate_to_rate_bit", "description": "snd pcm rate to rate bit convert sample rate to sndrv pcm rate xxx bit", "id": "snd_pcm_rate_to_rate_bit"}, "ntfs_bmap": {"ground_truth": "0", "function": "ntfs_bmap", "description": "ntfs bmap map logical file block to physical device block for regular non resident file not compressed and not encrypted map the logical block belonging to the file described by the address space mapping mapping to it physical device block the size of the block is equal to the blocksize field of the super block of the mounted file system which is guaranteed to be smaller than or equal to the cluster size thus the block is guaranteed to fit entirely inside the cluster which mean we do not need to care how many contiguous byte are available after the beginning of the block return the physical device block if the mapping succeeded or if the block is sparse or there wa an error note this is problem if someone try to run bmap on boot system file a that really is in block zero but there is nothing we can do bmap is just broken in that respect just like it cannot distinguish sparse from not available or error", "id": "ntfs_bmap"}, "platform_msi_domain_alloc_irqs": {"ground_truth": "0", "function": "platform_msi_domain_alloc_irqs", "description": "platform msi domain alloc irqs allocate msi interrupt for dev", "id": "platform_msi_domain_alloc_irqs"}, "__fls": {"ground_truth": "0", "function": "__fls", "description": "fl find last most significant set bit in long word undefined if no set bit exists so code should check against first", "id": "__fls"}, "fscrypt_ioctl_get_key_status": {"ground_truth": "0", "function": "fscrypt_ioctl_get_key_status", "description": "fscrypt ioctl get key status retrieve the status of an fscrypt master encryption key we set status to indicate whether the key is absent present or incompletely removed incompletely removed mean that the master key secret ha been removed but some file which had been unlocked with it are still in use this field allows application to easily determine the state of an encrypted directory without using hack such a trying to open regular file in it which can confuse the incompletely removed state with absent or present in addition for v2 policy key we allow application to determine via status flag and user count whether the key ha been added by the current user by other user or by both most application should not need this since ordinarily only one user should know given key however if secret key is shared by multiple user application may wish to add an already present key to prevent other user from removing it this ioctl can be used to check whether that really is the case before the work is done to add the key which might require prompting the user for passphrase for more detail see the f ioc get encryption key status section of documentation filesystems fscrypt rst", "id": "fscrypt_ioctl_get_key_status"}, "i40e_xdp_ring_update_tail": {"ground_truth": "0", "function": "i40e_xdp_ring_update_tail", "description": "i40e xdp ring update tail update the xdp tx ring tail register this function update the xdp tx ring tail register", "id": "i40e_xdp_ring_update_tail"}, "iscsi_iser_ep_connect": {"ground_truth": "0", "function": "iscsi_iser_ep_connect", "description": "iscsi iser ep connect initiate iser connection establishment allocate an iscsi endpoint an iser conn structure and bind them after that start rdma connection establishment via rdma cm we do not allocate iser conn embedded in iscsi endpoint since in teardown the endpoint will be destroyed at ep disconnect while iser conn will cleanup it resource asynchronuously", "id": "iscsi_iser_ep_connect"}, "phy_queue_state_machine": {"ground_truth": "0", "function": "phy_queue_state_machine", "description": "phy queue state machine trigger the state machine to run soon", "id": "phy_queue_state_machine"}, "fcoe_ctlr_timeout": {"ground_truth": "0", "function": "fcoe_ctlr_timeout", "description": "fcoe ctlr timeout fip timeout handler", "id": "fcoe_ctlr_timeout"}, "batadv_dat_drop_broadcast_packet": {"ground_truth": "0", "function": "batadv_dat_drop_broadcast_packet", "description": "batadv dat drop broadcast packet check if an arp request ha to be dropped because the node ha already obtained the reply via dat or not", "id": "batadv_dat_drop_broadcast_packet"}, "mpt_is_discovery_complete": {"ground_truth": "0", "function": "mpt_is_discovery_complete", "description": "mpt is discovery complete determine if discovery ha completed return when discovery completed else zero", "id": "mpt_is_discovery_complete"}, "netif_attrmask_next": {"ground_truth": "0", "function": "netif_attrmask_next", "description": "netif attrmask next get the next cpu rx queue in cpu rx queue mask return nr bit if no further cpu rx queue set", "id": "netif_attrmask_next"}, "cxgb4_create_server": {"ground_truth": "0", "function": "cxgb4_create_server", "description": "cxgb4 create server create an ip server", "id": "cxgb4_create_server"}, "hinic_clean_rq": {"ground_truth": "0", "function": "hinic_clean_rq", "description": "hinic clean rq clean hw receive queue is resource", "id": "hinic_clean_rq"}, "lpfc_oas_vpt_store": {"ground_truth": "0", "function": "lpfc_oas_vpt_store", "description": "lpfc oas vpt store store wwpn of vport whose target maybe enabled for optimized access storage oas operation", "id": "lpfc_oas_vpt_store"}, "__xudc_ep_enable": {"ground_truth": "0", "function": "__xudc_ep_enable", "description": "xudc ep enable enables the given endpoint", "id": "__xudc_ep_enable"}, "nvmf_reg_read64": {"ground_truth": "0", "function": "nvmf_reg_read64", "description": "nvmf reg read64 nvme fabric property get api function used by the host system to retrieve bit capsule property value from an nvme controller on the target system capsule property is an pcie register concept applied to the nvme fabric space", "id": "nvmf_reg_read64"}, "ubi_refill_pools": {"ground_truth": "0", "function": "ubi_refill_pools", "description": "ubi refill pool refill all fastmap peb pool", "id": "ubi_refill_pools"}, "mips_cdmm_void_work": {"ground_truth": "0", "function": "mips_cdmm_void_work", "description": "mips cdmm void work call void returning cdmm driver callback work on cpu callback function to call an arbitrary cdmm driver callback function which doe not return value", "id": "mips_cdmm_void_work"}, "igbvf_close": {"ground_truth": "0", "function": "igbvf_close", "description": "igbvf close disables network interface return this is not allowed to fail the close entry point is called when an interface is de activated by the o the hardware is still under the driver control but need to be disabled global mac reset is issued to stop the hardware and all transmit and receive resource are freed", "id": "igbvf_close"}, "xcan_set_error_state": {"ground_truth": "0", "function": "xcan_set_error_state", "description": "xcan set error state set new can error state set new can error state for the device updating statistic and populating the error frame if given", "id": "xcan_set_error_state"}, "llc_sap_next_state": {"ground_truth": "0", "function": "llc_sap_next_state", "description": "llc sap next state find transition exec action change sap state", "id": "llc_sap_next_state"}, "tep_get_page_size": {"ground_truth": "0", "function": "tep_get_page_size", "description": "tep get page size get the size of memory page on the traced machine this return the size of memory page on the traced machine if tep is null is returned", "id": "tep_get_page_size"}, "inode_attach_wb": {"ground_truth": "0", "function": "inode_attach_wb", "description": "inode attach wb associate an inode with it wb if inode doe not have it wb associate it with the wb matching the memcg of page or if page is null current may be called or inode lock", "id": "inode_attach_wb"}, "ext4_xattr_update_super_block": {"ground_truth": "0", "function": "ext4_xattr_update_super_block", "description": "ext4 xattr update super block if the ext4 feature compat ext attr feature of this file system is not set set it", "id": "ext4_xattr_update_super_block"}, "mei_cl_bus_module_put": {"ground_truth": "0", "function": "mei_cl_bus_module_put", "description": "mei cl bus module put release the underlying hw module", "id": "mei_cl_bus_module_put"}, "llc_pdu_decode_da": {"ground_truth": "0", "function": "llc_pdu_decode_da", "description": "llc pdu decode da extract dest address of input frame", "id": "llc_pdu_decode_da"}, "fc_exch_timer_set_locked": {"ground_truth": "0", "function": "fc_exch_timer_set_locked", "description": "fc exch timer set locked start timer for an exchange the the exchange lock held used for upper level protocol to time out the exchange the timer is cancelled when it fire or when the exchange completes", "id": "fc_exch_timer_set_locked"}, "iwlagn_rx_calc_noise": {"ground_truth": "0", "function": "iwlagn_rx_calc_noise", "description": "iwlagn rx calc noisecalculate noise level based on measurement during network silence just before arriving beacon this measurement can be done only if we know exactly when to expect beacon therefore only when we are associated", "id": "iwlagn_rx_calc_noise"}, "dclo_func": {"ground_truth": "0", "function": "dclo_func", "description": "dclo func emulate dclo instruction return since it always succeeds", "id": "dclo_func"}, "sd_read_block_provisioning": {"ground_truth": "0", "function": "sd_read_block_provisioning", "description": "sd read block provisioning query provisioning vpd page", "id": "sd_read_block_provisioning"}, "devm_extcon_dev_unregister": {"ground_truth": "0", "function": "devm_extcon_dev_unregister", "description": "devm extcon dev unregister resource managed extcon dev unregister unregister extcon device that is registered with devm extcon dev register function", "id": "devm_extcon_dev_unregister"}, "tomoyo_scan_transition": {"ground_truth": "1", "function": "tomoyo_scan_transition", "description": "tomoyo scan transition try to find specific domain transition type return true if found one false otherwise caller hold tomoyo read lock", "id": "tomoyo_scan_transition"}, "can_rcv_list_find": {"ground_truth": "0", "function": "can_rcv_list_find", "description": "can rcv list find determine optimal filterlist inside device filter struct return the optimal filterlist to reduce the filter handling in the receive path this function is called by service function that need to register or unregister can filter in the filter list filter match in general when mask can id mask so every bit set in the mask even can eff flag can rtr flag describe relevant bit for the filter the filter can be inverted can inv filter bit set in can id or it can filter for error message can err flag bit set in mask for error msg frame there is special filterlist and special rx path filter handling", "id": "can_rcv_list_find"}, "e1000_irq_disable": {"ground_truth": "0", "function": "e1000_irq_disable", "description": "e1000 irq disable mask off interrupt generation on the nic", "id": "e1000_irq_disable"}, "aa_audit_file": {"ground_truth": "1", "function": "aa_audit_file", "description": "aa audit file handle the auditing of file operation", "id": "aa_audit_file"}, "dvb_ca_en50221_camready_irq": {"ground_truth": "0", "function": "dvb_ca_en50221_camready_irq", "description": "dvb ca en50221 camready irq camready irq ha occurred", "id": "dvb_ca_en50221_camready_irq"}, "rsi_mac80211_attach": {"ground_truth": "0", "function": "rsi_mac80211_attach", "description": "rsi mac80211 attach this function is used to initialize mac80211 stack", "id": "rsi_mac80211_attach"}, "pci_host_bridge_acpi_msi_domain": {"ground_truth": "0", "function": "pci_host_bridge_acpi_msi_domain", "description": "pci host bridge acpi msi domain retrieve msi domain of pci host bridge this function us the callback function registered by pci msi register fwnode provider to retrieve the irq domain with type domain bus pci msi of the specified host bridge bus this return null on error or when the domain is not found", "id": "pci_host_bridge_acpi_msi_domain"}, "fw_rcode_string": {"ground_truth": "0", "function": "fw_rcode_string", "description": "fw rcode string convert firewire result code to an error description", "id": "fw_rcode_string"}, "hrtimer_next_event_without": {"ground_truth": "0", "function": "hrtimer_next_event_without", "description": "hrtimer next event without time until next expiry event one timer return the next expiry time over all timer except for the exclude one or ktime max if none of them is pending", "id": "hrtimer_next_event_without"}, "igc_setup_all_tx_resources": {"ground_truth": "0", "function": "igc_setup_all_tx_resources", "description": "igc setup all tx resource wrapper to allocate tx resource for all queue return on success negative on failure", "id": "igc_setup_all_tx_resources"}, "acpi_processor_get_platform_limit": {"ground_truth": "0", "function": "acpi_processor_get_platform_limit", "description": "acpi processor get platform limit tpc throttling present capability", "id": "acpi_processor_get_platform_limit"}, "os_area_get_property": {"ground_truth": "0", "function": "os_area_get_property", "description": "o area get property get saved params value from the device tree", "id": "os_area_get_property"}, "t3_offload_tx": {"ground_truth": "0", "function": "t3_offload_tx", "description": "t3 offload tx send an offload packet", "id": "t3_offload_tx"}, "pch_udc_pcd_dequeue": {"ground_truth": "0", "function": "pch_udc_pcd_dequeue", "description": "pch udc pcd dequeue this function de queue request packet it is called by gadget driver return code success linux error number failure", "id": "pch_udc_pcd_dequeue"}, "blk_rq_prep_clone": {"ground_truth": "0", "function": "blk_rq_prep_clone", "description": "blk rq prep clone helper function to setup clone request clone bios in rq src to rq and copy attribute of rq src to rq also page which the original bios are pointing to are not copied and the cloned bios just point same page so cloned bios must be completed before original bios which mean the caller must complete rq before rq src", "id": "blk_rq_prep_clone"}, "pci_bridge_secondary_bus_reset": {"ground_truth": "0", "function": "pci_bridge_secondary_bus_reset", "description": "pci bridge secondary bus reset reset the secondary bus on pci bridge use the bridge control register to assert reset on the secondary bus device on the secondary bus are left in power on state", "id": "pci_bridge_secondary_bus_reset"}, "synthvid_negotiate_ver": {"ground_truth": "0", "function": "synthvid_negotiate_ver", "description": "synthvid negotiate vercheck synthetic video protocol version with the host", "id": "synthvid_negotiate_ver"}, "ip6_tnl_locate": {"ground_truth": "0", "function": "ip6_tnl_locate", "description": "ip6 tnl locate find or create tunnel matching given parameter ip6 tnl locate first try to locate an existing tunnel based on parms if this is unsuccessful but create is set new tunnel device is created and registered for use", "id": "ip6_tnl_locate"}, "vmw_thread_fn": {"ground_truth": "0", "function": "vmw_thread_fn", "description": "vmw thread fn deferred process context irq handler this function implement the deferred part of irq processing the function is guaranteed to run at least once after the vmw irq handler ha returned with irq wake thread", "id": "vmw_thread_fn"}, "gfs2_make_fs_rw": {"ground_truth": "0", "function": "gfs2_make_fs_rw", "description": "gfs2 make f rw turn read only f into read write one", "id": "gfs2_make_fs_rw"}, "spu_bind_context": {"ground_truth": "0", "function": "spu_bind_context", "description": "spu bind context bind spu context to physical spu", "id": "spu_bind_context"}, "vxge_hw_device_intr_disable": {"ground_truth": "0", "function": "vxge_hw_device_intr_disable", "description": "vxge hw device intr disable disable titan interrupt disable titan interrupt see also vxge hw device intr enable", "id": "vxge_hw_device_intr_disable"}, "vt_waitactive": {"ground_truth": "0", "function": "vt_waitactive", "description": "vt waitactive active console wait", "id": "vt_waitactive"}, "ptp_find_pin": {"ground_truth": "0", "function": "ptp_find_pin", "description": "ptp find pin obtain the pin index of given auxiliary function the caller must hold ptp clock pincfg mux driver do not have access to that mutex a ptp clock is an opaque type however the core code acquires the mutex before invoking the driver is ptp clock info enable callback and so driver may call this function from that context", "id": "ptp_find_pin"}, "I40E_CLEAR_PF_SD_ENTRY": {"ground_truth": "0", "function": "I40E_CLEAR_PF_SD_ENTRY", "description": "i40e clear pf sd entry mark the sd entry a invalid in the hardware", "id": "I40E_CLEAR_PF_SD_ENTRY"}, "skb_queue_splice_tail_init": {"ground_truth": "0", "function": "skb_queue_splice_tail_init", "description": "skb queue splice tail init join two skb list and reinitialise the emptied list", "id": "skb_queue_splice_tail_init"}, "cvmx_spinlock_locked": {"ground_truth": "0", "function": "cvmx_spinlock_locked", "description": "cvmx spinlock locked zero if the spinlock is currently locked", "id": "cvmx_spinlock_locked"}, "lirc_scancode_event": {"ground_truth": "0", "function": "lirc_scancode_event", "description": "lirc scancode event send scancode data to lirc to be relayed to userspace this can be called in atomic context", "id": "lirc_scancode_event"}, "radeon_atpx_detect": {"ground_truth": "0", "function": "radeon_atpx_detect", "description": "radeon atpx detect detect whether we have px check if we have px system all asics return true if we have px system false if not", "id": "radeon_atpx_detect"}, "tty_register_ldisc": {"ground_truth": "0", "function": "tty_register_ldisc", "description": "tty register ldisc install line discipline", "id": "tty_register_ldisc"}, "i40e_find_mac": {"ground_truth": "0", "function": "i40e_find_mac", "description": "i40e find mac find mac addr in the macvlan filter list return the first filter with the provided mac address or null if mac address wa not found", "id": "i40e_find_mac"}, "rmi_unregister_transport_device": {"ground_truth": "0", "function": "rmi_unregister_transport_device", "description": "rmi unregister transport device unregister transport device connection", "id": "rmi_unregister_transport_device"}, "cpumask_intersects": {"ground_truth": "0", "function": "cpumask_intersects", "description": "cpumask intersects src1p src2p", "id": "cpumask_intersects"}, "unregister_mii_tstamp_controller": {"ground_truth": "0", "function": "unregister_mii_tstamp_controller", "description": "unregister mii tstamp controller unregisters an mii time stamping device", "id": "unregister_mii_tstamp_controller"}, "lpfc_cpumask_irq_mode_init": {"ground_truth": "0", "function": "lpfc_cpumask_irq_mode_init", "description": "lpfc cpumask irq mode init initalizes cpumask of phba based on irq chann mode", "id": "lpfc_cpumask_irq_mode_init"}, "ip_vs_nat_icmp": {"ground_truth": "0", "function": "ip_vs_nat_icmp", "description": "ip v nat icmp packet ha been made sufficiently writable in caller inout in out out in", "id": "ip_vs_nat_icmp"}, "batadv_orig_node_release": {"ground_truth": "0", "function": "batadv_orig_node_release", "description": "batadv orig node release release orig node from list and queue for free after rcu grace period", "id": "batadv_orig_node_release"}, "kvm_arm_num_regs": {"ground_truth": "0", "function": "kvm_arm_num_regs", "description": "kvm arm num regs how many register do we present via kvm get one reg this is for all register", "id": "kvm_arm_num_regs"}, "tep_find_event_by_name": {"ground_truth": "0", "function": "tep_find_event_by_name", "description": "tep find event by name find an event by given name this return an event with given name and under the system sys if sys is null the first event with name is returned", "id": "tep_find_event_by_name"}, "ntfs_rl_replace": {"ground_truth": "0", "function": "ntfs_rl_replace", "description": "ntfs rl replace overwrite runlist element with another runlist replace the runlist element dst at loc with src merge the left and right end of the inserted runlist if necessary it is up to the caller to serialize access to the runlists dst and src on success return pointer to the new combined runlist note both runlists dst and src are deallocated before returning so you cannot use the pointer for anything any more strictly speaking the returned runlist may be the same a dst but this is irrelevant on error return errno both runlists are left unmodified the following error code are defined enomem not enough memory to allocate runlist array einval invalid parameter were passed in", "id": "ntfs_rl_replace"}, "ixgbe_ptp_get_ts_config": {"ground_truth": "0", "function": "ixgbe_ptp_get_ts_config", "description": "ixgbe ptp get t config get current hardware timestamping configuration this function return the current timestamping setting rather than attempt to deconstruct register to fill in the value simply keep copy of the old setting around and return copy when requested", "id": "ixgbe_ptp_get_ts_config"}, "tipc_crypto_key_try_align": {"ground_truth": "0", "function": "tipc_crypto_key_try_align", "description": "tipc crypto key try align align rx key if possible peer ha used an unknown key slot this only happens when peer ha left and rejoned or we are newcomer that mean there must be no active key but pending key at unaligned slot if so we try to move the pending key to the new slot note potential passive key can exist it will be shifted correspondingly", "id": "tipc_crypto_key_try_align"}, "tipc_ehdr_validate": {"ground_truth": "0", "function": "tipc_ehdr_validate", "description": "tipc ehdr validate validate an encryption message return true if this is valid encryption message otherwise false", "id": "tipc_ehdr_validate"}, "of_icc_get": {"ground_truth": "0", "function": "of_icc_get", "description": "of icc get get path handle from dt node based on name this function will search for path between two endpoint and return an icc path handle on success use icc put to release constraint when they are not needed anymore if the interconnect api is disabled null is returned and the consumer driver will still build driver are free to handle this specifically but they do not have to", "id": "of_icc_get"}, "rdma_read_gid_attr_ndev_rcu": {"ground_truth": "0", "function": "rdma_read_gid_attr_ndev_rcu", "description": "rdma read gid attr ndev rcu read gid attribute netdevice which must be in up state return pointer to netdevice if the netdevice wa attached to gid and netdevice is in up state caller must hold rcu lock a this api read the netdev flag which can change while netdevice migrates to different net namespace return err ptr with error code otherwise", "id": "rdma_read_gid_attr_ndev_rcu"}, "ata_scsi_port_error_handler": {"ground_truth": "0", "function": "ata_scsi_port_error_handler", "description": "ata scsi port error handler recover the port after the command handle the recovery of the port ap after all the command have been recovered", "id": "ata_scsi_port_error_handler"}, "i40e_vlan_rx_add_vid": {"ground_truth": "0", "function": "i40e_vlan_rx_add_vid", "description": "i40e vlan rx add vid add vlan id filter to hw offload net device ops implementation for adding vlan id", "id": "i40e_vlan_rx_add_vid"}, "cipso_v4_genopt": {"ground_truth": "0", "function": "cipso_v4_genopt", "description": "cipso v4 genopt generate cipso option generate cipso option using the doi definition and security attribute passed to the function return the length of the option on success and negative value on failure", "id": "cipso_v4_genopt"}, "hrtimer_callback_running": {"ground_truth": "0", "function": "hrtimer_callback_running", "description": "hrtimer callback running helper function to check whether the timer is running the callback function", "id": "hrtimer_callback_running"}, "bdx_tx_cleanup": {"ground_truth": "0", "function": "bdx_tx_cleanup", "description": "bdx tx cleanup clean txf fifo run in the context of irq it scan txf fifo for descriptor free dma mapping and report to o that those packet were sent", "id": "bdx_tx_cleanup"}, "__propagate_umount": {"ground_truth": "0", "function": "__propagate_umount", "description": "propagate umount note unmounting amnt naturally propagates to all other mount it parent propagates to", "id": "__propagate_umount"}, "hw_stop_tx": {"ground_truth": "0", "function": "hw_stop_tx", "description": "hw stop tx stop transmitting this routine stop the transmit function of the hardware", "id": "hw_stop_tx"}, "inode_switch_wbs": {"ground_truth": "0", "function": "inode_switch_wbs", "description": "inode switch wb change the wb association of an inode switch inode is wb association to the wb identified by new wb id the switching is performed asynchronously and may fail silently", "id": "inode_switch_wbs"}, "arch_atomic64_read": {"ground_truth": "0", "function": "arch_atomic64_read", "description": "arch atomic64 read read atomic64 variable atomically read the value of doe not imply read memory barrier", "id": "arch_atomic64_read"}, "write_to_ucd_unit": {"ground_truth": "0", "function": "write_to_ucd_unit", "description": "write to ucd unit write firmware to nitrox ucd unit", "id": "write_to_ucd_unit"}, "label_merge_insert": {"ground_truth": "0", "function": "label_merge_insert", "description": "label merge insert create new label by merging and requires preallocated proxy", "id": "label_merge_insert"}, "__virtio_clear_bit": {"ground_truth": "0", "function": "__virtio_clear_bit", "description": "virtio clear bit helper to clear feature bit for use by transport", "id": "__virtio_clear_bit"}, "ssp_read_word": {"ground_truth": "0", "function": "ssp_read_word", "description": "ssp read word read word from the ssp port wait for data word in the ssp receive fifo and return the received data data is lsb justified the caller is expected to perform the necessary locking note currently if data is not expected to be received this function will wait for ever", "id": "ssp_read_word"}, "console_lock_spinning_disable_and_check": {"ground_truth": "0", "function": "console_lock_spinning_disable_and_check", "description": "console lock spinning disable and check mark end of code where another thread wa able to busy wait and check if there is waiter this is called at the end of the section where spinning is allowed it ha two function first it is signal that it is no longer safe to start busy waiting for the lock second it check if there is busy waiter and pass the lock right to her important caller lose the lock if there wa busy waiter they must not touch item synchronized by console lock in this case", "id": "console_lock_spinning_disable_and_check"}, "v9fs_vfs_create": {"ground_truth": "1", "function": "v9fs_vfs_create", "description": "v9fs vfs create vfs hook to create regular file open creat is handled in v9fs vfs atomic open this is only called for mknod", "id": "v9fs_vfs_create"}, "i40iw_cq_post_entries": {"ground_truth": "0", "function": "i40iw_cq_post_entries", "description": "i40iw cq post entry update tail in shadow memory", "id": "i40iw_cq_post_entries"}, "amdgpu_cs_get_fence": {"ground_truth": "0", "function": "amdgpu_cs_get_fence", "description": "amdgpu c get fence helper to get fence from drm amdgpu fence", "id": "amdgpu_cs_get_fence"}, "evm_read_xattrs": {"ground_truth": "1", "function": "evm_read_xattrs", "description": "evm read xattrs read for evm xattrs return number of byte read or error code a appropriate", "id": "evm_read_xattrs"}, "test_bit": {"ground_truth": "0", "function": "test_bit", "description": "test bit determine whether bit is set", "id": "test_bit"}, "__pci_epc_create": {"ground_truth": "0", "function": "__pci_epc_create", "description": "pci epc create create new endpoint controller epc device invoke to create new epc device and add it to pci epc class", "id": "__pci_epc_create"}, "scsi_init_io": {"ground_truth": "0", "function": "scsi_init_io", "description": "None", "id": "scsi_init_io"}, "handle_itdb": {"ground_truth": "0", "function": "handle_itdb", "description": "handle itdb restore itdb to program interruption tdb in guest lowcore and set tx abort indication if required", "id": "handle_itdb"}, "af_alg_sendmsg": {"ground_truth": "0", "function": "af_alg_sendmsg", "description": "af alg sendmsg implementation of sendmsg system call handler the sendmsg system call handler obtains the user data and store it in ctx tsgl list this implies allocation of the required number of struct af alg tsgl in addition the ctx is filled with the information sent via cmsg sock socket of connection to user space msg message from user space size size of message from user space ivsize the size of the iv for the cipher operation to verify that the user space provided iv ha the right size return the number of copied data upon success upon error", "id": "af_alg_sendmsg"}, "dwmac_get_adv_lp": {"ground_truth": "0", "function": "dwmac_get_adv_lp", "description": "dwmac get adv lp get adv and lp cap this is to expose the ane advertisement and link partner ability status to ethtool support", "id": "dwmac_get_adv_lp"}, "NE_ERR_INVALID_PAGE_SIZE": {"ground_truth": "0", "function": "NE_ERR_INVALID_PAGE_SIZE", "description": "ne err invalid page size the user space memory region is not backed by page multiple of mib", "id": "NE_ERR_INVALID_PAGE_SIZE"}, "pm8001_pci_probe": {"ground_truth": "0", "function": "pm8001_pci_probe", "description": "pm8001 pci probe probe supported device this function is the main initialization function when register new pci driver it is invoked all struct an hardware initilization should be done here also register interrupt", "id": "pm8001_pci_probe"}, "ice_init_pf": {"ground_truth": "0", "function": "ice_init_pf", "description": "ice init pf initialize general software structure struct ice pf", "id": "ice_init_pf"}, "dma_buf_poll_cb": {"ground_truth": "0", "function": "dma_buf_poll_cb", "description": "dma buf poll cb doc implicit fence polling to support cross device and cross driver synchronization of buffer access implicit fence represented internally in the kernel with struct dma fence can be attached to dma buf the glue for that and few related thing are provided in the dma resv structure userspace can query the state of these implicitly tracked fence using poll and related system call checking for epollin read access can be use to query the state of the most recent write or exclusive fence checking for epollout write access can be used to query the state of all attached fence shared and exclusive one note that this only signal the completion of the respective fence the dma transfer are complete cache flushing and any other necessary preparation before cpu access can begin still need to happen", "id": "dma_buf_poll_cb"}, "tty_ldisc_deinit": {"ground_truth": "0", "function": "tty_ldisc_deinit", "description": "tty ldisc deinit ldisc cleanup for new tty", "id": "tty_ldisc_deinit"}, "ixgbe_find_vlvf_slot": {"ground_truth": "0", "function": "ixgbe_find_vlvf_slot", "description": "ixgbe find vlvf slot find the vlanid or the first empty slot", "id": "ixgbe_find_vlvf_slot"}, "scmi_dump_header_dbg": {"ground_truth": "0", "function": "scmi_dump_header_dbg", "description": "scmi dump header dbg helper to dump message header", "id": "scmi_dump_header_dbg"}, "i40iw_get_encoded_wqe_size": {"ground_truth": "0", "function": "i40iw_get_encoded_wqe_size", "description": "i40iw get encoded wqe size given wq size return hardware encoded size", "id": "i40iw_get_encoded_wqe_size"}, "dwc2_hsotg_set_test_mode": {"ground_truth": "0", "function": "dwc2_hsotg_set_test_mode", "description": "dwc2 hsotg set test mode enable usb test mode", "id": "dwc2_hsotg_set_test_mode"}, "kbuffer_timestamp": {"ground_truth": "0", "function": "kbuffer_timestamp", "description": "kbuffer timestamp return the timestamp of the current event return the timestamp of the current next event", "id": "kbuffer_timestamp"}, "intel_context_lock_pinned": {"ground_truth": "0", "function": "intel_context_lock_pinned", "description": "intel context lock pinned stablises the pinned status of the hw context ce the context acquire lock on the pinned status of the hw context such that the context can neither be bound to the gpu or unbound whilst the lock is held intel context is pinned remains stable", "id": "intel_context_lock_pinned"}, "worker_enter_idle": {"ground_truth": "0", "function": "worker_enter_idle", "description": "worker enter idle enter idle state worker is entering idle state update stats and idle timer if necessary locking raw spin lock irq pool lock", "id": "worker_enter_idle"}, "dirty_cow_pnode": {"ground_truth": "0", "function": "dirty_cow_pnode", "description": "dirty cow pnode ensure pnode is not being committed return dirtied pnode on success or negative error code on failure", "id": "dirty_cow_pnode"}, "get_vaddr_frames": {"ground_truth": "0", "function": "get_vaddr_frames", "description": "get vaddr frame map virtual address to pfns this function map virtual address from start and fill vec structure with page frame number or page pointer to corresponding page choice depends on the type of the vma underlying the virtual address if start belongs to normal vma the function grab reference to each of the page to pin them in memory if start belongs to vm io vm pfnmap vma we do not touch page structure and the caller must make sure pfns are not reused for anything else while he is using them the function return number of page mapped which may be le than nr frame in particular we stop mapping if there are more vmas of different type underlying the specified range of virtual address when the function is not able to map single page it return error this function take care of grabbing mmap lock a necessary", "id": "get_vaddr_frames"}, "nfs_setup_write_request": {"ground_truth": "0", "function": "nfs_setup_write_request", "description": "nfs setup write request try to update an existing write request or create one if there is none note should always be called with the page lock held to prevent race if we have to add new request also assumes that the caller ha already called nfs flush incompatible if necessary", "id": "nfs_setup_write_request"}, "nfs_complete_unlink": {"ground_truth": "0", "function": "nfs_complete_unlink", "description": "nfs complete unlink initialize completion of the sillydelete since we are most likely to be called by dentry iput we only use the dentry to find the sillydelete we then copy the name into the qstr", "id": "nfs_complete_unlink"}, "ksz_alloc_desc": {"ground_truth": "0", "function": "ksz_alloc_desc", "description": "ksz alloc desc allocate hardware descriptor this local function allocates hardware descriptor for receiving and transmitting return if successful", "id": "ksz_alloc_desc"}, "spi_controller_dma_unmap_mem_op_data": {"ground_truth": "0", "function": "spi_controller_dma_unmap_mem_op_data", "description": "spi controller dma unmap mem op data dma unmap the buffer attached to memory operation some controller might want to do dma on the data buffer embedded in op this helper prepares thing so that the cpu can access the op data buf in out buffer again this function is not intended to be called from spi driver only spi controller driver should use it this function should be called after the dma operation ha finished and is only valid if the previous spi controller dma map mem op data call returned", "id": "spi_controller_dma_unmap_mem_op_data"}, "ixgbe_set_mta": {"ground_truth": "0", "function": "ixgbe_set_mta", "description": "ixgbe set mta set bit vector in multicast table", "id": "ixgbe_set_mta"}, "cc_get_tee_fips_status": {"ground_truth": "0", "function": "cc_get_tee_fips_status", "description": "cc get tee fips statusthe function called once at driver entry point to check whether tee fips error occurred", "id": "cc_get_tee_fips_status"}, "iio_simple_dummy_events_register": {"ground_truth": "0", "function": "iio_simple_dummy_events_register", "description": "iio simple dummy event register setup interrupt handling for event this function request the threaded interrupt to handle the event normally the irq is hardware interrupt and the number come from board configuration file here we get it from companion module that fake the interrupt for u note that module in no way form part of this example just assume that event magically appear via the provided interrupt", "id": "iio_simple_dummy_events_register"}, "binder_get_node_from_ref": {"ground_truth": "0", "function": "binder_get_node_from_ref", "description": "binder get node from ref get the node from the given proc desc given proc and ref handle return the associated binder node", "id": "binder_get_node_from_ref"}, "port_r16": {"ground_truth": "0", "function": "port_r16", "description": "port r16 read word from port register this routine read word from the port register", "id": "port_r16"}, "__nla_reserve_nohdr": {"ground_truth": "0", "function": "__nla_reserve_nohdr", "description": "nla reserve nohdr reserve room for attribute without header reserve room for attribute payload without header the caller is responsible to ensure that the skb provides enough tailroom for the payload", "id": "__nla_reserve_nohdr"}, "drm_connector_attach_vrr_capable_property": {"ground_truth": "1", "function": "drm_connector_attach_vrr_capable_property", "description": "drm connector attach vrr capable property creates the vrr capable property this is used by atomic driver to add support for querying variable refresh rate capability for connector", "id": "drm_connector_attach_vrr_capable_property"}, "ieee80211_stop_queue": {"ground_truth": "0", "function": "ieee80211_stop_queue", "description": "ieee80211 stop queue stop specific queue driver should use this function instead of netif stop queue", "id": "ieee80211_stop_queue"}, "dmaengine_get": {"ground_truth": "0", "function": "dmaengine_get", "description": "dmaengine get register interest in dma channel", "id": "dmaengine_get"}, "pch_gbe_mdio_read": {"ground_truth": "0", "function": "pch_gbe_mdio_read", "description": "pch gbe mdio read the read function for mii", "id": "pch_gbe_mdio_read"}, "vb2_fileio_is_active": {"ground_truth": "0", "function": "vb2_fileio_is_active", "description": "vb2 fileio is active return true if fileio is active this return true if read or write is used to stream the data a opposed to stream this is almost never an important distinction except in rare case one such case is that using read or write to stream format using v4l2 field alternate is not allowed since there is no way you can pas the field information of each buffer to from userspace driver that support this field format should check for this in the type vb2 ops queue setup op and reject it if this function return true", "id": "vb2_fileio_is_active"}, "asd_get_attached_sas_addr": {"ground_truth": "0", "function": "asd_get_attached_sas_addr", "description": "asd get attached sa addr extract generate attached sa address this function extract the sa address from an identify frame received if oob is sata then sa address is generated from the ha table locking the frame rcvd lock need to be held since this par the frame buffer", "id": "asd_get_attached_sas_addr"}, "w_e_end_rsdata_req": {"ground_truth": "0", "function": "w_e_end_rsdata_req", "description": "end rsdata req worker callback to send r data reply packet in response to r data request", "id": "w_e_end_rsdata_req"}, "batadv_store_throughput_override": {"ground_truth": "0", "function": "batadv_store_throughput_override", "description": "batadv store throughput override parse and store throughput override entered by the user", "id": "batadv_store_throughput_override"}, "set_trigger_filter": {"ground_truth": "0", "function": "set_trigger_filter", "description": "set trigger filter generic event command set filter implementation common implementation for event command filter parsing and filter instantiation usually used directly a the set filter method in event command implementation also used to remove filter if filter str null", "id": "set_trigger_filter"}, "drm_dp_stop_crc": {"ground_truth": "0", "function": "drm_dp_stop_crc", "description": "drm dp stop crc stop capture of frame crcs return on success or negative error code on failure", "id": "drm_dp_stop_crc"}, "mesh_plink_deactivate": {"ground_truth": "0", "function": "mesh_plink_deactivate", "description": "mesh plink deactivate deactivate mesh peer link all mesh path with this peer a next hop will be flushed", "id": "mesh_plink_deactivate"}, "hash_page_mm": {"ground_truth": "0", "function": "hash_page_mm", "description": "hash page mm result code is handled normal page fault critical hash insertion error access not permitted by subpage protection mechanism", "id": "hash_page_mm"}, "sem_obtain_object": {"ground_truth": "0", "function": "sem_obtain_object", "description": "sem obtain object sem lock check routine are called in the path where the rwsem is not held the caller hold the rcu read lock", "id": "sem_obtain_object"}, "qla4_82xx_pci_mem_bound_check": {"ground_truth": "0", "function": "qla4_82xx_pci_mem_bound_check", "description": "check memory access boundary used by test agent supportddr access only for now", "id": "qla4_82xx_pci_mem_bound_check"}}}