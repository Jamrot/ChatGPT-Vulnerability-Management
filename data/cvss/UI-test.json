{
    "UI": {
        "die_find_child": {
            "ground_truth": "1",
            "function": "die_find_child",
            "description": "die find child generic die search function in die tree trace die tree from rt die and call callback for each child die if callback return die find cb end this store the die into die mem and return it if callback return die find cb continue this continues to trace the tree optionally callback can return die find cb child and die find cb sibling those mean trace only the child and trace only the sibling respectively return null if callback can not find any appropriate die dwarf die rt die root die int callback dwarf die void callback function void data user data passed to the callback function dwarf die die mem buffer for result die",
            "id": "die_find_child"
        },
        "f2fs_quota_write": {
            "ground_truth": "1",
            "function": "f2fs_quota_write",
            "description": "f2fs quota write write to quotafile",
            "id": "f2fs_quota_write"
        },
        "btrfs_get_extent": {
            "ground_truth": "1",
            "function": "btrfs_get_extent",
            "description": "btrfs get extent lookup the first extent overlapping range in file this return the first type struct extent map which overlap with the given range reading it from the tree and caching it if necessary note that there may be more extent which overlap the given range after the returned extent map if page is not null and the extent is inline this also read the extent data directly into the page and mark the extent up to date in the io tree struct btrfs inode inode file to search in struct page page page to read extent data into if the extent is inline size pg offset offset into page to copy to u64 start file offset u64 len length of range starting at start err ptr on error non null extent map on success",
            "id": "btrfs_get_extent"
        },
        "vt_do_diacrit": {
            "ground_truth": "1",
            "function": "vt_do_diacrit",
            "description": "vt do diacrit diacritical table update unsigned int cmd ioctl request void user udp pointer to user data for ioctl int perm permission check computed by caller update the diacritical table atomically and safely lock them against simultaneous keypresses",
            "id": "vt_do_diacrit"
        },
        "btrfs_trans_release_chunk_metadata": {
            "ground_truth": "1",
            "function": "btrfs_trans_release_chunk_metadata",
            "description": "btrfs trans release chunk metadata to be called after all the new block group attached to the transaction handle have been created btrfs create pending block group",
            "id": "btrfs_trans_release_chunk_metadata"
        },
        "data_write": {
            "ground_truth": "1",
            "function": "data_write",
            "description": "data write data write data debugfs file write handler this function allows user space to send out data qmi encoded message to the associated remote test service and will return with the result of the transaction it serf a an example of how to have the qmi helper decode transaction response into provided object automatically file debugfs file context user buf reference to the user data count number of byte in user buf ppos offset in file to write return count or negative errno on failure",
            "id": "data_write"
        },
        "sysfs_create_mount_point": {
            "ground_truth": "1",
            "function": "sysfs_create_mount_point",
            "description": "sysfs create mount point create an always empty directory struct kobject parent kobj kobject that will contain this always empty directory const char name the name of the always empty directory to add",
            "id": "sysfs_create_mount_point"
        },
        "iucv_sever_pathid": {
            "ground_truth": "1",
            "function": "iucv_sever_pathid",
            "description": "iucv sever pathid sever an iucv path to free up the pathid used internally u16 pathid path identification number u8 userdata byte of user data",
            "id": "iucv_sever_pathid"
        },
        "f2fs_alloc_nid_failed": {
            "ground_truth": "1",
            "function": "f2fs_alloc_nid_failed",
            "description": "f2fs alloc nid failed f2fs alloc nid should be called prior to this function",
            "id": "f2fs_alloc_nid_failed"
        },
        "pvrdma_dereg_mr": {
            "ground_truth": "1",
            "function": "pvrdma_dereg_mr",
            "description": "pvrdma dereg mr deregister memory region struct ib mr ibmr memory region struct ib udata udata pointer to user data on success",
            "id": "pvrdma_dereg_mr"
        },
        "CIFS_MOUNT_MASK": {
            "ground_truth": "1",
            "function": "CIFS_MOUNT_MASK",
            "description": "cifs mount mask trying to reuse existing superblock for new mount",
            "id": "CIFS_MOUNT_MASK"
        },
        "lpfc_idiag_drbacc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_drbacc_write",
            "description": "lpfc idiag drbacc write syntax check and set up idiag drbacc command this routine get the debugfs idiag command struct from user space and then perform the syntax check for port doorbell register read dump or write set command accordingly in the case of port queue read command it set up the command in the idiag command struct for the following debugfs read operation in the case of port doorbell register write operation it executes the write operation into the port doorbell register accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from",
            "id": "lpfc_idiag_drbacc_write"
        },
        "i40iw_destroy_cq": {
            "ground_truth": "1",
            "function": "i40iw_destroy_cq",
            "description": "i40iw destroy cq destroy cq struct ib cq ib cq cq pointer struct ib udata udata user data or null for kernel object",
            "id": "i40iw_destroy_cq"
        },
        "path_has_submounts": {
            "ground_truth": "1",
            "function": "path_has_submounts",
            "description": "path ha submounts check for mount over dentry in the current namespace return true if the parent or it subdirectory contain mount point in the current namespace const struct path parent path to check",
            "id": "path_has_submounts"
        },
        "pvrdma_query_device": {
            "ground_truth": "1",
            "function": "pvrdma_query_device",
            "description": "pvrdma query device query device struct ib device ibdev the device to query struct ib device attr prop the device property struct ib udata uhw user data on success otherwise negative errno",
            "id": "pvrdma_query_device"
        },
        "cifs_compose_mount_options": {
            "ground_truth": "1",
            "function": "cifs_compose_mount_options",
            "description": "cifs compose mount option creates mount option for referral creates mount option for submount based on template option sb mountdata and replacing unc ip prefixpath option with one we have got form ref unc const char sb mountdata parent root dfs mount option template const char fullpath full path in unc format const struct dfs info3 param ref optional server is referral char devname optional pointer for saving device name pointer to new mount option or err ptr caller is responsible for freeing returned value if it is not error",
            "id": "cifs_compose_mount_options"
        },
        "i40iw_query_device": {
            "ground_truth": "1",
            "function": "i40iw_query_device",
            "description": "i40iw query device get device attribute struct ib device ibdev device pointer from stack struct ib device attr prop returning device attribute struct ib udata udata user data",
            "id": "i40iw_query_device"
        },
        "cgroup_writeback_umount": {
            "ground_truth": "1",
            "function": "cgroup_writeback_umount",
            "description": "cgroup writeback umount flush inode wb switch for umount this function is called when super block is about to be destroyed and flush in flight inode wb switch an inode wb switch go through rcu and then workqueue so the two need to be flushed in order to ensure that all previously scheduled switch are finished a wb switch are rare occurrence and synchronize rcu can take while perform flushing iff wb switch are in flight void no argument",
            "id": "cgroup_writeback_umount"
        },
        "pvrdma_destroy_qp": {
            "ground_truth": "1",
            "function": "pvrdma_destroy_qp",
            "description": "pvrdma destroy qp destroy queue pair struct ib qp qp the queue pair to destroy struct ib udata udata user data or null for kernel object always",
            "id": "pvrdma_destroy_qp"
        },
        "copy_to_user_page": {
            "ground_truth": "1",
            "function": "copy_to_user_page",
            "description": "copy to user page copy user data from to page which is mapped into different process address space really we want to allow our user space model to handle this note that this code need to run on the current cpu",
            "id": "copy_to_user_page"
        },
        "may_umount_tree": {
            "ground_truth": "1",
            "function": "may_umount_tree",
            "description": "may umount tree check if mount tree is busy this is called to check if tree of mount ha any open file pwds chroots or sub mount that are busy struct vfsmount undescribed",
            "id": "may_umount_tree"
        },
        "i40iw_alloc_ucontext": {
            "ground_truth": "1",
            "function": "i40iw_alloc_ucontext",
            "description": "i40iw alloc ucontext allocate the user context data structure this keep track of all object associated with particular user mode client struct ib ucontext uctx uverbs context pointer from stack struct ib udata udata user data",
            "id": "i40iw_alloc_ucontext"
        },
        "aa_unpack": {
            "ground_truth": "1",
            "function": "aa_unpack",
            "description": "aa unpack unpack packed binary profile data loaded from user space unpack user data and return refcounted allocated profile stored in lh in order of discovery with the list chain stored in base list or error struct aa loaddata udata user data copied to kmem not null struct list head lh list to place unpacked profile in aa repl w const char n return namespace profile is in if specified else null not null profile on lh else error pointer if fails to unpack",
            "id": "aa_unpack"
        },
        "btrfs_drop_pages": {
            "ground_truth": "1",
            "function": "btrfs_drop_pages",
            "description": "btrfs drop page unlocks page after btrfs file write is done with them",
            "id": "btrfs_drop_pages"
        },
        "ib_destroy_cq_user": {
            "ground_truth": "1",
            "function": "ib_destroy_cq_user",
            "description": "ib destroy cq user destroys the specified cq struct ib cq cq the cq to destroy struct ib udata udata valid user data or null for kernel object",
            "id": "ib_destroy_cq_user"
        },
        "pvrdma_modify_srq": {
            "ground_truth": "1",
            "function": "pvrdma_modify_srq",
            "description": "pvrdma modify srq modify shared receive queue attribute return on success otherwise return an errno struct ib srq ibsrq the shared receive queue to modify struct ib srq attr attr the shared receive queue is new attribute enum ib srq attr mask attr mask attribute mask struct ib udata udata user data",
            "id": "pvrdma_modify_srq"
        },
        "__fsnotify_update_child_dentry_flags": {
            "ground_truth": "1",
            "function": "__fsnotify_update_child_dentry_flags",
            "description": "fsnotify update child dentry flag given an inode first check if we care what happens to our child inotify and dnotify both tell their parent about event if we care about any event on child we run all of our child and set dentry flag saying that the parent care thus when an event happens on child it can quickly tell if if there is need to find parent and send the event to the parent",
            "id": "__fsnotify_update_child_dentry_flags"
        },
        "update_max_tr": {
            "ground_truth": "1",
            "function": "update_max_tr",
            "description": "update max tr snapshot all trace buffer from global trace to max tr flip the buffer between the tr and the max tr and record information about which task wa the cause of this latency struct trace array tr tracer struct task struct tsk the task with the latency int cpu the cpu that initiated the trace void cond data user data associated with conditional snapshot",
            "id": "update_max_tr"
        },
        "rvt_modify_qp": {
            "ground_truth": "1",
            "function": "rvt_modify_qp",
            "description": "rvt modify qp modify the attribute of queue pair struct ib qp ibqp the queue pair who is attribute we are modifying struct ib qp attr attr the new attribute int attr mask the mask of attribute to modify struct ib udata udata user data for libibverbs so on success otherwise return an errno",
            "id": "rvt_modify_qp"
        },
        "write_inode_now": {
            "ground_truth": "1",
            "function": "write_inode_now",
            "description": "write inode now write an inode to disk this function commits an inode to disk immediately if it is dirty this is primarily needed by knfsd the caller must either have ref on the inode or must have set will free struct inode inode inode to write to disk int sync whether the write should be synchronous or not",
            "id": "write_inode_now"
        },
        "tiocsetd": {
            "ground_truth": "1",
            "function": "tiocsetd",
            "description": "tiocsetd set line discipline struct tty struct tty tty device int user pointer to user data set the line discipline according to user request locking see tty set ldisc this function is just helper",
            "id": "tiocsetd"
        },
        "tty_set_ldisc": {
            "ground_truth": "1",
            "function": "tty_set_ldisc",
            "description": "tty set ldisc set line discipline struct tty struct tty the terminal to set int disc the line discipline number set the discipline of tty line must be called from process context the ldisc change logic ha to protect itself against any overlapping ldisc change including on the other end of pty pair the close of one side of tty pty pair and eventually hangup",
            "id": "tty_set_ldisc"
        },
        "pvrdma_create_srq": {
            "ground_truth": "1",
            "function": "pvrdma_create_srq",
            "description": "pvrdma create srq create shared receive queue struct ib srq ibsrq the ib shared receive queue struct ib srq init attr init attr shared receive queue attribute struct ib udata udata user data on success otherwise return an errno",
            "id": "pvrdma_create_srq"
        },
        "ubifs_umount": {
            "ground_truth": "1",
            "function": "ubifs_umount",
            "description": "ubifs umount un mount ubifs file system note this function is called to free allocated resourced when un mounting a well a free resource when an error occurred while we were half way through mounting error path cleanup function so it ha to make sure the resource wa actually allocated before freeing it struct ubifs info ubifs file system description object",
            "id": "ubifs_umount"
        },
        "xfs_reflink_allocate_cow": {
            "ground_truth": "1",
            "function": "xfs_reflink_allocate_cow",
            "description": "xfs reflink allocate cow allocate all cow reservation covering range of block in file",
            "id": "xfs_reflink_allocate_cow"
        },
        "do_loop_readv_writev": {
            "ground_truth": "1",
            "function": "do_loop_readv_writev",
            "description": "do loop readv writev do it by hand with file ops",
            "id": "do_loop_readv_writev"
        },
        "console_unlock": {
            "ground_truth": "0",
            "function": "console_unlock",
            "description": "console unlock unlock the console system release the console lock which the caller hold on the console system and the console driver list while the console lock wa held console output may have been buffered by printk if this is the case console unlock emits the output prior to releasing the lock if there is output waiting we wake dev kmsg and syslog user console unlock may be called from any context void no argument",
            "id": "console_unlock"
        },
        "writeback_single_inode": {
            "ground_truth": "1",
            "function": "writeback_single_inode",
            "description": "writeback single inode write out an inode is dirty page either the caller ha an active reference on the inode or the inode ha will free set this function is designed to be called for writing back one inode which we go from filesystem flusher thread us writeback single inode and doe more profound writeback list handling in writeback sb inodes",
            "id": "writeback_single_inode"
        },
        "diag_cmd_data_alloc": {
            "ground_truth": "1",
            "function": "diag_cmd_data_alloc",
            "description": "diag cmd data alloc fill in bde struct with dma buffer this function allocates page size buffer and populates an lpfc dmabufext if allowed the user data pointed to with indataptr is copied into the kernel memory the chained list of page size buffer is returned struct lpfc hba phba pointer to hba context object struct ulp bde64 bpl pointer to bit bde structure uint32 size number of byte to process int nocopydata flag to copy user data into the allocated buffer",
            "id": "diag_cmd_data_alloc"
        },
        "ext4_try_create_inline_dir": {
            "ground_truth": "1",
            "function": "ext4_try_create_inline_dir",
            "description": "ext4 try create inline dir try to create the inline data for the new dir if it succeeds return otherwise return the error in case of enospc the caller should create the normal disk layout dir",
            "id": "ext4_try_create_inline_dir"
        },
        "debugfs_create_automount": {
            "ground_truth": "1",
            "function": "debugfs_create_automount",
            "description": "debugfs create automount create automount point in the debugfs filesystem should return what automount would const char name pointer to string containing the name of the file to create struct dentry parent pointer to the parent dentry for this file this should be directory dentry if set if this parameter is null then the file will be created in the root of the debugfs filesystem debugfs automount function to be called when pathname resolution step on that one void data opaque argument to pas to",
            "id": "debugfs_create_automount"
        },
        "rdma_destroy_ah_user": {
            "ground_truth": "1",
            "function": "rdma_destroy_ah_user",
            "description": "rdma destroy ah user destroys an address handle struct ib ah ah the address handle to destroy u32 flag destroy address handle flag see enum rdma destroy ah flag struct ib udata udata valid user data or null for kernel object",
            "id": "rdma_destroy_ah_user"
        },
        "flush_write_bio": {
            "ground_truth": "1",
            "function": "flush_write_bio",
            "description": "flush write bio submit bio from extent page data via submit one bio return if everything is ok return for error",
            "id": "flush_write_bio"
        },
        "strndup_user": {
            "ground_truth": "1",
            "function": "strndup_user",
            "description": "strndup user duplicate an existing string from user space const char user the string to duplicate long maximum number of byte to copy including the trailing nul newly allocated copy of or an err ptr in case of error",
            "id": "strndup_user"
        },
        "ntfs_remount": {
            "ground_truth": "1",
            "function": "ntfs_remount",
            "description": "ntfs remount change the mount option of mounted ntfs filesystem change the mount option of an already mounted ntfs filesystem note the vfs set the sb flag remount flag to flag after ntfs remount return successfully return otherwise sb flag are not changed struct super block sb superblock of mounted ntfs filesystem int flag remount flag char opt remount option string",
            "id": "ntfs_remount"
        },
        "usb_serial_generic_write": {
            "ground_truth": "1",
            "function": "usb_serial_generic_write",
            "description": "usb serial generic write generic write function struct tty struct tty tty for the port struct usb serial port port usb serial port const unsigned char buf data to write int count number of byte to write the number of character buffered which may be anything from zero to count or negative errno value",
            "id": "usb_serial_generic_write"
        },
        "IIO_MOUNT_MATRIX": {
            "ground_truth": "1",
            "function": "IIO_MOUNT_MATRIX",
            "description": "iio mount matrix initialize mount matrix extended channel attribute shared whether the attribute is shared between all channel get pointer to an iio get mount matrix accessor",
            "id": "IIO_MOUNT_MATRIX"
        },
        "btrfs_mount": {
            "ground_truth": "1",
            "function": "btrfs_mount",
            "description": "btrfs mount mount function which is called by vfs layer in order to allow mounting subvolume directly btrfs us mount subtree which need vfsmount of device is root this mean device is root ha to be mounted internally in any case operation flow parse subvol id related option for later use in mount subvol mount device is root by calling vfs kern mount note vfs kern mount is used by vfs to call btrfs mount in the first place in order to avoid calling btrfs mount again we use different file system type which is not registered to vfs by register filesystem btrfs root f type a result btrfs mount root is called the return value will be used by mount subtree in mount subvol call mount subvol to get the dentry of subvolume since there is btrfs subvolume set default mount subvol is called always",
            "id": "btrfs_mount"
        },
        "nfs_mount": {
            "ground_truth": "1",
            "function": "nfs_mount",
            "description": "nfs mount obtain an nfs file handle for the given host and path us default timeout parameter specified by underlying transport on successful return the auth flavs list and auth flav len will be populated with the list from the server or faked up list if the server did not provide one struct nfs mount request info pointer to mount request argument",
            "id": "nfs_mount"
        },
        "ping_write": {
            "ground_truth": "1",
            "function": "ping_write",
            "description": "ping write ping write ping pong debugfs file write handler this function allows user space to send out ping pong qmi encoded message to the associated remote test service and will return with the result of the transaction it serf a an example of how to provide custom response handler file debugfs file context user buf reference to the user data ignored count number of byte in user buf ppos offset in file to write return count or negative errno on failure",
            "id": "ping_write"
        },
        "ext4_write_inode": {
            "ground_truth": "1",
            "function": "ext4_write_inode",
            "description": "ext4 write inode ext4 write inode we are called from few place within generic file aio write generic write sync for sync file here there will be no transaction running we wait for any running transaction to commit within flush work sys sync kupdate and such we wait on commit if told to within iput final write inode now we wait on commit if told to in all case it is actually safe for u to return without doing anything because the inode ha been copied into raw inode buffer in ext4 mark inode dirty this is correctness thing for wb sync all writeback note that we are absolutely dependent upon all inode dirtiers doing the right thing they must call mark inode dirty after dirtying info in which we are interested it would be bug for them to not do this the code mark inode dirty inode stuff inode size expr is in error because write inode could occur while stuff is running and the new size will be lost plus the inode will no longer be on the superblock is dirty inode list",
            "id": "ext4_write_inode"
        },
        "ntfs_file_fsync": {
            "ground_truth": "1",
            "function": "ntfs_file_fsync",
            "description": "ntfs file fsync sync file to disk data integrity sync of file to disk used for fsync fdatasync and msync system call this function is inspired by f buffer file fsync if datasync is false write the mft record and all associated extent mft record a well a the data attribute and then sync the block device if datasync is true and the attribute is non resident we skip the writing of the mft record and all associated extent mft record this might still happen due to the write inode now call also if datasync is true we do not wait on the inode to be written out but we always wait on the page cache page to be written out locking caller must hold mutex on the inode todo we should probably also write all attribute index inodes associated with this inode but since we have no simple way of getting to them we ignore this problem for now struct file filp file to be synced loff start undescribed loff end undescribed int datasync if non zero only flush user data and not metadata",
            "id": "ntfs_file_fsync"
        },
        "rvt_modify_srq": {
            "ground_truth": "1",
            "function": "rvt_modify_srq",
            "description": "rvt modify srq modify shared receive queue struct ib srq ibsrq the srq to modify struct ib srq attr attr the new attribute of the srq enum ib srq attr mask attr mask indicates which attribute to modify struct ib udata udata user data for libibverbs so on success",
            "id": "rvt_modify_srq"
        },
        "mcp_i2c_write": {
            "ground_truth": "1",
            "function": "mcp_i2c_write",
            "description": "mcp i2c write an output report can contain minimum and maximum user data byte if the number of data byte is more then we send it in chunk of byte last chunk may contain exactly or le byte total number of byte is informed in very first report to mcp2221 from that point onwards it first collect all the data from host and then send to i2c slave device",
            "id": "mcp_i2c_write"
        },
        "get_user": {
            "ground_truth": "1",
            "function": "get_user",
            "description": "get user get simple variable from user space this macro copy single simple variable from user space to kernel space it support simple type like char and int but not larger data type like structure or array ptr must have pointer to simple variable type and the result of dereferencing ptr must be assignable to without cast variable to store result ptr source address in user space user context only this function may sleep if pagefaults are enabled zero on success or efault on error on error the variable is set to zero",
            "id": "get_user"
        },
        "put_user": {
            "ground_truth": "1",
            "function": "put_user",
            "description": "put user write simple value into user space this macro copy single simple value from kernel space to user space it support simple type like char and int but not larger data type like structure or array ptr must have pointer to simple variable type and must be assignable to the result of dereferencing ptr value to copy to user space ptr destination address in user space user context only this function may sleep if pagefaults are enabled zero on success or efault on error",
            "id": "put_user"
        },
        "ssb_set_drvdata": {
            "ground_truth": "1",
            "function": "ssb_set_drvdata",
            "description": "ssb set drvdata device specific user data",
            "id": "ssb_set_drvdata"
        },
        "fuse_mount_get": {
            "ground_truth": "1",
            "function": "fuse_mount_get",
            "description": "fuse mount get struct fuse mount fm undescribed",
            "id": "fuse_mount_get"
        },
        "seccomp_prepare_user_filter": {
            "ground_truth": "1",
            "function": "seccomp_prepare_user_filter",
            "description": "seccomp prepare user filter prepares user supplied sock fprog return on success and non zero otherwise const char user user filter pointer to the user data containing sock fprog",
            "id": "seccomp_prepare_user_filter"
        },
        "nfs_do_submount": {
            "ground_truth": "1",
            "function": "nfs_do_submount",
            "description": "nfs do submount set up mountpoint when crossing filesystem boundary struct f context fc pointer to struct nfs f context",
            "id": "nfs_do_submount"
        },
        "ssb_get_devtypedata": {
            "ground_truth": "1",
            "function": "ssb_get_devtypedata",
            "description": "ssb get devtypedata devicetype specific user data this is per device type not per device",
            "id": "ssb_get_devtypedata"
        },
        "cu_walk_functions_at": {
            "ground_truth": "1",
            "function": "cu_walk_functions_at",
            "description": "cu walk function at walk on function dy at given address walk on function dy at given addr in cu die passed dy should be subprogram or inlined subroutine dwarf die cu die cu die dwarf addr addr an address int callback dwarf die void callback which called with found dy void data user data",
            "id": "cu_walk_functions_at"
        },
        "snd_lookup_minor_data": {
            "ground_truth": "1",
            "function": "snd_lookup_minor_data",
            "description": "snd lookup minor data get user data of registered device check that minor device with the specified type is registered and return it user data pointer this function increment the reference counter of the card instance if an associated instance with the given minor number and type is found the caller must call snd card unref appropriately later unsigned int minor the minor number int type device type sndrv device type xxx the user data pointer if the specified device is found null otherwise",
            "id": "snd_lookup_minor_data"
        },
        "i40iw_modify_qp": {
            "ground_truth": "1",
            "function": "i40iw_modify_qp",
            "description": "i40iw modify qp modify qp request struct ib qp ibqp qp is pointer for modify struct ib qp attr attr access attribute int attr mask state mask struct ib udata udata user data",
            "id": "i40iw_modify_qp"
        },
        "radix_tree_free_nodes": {
            "ground_truth": "1",
            "function": "radix_tree_free_nodes",
            "description": "radix tree free node free any node below this node the tree is presumed to not need shrinking and any user data in the tree is presumed to not need destructor called on it if we need to add destructor we can add that functionality later note that we may not clear tag or slot from the tree a an rcu walker may still have pointer into this subtree we could replace the entry with radix tree retry but we will still have to clear those in rcu free",
            "id": "radix_tree_free_nodes"
        },
        "resetFPA11": {
            "ground_truth": "0",
            "function": "resetFPA11",
            "description": "resetfpa11 reset the fpa11 chip called to initialize and reset the emulator",
            "id": "resetFPA11"
        },
        "create_io_em": {
            "ground_truth": "0",
            "function": "create_io_em",
            "description": "create io em the caller of this must take lock extent",
            "id": "create_io_em"
        },
        "arch_clk_init": {
            "ground_truth": "0",
            "function": "arch_clk_init",
            "description": "arch clk init placeholder for compatibility until the lazy cpu do this on their own",
            "id": "arch_clk_init"
        },
        "ppc440spe_chan_set_first_xor_descriptor": {
            "ground_truth": "0",
            "function": "ppc440spe_chan_set_first_xor_descriptor",
            "description": "ppc440spe chan set first xor descriptor init xorcore chain struct ppc440spe adma chan chan undescribed struct ppc440spe adma desc slot next desc undescribed",
            "id": "ppc440spe_chan_set_first_xor_descriptor"
        },
        "__v4l2_ctrl_modify_range": {
            "ground_truth": "0",
            "function": "__v4l2_ctrl_modify_range",
            "description": "v4l2 ctrl modify range unlocked variant of v4l2 ctrl modify range update the range of control on the fly this work for control type integer boolean menu integer menu and bitmask for menu control the step value is interpreted a menu skip mask an error is returned if one of the range argument is invalid for this control type the caller is responsible for acquiring the control handler mutex on behalf of v4l2 ctrl modify range struct v4l2 ctrl ctrl the control to update s64 min the control is minimum value s64 max the control is maximum value u64 step the control is step value s64 def the control is default value",
            "id": "__v4l2_ctrl_modify_range"
        },
        "visconti_pin_config_set": {
            "ground_truth": "0",
            "function": "visconti_pin_config_set",
            "description": "visconti pin config set pinconf",
            "id": "visconti_pin_config_set"
        },
        "hfi1_vnic_txreq_init": {
            "ground_truth": "0",
            "function": "hfi1_vnic_txreq_init",
            "description": "hfi1 vnic txreq init vnic hfi1 internal function",
            "id": "hfi1_vnic_txreq_init"
        },
        "snd_sf_clear": {
            "ground_truth": "0",
            "function": "snd_sf_clear",
            "description": "snd sf clear release all list record",
            "id": "snd_sf_clear"
        },
        "unusable_free_index": {
            "ground_truth": "0",
            "function": "unusable_free_index",
            "description": "unusable free index return an index indicating how much of the available free memory is unusable for an allocation of the requested size",
            "id": "unusable_free_index"
        },
        "tcp_rate_gen": {
            "ground_truth": "0",
            "function": "tcp_rate_gen",
            "description": "tcp rate gen update the connection delivery information and generate rate sample",
            "id": "tcp_rate_gen"
        },
        "mvebu_pci_host_probe": {
            "ground_truth": "0",
            "function": "mvebu_pci_host_probe",
            "description": "mvebu pci host probe this is copy of pci host probe except that it doe the remap a the last step once we are sure we will not fail it should be removed once the remap error handling issue ha been sorted out",
            "id": "mvebu_pci_host_probe"
        },
        "gru_alloc_vma_data": {
            "ground_truth": "0",
            "function": "gru_alloc_vma_data",
            "description": "gru alloc vma data allocate vma private data structure",
            "id": "gru_alloc_vma_data"
        },
        "xen_mm_unpin_all": {
            "ground_truth": "0",
            "function": "xen_mm_unpin_all",
            "description": "xen mm unpin all on resume undo any pinning done at save so that the rest of the kernel doe not see any unexpected pinned pagetables",
            "id": "xen_mm_unpin_all"
        },
        "k3_r5_rproc_stop": {
            "ground_truth": "0",
            "function": "k3_r5_rproc_stop",
            "description": "k3 r5 rproc stop the r5f stop function includes the following operation halt r5f core the sequence is different between lockstep and split mode and the order of core the operation are performed are also in general reverse to that of the start function the lockstep mode requires each operation to be performed first on core0 followed by core1 the split mode requires that core0 to be maintained always in higher power state that core1 implying core1 need to be stopped first before core0 note that the r5f halt operation in general is not effective when the r5f core is running but is needed to make sure the core will not run after deasserting the reset the subsequent time the asserting of reset can be done here but is preferred to be done in the unprepare ops this maintains the symmetric behavior between the start stop prepare and unprepare ops and also balance them well between sysfs istate flow and device bind unbind or module removal",
            "id": "k3_r5_rproc_stop"
        },
        "pte_modify": {
            "ground_truth": "0",
            "function": "pte_modify",
            "description": "pte modify the following pte modification function only work if pte present is true undefined behaviour if not",
            "id": "pte_modify"
        },
        "nfs_timespec_to_change_attr": {
            "ground_truth": "0",
            "function": "nfs_timespec_to_change_attr",
            "description": "nfs timespec to change attr convert struct timespec64 into bit change attribute this doe approximately the same thing a timespec64 to n but for calculation efficiency we multiply the second by",
            "id": "nfs_timespec_to_change_attr"
        },
        "fm_v4l2_vidioc_querycap": {
            "ground_truth": "0",
            "function": "fm_v4l2_vidioc_querycap",
            "description": "fm v4l2 vidioc querycap v4l2 radio dev radiox device ioctl interface",
            "id": "fm_v4l2_vidioc_querycap"
        },
        "_cx18_enqueue": {
            "ground_truth": "0",
            "function": "_cx18_enqueue",
            "description": "cx18 enqueue cx18 queue utility function",
            "id": "_cx18_enqueue"
        },
        "mpc52xx_gpt_stop_timer": {
            "ground_truth": "0",
            "function": "mpc52xx_gpt_stop_timer",
            "description": "mpc52xx gpt stop timer stop gpt return an error if attempting to stop wdt struct mpc52xx gpt priv gpt pointer to gpt private data structure",
            "id": "mpc52xx_gpt_stop_timer"
        },
        "rv370_pcie_wreg": {
            "ground_truth": "0",
            "function": "rv370_pcie_wreg",
            "description": "rv370 pcie wreg indirect register accessors they used to be inlined but this increase code size by kbytes since each performs pair of mmio ops within spin lock irqsave spin unlock irqrestore region the cost of call ret is almost negligible mmio and locking cost several dozen of cycle each at best call ret is cycle",
            "id": "rv370_pcie_wreg"
        },
        "lbs_add_card": {
            "ground_truth": "0",
            "function": "lbs_add_card",
            "description": "lb add card add the card it will probe the card allocate the lb priv and initialize the device void card pointer to card struct device dmdev pointer to type struct device pointer to type struct lb private structure",
            "id": "lbs_add_card"
        },
        "sdma_v5_2_ring_emit_pipeline_sync": {
            "ground_truth": "0",
            "function": "sdma_v5_2_ring_emit_pipeline_sync",
            "description": "sdma v5 ring emit pipeline sync sync the pipeline make sure all previous operation are completed cik struct amdgpu ring ring amdgpu ring pointer",
            "id": "sdma_v5_2_ring_emit_pipeline_sync"
        },
        "aq_mss_set_ingress_sa_record": {
            "ground_truth": "0",
            "function": "aq_mss_set_ingress_sa_record",
            "description": "aq ms set ingres sa record pack the field of rec and write the packed data into the specified row of the ingres sa lookup table rec in the bitfield value to write to the table row table index the table row to write max",
            "id": "aq_mss_set_ingress_sa_record"
        },
        "csio_wr_process_fl": {
            "ground_truth": "0",
            "function": "csio_wr_process_fl",
            "description": "csio wr process fl csio wr process fl process freelist completion hw hw module the ingres queue attached to the freelist wr the freelist completion wr in the ingres queue len to qid the lower bit of the first flit of the rsp footer iq handler caller is handler for this completion priv private pointer of caller",
            "id": "csio_wr_process_fl"
        },
        "CPUcheck_maincodeok_turnonCPU": {
            "ground_truth": "0",
            "function": "CPUcheck_maincodeok_turnonCPU",
            "description": "cpucheck maincodeok turnoncpu procedure check whether main code is download ok if ok turn on cpu description cpu register locates in different page against general register switch to cpu register in the begin and switch back before return argument the pointer of the adapter return ndis status failure the following initialization process should be terminated ndis status success if firmware initialization process success",
            "id": "CPUcheck_maincodeok_turnonCPU"
        },
        "__vxge_hw_ring_item_dma_addr": {
            "ground_truth": "0",
            "function": "__vxge_hw_ring_item_dma_addr",
            "description": "vxge hw ring item dma addr vxge hw ring item dma addr return the dma address of an item this function return the dma address of given item",
            "id": "__vxge_hw_ring_item_dma_addr"
        },
        "nci_spi_allocate_spi": {
            "ground_truth": "0",
            "function": "nci_spi_allocate_spi",
            "description": "nci spi allocate spi allocate new nci spi struct spi device spi spi device u8 acknowledge mode acknowledge mode used by the nfc device unsigned int delay delay between transaction in u struct nci dev ndev nci dev to send incoming nci frame to",
            "id": "nci_spi_allocate_spi"
        },
        "anc_configure": {
            "ground_truth": "0",
            "function": "anc_configure",
            "description": "anc configure anc iir fir coefficient configuration sequence",
            "id": "anc_configure"
        },
        "_enable_clocks": {
            "ground_truth": "0",
            "function": "_enable_clocks",
            "description": "enable clock enable hwmod main clock and interface clock enables all clock necessary for register read and writes to succeed on the hwmod oh return struct omap hwmod oh struct omap hwmod",
            "id": "_enable_clocks"
        },
        "sun8i_ss_get_engine_number": {
            "ground_truth": "0",
            "function": "sun8i_ss_get_engine_number",
            "description": "sun8i s get engine number sun8i s get engine number get the next channel slot this is simple round robin way of getting the next channel",
            "id": "sun8i_ss_get_engine_number"
        },
        "xprt_conditional_disconnect": {
            "ground_truth": "0",
            "function": "xprt_conditional_disconnect",
            "description": "xprt conditional disconnect force transport to disconnect this attempt to break the connection if and only if cookie match the current transport connection cookie it ensures that we do not try to break the connection more than once when we need to retransmit batch of rpc request struct rpc xprt xprt transport to disconnect unsigned int cookie connection cookie",
            "id": "xprt_conditional_disconnect"
        },
        "__x25_remove_neigh": {
            "ground_truth": "0",
            "function": "__x25_remove_neigh",
            "description": "x25 remove neigh remove neighbour from x25 neigh list struct x25 neigh nb neigh to remove remove neighbour from x25 neigh list if it wa there caller must hold x25 neigh list lock",
            "id": "__x25_remove_neigh"
        },
        "mv88e6352_config_eventcap": {
            "ground_truth": "0",
            "function": "mv88e6352_config_eventcap",
            "description": "mv88e6352 config eventcap mv88e6352 config eventcap configure tai event capture this will also reset the capture sequence counter event ptp clock pps internal or ptp clock extts external rising zero for falling edge trigger else rising edge trigger",
            "id": "mv88e6352_config_eventcap"
        },
        "startup_registers": {
            "ground_truth": "0",
            "function": "startup_registers",
            "description": "startup register init register at driver load time",
            "id": "startup_registers"
        },
        "s3c_i2c1_cfg_gpio": {
            "ground_truth": "0",
            "function": "s3c_i2c1_cfg_gpio",
            "description": "s3c i2c1 cfg gpio defined by architecture to configure gpio",
            "id": "s3c_i2c1_cfg_gpio"
        },
        "vboxsf_path_from_dentry": {
            "ground_truth": "0",
            "function": "vboxsf_path_from_dentry",
            "description": "vboxsf path from dentry dentry contains string encoded in coding system that corresponds to sbi nls we must convert it to utf8 here return shfl string allocated through getname must be freed using putname or an err ptr on error",
            "id": "vboxsf_path_from_dentry"
        },
        "check_pending": {
            "ground_truth": "0",
            "function": "check_pending",
            "description": "check pending check if there are more mcast mac to be set or previous command is still pending",
            "id": "check_pending"
        },
        "ata_sas_port_alloc": {
            "ground_truth": "0",
            "function": "ata_sas_port_alloc",
            "description": "ata sa port alloc allocate port for sa attached sata device struct ata host host ata host container for all sa port struct ata port info port info information from low level host driver struct scsi host shost scsi host that the scsi device is attached to locking pci etc bus probe sem ata port pointer on success null on failure",
            "id": "ata_sas_port_alloc"
        },
        "vtime_delta": {
            "ground_truth": "0",
            "function": "vtime_delta",
            "description": "vtime delta account time for transition between system hard irq or soft irq state note that this function is called with interrupt enabled",
            "id": "vtime_delta"
        },
        "ipw_wx_get_encodeext": {
            "ground_truth": "0",
            "function": "ipw_wx_get_encodeext",
            "description": "ipw wx get encodeext siocgiwencodeext",
            "id": "ipw_wx_get_encodeext"
        },
        "sd_probe": {
            "ground_truth": "0",
            "function": "sd_probe",
            "description": "sd probe called during driver initialization and whenever new scsi device is attached to the system it is called once for each scsi device not just disk present struct device dev pointer to device object return if successful or not interested in this scsi device scanner when there is an error note this function is invoked from the scsi mid level this function set up the mapping between given found in sdp and new device name dev sda more precisely it is the block device major and minor number that is chosen here assume sd probe is not re entrant for time being also think about sd probe and sd remove running coincidentally",
            "id": "sd_probe"
        },
        "pcrlock": {
            "ground_truth": "0",
            "function": "pcrlock",
            "description": "pcrlock lock trusted key by extending selected pcr prevents trusted key that is sealed to pcrs from being accessed this us the tpm driver is extend function",
            "id": "pcrlock"
        },
        "mvpp2_prs_def_flow_init": {
            "ground_truth": "0",
            "function": "mvpp2_prs_def_flow_init",
            "description": "mvpp2 pr def flow init default flow entry initialization for all port",
            "id": "mvpp2_prs_def_flow_init"
        },
        "copy_vma": {
            "ground_truth": "0",
            "function": "copy_vma",
            "description": "copy vma copy the vma structure to new location in the same mm prior to moving page table entry to effect an mremap move",
            "id": "copy_vma"
        },
        "pvr2_hdw_get_streaming": {
            "ground_truth": "0",
            "function": "pvr2_hdw_get_streaming",
            "description": "pvr2 hdw get streaming find out if streaming is on",
            "id": "pvr2_hdw_get_streaming"
        },
        "__adis_write_reg_16": {
            "ground_truth": "0",
            "function": "__adis_write_reg_16",
            "description": "adis write reg write byte to pair of register unlocked struct adis adis the adis device unsigned int reg the address of the lower of the two register uint16 val undescribed",
            "id": "__adis_write_reg_16"
        },
        "hv_stimer_init": {
            "ground_truth": "0",
            "function": "hv_stimer_init",
            "description": "hv stimer init hv stimer init per cpu initialization of the clockevent",
            "id": "hv_stimer_init"
        },
        "hl_hw_queue_inc_ci_kernel": {
            "ground_truth": "0",
            "function": "hl_hw_queue_inc_ci_kernel",
            "description": "hl hw queue inc ci kernel hl hw queue inc ci kernel increment ci for kernel is queue hdev pointer to hl device structure hw queue id which queue to increment it ci",
            "id": "hl_hw_queue_inc_ci_kernel"
        },
        "iscsi_sna_lt": {
            "ground_truth": "0",
            "function": "iscsi_sna_lt",
            "description": "iscsi sna lt serial number arithmetic bit rfc1982",
            "id": "iscsi_sna_lt"
        },
        "snd_hdac_power_down_pm": {
            "ground_truth": "0",
            "function": "snd_hdac_power_down_pm",
            "description": "snd hdac power down pm power down the codec like snd hdac power up pm this function is used in recursive code path like init code which may be called by pm suspend resume again return zero if successful or negative error code struct hdac device codec the codec object",
            "id": "snd_hdac_power_down_pm"
        },
        "sd_init": {
            "ground_truth": "0",
            "function": "sd_init",
            "description": "sd init this function is called at probe and resume time",
            "id": "sd_init"
        },
        "nanddev_pos_next_lun": {
            "ground_truth": "0",
            "function": "nanddev_pos_next_lun",
            "description": "nanddev po next lun move position to the next lun update po to point to the start of the next lun useful when you want to iterate over all luns of nand device struct nand device nand nand device struct nand po po the position to update",
            "id": "nanddev_pos_next_lun"
        },
        "sctp_ulpevent_is_enabled": {
            "ground_truth": "0",
            "function": "sctp_ulpevent_is_enabled",
            "description": "sctp ulpevent is enabled given an event subscription is this event enabled",
            "id": "sctp_ulpevent_is_enabled"
        },
        "ecryptfs_msg_ctx_free_to_alloc": {
            "ground_truth": "1",
            "function": "ecryptfs_msg_ctx_free_to_alloc",
            "description": "ecryptfs msg ctx free to alloc must be called with ecryptfs msg ctx list mux held struct ecryptfs msg ctx msg ctx the context to move from the free list to the alloc list",
            "id": "ecryptfs_msg_ctx_free_to_alloc"
        },
        "ice_fltr_remove_mac": {
            "ground_truth": "0",
            "function": "ice_fltr_remove_mac",
            "description": "ice fltr remove mac remove mac filter struct ice vsi vsi pointer to vsi struct const u8 mac filter mac to remove enum ice sw fwd act type action action to remove",
            "id": "ice_fltr_remove_mac"
        },
        "qed_eq_prod_update": {
            "ground_truth": "0",
            "function": "qed_eq_prod_update",
            "description": "qed eq prod update eq api",
            "id": "qed_eq_prod_update"
        },
        "vchnl_vf_send_add_hmc_objs_req": {
            "ground_truth": "0",
            "function": "vchnl_vf_send_add_hmc_objs_req",
            "description": "vchnl vf send add hmc objs req add hmc object struct i40iw sc dev dev iwarp device pointer struct i40iw virtchnl req vchnl req virtual channel message request pointer enum i40iw hmc rsrc type rsrc type undescribed u32 start index undescribed u32 rsrc count undescribed",
            "id": "vchnl_vf_send_add_hmc_objs_req"
        },
        "amd_chipset_sb_type_init": {
            "ground_truth": "0",
            "function": "amd_chipset_sb_type_init",
            "description": "amd chipset sb type init amd chipset sb type init initialize amd chipset southbridge type amd fch sb generation and revision is identified by smbus controller vendor device and revision id return if it is an amd chipset otherwise",
            "id": "amd_chipset_sb_type_init"
        },
        "pch_gbe_init_phy": {
            "ground_truth": "0",
            "function": "pch_gbe_init_phy",
            "description": "pch gbe init phy initialize phy struct pch gbe adapter adapter board private structure to initialize successfully negative value failed",
            "id": "pch_gbe_init_phy"
        },
        "aer_probe": {
            "ground_truth": "0",
            "function": "aer_probe",
            "description": "aer probe initialize resource invoked when pci express bus load aer service driver struct pcie device dev pointer to the pcie dev data structure",
            "id": "aer_probe"
        },
        "bfa_nw_ioc_mbox_queue": {
            "ground_truth": "0",
            "function": "bfa_nw_ioc_mbox_queue",
            "description": "bfa nw ioc mbox queue queue mailbox command request to firmware wait if mailbox is busy responsibility of caller to serialize struct bfa ioc ioc ioc instance struct bfa mbox cmd cmd mailbox command bfa mbox cmd cbfn cbfn callback function void cbarg argument to callback",
            "id": "bfa_nw_ioc_mbox_queue"
        },
        "mvneta_rx_desc_fill": {
            "ground_truth": "0",
            "function": "mvneta_rx_desc_fill",
            "description": "mvneta rx desc fill handle rx descriptor fill by setting buf cookie and buf phys addr",
            "id": "mvneta_rx_desc_fill"
        },
        "ip_auto_config": {
            "ground_truth": "0",
            "function": "ip_auto_config",
            "description": "ip auto config ip autoconfig dispatcher",
            "id": "ip_auto_config"
        },
        "ci_hdrc_add_device": {
            "ground_truth": "0",
            "function": "ci_hdrc_add_device",
            "description": "ci hdrc add device add ci hdrc device",
            "id": "ci_hdrc_add_device"
        },
        "hw_breakpoint_validate_len": {
            "ground_truth": "0",
            "function": "hw_breakpoint_validate_len",
            "description": "hw breakpoint validate len watchpoint match range is always doubleword byte aligned on powerpc if the given range is crossing doubleword boundary we need to increase the length such that next doubleword also get covered ex address len byte byte in this case we should configure hw a start addr address hw breakpoint size len byte start addr is inclusive but end addr is exclusive",
            "id": "hw_breakpoint_validate_len"
        },
        "get_channel_type": {
            "ground_truth": "0",
            "function": "get_channel_type",
            "description": "get channel type return type of detected device",
            "id": "get_channel_type"
        },
        "sata_pmp_attach": {
            "ground_truth": "0",
            "function": "sata_pmp_attach",
            "description": "sata pmp attach attach sata pmp device struct ata device dev sata pmp device to attach configure and attach sata pmp device dev this function is also responsible for allocating and initializing pmp link locking kernel thread context may sleep on success errno on failure",
            "id": "sata_pmp_attach"
        },
        "set_ai_fifo_size": {
            "ground_truth": "0",
            "function": "set_ai_fifo_size",
            "description": "set ai fifo size adjusts the size of hardware fifo which determines block size for dma xfers",
            "id": "set_ai_fifo_size"
        },
        "svga_set_timings": {
            "ground_truth": "0",
            "function": "svga_set_timings",
            "description": "svga set timing set crt timing register",
            "id": "svga_set_timings"
        },
        "ov772x_probe": {
            "ground_truth": "0",
            "function": "ov772x_probe",
            "description": "ov772x probe i2c driver function",
            "id": "ov772x_probe"
        },
        "puts": {
            "ground_truth": "0",
            "function": "puts",
            "description": "put tty",
            "id": "puts"
        },
        "hfi1_process_ecn_slowpath": {
            "ground_truth": "0",
            "function": "hfi1_process_ecn_slowpath",
            "description": "hfi1 process ecn slowpath process fecn or becn bit process the packet is fecn or becn bit by now the packet ha already been evaluated whether processing of those bit should be done the significance of the prescan argument is that if the caller is the rxq prescan cnp will be send out instead of waiting for the normal packet processing to send an ack with becn set or cnp struct rvt qp qp the packet is destination qp struct hfi1 packet pkt the packet itself bool prescan is the caller the rxq prescan",
            "id": "hfi1_process_ecn_slowpath"
        },
        "arc_free_rx_queue": {
            "ground_truth": "0",
            "function": "arc_free_rx_queue",
            "description": "arc free rx queue free skb from rx queue this function must be called while emac disable struct net device ndev pointer to the network device",
            "id": "arc_free_rx_queue"
        },
        "__drm_connector_put_safe": {
            "ground_truth": "0",
            "function": "__drm_connector_put_safe",
            "description": "drm connector put safe extra safe connector put function that work in any context should only be used from the connector iter function where we never really expect to actually release the connector when dropping our final reference",
            "id": "__drm_connector_put_safe"
        },
        "ia_css_ifmtr_lines_needed_for_bayer_order": {
            "ground_truth": "0",
            "function": "ia_css_ifmtr_lines_needed_for_bayer_order",
            "description": "ia cs ifmtr line needed for bayer order isp expects grbg bayer order we skip one line and or one row to correct in case the input bayer order is different",
            "id": "ia_css_ifmtr_lines_needed_for_bayer_order"
        },
        "preview_config_rgb_blending": {
            "ground_truth": "0",
            "function": "preview_config_rgb_blending",
            "description": "preview config rgb blending preview config rgb blending configure rgb rgb blending",
            "id": "preview_config_rgb_blending"
        },
        "trace_imc_prepare_sample": {
            "ground_truth": "0",
            "function": "trace_imc_prepare_sample",
            "description": "trace imc prepare sample function to parse trace imc data obtained and to prepare the perf sample",
            "id": "trace_imc_prepare_sample"
        },
        "rts7751r2d_setup": {
            "ground_truth": "0",
            "function": "rts7751r2d_setup",
            "description": "rts7751r2d setup initialize the board",
            "id": "rts7751r2d_setup"
        },
        "smc_copy_sock_settings_to_clc": {
            "ground_truth": "0",
            "function": "smc_copy_sock_settings_to_clc",
            "description": "smc copy sock setting to clc copy only relevant setting and flag of sol socket level from smc to clc socket since smc is not called for these option from net core",
            "id": "smc_copy_sock_settings_to_clc"
        },
        "stub_rx_pdu": {
            "ground_truth": "0",
            "function": "stub_rx_pdu",
            "description": "stub rx pdu recv pdu",
            "id": "stub_rx_pdu"
        },
        "bL_switcher_put_enabled": {
            "ground_truth": "0",
            "function": "bL_switcher_put_enabled",
            "description": "bl switcher put enabled use these function to temporarily prevent enabling disabling of the switcher bl switcher get enabled return true if the switcher is currently enabled each call to bl switcher get enabled must be followed by call to bl switcher put enabled these function are not recursive",
            "id": "bL_switcher_put_enabled"
        },
        "sm750_calc_pll_value": {
            "ground_truth": "0",
            "function": "sm750_calc_pll_value",
            "description": "sm750 calc pll value monk liu re write the calculatepll function of ddk750 the original version function doe not use some mathematics trick and shortcut when it doing the calculation of the best combination think this version give little upgrade in speed pll clock formular request clock input clock input clock hz power",
            "id": "sm750_calc_pll_value"
        },
        "ZSTD_insertBt1": {
            "ground_truth": "0",
            "function": "ZSTD_insertBt1",
            "description": "zstd insertbt1 zstd insertbt1 add one or multiple position to tree ip assumed iend return nb of position added",
            "id": "ZSTD_insertBt1"
        },
        "ppa_d_pulse": {
            "ground_truth": "0",
            "function": "ppa_d_pulse",
            "description": "ppa pulse end of ppa io",
            "id": "ppa_d_pulse"
        },
        "mdesc_adi_init": {
            "ground_truth": "0",
            "function": "mdesc_adi_init",
            "description": "mdesc adi init mdesc adi init parse machine description provided by the hypervisor to detect adi capability hypervisor report adi capability of platform in hwcap list property for cpu node if the platform support adi hwcap list property contains the keyword adp if the platform support adi platform node will contain adp blksz adp nbits and ue on adp property to describe the adi capability",
            "id": "mdesc_adi_init"
        },
        "defined": {
            "ground_truth": "0",
            "function": "defined",
            "description": "defined writeback",
            "id": "defined"
        },
        "axienet_start_xmit_done": {
            "ground_truth": "0",
            "function": "axienet_start_xmit_done",
            "description": "axienet start xmit done invoked once transmit is completed by the axi dma tx channel this function is invoked from the axi dma tx isr to notify the completion of transmit operation it clear field in the corresponding tx bd and unmaps the corresponding buffer so that cpu can regain ownership of the buffer it finally invokes netif wake queue to restart transmission if required struct net device ndev pointer to the net device structure",
            "id": "axienet_start_xmit_done"
        },
        "recording_options": {
            "ground_truth": "0",
            "function": "recording_options",
            "description": "recording option struct auxtrace record callback for recording aux area data recording option validate and process recording option info priv size return the size of the private data in auxtrace info event info fill fill in the private data in auxtrace info event free free this auxtrace record structure snapshot start starting snapshot snapshot finish finishing snapshot find snapshot find data to snapshot within auxtrace mmap parse snapshot option parse snapshot option reference provide bit reference number for auxtrace event read finish called after reading from an auxtrace mmap alignment alignment if any for aux area data default aux sample size default sample size for aux sample option pmu associated pmu evlist selected event list",
            "id": "recording_options"
        },
        "dc_status": {
            "ground_truth": "0",
            "function": "dc_status",
            "description": "dc status clock related",
            "id": "dc_status"
        },
        "lcd_device_register": {
            "ground_truth": "0",
            "function": "lcd_device_register",
            "description": "lcd device register register new object of lcd device class creates and register new lcd device return either an err ptr or pointer to the newly allocated device const char name the name of the new object must be the same a the name of the respective framebuffer device struct device parent pointer to the parent is struct device void devdata an optional pointer to be stored in the device the method may retrieve it by using lcd get data ld struct lcd ops ops the lcd operation structure",
            "id": "lcd_device_register"
        },
        "getindex": {
            "ground_truth": "0",
            "function": "getindex",
            "description": "getindex return the value in the graphic address register",
            "id": "getindex"
        },
        "mfd_cell_disable": {
            "ground_truth": "0",
            "function": "mfd_cell_disable",
            "description": "mfd cell disable convenience function for client using shared cell refcounting happens automatically with the cell is enable disable callback being called only when device is first being enabled or no other client are making use of it",
            "id": "mfd_cell_disable"
        },
        "smc_phy_powerdown": {
            "ground_truth": "0",
            "function": "smc_phy_powerdown",
            "description": "smc phy powerdown powerdown phy power down the specified phy struct net device dev net device",
            "id": "smc_phy_powerdown"
        },
        "acpi_irq_penalty_init": {
            "ground_truth": "0",
            "function": "acpi_irq_penalty_init",
            "description": "acpi irq penalty init acpi pci interrupt link pci link",
            "id": "acpi_irq_penalty_init"
        },
        "snd_midi_channel": {
            "ground_truth": "0",
            "function": "snd_midi_channel",
            "description": "snd midi channel executes the callback for all voice of to the specified channel",
            "id": "snd_midi_channel"
        },
        "__expr_eliminate_eq": {
            "ground_truth": "0",
            "function": "__expr_eliminate_eq",
            "description": "expr eliminate eq expr eliminate eq helper walk the two expression tree given in ep1 and ep2 any node that doe not have type notype or and is considered leaf and is compared against all other leaf two equal leaf are both replaced with either or a appropriate for notype to be eliminated later",
            "id": "__expr_eliminate_eq"
        },
        "__hash_32": {
            "ground_truth": "0",
            "function": "__hash_32",
            "description": "hash while it would be legal to substitute different hash operation entirely let is keep it simple and just use an optimized multiply by golden ratio the best way to do that appears to be to multiply by with shift and add and use mulu to multiply the high half by because the ha multi cycle shift this addition chain is chosen to minimise the shift distance despite every attempt to spoon feed it simple operation gcc doggedly insists on doing annoying thing like converting lsl cycle to two add cycle it also like to notice two shift in row like and and convert that to but shift longer than bit are extra slow on m68k so that is lose since the is very simple in order processor with no instruction scheduling effect on execution time we can safely take it out of gcc is hand and write one big asm block without calling overhead this operation is byte instruction plus one immediate constant and cycle because is fetched twice it can not be postincrement and thus it can not be fully general or register is preferred but offsettable memory or immediate will work",
            "id": "__hash_32"
        },
        "filelayout_get_dserver_offset": {
            "ground_truth": "0",
            "function": "filelayout_get_dserver_offset",
            "description": "filelayout get dserver offset this function is used by the layout driver to calculate the offset of the file on the dserver based on whether the layout type is stripe dense or stripe sparse",
            "id": "filelayout_get_dserver_offset"
        },
        "KVM_REG_ARM64_SVE_ZREG": {
            "ground_truth": "0",
            "function": "KVM_REG_ARM64_SVE_ZREG",
            "description": "kvm reg arm64 sve zreg reg id range for register",
            "id": "KVM_REG_ARM64_SVE_ZREG"
        },
        "ice_dcbnl_vsi_del_app": {
            "ground_truth": "0",
            "function": "ice_dcbnl_vsi_del_app",
            "description": "ice dcbnl vsi del app delete app on all vsis delete given app from all the vsis for given pf struct ice vsi vsi pointer to the main vsi struct ice dcb app priority table app app to delete",
            "id": "ice_dcbnl_vsi_del_app"
        },
        "afs_sleep_and_retry": {
            "ground_truth": "0",
            "function": "afs_sleep_and_retry",
            "description": "afs sleep and retry sleep and retry the operation to the same fileserver",
            "id": "afs_sleep_and_retry"
        },
        "enable": {
            "ground_truth": "0",
            "function": "enable",
            "description": "enable struct clkops some clock function pointer companion clk is an accompanying clock to the one being queried that must be enabled for the ip module connected to the clock to become accessible by the hardware neither find idlest nor block specific the hwmod code ha been created to handle this but until hwmod data is ready and driver have been converted to use pm runtime call in place of clk enable clk disable find idlest and enable fn ptr that enables the current clock in hardware disable fn ptr that enables the current clock in hardware find idlest function returning the idlest register for the clock is ip blk find companion function returning the companion clk reg for the clock allow idle fn ptr that enables autoidle for the current clock in hardware deny idle fn ptr that disables autoidle for the current clock in hardware find companion should be needed that information is ip find companion must unfortunately remain",
            "id": "enable"
        },
        "__do_block_io_op": {
            "ground_truth": "0",
            "function": "__do_block_io_op",
            "description": "do block io op function to copy the from the ring buffer the istruct blkif request which ha the sector we want number of them grant reference etc and transmute it to the block api to hand it over to the proper block disk",
            "id": "__do_block_io_op"
        },
        "vxlan_err_lookup": {
            "ground_truth": "0",
            "function": "vxlan_err_lookup",
            "description": "vxlan err lookup callback from net ipv udp to check that we have vni for error",
            "id": "vxlan_err_lookup"
        },
        "gotop_read_data": {
            "ground_truth": "0",
            "function": "gotop_read_data",
            "description": "gotop read data gotop part",
            "id": "gotop_read_data"
        },
        "rp_open": {
            "ground_truth": "0",
            "function": "rp_open",
            "description": "rp open exception handler that open serial port creates xmit buf storage fill in port is port struct initializes the port hardware",
            "id": "rp_open"
        },
        "cleanup_freed_for_journal_list": {
            "ground_truth": "1",
            "function": "cleanup_freed_for_journal_list",
            "description": "cleanup freed for journal list this used to be much more involved and am keeping it just in case thing get ugly again it get called by flush commit list and clean up any data stored about block freed during transaction",
            "id": "cleanup_freed_for_journal_list"
        },
        "account_user_time": {
            "ground_truth": "0",
            "function": "account_user_time",
            "description": "account user time account user cpu time to process the process that the cpu time get accounted to cputime the cpu time spent in user space since the last update",
            "id": "account_user_time"
        },
        "spufs_mfc_mmap": {
            "ground_truth": "0",
            "function": "spufs_mfc_mmap",
            "description": "spufs mfc mmap mmap support for problem state mfc dma area",
            "id": "spufs_mfc_mmap"
        },
        "sbitmap_any_bit_set": {
            "ground_truth": "0",
            "function": "sbitmap_any_bit_set",
            "description": "sbitmap any bit set check for set bit in type struct sbitmap const struct sbitmap sb bitmap to check true if any bit in the bitmap is set false otherwise",
            "id": "sbitmap_any_bit_set"
        },
        "acpi_video_device_enumerate": {
            "ground_truth": "0",
            "function": "acpi_video_device_enumerate",
            "description": "acpi video device enumerate arg video video bus device return error call dod to enumerate all device attached to display adapter",
            "id": "acpi_video_device_enumerate"
        },
        "microcode_check": {
            "ground_truth": "0",
            "function": "microcode_check",
            "description": "microcode check the microcode loader call this upon late microcode load to recheck feature only when microcode ha been updated caller hold microcode mutex and cpu hotplug lock",
            "id": "microcode_check"
        },
        "hinic_sq_put_wqe": {
            "ground_truth": "0",
            "function": "hinic_sq_put_wqe",
            "description": "hinic sq put wqe release the ci for new wqes struct hinic sq sq send queue unsigned int wqe size the size of the wqe",
            "id": "hinic_sq_put_wqe"
        },
        "_free_optimized_voltages": {
            "ground_truth": "0",
            "function": "_free_optimized_voltages",
            "description": "free optimized voltage free resource for optvoltages struct device dev device for which we need to free info struct ti opp supply data data data specific to the device",
            "id": "_free_optimized_voltages"
        },
        "snd_seq_oss_writeq_new": {
            "ground_truth": "0",
            "function": "snd_seq_oss_writeq_new",
            "description": "snd seq os writeq new seq os writeq",
            "id": "snd_seq_oss_writeq_new"
        },
        "vx_write_codec_reg": {
            "ground_truth": "0",
            "function": "vx_write_codec_reg",
            "description": "vx write codec reg write codec data 24bit",
            "id": "vx_write_codec_reg"
        },
        "fat_chain_add": {
            "ground_truth": "0",
            "function": "fat_chain_add",
            "description": "fat chain add fat chain add add new cluster to the chain of cluster represented by inode",
            "id": "fat_chain_add"
        },
        "lpfc_bus_reset_handler": {
            "ground_truth": "0",
            "function": "lpfc_bus_reset_handler",
            "description": "lpfc bus reset handler scsi host template eh bus reset handler entry point this routine doe target reset to all target on cmnd device host this emulates parallel scsi bus reset semantics return code error success struct scsi cmnd cmnd pointer to scsi cmnd data structure",
            "id": "lpfc_bus_reset_handler"
        },
        "dpsw_vlan_remove": {
            "ground_truth": "0",
            "function": "dpsw_vlan_remove",
            "description": "dpsw vlan remove remove an entire vlan struct fsl mc io mc io pointer to mc portal is object u32 cmd flag command flag one or more of mc cmd flag u16 token token of dpsw object u16 vlan id vlan identifier completion status on success error code otherwise",
            "id": "dpsw_vlan_remove"
        },
        "rcu_qs": {
            "ground_truth": "0",
            "function": "rcu_qs",
            "description": "rcu q record an rcu quiescent state",
            "id": "rcu_qs"
        },
        "jbd2_journal_destroy_transaction_cache": {
            "ground_truth": "0",
            "function": "jbd2_journal_destroy_transaction_cache",
            "description": "jbd2 journal destroy transaction cache transaction cache support",
            "id": "jbd2_journal_destroy_transaction_cache"
        },
        "__xchg8": {
            "ground_truth": "0",
            "function": "__xchg8",
            "description": "xchg8 xchg32 defined in arch parisc lib bitops",
            "id": "__xchg8"
        },
        "dtSearchNode": {
            "ground_truth": "0",
            "function": "dtSearchNode",
            "description": "dtsearchnode name dtsearchnode function search for an dtpage containing specified address this function is mainly used by defragfs utility note search result on stack the found page is pinned at exit the result page must be an internal dtpage lmxaddr give the address of the left most page of the dtree level in which the required dtpage resides",
            "id": "dtSearchNode"
        },
        "disable_metric_set": {
            "ground_truth": "0",
            "function": "disable_metric_set",
            "description": "disable metric set the oa unit disable metric set remove system constraint associated with using",
            "id": "disable_metric_set"
        },
        "lmc_t1_set_clock": {
            "ground_truth": "0",
            "function": "lmc_t1_set_clock",
            "description": "lmc t1 set clock internal external",
            "id": "lmc_t1_set_clock"
        },
        "gen_pool_create": {
            "ground_truth": "0",
            "function": "gen_pool_create",
            "description": "gen pool create create new special memory pool create new special memory pool that can be used to manage special purpose memory not managed by the regular kmalloc kfree interface int min alloc order log base of number of byte each bitmap bit represents int nid node id of the node the pool structure should be allocated on or",
            "id": "gen_pool_create"
        },
        "ahd_handle_nonpkt_busfree": {
            "ground_truth": "0",
            "function": "ahd_handle_nonpkt_busfree",
            "description": "ahd handle nonpkt busfree non packetized unexpected or expected busfree",
            "id": "ahd_handle_nonpkt_busfree"
        },
        "get_partial_node": {
            "ground_truth": "0",
            "function": "get_partial_node",
            "description": "get partial node try to allocate partial slab from specific node",
            "id": "get_partial_node"
        },
        "__jhash_nwords": {
            "ground_truth": "0",
            "function": "__jhash_nwords",
            "description": "jhash nwords jhash nwords hash exactly or word",
            "id": "__jhash_nwords"
        },
        "zynqmp_pm_clock_getdivider": {
            "ground_truth": "0",
            "function": "zynqmp_pm_clock_getdivider",
            "description": "zynqmp pm clock getdivider get the clock divider for given id this function is used by master to get divider value for any clock u32 clock id id of the clock u32 divider divider value return status either success or error reason",
            "id": "zynqmp_pm_clock_getdivider"
        },
        "MR_PopulateDrvRaidMap": {
            "ground_truth": "0",
            "function": "MR_PopulateDrvRaidMap",
            "description": "mr populatedrvraidmap this function will populate driver map using firmware raid map",
            "id": "MR_PopulateDrvRaidMap"
        },
        "all_notes_off": {
            "ground_truth": "0",
            "function": "all_notes_off",
            "description": "all note off all note off",
            "id": "all_notes_off"
        },
        "mpc1_mpc_init": {
            "ground_truth": "0",
            "function": "mpc1_mpc_init",
            "description": "mpc1 mpc init reset the mpcc hw status by disconnecting all muxes parameter in out mpc mpc context return void",
            "id": "mpc1_mpc_init"
        },
        "ene_tx_set_transmitters": {
            "ground_truth": "0",
            "function": "ene_tx_set_transmitters",
            "description": "ene tx set transmitter enable disable transmitter",
            "id": "ene_tx_set_transmitters"
        },
        "tegra_io_rail_power_off": {
            "ground_truth": "0",
            "function": "tegra_io_rail_power_off",
            "description": "tegra io rail power off disable power to rail see also tegra io pad power disable unsigned int id tegra pad id for which to disable power",
            "id": "tegra_io_rail_power_off"
        },
        "svc_thread_recv_status_ok": {
            "ground_truth": "0",
            "function": "svc_thread_recv_status_ok",
            "description": "svc thread recv status ok handle the successful status send back the correspond status to the service client struct stratix10 svc data data pointer to service data structure struct stratix10 svc cb data cb data pointer to callback data structure to service client struct arm smccc re re result from smc or hvc call",
            "id": "svc_thread_recv_status_ok"
        },
        "catu_get_table": {
            "ground_truth": "0",
            "function": "catu_get_table",
            "description": "catu get table catu get table retrieve the table pointer for the given offset within the buffer the buffer is wrapped around to valid offset return the cpu virtual address for the beginning of the table containing the data page pointer for offset if daddrp is not null daddrp point the dma address of the beginning of the table",
            "id": "catu_get_table"
        },
        "ahd_done": {
            "ground_truth": "0",
            "function": "ahd_done",
            "description": "ahd done call the higher level scsi done function and free the scb",
            "id": "ahd_done"
        },
        "ef4_reset": {
            "ground_truth": "0",
            "function": "ef4_reset",
            "description": "ef4 reset reset the nic using the specified method note that the reset may fail in which case the card will be left in an unusable state caller must hold the rtnl lock",
            "id": "ef4_reset"
        },
        "num_domains_get": {
            "ground_truth": "0",
            "function": "num_domains_get",
            "description": "num domain get struct scmi power ops represents the various operation provided by scmi power protocol num domain get get the count of power domain provided by scmi name get get the name of power domain state set set the power state of power domain state get get the power state of power domain",
            "id": "num_domains_get"
        },
        "envctrl_i2c_data_translate": {
            "ground_truth": "0",
            "function": "envctrl_i2c_data_translate",
            "description": "envctrl i2c data translate function description decode data read from an adc device using firmware table return number of read byte data is stored in bufdata in ascii format",
            "id": "envctrl_i2c_data_translate"
        },
        "ddebug_dyndbg_boot_param_cb": {
            "ground_truth": "0",
            "function": "ddebug_dyndbg_boot_param_cb",
            "description": "ddebug dyndbg boot param cb handle both dyndbg and module dyndbg params at boot",
            "id": "ddebug_dyndbg_boot_param_cb"
        },
        "fsnotify_drop_object": {
            "ground_truth": "0",
            "function": "fsnotify_drop_object",
            "description": "fsnotify drop object drop object reference originally held by connector",
            "id": "fsnotify_drop_object"
        },
        "lis3lv02d_sysfs_poweron": {
            "ground_truth": "0",
            "function": "lis3lv02d_sysfs_poweron",
            "description": "lis3lv02d sysfs poweron sysfs stuff",
            "id": "lis3lv02d_sysfs_poweron"
        },
        "nvkm_instmem_rd32": {
            "ground_truth": "0",
            "function": "nvkm_instmem_rd32",
            "description": "nvkm instmem rd32 instmem subdev base implementation",
            "id": "nvkm_instmem_rd32"
        },
        "igc_configure": {
            "ground_truth": "0",
            "function": "igc_configure",
            "description": "igc configure configure the hardware for rx and tx struct igc adapter adapter private board structure",
            "id": "igc_configure"
        },
        "dm646x_init": {
            "ground_truth": "0",
            "function": "dm646x_init",
            "description": "dm646x init dm646x function declaration",
            "id": "dm646x_init"
        },
        "read_register": {
            "ground_truth": "0",
            "function": "read_register",
            "description": "read register pcc can be used with perf critical driver such a cppc so it make sense to locally cache the virtual address and use it to read write to pcc register such a doorbell register the below read register and write register are used to read and write from perf critical register such a pcc doorbell register",
            "id": "read_register"
        },
        "snd_ca0106_pcm_trigger_capture": {
            "ground_truth": "0",
            "function": "snd_ca0106_pcm_trigger_capture",
            "description": "snd ca0106 pcm trigger capture trigger capture callback",
            "id": "snd_ca0106_pcm_trigger_capture"
        },
        "of_io_request_and_map": {
            "ground_truth": "0",
            "function": "of_io_request_and_map",
            "description": "of io request and map of io request and map request resource and map the memory mapped io for given device node device the device whose io range will be mapped index index of the io range name name override for the memory region request or null return pointer to the requested and mapped memory or an err ptr encoded error code on failure usage example base of io request and map node foo if is err base return ptr err base",
            "id": "of_io_request_and_map"
        },
        "cryptd_aead_queued": {
            "ground_truth": "0",
            "function": "cryptd_aead_queued",
            "description": "cryptd aead queued must be called without moving cpu",
            "id": "cryptd_aead_queued"
        },
        "bio_truncate": {
            "ground_truth": "1",
            "function": "bio_truncate",
            "description": "bio truncate truncate the bio to small size of new size truncate the bio to new size of new size if bio op bio is req op read zero the truncated part this function should only be used for handling corner case such a bio eod struct bio bio the bio to be truncated unsigned new size new size for truncating the bio",
            "id": "bio_truncate"
        },
        "mpc52xx_gpt_gpio_get": {
            "ground_truth": "0",
            "function": "mpc52xx_gpt_gpio_get",
            "description": "mpc52xx gpt gpio get gpiolib hook",
            "id": "mpc52xx_gpt_gpio_get"
        },
        "scsw_cmd_is_valid_sctl": {
            "ground_truth": "0",
            "function": "scsw_cmd_is_valid_sctl",
            "description": "scsw cmd is valid sctl check sctl field validity return non zero if the sctl field of the specified command mode scsw is valid zero otherwise union scsw scsw pointer to scsw",
            "id": "scsw_cmd_is_valid_sctl"
        },
        "abituguru3_synchronize": {
            "ground_truth": "0",
            "function": "abituguru3_synchronize",
            "description": "abituguru3 synchronize this synchronizes u with the uguru3 is protocol state machine this must be done before each command",
            "id": "abituguru3_synchronize"
        },
        "gpio_keys_enable_button": {
            "ground_truth": "0",
            "function": "gpio_keys_enable_button",
            "description": "gpio key enable button enables given gpio button enables given button pointed by bdata make sure that bdata disable lock is locked when entering this function to avoid race with concurrent thread trying to enable the same button at the same time struct gpio button data bdata button data for button to be disabled",
            "id": "gpio_keys_enable_button"
        },
        "ftrace_make_call": {
            "ground_truth": "0",
            "function": "ftrace_make_call",
            "description": "ftrace make call convert nop call site into call to addr this is very sensitive operation and great care need to be taken by the arch the operation should carefully read the location check to see if what is read is indeed what we expect it to be and then on success of the compare it should write to the location the code segment at rec ip should be nop return must be on success efault on error reading the location einval on failed compare of the content eperm on error writing to the location any other value will be considered failure struct dyn ftrace rec the call site record mcount fentry unsigned long addr the address that the call site should call",
            "id": "ftrace_make_call"
        },
        "native_write_msr_safe": {
            "ground_truth": "0",
            "function": "native_write_msr_safe",
            "description": "native write msr safe can be uninlined because referenced by paravirt",
            "id": "native_write_msr_safe"
        },
        "cpu_clock_sample": {
            "ground_truth": "0",
            "function": "cpu_clock_sample",
            "description": "cpu clock sample sample per thread clock for the given task clkid is validated",
            "id": "cpu_clock_sample"
        },
        "reset_chelsio_generic_dev": {
            "ground_truth": "0",
            "function": "reset_chelsio_generic_dev",
            "description": "reset chelsio generic dev device specific reset method for chelsio t4 based adapter",
            "id": "reset_chelsio_generic_dev"
        },
        "sg_set_page": {
            "ground_truth": "0",
            "function": "sg_set_page",
            "description": "sg set page set sg entry to point at given page use this function to set an sg entry pointing at page never assign the page directly we encode sg table information in the lower bit of the page pointer see sg page for looking up the page belonging to an sg entry struct scatterlist sg sg entry struct page page the page unsigned int len length of data unsigned int offset offset into page",
            "id": "sg_set_page"
        },
        "xfs_bulkstat": {
            "ground_truth": "0",
            "function": "xfs_bulkstat",
            "description": "xfs bulkstat return stat information in bulk by inode for the filesystem",
            "id": "xfs_bulkstat"
        },
        "ipv6_exthdrs_init": {
            "ground_truth": "0",
            "function": "ipv6_exthdrs_init",
            "description": "ipv6 exthdrs init extension header",
            "id": "ipv6_exthdrs_init"
        },
        "_scsih_mark_responding_sas_device": {
            "ground_truth": "0",
            "function": "_scsih_mark_responding_sas_device",
            "description": "scsih mark responding sa device mark sa device a responding after host reset find out whether device are still responding used in scsih remove unresponsive sa device struct mpt3sas adapter ioc per adapter object mpi2sasdevicepage0 sa device pg0 sa device page",
            "id": "_scsih_mark_responding_sas_device"
        },
        "krait_add_clks": {
            "ground_truth": "0",
            "function": "krait_add_clks",
            "description": "krait add clks id for l2 otherwise id physical cpu number",
            "id": "krait_add_clks"
        },
        "sctp_sf_violation_chunk": {
            "ground_truth": "0",
            "function": "sctp_sf_violation_chunk",
            "description": "sctp sf violation chunk handle protocol violation of an invalid chunk bundling for example when we have an association and we receive bundled init ack or shudown complete our peer is clearly violationg the must not bundle statement from the spec additionally there might be an attacker on the path and we may not want to continue this communication",
            "id": "sctp_sf_violation_chunk"
        },
        "arch_local_irq_restore": {
            "ground_truth": "0",
            "function": "arch_local_irq_restore",
            "description": "arch local irq restore this only restores external and interrupt state",
            "id": "arch_local_irq_restore"
        },
        "temp_show": {
            "ground_truth": "0",
            "function": "temp_show",
            "description": "temp show sysfs stuff",
            "id": "temp_show"
        },
        "mips_set_personality_nan": {
            "ground_truth": "0",
            "function": "mips_set_personality_nan",
            "description": "mips set personality nan select the ieee nan encoding and ab fmt neg fmt execution mode in fcsr according to the elf nan personality",
            "id": "mips_set_personality_nan"
        },
        "pcmcia_read_config_byte": {
            "ground_truth": "0",
            "function": "pcmcia_read_config_byte",
            "description": "pcmcia read config byte read byte from card configuration register pcmcia read config byte read byte from configuration register in attribute memory struct pcmcia device dev undescribed off where undescribed u8 val undescribed",
            "id": "pcmcia_read_config_byte"
        },
        "acpi_db_execution_walk": {
            "ground_truth": "0",
            "function": "acpi_db_execution_walk",
            "description": "acpi db execution walk function acpi db execution walk parameter walk callback return status description execute control method name is relative to the current scope",
            "id": "acpi_db_execution_walk"
        },
        "cache_random_seq_destroy": {
            "ground_truth": "0",
            "function": "cache_random_seq_destroy",
            "description": "cache random seq destroy destroy the per cache random freelist sequence",
            "id": "cache_random_seq_destroy"
        },
        "omap36xx_gate_clk_enable_with_hsdiv_restore": {
            "ground_truth": "0",
            "function": "omap36xx_gate_clk_enable_with_hsdiv_restore",
            "description": "omap36xx gate clk enable with hsdiv restore enable clock suffering from hsdivider pwrdn problem implement erratum id i556 only dpll3 m3 ck dpll4 m2 ck dpll4 m3 ck dpll4 m4 ck dpll4 m5 ck dpll4 m6 ck divider get loaded with reset valueafter their respective pwrdn bit are set any dummy write any other value different from the read value to the corresponding cm clksel register will refresh the divider struct clk hw hw undescribed",
            "id": "omap36xx_gate_clk_enable_with_hsdiv_restore"
        },
        "hsiphash": {
            "ground_truth": "0",
            "function": "hsiphash",
            "description": "hsiphash compute bit hsiphash prf value const void data buffer to hash size len undescribed const hsiphash key key the hsiphash key",
            "id": "hsiphash"
        },
        "wm97xx_read_aux_adc": {
            "ground_truth": "0",
            "function": "wm97xx_read_aux_adc",
            "description": "wm97xx read aux adc read the aux adc read the selected aux adc struct wm97xx wm wm97xx device u16 adcsel codec adc to be read",
            "id": "wm97xx_read_aux_adc"
        },
        "LM77_TEMP_TO_REG": {
            "ground_truth": "0",
            "function": "LM77_TEMP_TO_REG",
            "description": "lm77 temp to reg in the temperature register the low bit are not part of the temperature value they are the status bit",
            "id": "LM77_TEMP_TO_REG"
        },
        "xfs_ifork_verify_local_attr": {
            "ground_truth": "1",
            "function": "xfs_ifork_verify_local_attr",
            "description": "xfs ifork verify local attr verify the inline content of the attr fork of an inode",
            "id": "xfs_ifork_verify_local_attr"
        },
        "pci_fixup_83c553": {
            "ground_truth": "0",
            "function": "pci_fixup_83c553",
            "description": "pci fixup 83c553 we do not use this to fix the device but initialisation of it it is not the correct use for this but it work note that the arbiter isa bridge appears to be buggy specifically in the following area park on cpu isa bridge ping pong isa bridge master handling of target retry bug is responsible for the sound dma grinding to halt we now live with bug",
            "id": "pci_fixup_83c553"
        },
        "kernel_sock_shutdown": {
            "ground_truth": "0",
            "function": "kernel_sock_shutdown",
            "description": "kernel sock shutdown shut down part of full duplex connection kernel space struct socket sock socket enum sock shutdown cmd how connection part return or an error",
            "id": "kernel_sock_shutdown"
        },
        "cpia2_close": {
            "ground_truth": "0",
            "function": "cpia2_close",
            "description": "cpia2 close cpia2 close",
            "id": "cpia2_close"
        },
        "batadv_mcast_querier_log": {
            "ground_truth": "0",
            "function": "batadv_mcast_querier_log",
            "description": "batadv mcast querier log debug output regarding the querier status on link output debug message to the logging facility with log level amcast regarding change to the querier status on the link which are relevant to our multicast optimization usually this is about whether querier appeared or vanished in our mesh or whether the querier is in the suboptimal position of being behind our local bridge segment snooping switch will directly forward listener report to the querier therefore batman adv and the bridge will potentially not see these listener the querier is potentially shadowing listener from u then this is only interesting for node with bridge on top of their soft interface struct batadv priv bat priv the bat priv with all the soft interface information char str proto string for the querier protocol igmp or mld struct batadv mcast querier state old state the previous querier state on our link struct batadv mcast querier state new state the new querier state on our link",
            "id": "batadv_mcast_querier_log"
        },
        "snd_gf1_pcm_new": {
            "ground_truth": "0",
            "function": "snd_gf1_pcm_new",
            "description": "snd gf1 pcm new gu pcm",
            "id": "snd_gf1_pcm_new"
        },
        "bvme6000_hwclk": {
            "ground_truth": "0",
            "function": "bvme6000_hwclk",
            "description": "bvme6000 hwclk look like op is non zero for setting the clock and zero for reading the clock struct hwclk time unsigned sec unsigned min unsigned hour unsigned day unsigned mon unsigned year int wday is sunday mean unknown do not set",
            "id": "bvme6000_hwclk"
        },
        "crash_prepare_suspend": {
            "ground_truth": "0",
            "function": "crash_prepare_suspend",
            "description": "crash prepare suspend to preserve the crash dump kernel image the relevant memory segment should be mapped again around the hibernation",
            "id": "crash_prepare_suspend"
        },
        "mipi_dsi_dcs_enter_sleep_mode": {
            "ground_truth": "0",
            "function": "mipi_dsi_dcs_enter_sleep_mode",
            "description": "mipi dsi dc enter sleep mode disable all unnecessary block inside the display module except interface communication struct mipi dsi device dsi dsi peripheral device on success or negative error code on failure",
            "id": "mipi_dsi_dcs_enter_sleep_mode"
        },
        "rpciod_start": {
            "ground_truth": "0",
            "function": "rpciod_start",
            "description": "rpciod start start up the rpciod workqueue",
            "id": "rpciod_start"
        },
        "igb_up": {
            "ground_truth": "0",
            "function": "igb_up",
            "description": "igb up open the interface and prepare it to handle traffic struct igb adapter adapter board private structure",
            "id": "igb_up"
        },
        "set_addr_win": {
            "ground_truth": "0",
            "function": "set_addr_win",
            "description": "set addr win save display writing zone",
            "id": "set_addr_win"
        },
        "bcm63xx_nvram_init": {
            "ground_truth": "0",
            "function": "bcm63xx_nvram_init",
            "description": "bcm63xx nvram init initializes nvram initialized the local nvram copy from the target address and check it checksum void nvram address of the nvram data",
            "id": "bcm63xx_nvram_init"
        },
        "__udp6_lib_mcast_deliver": {
            "ground_truth": "0",
            "function": "__udp6_lib_mcast_deliver",
            "description": "udp6 lib mcast deliver note called only from the bh handler context so we do not need to lock the hash",
            "id": "__udp6_lib_mcast_deliver"
        },
        "gve_assign_tx_qpl": {
            "ground_truth": "0",
            "function": "gve_assign_tx_qpl",
            "description": "gve assign tx qpl return pointer to the next available tx qpl in the list of qpls",
            "id": "gve_assign_tx_qpl"
        },
        "xdr_enter_page": {
            "ground_truth": "0",
            "function": "xdr_enter_page",
            "description": "xdr enter page decode data from the xdr page move data beyond the current pointer position from the xdr head buffer into the page list any data that lie beyond current position len byte is moved into the xdr tail the current pointer is then repositioned at the beginning of the first xdr page struct xdr stream xdr pointer to xdr stream struct unsigned int len number of byte of page data",
            "id": "xdr_enter_page"
        },
        "tb_switch_tmu_disable": {
            "ground_truth": "0",
            "function": "tb_switch_tmu_disable",
            "description": "tb switch tmu disable disable tmu of switch turn off tmu of sw if it is enabled if not enabled doe nothing struct tb switch sw switch whose tmu to disable",
            "id": "tb_switch_tmu_disable"
        },
        "qbman_release_desc_set_rcdi": {
            "ground_truth": "0",
            "function": "qbman_release_desc_set_rcdi",
            "description": "qbman release desc set rcdi determines whether or not the portal is rcdi interrupt source should be asserted after the release command is completed struct qbman release desc undescribed int enable undescribed",
            "id": "qbman_release_desc_set_rcdi"
        },
        "mrdy_set_low": {
            "ground_truth": "0",
            "function": "mrdy_set_low",
            "description": "mrdy set low clear mrdy gpio struct ifx spi device ifx device we are controlling",
            "id": "mrdy_set_low"
        },
        "radeon_atpx_validate": {
            "ground_truth": "0",
            "function": "radeon_atpx_validate",
            "description": "radeon atpx validate validate atpx function validate that required function are enabled all asics return on success error on failure struct radeon atpx atpx radeon atpx struct",
            "id": "radeon_atpx_validate"
        },
        "assign_requested_resources_sorted": {
            "ground_truth": "0",
            "function": "assign_requested_resources_sorted",
            "description": "assign requested resource sorted satisfy resource request satisfy resource request of each element in the list add request that could not be satisfied to the failed list struct list head head head of the list tracking request for resource struct list head fail head head of the list tracking request that could not be allocated",
            "id": "assign_requested_resources_sorted"
        },
        "intel_sdvo_get_preferred_input_mode": {
            "ground_truth": "0",
            "function": "intel_sdvo_get_preferred_input_mode",
            "description": "intel sdvo get preferred input mode asks the sdvo controller for the preferred input mode given the output mode unfortunately we have to set up the full output mode to do that",
            "id": "intel_sdvo_get_preferred_input_mode"
        },
        "ehv_bc_udbg_putc": {
            "ground_truth": "0",
            "function": "ehv_bc_udbg_putc",
            "description": "ehv bc udbg putc the udbg subsystem call this function to display single character we convert cr to cr lf",
            "id": "ehv_bc_udbg_putc"
        },
        "media_device_delete": {
            "ground_truth": "0",
            "function": "media_device_delete",
            "description": "medium device delete release medium device call kref put this interface should be called to put medium device instance kref struct medium device mdev struct type medium device pointer const char module name should be filled with kbuild modname struct module owner struct module pointer this module for the driver this module is null for built in driver it is safe even when this module is null",
            "id": "media_device_delete"
        },
        "ep93xx_devcfg_set_clear": {
            "ground_truth": "0",
            "function": "ep93xx_devcfg_set_clear",
            "description": "ep93xx devcfg set clear ep93xx system controller software locked register write",
            "id": "ep93xx_devcfg_set_clear"
        },
        "data_make_reusable": {
            "ground_truth": "0",
            "function": "data_make_reusable",
            "description": "data make reusable given the text data ring put the associated descriptor of each data block from lpos begin until lpos end into the reusable state if there is any problem making the associated descriptor reusable either the descriptor ha not yet been finalized or another writer context ha already pushed the tail lpos past the problematic data block regardless on error the caller can re load the tail lpos to determine the situation",
            "id": "data_make_reusable"
        },
        "o2hb_dead_threshold_set": {
            "ground_truth": "0",
            "function": "o2hb_dead_threshold_set",
            "description": "o2hb dead threshold set only set new threshold if there are no active region no locking or otherwise interesting code is required for reading o2hb dead threshold a it can not change once region are active and it is not interesting to anyone until then anyway",
            "id": "o2hb_dead_threshold_set"
        },
        "arch_uninstall_hw_breakpoint": {
            "ground_truth": "0",
            "function": "arch_uninstall_hw_breakpoint",
            "description": "arch uninstall hw breakpoint uninstall the breakpoint contained in the given counter first we search the debug address register it us and then we disable it atomic we hold the counter ctx lock and we only handle variable and register local to this cpu",
            "id": "arch_uninstall_hw_breakpoint"
        },
        "struct": {
            "ground_truth": "0",
            "function": "struct",
            "description": "struct zero page is global shared page that is always zero used for zero mapped memory area etc",
            "id": "struct"
        },
        "be_cmd_q_destroy": {
            "ground_truth": "0",
            "function": "be_cmd_q_destroy",
            "description": "be cmd destroy generic destroyer function for all type of queue us mbox",
            "id": "be_cmd_q_destroy"
        },
        "wl18xx_acx_interrupt_notify_config": {
            "ground_truth": "0",
            "function": "wl18xx_acx_interrupt_notify_config",
            "description": "wl18xx acx interrupt notify config when the host is suspended we do not want to get any fast link psm notification",
            "id": "wl18xx_acx_interrupt_notify_config"
        },
        "hrz_open": {
            "ground_truth": "0",
            "function": "hrz_open",
            "description": "hrz open open vc",
            "id": "hrz_open"
        },
        "dname_to_vma_addr": {
            "ground_truth": "0",
            "function": "dname_to_vma_addr",
            "description": "dname to vma addr dname to vma addr map dentry name into two unsigned longs which represent vma start and end address",
            "id": "dname_to_vma_addr"
        },
        "edge_startup": {
            "ground_truth": "0",
            "function": "edge_startup",
            "description": "edge startup edge startup",
            "id": "edge_startup"
        },
        "msb_init_disk": {
            "ground_truth": "0",
            "function": "msb_init_disk",
            "description": "msb init disk register the block device",
            "id": "msb_init_disk"
        },
        "dce110_timing_generator_enable_crtc_reset": {
            "ground_truth": "0",
            "function": "dce110_timing_generator_enable_crtc_reset",
            "description": "dce110 timing generator enable crtc reset reset crtc position on master vsync",
            "id": "dce110_timing_generator_enable_crtc_reset"
        },
        "mpc5121_nfc_command": {
            "ground_truth": "0",
            "function": "mpc5121_nfc_command",
            "description": "mpc5121 nfc command write command to nand flash",
            "id": "mpc5121_nfc_command"
        },
        "bpf_selem_unlink_storage_nolock": {
            "ground_truth": "0",
            "function": "bpf_selem_unlink_storage_nolock",
            "description": "bpf selem unlink storage nolock local storage lock must be held and selem local storage local storage the caller must ensure selem smap is still valid to be dereferenced for it smap elem size and smap cache idx",
            "id": "bpf_selem_unlink_storage_nolock"
        },
        "init_pci_cap_pcix_perm": {
            "ground_truth": "0",
            "function": "init_pci_cap_pcix_perm",
            "description": "init pci cap pcix perm permission for pci capability",
            "id": "init_pci_cap_pcix_perm"
        },
        "adf_clean_vf_map": {
            "ground_truth": "0",
            "function": "adf_clean_vf_map",
            "description": "adf clean vf map clean vf id mapings function clean internal id for virtual function bool vf flag indicating whether mapping is cleaned for vfs only or for vfs and pfs",
            "id": "adf_clean_vf_map"
        },
        "sctp_unhash_endpoint": {
            "ground_truth": "0",
            "function": "sctp_unhash_endpoint",
            "description": "sctp unhash endpoint remove endpoint from the hash local bh safe",
            "id": "sctp_unhash_endpoint"
        },
        "chunk_drange_filter": {
            "ground_truth": "0",
            "function": "chunk_drange_filter",
            "description": "chunk drange filter pstart pend",
            "id": "chunk_drange_filter"
        },
        "cdns_readl": {
            "ground_truth": "0",
            "function": "cdns_readl",
            "description": "cdns readl register accessor helper",
            "id": "cdns_readl"
        },
        "ql_this_adapter_controls_port": {
            "ground_truth": "0",
            "function": "ql_this_adapter_controls_port",
            "description": "ql this adapter control port caller hold hw lock",
            "id": "ql_this_adapter_controls_port"
        },
        "bnx2x_idle_chk6": {
            "ground_truth": "0",
            "function": "bnx2x_idle_chk6",
            "description": "bnx2x idle chk6 specific test for qm rd wr pointer and rd wr bank",
            "id": "bnx2x_idle_chk6"
        },
        "task_tick_dl": {
            "ground_truth": "0",
            "function": "task_tick_dl",
            "description": "task tick dl scheduler tick hitting task of our scheduling class note this function can be called remotely by the tick offload that go along full dynticks therefore no local assumption can be made and everything must be accessed through the rq and curr passed in parameter",
            "id": "task_tick_dl"
        },
        "_base_determine_wait_on_discovery": {
            "ground_truth": "0",
            "function": "_base_determine_wait_on_discovery",
            "description": "base determine wait on discovery desposition decide whether to wait on discovery to complete used to either locate boot device or report volume ahead of physical device struct mpt3sas adapter ioc per adapter object for wait for do not wait",
            "id": "_base_determine_wait_on_discovery"
        },
        "open_shroot": {
            "ground_truth": "1",
            "function": "open_shroot",
            "description": "open shroot open the directory at the root of share",
            "id": "open_shroot"
        },
        "calc_deleted_bytes_number": {
            "ground_truth": "0",
            "function": "calc_deleted_bytes_number",
            "description": "calc deleted byte number calculate number of byte which will be deleted or cut during balance",
            "id": "calc_deleted_bytes_number"
        },
        "xfs_end_cksum": {
            "ground_truth": "0",
            "function": "xfs_end_cksum",
            "description": "xfs end cksum convert the intermediate checksum to the final ondisk format the crc32c calculation us le format even on be machine but return the result in host endian format hence we need to byte swap it back to le format so that it is consistent on disk",
            "id": "xfs_end_cksum"
        },
        "mpt3sas_config_get_ioc_pg1": {
            "ground_truth": "0",
            "function": "mpt3sas_config_get_ioc_pg1",
            "description": "mpt3sas config get ioc pg1 obtain ioc page struct mpt3sas adapter ioc per adapter object mpi2configreply mpi reply reply mf payload returned from firmware config page content of the config page sleep for success non zero for failure",
            "id": "mpt3sas_config_get_ioc_pg1"
        },
        "get_timestamp": {
            "ground_truth": "0",
            "function": "get_timestamp",
            "description": "get timestamp get timestamp value for rx need to check this",
            "id": "get_timestamp"
        },
        "mv88e6390x_port_set_speed_duplex": {
            "ground_truth": "0",
            "function": "mv88e6390x_port_set_speed_duplex",
            "description": "mv88e6390x port set speed duplex support mbps 88e6190x",
            "id": "mv88e6390x_port_set_speed_duplex"
        },
        "snd_usb_find_input_terminal_descriptor": {
            "ground_truth": "0",
            "function": "snd_usb_find_input_terminal_descriptor",
            "description": "snd usb find input terminal descriptor find an input terminal descriptor either uac1 or uac2 with the given terminal id",
            "id": "snd_usb_find_input_terminal_descriptor"
        },
        "prefix_is_mapped": {
            "ground_truth": "0",
            "function": "prefix_is_mapped",
            "description": "prefix is mapped test if the prefix is mapped into the gmap shadow",
            "id": "prefix_is_mapped"
        },
        "ipa_smp2p_clock_release": {
            "ground_truth": "0",
            "function": "ipa_smp2p_clock_release",
            "description": "ipa smp2p clock release drop the clock reference if it wa taken in ipa smp2p notify",
            "id": "ipa_smp2p_clock_release"
        },
        "i40iw_send_syn_cqp_callback": {
            "ground_truth": "0",
            "function": "i40iw_send_syn_cqp_callback",
            "description": "i40iw send syn cqp callback do syn ack after qhash struct i40iw cqp request cqp request qhash cqp completion u32 send ack flag send ack",
            "id": "i40iw_send_syn_cqp_callback"
        },
        "eg_cache_get_by_tag": {
            "ground_truth": "0",
            "function": "eg_cache_get_by_tag",
            "description": "eg cache get by tag this can be called from any context since it save cpu flag",
            "id": "eg_cache_get_by_tag"
        },
        "arcnet_dump_skb": {
            "ground_truth": "0",
            "function": "arcnet_dump_skb",
            "description": "arcnet dump skb dump the content of an sk buff",
            "id": "arcnet_dump_skb"
        },
        "tep_data_preempt_count": {
            "ground_truth": "0",
            "function": "tep_data_preempt_count",
            "description": "tep data preempt count parse the preempt count from the record this return the preempt count from record struct tep handle tep handle to the trace event parser context struct tep record rec the record to parse",
            "id": "tep_data_preempt_count"
        },
        "startup": {
            "ground_truth": "0",
            "function": "startup",
            "description": "startup value mean no gpio will be used for reset reset gpio should only be specified for pxa27x cpu where silicon bug prevents correct operation of the reset line if not specified the default behaviour on these cpu is to consider gpio a the ac97 reset line which is the default on most board reset gpio ac97 reset gpio normally gpio113 or gpio95 codec pdata ac97 codec platform data",
            "id": "startup"
        },
        "move_notify": {
            "ground_truth": "0",
            "function": "move_notify",
            "description": "move notify if this callback is provided the framework can avoid pinning the backing store while mapping exists this callback is called with the lock of the reservation object associated with the dma buf held and the mapping function must be called with this lock held a well this make sure that no mapping is created concurrently with an ongoing move operation mapping stay valid and are not directly affected by this callback but the dma buf can now be in different physical location so all mapping should be destroyed and re created a soon a possible new mapping can be created after this callback return and will point to the new location of the dma buf move notify optional notification that the dma buf is moving",
            "id": "move_notify"
        },
        "qib_sdma_update_7322_tail": {
            "ground_truth": "0",
            "function": "qib_sdma_update_7322_tail",
            "description": "qib sdma update tail must be called with sdma lock held or before init finished",
            "id": "qib_sdma_update_7322_tail"
        },
        "pcc_mbox_probe": {
            "ground_truth": "0",
            "function": "pcc_mbox_probe",
            "description": "pcc mbox probe called when we find match for the pcct platform device this is purely used to represent the pcct a virtual device for registering with the generic mailbox framework struct platform device pdev pointer to platform device returned when match is found for success else errno",
            "id": "pcc_mbox_probe"
        },
        "intel_pasid_setup_nested": {
            "ground_truth": "0",
            "function": "intel_pasid_setup_nested",
            "description": "intel pasid setup nested set up pasid entry for nested translation this could be used for guest shared virtual address in this case the first level page table are used for gva gpa translation in the guest second level page table are used for gpa hpa translation struct intel iommu iommu iommu which the device belong to struct device dev device to be set up for translation pgd gpgd flptptr first level page translation pointer in gpa u32 pasid pasid to be programmed in the device pasid table struct iommu gpasid bind data vtd pasid data additional pasid info from the guest bind request struct dmar domain domain domain info for setting up second level page table int addr width address width of the first level guest",
            "id": "intel_pasid_setup_nested"
        },
        "dfx_int_pr_halt_id": {
            "ground_truth": "0",
            "function": "dfx_int_pr_halt_id",
            "description": "dfx int pr halt id dfx int pr halt id overview display halt id is in string form return none argument bp pointer to board information functional description determine current halt id and display appropriate string return code none assumption none side effect none",
            "id": "dfx_int_pr_halt_id"
        },
        "sched_setnuma": {
            "ground_truth": "0",
            "function": "sched_setnuma",
            "description": "sched setnuma requeue task on given node and accurately track the number of numa task on the runqueues",
            "id": "sched_setnuma"
        },
        "drm_connector_attach_content_type_property": {
            "ground_truth": "0",
            "function": "drm_connector_attach_content_type_property",
            "description": "drm connector attach content type property attach content type property called by driver the first time hdmi connector is made struct drm connector connector connector to attach content type property on",
            "id": "drm_connector_attach_content_type_property"
        },
        "keyib_sign": {
            "ground_truth": "0",
            "function": "keyib_sign",
            "description": "keyib sign pauth sign value with key ia and modifier value",
            "id": "keyib_sign"
        },
        "dec_num_slices": {
            "ground_truth": "0",
            "function": "dec_num_slices",
            "description": "dec num slice decrement sice number in available sice number stop if possible or just decrement if not stop at zero",
            "id": "dec_num_slices"
        },
        "vmw_cmd_end_gb_query": {
            "ground_truth": "0",
            "function": "vmw_cmd_end_gb_query",
            "description": "vmw cmd end gb query validate svga 3d cmd end gb query command struct vmw private dev priv pointer to device private struct struct vmw sw context sw context the software context used for this command submission svga3dcmdheader header pointer to the command header in the command stream",
            "id": "vmw_cmd_end_gb_query"
        },
        "kvm_pmi_trigger_fn": {
            "ground_truth": "0",
            "function": "kvm_pmi_trigger_fn",
            "description": "kvm pmi trigger fn note each perf counter is defined a struct kvm pmc there are two type of perf counter general purpose gp and fixed gp counter are stored in gp counter and fixed counter are stored in fixed counter respectively both of them are part of struct kvm pmu pmu understands the difference between gp counter and fixed counter however amd doe not support fixed counter there are three type of index to access perf counter pmc msr named msr for example intel ha msr ia32 perfctrn and amd ha msr k7 perfctrn msr index named idx this normally is used by rdpmc instruction for instance amd rdpmc instruction us 0003h in ecx to access c001 0007h msr k7 perctr3 intel ha similar mechanism except that it also support fixed counter idx can be used to a index to gp and fixed counter global pmc index named pmc pmc is an index specific to pmu code each pmc stored in kvm pmc idx field is unique across all perf counter both gp and fixed the mapping relationship between pmc and perf counter is a the following intel intel pmc max generic gp counter intel pmc idx fixed intel pmc idx fixed fixed amd amd64 num counter gp counter",
            "id": "kvm_pmi_trigger_fn"
        },
        "vb2_queue_init": {
            "ground_truth": "0",
            "function": "vb2_queue_init",
            "description": "vb2 queue init initialize videobuf2 queue the vb2 queue structure should be allocated by the driver the driver is responsible of clearing it is content and setting initial value for some required entry before calling this function ops mem ops type and io mode are mandatory please refer to the struct vb2 queue description in include medium videobuf2 core for more information struct vb2 queue pointer to type struct vb2 queue with videobuf2 queue",
            "id": "vb2_queue_init"
        },
        "s5p_hash_digest": {
            "ground_truth": "0",
            "function": "s5p_hash_digest",
            "description": "s5p hash digest calculate digest from req src return value see s5p hash final above struct ahash request req ahash request",
            "id": "s5p_hash_digest"
        },
        "qla4xxx_do_dpc": {
            "ground_truth": "0",
            "function": "qla4xxx_do_dpc",
            "description": "qla4xxx do dpc dpc routine this routine is task that is schedule by the interrupt handler to perform the background processing for interrupt we put it on task queue that is consumed whenever the scheduler run that is so you can do anything put the process to sleep etc in fact the mid level try to sleep when it reach the driver threshold host can queue this can cause panic if we were in our interrupt code struct work struct work context to obtain pointer to host adapter structure",
            "id": "qla4xxx_do_dpc"
        },
        "nilfs_ioctl_getflags": {
            "ground_truth": "1",
            "function": "nilfs_ioctl_getflags",
            "description": "nilfs ioctl getflags ioctl to support lsattr struct inode inode undescribed void user argp undescribed",
            "id": "nilfs_ioctl_getflags"
        },
        "vfe_buf_add_pending": {
            "ground_truth": "0",
            "function": "vfe_buf_add_pending",
            "description": "vfe buf add pending vfe buf add pending add output buffer to list of pending output vfe output buffer video buffer",
            "id": "vfe_buf_add_pending"
        },
        "mpc_rcvd_sweep_resp": {
            "ground_truth": "0",
            "function": "mpc_rcvd_sweep_resp",
            "description": "mpc rcvd sweep resp helper function of ctcmpc unpack skb",
            "id": "mpc_rcvd_sweep_resp"
        },
        "mv_udc_wakeup": {
            "ground_truth": "0",
            "function": "mv_udc_wakeup",
            "description": "mv udc wakeup try to wake up the host connected to this gadget",
            "id": "mv_udc_wakeup"
        },
        "playback_thread": {
            "ground_truth": "0",
            "function": "playback_thread",
            "description": "playback thread function implement the playback thread thread which doe the playback functionality in loop it wait for free mbo from mostcore for particular channel and copy the data from ring buffer to mbo submit the mbo back to mostcore after copying the data return on success or error code otherwise void data private data",
            "id": "playback_thread"
        },
        "assoc_array_subtree_iterate": {
            "ground_truth": "0",
            "function": "assoc_array_subtree_iterate",
            "description": "assoc array subtree iterate iterate over an associative array the caller must hold the rcu read lock or better",
            "id": "assoc_array_subtree_iterate"
        },
        "input_system_get_state": {
            "ground_truth": "0",
            "function": "input_system_get_state",
            "description": "input system get state read the state of input system id param id in input system identifier param state out input system state structure return none state input system id state",
            "id": "input_system_get_state"
        },
        "init_list_set": {
            "ground_truth": "0",
            "function": "init_list_set",
            "description": "init list set create list set type of set",
            "id": "init_list_set"
        },
        "xen_arch_setup": {
            "ground_truth": "0",
            "function": "xen_arch_setup",
            "description": "xen arch setup this function is not called for hvm domain",
            "id": "xen_arch_setup"
        },
        "get_task_mm": {
            "ground_truth": "0",
            "function": "get_task_mm",
            "description": "get task mm acquire reference to the task is mm return null if the task ha no mm check pf kthread meaning this kernel workthread ha transiently adopted user mm with use mm to do it aio is not set and if so return reference to it after bumping up the use count user must release the mm via mmput after use typically used by proc and ptrace struct task struct task undescribed",
            "id": "get_task_mm"
        },
        "rt2x00queue_index_inc": {
            "ground_truth": "0",
            "function": "rt2x00queue_index_inc",
            "description": "rt2x00queue index inc index incrementation function this function will increase the requested index on the entry is queue it will grab the appropriate lock and handle queue overflow event by resetting the index to the start of the queue struct queue entry entry queue entry type struct queue entry to perform the action on enum queue index index index type type enum queue index to perform the action on",
            "id": "rt2x00queue_index_inc"
        },
        "vxge_vlan_rx_kill_vid": {
            "ground_truth": "0",
            "function": "vxge_vlan_rx_kill_vid",
            "description": "vxge vlan rx kill vid remove the vlan id from the device is vlan id table struct net device dev net device pointer be16 proto vlan protocol u16 vid vid",
            "id": "vxge_vlan_rx_kill_vid"
        },
        "s3c2412_cpufreq_setrefresh": {
            "ground_truth": "0",
            "function": "s3c2412_cpufreq_setrefresh",
            "description": "s3c2412 cpufreq setrefresh this is in here a it is so small it doe not currently warrant file to itself we expect that any s3c24xx needing this is going to also need the iotiming support",
            "id": "s3c2412_cpufreq_setrefresh"
        },
        "rs_rate_from_ucode_rate": {
            "ground_truth": "0",
            "function": "rs_rate_from_ucode_rate",
            "description": "r rate from ucode rate convert ucode rate into an r rate object",
            "id": "rs_rate_from_ucode_rate"
        },
        "ace_interrupt_checkstate": {
            "ground_truth": "0",
            "function": "ace_interrupt_checkstate",
            "description": "ace interrupt checkstate interrupt handling routine",
            "id": "ace_interrupt_checkstate"
        },
        "aureon_spi_read": {
            "ground_truth": "0",
            "function": "aureon_spi_read",
            "description": "aureon spi read read data in spi mode",
            "id": "aureon_spi_read"
        },
        "mchip_set": {
            "ground_truth": "0",
            "function": "mchip_set",
            "description": "mchip set set value into the register",
            "id": "mchip_set"
        },
        "ata_vlb_sync": {
            "ground_truth": "0",
            "function": "ata_vlb_sync",
            "description": "ata vlb sync some localbus eide interface require special access sequence when using bit instruction to transfer data we call this the vlb sync sequence which consists of three successive read of the sector count register location with interrupt disabled to ensure that the read all happen together",
            "id": "ata_vlb_sync"
        },
        "srl128": {
            "ground_truth": "0",
            "function": "srl128",
            "description": "srl128 bit shift right logical with rounding",
            "id": "srl128"
        },
        "arp_fwd_proxy": {
            "ground_truth": "0",
            "function": "arp_fwd_proxy",
            "description": "arp fwd proxy check if we can use proxy arp for this path",
            "id": "arp_fwd_proxy"
        },
        "alc882_fixup_no_primary_hp": {
            "ground_truth": "0",
            "function": "alc882_fixup_no_primary_hp",
            "description": "alc882 fixup no primary hp do not take hp output a primary strangely the speaker output doe not work on vaio and some vaio all in one desktop pc for example vgc ln51jgb through dac",
            "id": "alc882_fixup_no_primary_hp"
        },
        "vfp_single_fnmul": {
            "ground_truth": "0",
            "function": "vfp_single_fnmul",
            "description": "vfp single fnmul sd sn sm",
            "id": "vfp_single_fnmul"
        },
        "cavium_rng_remove": {
            "ground_truth": "0",
            "function": "cavium_rng_remove",
            "description": "cavium rng remove disable vf and rng hardware",
            "id": "cavium_rng_remove"
        },
        "twl_init": {
            "ground_truth": "0",
            "function": "twl_init",
            "description": "twl init this function is called on driver initialization",
            "id": "twl_init"
        },
        "msi_bitmap_reserve_dt_hwirqs": {
            "ground_truth": "0",
            "function": "msi_bitmap_reserve_dt_hwirqs",
            "description": "msi bitmap reserve dt hwirqs reserve irqs specified in the device tree look in the device tree to see if there is property specifying which irqs can be used for msi if found those irqs reserved in the device tree are reserved in the bitmap return for success if there wa an error and if no property wa found in the device tree struct msi bitmap bmp pointer to the msi bitmap",
            "id": "msi_bitmap_reserve_dt_hwirqs"
        },
        "print_cmdline": {
            "ground_truth": "0",
            "function": "print_cmdline",
            "description": "print cmdline print out the commandline prefixed with cmd",
            "id": "print_cmdline"
        },
        "snd_uart16550_interrupt": {
            "ground_truth": "0",
            "function": "snd_uart16550_interrupt",
            "description": "snd uart16550 interrupt note on servicing interupts after receiving interrupt it is important to indicate to the uart that this ha been done for rx interrupt this is done by reading the received byte for tx interrupt this is done by either writing byte reading the iir it is particularly important to read the iir if tx interrupt is received when there is no data in tx buff a in this case there no other indication that the interrupt ha been serviced and it remains outstanding indefinitely this ha the curious side effect that and no further interrupt will be generated from this device at all it is also desirable to clear outstanding interrupt when the device is opened closed note that some device need out2 to be set before they will generate interrupt at all possibly tied to an internal pull up on ct",
            "id": "snd_uart16550_interrupt"
        },
        "remove_domain_devices": {
            "ground_truth": "0",
            "function": "remove_domain_devices",
            "description": "remove domain device read power domain data",
            "id": "remove_domain_devices"
        },
        "dp_connector_get_modes": {
            "ground_truth": "0",
            "function": "dp_connector_get_modes",
            "description": "dp connector get mode callback to add drm mode via drm mode probed add struct drm connector connector pointer to drm connector structure number of mode added",
            "id": "dp_connector_get_modes"
        },
        "mmc_blk_status_error": {
            "ground_truth": "0",
            "function": "mmc_blk_status_error",
            "description": "mmc blk status error check for error the host controller driver might not have seen such a response mode error or invalid card state",
            "id": "mmc_blk_status_error"
        },
        "i915_syncmap_set": {
            "ground_truth": "0",
            "function": "i915_syncmap_set",
            "description": "i915 syncmap set mark the most recent syncpoint between context when we synchronise this root timeline with another id we also know that we have synchronized with all previous seqno along that timeline if we then have request to synchronise with the same seqno or older we can omit it see i915 syncmap is later return on success or negative error code struct i915 syncmap root pointer to the i915 syncmap u64 id the context id other timeline we have synchronised to u32 seqno the sequence number along the other timeline",
            "id": "i915_syncmap_set"
        },
        "omap_hsmmc_xfer_done": {
            "ground_truth": "0",
            "function": "omap_hsmmc_xfer_done",
            "description": "omap hsmmc xfer done notify the transfer complete to mmc core",
            "id": "omap_hsmmc_xfer_done"
        },
        "dcss_blkctl_cfg": {
            "ground_truth": "0",
            "function": "dcss_blkctl_cfg",
            "description": "dc blkctl cfg blkctl",
            "id": "dcss_blkctl_cfg"
        },
        "maxim_get_charger_type": {
            "ground_truth": "0",
            "function": "maxim_get_charger_type",
            "description": "maxim get charger type helper function for mapping value of status2 chgtyp register on max14577 and max77836 chipsets to enum maxim muic charger type",
            "id": "maxim_get_charger_type"
        },
        "kvm_arm_setup_debug": {
            "ground_truth": "0",
            "function": "kvm_arm_setup_debug",
            "description": "kvm arm setup debug set up debug related stuff this is called before each entry into the hypervisor to setup any debug related register currently this just ensures we will trap access to performance monitor mdcr el2 tpm mdcr el2 tpmcr debug rom address mdcr el2 tdra o related register mdcr el2 tdosa statistical profiler mdcr el2 tpms mdcr el2 e2pb additionally kvm only trap guest access to the debug register if the guest is not actively using them see the kvm arm64 debug dirty flag on vcpu arch flag since the guest must not interfere with the hardware state when debugging the guest we must ensure that trapping is enabled whenever we are debugging the guest using the debug register struct kvm vcpu vcpu the vcpu pointer",
            "id": "kvm_arm_setup_debug"
        },
        "intel_vgpu_create_ppgtt_mm": {
            "ground_truth": "0",
            "function": "intel_vgpu_create_ppgtt_mm",
            "description": "intel vgpu create ppgtt mm create ppgtt mm object for vgpu this function is used to create ppgtt mm object for vgpu struct intel vgpu vgpu vgpu enum intel gvt gtt type root entry type ppgtt root entry type u64 pdps guest pdps zero on success negative error code in pointer if failed",
            "id": "intel_vgpu_create_ppgtt_mm"
        },
        "pc_tcode_actions": {
            "ground_truth": "0",
            "function": "pc_tcode_actions",
            "description": "pc tcode action pcm pseudo code",
            "id": "pc_tcode_actions"
        },
        "fixup_mipi_sequences": {
            "ground_truth": "0",
            "function": "fixup_mipi_sequences",
            "description": "fixup mipi sequence some v1 vbt mipi sequence do the deassert in the init otp sequence the deassert must be done before calling intel dsi device ready so for these device we split the init otp sequence into deassert sequence and the actual init otp part",
            "id": "fixup_mipi_sequences"
        },
        "dspio_free_dma_chan": {
            "ground_truth": "0",
            "function": "dspio_free_dma_chan",
            "description": "dspio free dma chan free dsp dma via an scp message",
            "id": "dspio_free_dma_chan"
        },
        "mon_alloc_msg": {
            "ground_truth": "0",
            "function": "mon_alloc_msg",
            "description": "mon alloc msg allocate memory for incoming message",
            "id": "mon_alloc_msg"
        },
        "ovs_vport_set_options": {
            "ground_truth": "0",
            "function": "ovs_vport_set_options",
            "description": "ov vport set option modify existing vport device for kernel caller modifies an existing device with the specified configuration which is dependent on device type ov mutex must be held struct vport vport vport to modify struct nlattr option new configuration",
            "id": "ovs_vport_set_options"
        },
        "mwifiex_cmd_append_tsf_tlv": {
            "ground_truth": "0",
            "function": "mwifiex_cmd_append_tsf_tlv",
            "description": "mwifiex cmd append tsf tlv append tsf tracking info from the scan table for the target ap this function is called from the network join command preparation routine the tsf table tsf sent to the firmware contains two tsf value the tsf of the target ap from it previous beacon probe response the tsf timestamp of our local mac at the time we observed the beacon probe response the firmware us the timestamp value to set an initial tsf value in the mac for the new association after reassociation attempt",
            "id": "mwifiex_cmd_append_tsf_tlv"
        },
        "fpga_bridge_create": {
            "ground_truth": "0",
            "function": "fpga_bridge_create",
            "description": "fpga bridge create create and initialize struct fpga bridge the caller of this function is responsible for freeing the bridge with fpga bridge free using devm fpga bridge create instead is recommended struct device dev fpga bridge device from pdev const char name fpga bridge name const struct fpga bridge ops br ops pointer to structure of fpga bridge ops void priv fpga bridge private data struct fpga bridge or null",
            "id": "fpga_bridge_create"
        }
    }
}