{
    "vulfix_extractfix": {
        "LIBJPG-EF20-CVE-2018-19664": {
            "base": "#define PUT_2B(array, offset, value) \\\n#define PUT_4B(array, offset, value) \\\n\nGLOBAL(djpeg_dest_ptr)\njinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,\n                boolean use_inversion_array)\n{\n  bmp_dest_ptr dest;\n  JDIMENSION row_width;\n\n  /* Create module interface object, fill in method pointers */\n  dest = (bmp_dest_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_dest_struct));\n  dest->pub.start_output = start_output_bmp;\n  dest->pub.finish_output = finish_output_bmp;\n  dest->pub.calc_buffer_dimensions = NULL;\n  dest->is_os2 = is_os2;\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE) {\n    dest->pub.put_pixel_rows = put_gray_rows;\n  } else if (IsExtRGB(cinfo->out_color_space)) {\n    if (cinfo->quantize_colors)\n      dest->pub.put_pixel_rows = put_gray_rows;\n    else\n      dest->pub.put_pixel_rows = put_pixel_rows;\n",
            "info-manual": "#define PUT_2B(array, offset, value) \\\n#define PUT_4B(array, offset, value) \\\n\nGLOBAL(djpeg_dest_ptr)\njinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,\n                boolean use_inversion_array)\n{\n  bmp_dest_ptr dest;\n  JDIMENSION row_width;\n\n  /* Create module interface object, fill in method pointers */\n  dest = (bmp_dest_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_dest_struct));\n  dest->pub.start_output = start_output_bmp;\n  dest->pub.finish_output = finish_output_bmp;\n  dest->pub.calc_buffer_dimensions = NULL;\n  dest->is_os2 = is_os2;\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE) {\n    dest->pub.put_pixel_rows = put_gray_rows;\n  } else if (IsExtRGB(cinfo->out_color_space)) {\n    if (cinfo->quantize_colors)\n      dest->pub.put_pixel_rows = put_gray_rows;\n    else\n      dest->pub.put_pixel_rows = put_pixel_rows;\n  /* BUG: heap buffer overflow\n   *   } else if (cinfo->out_color_space == JCS_RGB565 ||\n   *              cinfo->out_color_space == JCS_CMYK) {\n   *     dest->pub.put_pixel_rows = put_pixel_rows;\n   *   } else {\n   * FIXED:\n   */\n"
        },
        "LIBJPG-EF22-CVE-2012-2806": {
            "base": "#define JPEG_INTERNALS\n#define INPUT_VARS(cinfo)  \\\n#define INPUT_SYNC(cinfo)  \\\n#define INPUT_RELOAD(cinfo)  \\\n#define MAKE_BYTE_AVAIL(cinfo,action)  \\\n#define INPUT_BYTE(cinfo,V,action)  \\\n#define INPUT_2BYTES(cinfo,V,action)  \\\n#define get_dac(cinfo)  skip_variable(cinfo)\n#define APP0_DATA_LEN\t14\t/* Length of interesting data in APP0 */\n#define APP14_DATA_LEN\t12\t/* Length of interesting data in APP14 */\n#define APPN_DATA_LEN\t14\t/* Must be the largest of the above!! */\n\nLOCAL(boolean)\nget_sos (j_decompress_ptr cinfo)\n/* Process a SOS marker */\n{\n  INT32 length;\n  int i, ci, n, c, cc;\n  jpeg_component_info * compptr;\n  INPUT_VARS(cinfo);\n\n  if (! cinfo->marker->saw_SOF)\n    ERREXIT(cinfo, JERR_SOS_NO_SOF);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n\n  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */\n\n  TRACEMS1(cinfo, 1, JTRC_SOS, n);\n\n  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  cinfo->comps_in_scan = n;\n\n  /* Collect the component-spec parameters */\n\n",
            "info-manual": "#define JPEG_INTERNALS\n#define INPUT_VARS(cinfo)  \\\n#define INPUT_SYNC(cinfo)  \\\n#define INPUT_RELOAD(cinfo)  \\\n#define MAKE_BYTE_AVAIL(cinfo,action)  \\\n#define INPUT_BYTE(cinfo,V,action)  \\\n#define INPUT_2BYTES(cinfo,V,action)  \\\n#define get_dac(cinfo)  skip_variable(cinfo)\n#define APP0_DATA_LEN\t14\t/* Length of interesting data in APP0 */\n#define APP14_DATA_LEN\t12\t/* Length of interesting data in APP14 */\n#define APPN_DATA_LEN\t14\t/* Must be the largest of the above!! */\n\nLOCAL(boolean)\nget_sos (j_decompress_ptr cinfo)\n/* Process a SOS marker */\n{\n  INT32 length;\n  int i, ci, n, c, cc;\n  jpeg_component_info * compptr;\n  INPUT_VARS(cinfo);\n\n  if (! cinfo->marker->saw_SOF)\n    ERREXIT(cinfo, JERR_SOS_NO_SOF);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n\n  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */\n\n  TRACEMS1(cinfo, 1, JTRC_SOS, n);\n\n  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  cinfo->comps_in_scan = n;\n\n  /* Collect the component-spec parameters */\n\n  /* BUG: stack buffer overflow\n   *   for (i = 0; i < cinfo->num_components; i++)\n   *     cinfo->cur_comp_info[i] = NULL;\n   * \n   *   for (i = 0; i < n; i++) {\n   *     INPUT_BYTE(cinfo, cc, return FALSE);\n   *     INPUT_BYTE(cinfo, c, return FALSE);\n   *     \n   *     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n   * \t ci++, compptr++) {\n   *       if (cc == compptr->component_id && !cinfo->cur_comp_info[ci])\n   * FIXED:\n   */\n"
        },
        "LIBTIFF-EF01-CVE-2016-5321": {
            "base": "#define PATH_MAX 1024\n#define\tstreq(a,b)\t(strcmp((a),(b)) == 0)\n#define\tstrneq(a,b,n)\t(strncmp((a),(b),(n)) == 0)\n#define\tTRUE\t1\n#define\tFALSE\t0\n#define TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))\n#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)\n#define EDGE_TOP      1\n#define EDGE_LEFT     2\n#define EDGE_BOTTOM   3\n#define EDGE_RIGHT    4\n#define EDGE_CENTER   5\n#define MIRROR_HORIZ  1\n#define MIRROR_VERT   2\n#define MIRROR_BOTH   3\n#define ROTATECW_90   8\n#define ROTATECW_180 16\n#define ROTATECW_270 32\n#define ROTATE_ANY (ROTATECW_90 | ROTATECW_180 | ROTATECW_270)\n#define CROP_NONE     0\n#define CROP_MARGINS  1\n#define CROP_WIDTH    2\n#define CROP_LENGTH   4\n#define CROP_ZONES    8\n#define CROP_REGIONS 16\n#define CROP_ROTATE  32\n#define CROP_MIRROR  64\n#define CROP_INVERT 128\n#define ONE_FILE_COMPOSITE       0 /* One file, sections combined sections */\n#define ONE_FILE_SEPARATED       1 /* One file, sections to new IFDs */\n#define FILE_PER_IMAGE_COMPOSITE 2 /* One file per image, combined sections */\n#define FILE_PER_IMAGE_SEPARATED 3 /* One file per input image */\n#define FILE_PER_SELECTION       4 /* One file per selection */\n#define COMPOSITE_IMAGES         0 /* Selections combined into one image */  \n#define SEPARATED_IMAGES         1 /* Selections saved to separate images */\n#define STRIP    1\n#define TILE     2\n#define MAX_REGIONS   8  /* number of regions to extract from a single page */\n#define MAX_OUTBUFFS  8  /* must match larger of zones or regions */\n#define MAX_SECTIONS 32  /* number of sections per page to write to output */\n#define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */\n#define MAX_SAMPLES   8  /* maximum number of samples per pixel supported */\n#define MAX_BITS_PER_SAMPLE 64 /* maximum bit depth supported */\n#define MAX_EXPORT_PAGES 999999  /* maximum number of export pages per file */\n#define DUMP_NONE   0\n#define DUMP_TEXT   1\n#define DUMP_RAW    2\n#define MAX_PAPERNAMES 49\n#define MAX_PAPERNAME_LENGTH 15\n#define DEFAULT_RESUNIT      RESUNIT_INCH\n#define DEFAULT_PAGE_HEIGHT   14.0\n#define DEFAULT_PAGE_WIDTH     8.5\n#define DEFAULT_RESOLUTION   300\n#define DEFAULT_PAPER_SIZE  \"legal\"\n#define ORIENTATION_NONE       0\n#define ORIENTATION_PORTRAIT   1\n#define ORIENTATION_LANDSCAPE  2\n#define ORIENTATION_SEASCAPE   4\n#define ORIENTATION_AUTO      16\n#define PAGE_MODE_NONE         0\n#define PAGE_MODE_RESOLUTION   1\n#define PAGE_MODE_PAPERSIZE    2\n#define PAGE_MODE_MARGINS      4\n#define PAGE_MODE_ROWSCOLS     8\n#define INVERT_DATA_ONLY      10\n#define INVERT_DATA_AND_TAG   11\n#define\tCopyField(tag, v) \\\n#define\tCopyField2(tag, v1, v2) \\\n#define\tCopyField3(tag, v1, v2, v3) \\\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n#define\tCopyTag(tag, count, type)\tcpTag(in, out, tag, count, type)\n\nstatic int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n",
            "info-manual": "#define PATH_MAX 1024\n#define\tstreq(a,b)\t(strcmp((a),(b)) == 0)\n#define\tstrneq(a,b,n)\t(strncmp((a),(b),(n)) == 0)\n#define\tTRUE\t1\n#define\tFALSE\t0\n#define TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))\n#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)\n#define EDGE_TOP      1\n#define EDGE_LEFT     2\n#define EDGE_BOTTOM   3\n#define EDGE_RIGHT    4\n#define EDGE_CENTER   5\n#define MIRROR_HORIZ  1\n#define MIRROR_VERT   2\n#define MIRROR_BOTH   3\n#define ROTATECW_90   8\n#define ROTATECW_180 16\n#define ROTATECW_270 32\n#define ROTATE_ANY (ROTATECW_90 | ROTATECW_180 | ROTATECW_270)\n#define CROP_NONE     0\n#define CROP_MARGINS  1\n#define CROP_WIDTH    2\n#define CROP_LENGTH   4\n#define CROP_ZONES    8\n#define CROP_REGIONS 16\n#define CROP_ROTATE  32\n#define CROP_MIRROR  64\n#define CROP_INVERT 128\n#define ONE_FILE_COMPOSITE       0 /* One file, sections combined sections */\n#define ONE_FILE_SEPARATED       1 /* One file, sections to new IFDs */\n#define FILE_PER_IMAGE_COMPOSITE 2 /* One file per image, combined sections */\n#define FILE_PER_IMAGE_SEPARATED 3 /* One file per input image */\n#define FILE_PER_SELECTION       4 /* One file per selection */\n#define COMPOSITE_IMAGES         0 /* Selections combined into one image */  \n#define SEPARATED_IMAGES         1 /* Selections saved to separate images */\n#define STRIP    1\n#define TILE     2\n#define MAX_REGIONS   8  /* number of regions to extract from a single page */\n#define MAX_OUTBUFFS  8  /* must match larger of zones or regions */\n#define MAX_SECTIONS 32  /* number of sections per page to write to output */\n#define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */\n#define MAX_SAMPLES   8  /* maximum number of samples per pixel supported */\n#define MAX_BITS_PER_SAMPLE 64 /* maximum bit depth supported */\n#define MAX_EXPORT_PAGES 999999  /* maximum number of export pages per file */\n#define DUMP_NONE   0\n#define DUMP_TEXT   1\n#define DUMP_RAW    2\n#define MAX_PAPERNAMES 49\n#define MAX_PAPERNAME_LENGTH 15\n#define DEFAULT_RESUNIT      RESUNIT_INCH\n#define DEFAULT_PAGE_HEIGHT   14.0\n#define DEFAULT_PAGE_WIDTH     8.5\n#define DEFAULT_RESOLUTION   300\n#define DEFAULT_PAPER_SIZE  \"legal\"\n#define ORIENTATION_NONE       0\n#define ORIENTATION_PORTRAIT   1\n#define ORIENTATION_LANDSCAPE  2\n#define ORIENTATION_SEASCAPE   4\n#define ORIENTATION_AUTO      16\n#define PAGE_MODE_NONE         0\n#define PAGE_MODE_RESOLUTION   1\n#define PAGE_MODE_PAPERSIZE    2\n#define PAGE_MODE_MARGINS      4\n#define PAGE_MODE_ROWSCOLS     8\n#define INVERT_DATA_ONLY      10\n#define INVERT_DATA_AND_TAG   11\n#define\tCopyField(tag, v) \\\n#define\tCopyField2(tag, v1, v2) \\\n#define\tCopyField3(tag, v1, v2, v3) \\\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n#define\tCopyTag(tag, count, type)\tcpTag(in, out, tag, count, type)\n\nstatic int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* BUG: stack buffer overflow\n       *       for (s = 0; s < spp; s++)\n       *         {  // Read each plane of a tile set into srcbuffs[s] \n       * \ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n       * FIXED:\n       */\n"
        },
        "LIBTIFF-EF02_01-CVE-2014-8128": {
            "base": "#define\tstreq(a,b)\t(strcmp(a,b) == 0)\n#define\tCopyField(tag, v) \\\n#define\tCopyField2(tag, v1, v2) \\\n#define\tCopyField3(tag, v1, v2, v3) \\\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n#define M_E\t\t2.7182818284590452354\n\nstatic void\nsetImage1(const uint8* br, uint32 rw, uint32 rh)\n{\n    int step = rh;\n    int limit = tnh;\n    int err = 0;\n    int bpr = TIFFhowmany8(rw);\n    int sy = 0;\n    uint8* row = thumbnail;\n    uint32 dy;\n    for (dy = 0; dy < tnh; dy++) {\n\tconst uint8* rows[256];\n\tuint32 nrows = 1;\n\tfprintf(stderr, \"bpr=%d, sy=%d, bpr*sy=%d\\n\", bpr, sy, bpr*sy);\n\trows[0] = br + bpr*sy;\n\terr += step;\n\twhile (err >= limit) {\n\t    err -= limit;\n\t    sy++;\n\t    if (err >= limit)\n",
            "info-manual": "#define\tstreq(a,b)\t(strcmp(a,b) == 0)\n#define\tCopyField(tag, v) \\\n#define\tCopyField2(tag, v1, v2) \\\n#define\tCopyField3(tag, v1, v2, v3) \\\n#define\tCopyField4(tag, v1, v2, v3, v4) \\\n#define\tNTAGS\t(sizeof (tags) / sizeof (tags[0]))\n#define M_E\t\t2.7182818284590452354\n\nstatic void\nsetImage1(const uint8* br, uint32 rw, uint32 rh)\n{\n    int step = rh;\n    int limit = tnh;\n    int err = 0;\n    int bpr = TIFFhowmany8(rw);\n    int sy = 0;\n    uint8* row = thumbnail;\n    uint32 dy;\n    for (dy = 0; dy < tnh; dy++) {\n\tconst uint8* rows[256];\n\tuint32 nrows = 1;\n\tfprintf(stderr, \"bpr=%d, sy=%d, bpr*sy=%d\\n\", bpr, sy, bpr*sy);\n\trows[0] = br + bpr*sy;\n\terr += step;\n\twhile (err >= limit) {\n\t    err -= limit;\n\t    sy++;\n\t    if (err >= limit)\n\t\t/* BUG: stack buffer overflow\n\t\t * \t\trows[nrows++] = br + bpr*sy;\n\t\t * \t}\n\t\t * \tsetrow(row, nrows, rows);\n\t\t * FIXED:\n\t\t */\n"
        },
        "LIBTIFF-EF02_02-CVE-2014-8128": {
            "base": "#define SETPIXEL(op, v) {\t\t\t\\\n#define LITERALROW\t0x00\n#define LITERALSPAN\t0x40\n#define WHITE   \t((1<<2)-1)\n\nstatic int\nNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}\n",
            "info-manual": "#define SETPIXEL(op, v) {\t\t\t\\\n#define LITERALROW\t0x00\n#define LITERALSPAN\t0x40\n#define WHITE   \t((1<<2)-1)\n\nstatic int\nNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}\n\n/* BUG: heap buffer overflow\n\n * \n\n * int\n\n * TIFFInitNeXT(TIFF* tif, int scheme)\n\n * FIXED:\n\n */\n"
        },
        "LIBTIFF-EF07-CVE-2016-10094": {
            "base": "#define TIFF2PDF_MODULE \"tiff2pdf\"\n#define PS_UNIT_SIZE\t72.0F\n#define TIFF2PDF_FILEID_SIZE 33\n#define TIFF2PDF_DATETIME_SIZE 17\n#define TIFF2PDF_CREATOR_SIZE 512\n#define TIFF2PDF_AUTHOR_SIZE 512\n#define TIFF2PDF_TITLE_SIZE 512\n#define TIFF2PDF_SUBJECT_SIZE 512\n#define TIFF2PDF_KEYWORDS_SIZE 512\n#define check_snprintf_ret(t2p, rv, buf) do { \\\n\ntsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n",
            "info-manual": "#define TIFF2PDF_MODULE \"tiff2pdf\"\n#define PS_UNIT_SIZE\t72.0F\n#define TIFF2PDF_FILEID_SIZE 33\n#define TIFF2PDF_DATETIME_SIZE 17\n#define TIFF2PDF_CREATOR_SIZE 512\n#define TIFF2PDF_AUTHOR_SIZE 512\n#define TIFF2PDF_TITLE_SIZE 512\n#define TIFF2PDF_SUBJECT_SIZE 512\n#define TIFF2PDF_KEYWORDS_SIZE 512\n#define check_snprintf_ret(t2p, rv, buf) do { \\\n\ntsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\t/* BUG:  heap buffer overflow\n\t\t\t\t * \t\t\t\tif (count >= 4) {\n\t\t\t\t *                                         int retTIFFReadRawTile;\n\t\t\t\t *                     // Ignore EOI marker of JpegTables \n\t\t\t\t * FIXED:\n\t\t\t\t */\n"
        },
        "LIBTIFF-EF08-CVE-2017-7601": {
            "base": "#define WIN32_LEAN_AND_MEAN\n#define VC_EXTRALEAN\n#define width_in_blocks width_in_data_units\n#define SETJMP(jbuf)\t\tsetjmp(jbuf)\n#define LONGJMP(jbuf,code)\tlongjmp(jbuf,code)\n#define JMP_BUF\t\t\tjmp_buf\n#define\tJState(tif)\t((JPEGState*)(tif)->tif_data)\n#define\tFIELD_JPEGTABLES\t(FIELD_CODEC+0)\n#define\tCALLJPEG(sp, fail, op)\t(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))\n#define\tCALLVJPEG(sp, op)\tCALLJPEG(sp, 0, ((op),1))\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF2 0xC2\n#define JPEG_MARKER_SOF9 0xC9\n#define JPEG_MARKER_SOF10 0xCA\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#define SIZE_OF_JPEGTABLES 2000\n\nstatic int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n",
            "info-manual": "#define WIN32_LEAN_AND_MEAN\n#define VC_EXTRALEAN\n#define width_in_blocks width_in_data_units\n#define SETJMP(jbuf)\t\tsetjmp(jbuf)\n#define LONGJMP(jbuf,code)\tlongjmp(jbuf,code)\n#define JMP_BUF\t\t\tjmp_buf\n#define\tJState(tif)\t((JPEGState*)(tif)->tif_data)\n#define\tFIELD_JPEGTABLES\t(FIELD_CODEC+0)\n#define\tCALLJPEG(sp, fail, op)\t(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))\n#define\tCALLVJPEG(sp, op)\tCALLJPEG(sp, 0, ((op),1))\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF2 0xC2\n#define JPEG_MARKER_SOF9 0xC9\n#define JPEG_MARKER_SOF10 0xCA\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#define SIZE_OF_JPEGTABLES 2000\n\nstatic int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n\n/* BUG: runtime error: shift exponent 136 is too large for 64 bit type 'long int'\n\n * \n\n * \t\t//\n\n * \t\t * A ReferenceBlackWhite field *must* be present since the\n\n * FIXED:\n\n */\n"
        },
        "LIBTIFF-EF09-CVE-2016-3623": {
            "base": "#define\tstreq(a,b)\t(strcmp(a,b) == 0)\n#define\tCopyField(tag, v) \\\n#define\thowmany(x, y)\t(((x)+((y)-1))/(y))\n#define\troundup(x, y)\t(howmany(x,y)*((uint32)(y)))\n#define\tLumaRed\t\tycbcrCoeffs[0]\n#define\tLumaGreen\tycbcrCoeffs[1]\n#define\tLumaBlue\tycbcrCoeffs[2]\n\nint\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n",
            "info-manual": "#define\tstreq(a,b)\t(strcmp(a,b) == 0)\n#define\tCopyField(tag, v) \\\n#define\thowmany(x, y)\t(((x)+((y)-1))/(y))\n#define\troundup(x, y)\t(howmany(x,y)*((uint32)(y)))\n#define\tLumaRed\t\tycbcrCoeffs[0]\n#define\tLumaGreen\tycbcrCoeffs[1]\n#define\tLumaBlue\tycbcrCoeffs[2]\n\nint\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n\t\t/* BUG: runtime error: division by zero\n\t\t * \t\tcase 'h':\n\t\t * \t\t\thorizSubSampling = atoi(optarg);\n\t\t * \t\t\tbreak;\n\t\t * \t\tcase 'v':\n\t\t * \t\t\tvertSubSampling = atoi(optarg);\n\t\t * \t\t\tbreak;\n\t\t * \t\tcase 'r':\n\t\t * \t\t\trowsperstrip = atoi(optarg);\n\t\t * FIXED:\n\t\t */\n"
        },
        "LIBTIFF-EF10-CVE-2017-7595": {
            "base": "#define WIN32_LEAN_AND_MEAN\n#define VC_EXTRALEAN\n#define width_in_blocks width_in_data_units\n#define SETJMP(jbuf)\t\tsetjmp(jbuf)\n#define LONGJMP(jbuf,code)\tlongjmp(jbuf,code)\n#define JMP_BUF\t\t\tjmp_buf\n#define\tJState(tif)\t((JPEGState*)(tif)->tif_data)\n#define\tFIELD_JPEGTABLES\t(FIELD_CODEC+0)\n#define\tCALLJPEG(sp, fail, op)\t(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))\n#define\tCALLVJPEG(sp, op)\tCALLJPEG(sp, 0, ((op),1))\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF2 0xC2\n#define JPEG_MARKER_SOF9 0xC9\n#define JPEG_MARKER_SOF10 0xCA\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#define SIZE_OF_JPEGTABLES 2000\n\nstatic int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n",
            "info-manual": "#define WIN32_LEAN_AND_MEAN\n#define VC_EXTRALEAN\n#define width_in_blocks width_in_data_units\n#define SETJMP(jbuf)\t\tsetjmp(jbuf)\n#define LONGJMP(jbuf,code)\tlongjmp(jbuf,code)\n#define JMP_BUF\t\t\tjmp_buf\n#define\tJState(tif)\t((JPEGState*)(tif)->tif_data)\n#define\tFIELD_JPEGTABLES\t(FIELD_CODEC+0)\n#define\tCALLJPEG(sp, fail, op)\t(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))\n#define\tCALLVJPEG(sp, op)\tCALLJPEG(sp, 0, ((op),1))\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF2 0xC2\n#define JPEG_MARKER_SOF9 0xC9\n#define JPEG_MARKER_SOF10 0xCA\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#define SIZE_OF_JPEGTABLES 2000\n\nstatic int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n\t\t\n/* BUG: runtime error: division by zero\n\t\t\n * \t\t\n\t\t\n * \t\t//\n\t\t\n * \t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t\n * FIXED:\n\t\t\n */\n"
        },
        "LIBXML2-EF15-CVE-2016-1838": {
            "base": "#define IN_LIBXML\n#define XML_DIR_SEP '\\\\'\n#define XML_DIR_SEP '/'\n#define XML_PARSER_BIG_ENTITY 1000\n#define XML_PARSER_LOT_ENTITY 5000\n#define XML_PARSER_NON_LINEAR 10\n#define SAX2 1\n#define XML_PARSER_BIG_BUFFER_SIZE 300\n#define XML_PARSER_BUFFER_SIZE 100\n#define SAX_COMPAT_MODE BAD_CAST \"SAX compatibility mode document\"\n#define XML_PARSER_CHUNK_SIZE 100\n#define RAW (*ctxt->input->cur)\n#define CUR (*ctxt->input->cur)\n#define NXT(val) ctxt->input->cur[(val)]\n#define CUR_PTR ctxt->input->cur\n#define CMP4( s, c1, c2, c3, c4 ) \\\n#define CMP5( s, c1, c2, c3, c4, c5 ) \\\n#define CMP6( s, c1, c2, c3, c4, c5, c6 ) \\\n#define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \\\n#define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \\\n#define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \\\n#define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \\\n#define SKIP(val) do {\t\t\t\t\t\t\t\\\n#define SKIPL(val) do {\t\t\t\t\t\t\t\\\n#define SHRINK if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define GROW if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define SKIP_BLANKS xmlSkipBlankChars(ctxt)\n#define NEXT xmlNextChar(ctxt)\n#define NEXT1 {\t\t\t\t\t\t\t\t\\\n#define NEXTL(l) do {\t\t\t\t\t\t\t\\\n#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)\n#define COPY_BUF(l,b,i,v)\t\t\t\t\t\t\\\n#define growBuffer(buffer, n) {\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_parser\n\nstatic void\nxmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                const xmlChar *URI, int line, int nsNr, int tlen) {\n",
            "info-manual": "#define IN_LIBXML\n#define XML_DIR_SEP '\\\\'\n#define XML_DIR_SEP '/'\n#define XML_PARSER_BIG_ENTITY 1000\n#define XML_PARSER_LOT_ENTITY 5000\n#define XML_PARSER_NON_LINEAR 10\n#define SAX2 1\n#define XML_PARSER_BIG_BUFFER_SIZE 300\n#define XML_PARSER_BUFFER_SIZE 100\n#define SAX_COMPAT_MODE BAD_CAST \"SAX compatibility mode document\"\n#define XML_PARSER_CHUNK_SIZE 100\n#define RAW (*ctxt->input->cur)\n#define CUR (*ctxt->input->cur)\n#define NXT(val) ctxt->input->cur[(val)]\n#define CUR_PTR ctxt->input->cur\n#define CMP4( s, c1, c2, c3, c4 ) \\\n#define CMP5( s, c1, c2, c3, c4, c5 ) \\\n#define CMP6( s, c1, c2, c3, c4, c5, c6 ) \\\n#define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \\\n#define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \\\n#define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \\\n#define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \\\n#define SKIP(val) do {\t\t\t\t\t\t\t\\\n#define SKIPL(val) do {\t\t\t\t\t\t\t\\\n#define SHRINK if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define GROW if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define SKIP_BLANKS xmlSkipBlankChars(ctxt)\n#define NEXT xmlNextChar(ctxt)\n#define NEXT1 {\t\t\t\t\t\t\t\t\\\n#define NEXTL(l) do {\t\t\t\t\t\t\t\\\n#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)\n#define COPY_BUF(l,b,i,v)\t\t\t\t\t\t\\\n#define growBuffer(buffer, n) {\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_parser\n\nstatic void\nxmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                const xmlChar *URI, int line, int nsNr, int tlen) {\n    /* BUG: heap buffer overflow\n     *     const xmlChar *name;\n     * \n     *     GROW;\n     *     if ((RAW != '<') || (NXT(1) != '/')) {\n     * \txmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n     * \treturn;\n     *     }\n     *     SKIP(2);\n     * \n     *     if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n     *         if (ctxt->input->cur[tlen] == '>') {\n     * \t    ctxt->input->cur += tlen + 1;\n     * \t    ctxt->input->col += tlen + 1;\n     * FIXED:\n     */\n"
        },
        "LIBXML2-EF17-CVE-2012-5134": {
            "base": "#define IN_LIBXML\n#define XML_DIR_SEP '\\\\'\n#define XML_DIR_SEP '/'\n#define XML_PARSER_BIG_ENTITY 1000\n#define XML_PARSER_LOT_ENTITY 5000\n#define XML_PARSER_NON_LINEAR 10\n#define SAX2 1\n#define XML_PARSER_BIG_BUFFER_SIZE 300\n#define XML_PARSER_BUFFER_SIZE 100\n#define SAX_COMPAT_MODE BAD_CAST \"SAX compatibility mode document\"\n#define XML_PARSER_CHUNK_SIZE 100\n#define RAW (*ctxt->input->cur)\n#define CUR (*ctxt->input->cur)\n#define NXT(val) ctxt->input->cur[(val)]\n#define CUR_PTR ctxt->input->cur\n#define CMP4( s, c1, c2, c3, c4 ) \\\n#define CMP5( s, c1, c2, c3, c4, c5 ) \\\n#define CMP6( s, c1, c2, c3, c4, c5, c6 ) \\\n#define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \\\n#define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \\\n#define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \\\n#define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \\\n#define SKIP(val) do {\t\t\t\t\t\t\t\\\n#define SKIPL(val) do {\t\t\t\t\t\t\t\\\n#define SHRINK if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define GROW if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define SKIP_BLANKS xmlSkipBlankChars(ctxt)\n#define NEXT xmlNextChar(ctxt)\n#define NEXT1 {\t\t\t\t\t\t\t\t\\\n#define NEXTL(l) do {\t\t\t\t\t\t\t\\\n#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)\n#define COPY_BUF(l,b,i,v)\t\t\t\t\t\t\\\n#define growBuffer(buffer, n) {\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_parser\n\nstatic xmlChar *\nxmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n    xmlChar limit = 0;\n    xmlChar *buf = NULL;\n    xmlChar *rep = NULL;\n    size_t len = 0;\n    size_t buf_size = 0;\n    int c, l, in_space = 0;\n    xmlChar *current = NULL;\n    xmlEntityPtr ent;\n\n    if (NXT(0) == '\"') {\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\tlimit = '\"';\n        NEXT;\n    } else if (NXT(0) == '\\'') {\n\tlimit = '\\'';\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n        NEXT;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buf_size = XML_PARSER_BUFFER_SIZE;\n    buf = (xmlChar *) xmlMallocAtomic(buf_size);\n    if (buf == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     */\n    c = CUR_CHAR(l);\n    while (((NXT(0) != limit) && /* checked */\n            (IS_CHAR(c)) && (c != '<')) &&\n            (ctxt->instate != XML_PARSER_EOF)) {\n        /*\n         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n         * special option is given\n         */\n        if ((len > XML_MAX_TEXT_LENGTH) &&\n            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                           \"AttValue lenght too long\\n\");\n            goto mem_error;\n        }\n\tif (c == 0) break;\n\tif (c == '&') {\n\t    in_space = 0;\n\t    if (NXT(1) == '#') {\n\t\tint val = xmlParseCharRef(ctxt);\n\n\t\tif (val == '&') {\n\t\t    if (ctxt->replaceEntities) {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t    } else {\n\t\t\t/*\n\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n\t\t\t * called by the attribute() function in SAX.c\n\t\t\t */\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    }\n\t\t} else if (val != 0) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    len += xmlCopyChar(0, &buf[len], val);\n\t\t}\n\t    } else {\n\t\tent = xmlParseEntityRef(ctxt);\n\t\tctxt->nbentities++;\n\t\tif (ent != NULL)\n\t\t    ctxt->nbentities += ent->owner;\n\t\tif ((ent != NULL) &&\n\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    if ((ctxt->replaceEntities == 0) &&\n\t\t        (ent->content[0] == '&')) {\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    } else {\n\t\t\tbuf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if ((ent != NULL) &&\n\t\t           (ctxt->replaceEntities != 0)) {\n\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n\t\t\t\t\t\t      0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    current = rep;\n\t\t\t    while (*current != 0) { /* non input consuming */\n                                if ((*current == 0xD) || (*current == 0xA) ||\n                                    (*current == 0x9)) {\n                                    buf[len++] = 0x20;\n                                    current++;\n                                } else\n                                    buf[len++] = *current++;\n\t\t\t\tif (len + 10 > buf_size) {\n\t\t\t\t    growBuffer(buf, 10);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tif (ent->content != NULL)\n\t\t\t    buf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if (ent != NULL) {\n\t\t    int i = xmlStrlen(ent->name);\n\t\t    const xmlChar *cur = ent->name;\n\n\t\t    /*\n\t\t     * This may look absurd but is needed to detect\n\t\t     * entities problems\n\t\t     */\n\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t\t\t(ent->content != NULL)) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Just output the reference\n\t\t     */\n\t\t    buf[len++] = '&';\n\t\t    while (len + i + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, i + 10);\n\t\t    }\n\t\t    for (;i > 0;i--)\n\t\t\tbuf[len++] = *cur++;\n\t\t    buf[len++] = ';';\n\t\t}\n\t    }\n\t} else {\n\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n\t        if ((len != 0) || (!normalize)) {\n\t\t    if ((!normalize) || (!in_space)) {\n\t\t\tCOPY_BUF(l,buf,len,0x20);\n\t\t\twhile (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t    }\n\t\t    in_space = 1;\n\t\t}\n\t    } else {\n\t        in_space = 0;\n\t\tCOPY_BUF(l,buf,len,c);\n\t\tif (len + 10 > buf_size) {\n\t\t    growBuffer(buf, 10);\n\t\t}\n\t    }\n\t    NEXTL(l);\n\t}\n\tGROW;\n\tc = CUR_CHAR(l);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        goto error;\n\n    if ((in_space) && (normalize)) {\n",
            "info-manual": "#define IN_LIBXML\n#define XML_DIR_SEP '\\\\'\n#define XML_DIR_SEP '/'\n#define XML_PARSER_BIG_ENTITY 1000\n#define XML_PARSER_LOT_ENTITY 5000\n#define XML_PARSER_NON_LINEAR 10\n#define SAX2 1\n#define XML_PARSER_BIG_BUFFER_SIZE 300\n#define XML_PARSER_BUFFER_SIZE 100\n#define SAX_COMPAT_MODE BAD_CAST \"SAX compatibility mode document\"\n#define XML_PARSER_CHUNK_SIZE 100\n#define RAW (*ctxt->input->cur)\n#define CUR (*ctxt->input->cur)\n#define NXT(val) ctxt->input->cur[(val)]\n#define CUR_PTR ctxt->input->cur\n#define CMP4( s, c1, c2, c3, c4 ) \\\n#define CMP5( s, c1, c2, c3, c4, c5 ) \\\n#define CMP6( s, c1, c2, c3, c4, c5, c6 ) \\\n#define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \\\n#define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \\\n#define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \\\n#define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \\\n#define SKIP(val) do {\t\t\t\t\t\t\t\\\n#define SKIPL(val) do {\t\t\t\t\t\t\t\\\n#define SHRINK if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define GROW if ((ctxt->progressive == 0) &&\t\t\t\t\\\n#define SKIP_BLANKS xmlSkipBlankChars(ctxt)\n#define NEXT xmlNextChar(ctxt)\n#define NEXT1 {\t\t\t\t\t\t\t\t\\\n#define NEXTL(l) do {\t\t\t\t\t\t\t\\\n#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)\n#define COPY_BUF(l,b,i,v)\t\t\t\t\t\t\\\n#define growBuffer(buffer, n) {\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_parser\n\nstatic xmlChar *\nxmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n    xmlChar limit = 0;\n    xmlChar *buf = NULL;\n    xmlChar *rep = NULL;\n    size_t len = 0;\n    size_t buf_size = 0;\n    int c, l, in_space = 0;\n    xmlChar *current = NULL;\n    xmlEntityPtr ent;\n\n    if (NXT(0) == '\"') {\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\tlimit = '\"';\n        NEXT;\n    } else if (NXT(0) == '\\'') {\n\tlimit = '\\'';\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n        NEXT;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buf_size = XML_PARSER_BUFFER_SIZE;\n    buf = (xmlChar *) xmlMallocAtomic(buf_size);\n    if (buf == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     */\n    c = CUR_CHAR(l);\n    while (((NXT(0) != limit) && /* checked */\n            (IS_CHAR(c)) && (c != '<')) &&\n            (ctxt->instate != XML_PARSER_EOF)) {\n        /*\n         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n         * special option is given\n         */\n        if ((len > XML_MAX_TEXT_LENGTH) &&\n            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                           \"AttValue lenght too long\\n\");\n            goto mem_error;\n        }\n\tif (c == 0) break;\n\tif (c == '&') {\n\t    in_space = 0;\n\t    if (NXT(1) == '#') {\n\t\tint val = xmlParseCharRef(ctxt);\n\n\t\tif (val == '&') {\n\t\t    if (ctxt->replaceEntities) {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t    } else {\n\t\t\t/*\n\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n\t\t\t * called by the attribute() function in SAX.c\n\t\t\t */\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    }\n\t\t} else if (val != 0) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    len += xmlCopyChar(0, &buf[len], val);\n\t\t}\n\t    } else {\n\t\tent = xmlParseEntityRef(ctxt);\n\t\tctxt->nbentities++;\n\t\tif (ent != NULL)\n\t\t    ctxt->nbentities += ent->owner;\n\t\tif ((ent != NULL) &&\n\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    if ((ctxt->replaceEntities == 0) &&\n\t\t        (ent->content[0] == '&')) {\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    } else {\n\t\t\tbuf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if ((ent != NULL) &&\n\t\t           (ctxt->replaceEntities != 0)) {\n\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n\t\t\t\t\t\t      0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    current = rep;\n\t\t\t    while (*current != 0) { /* non input consuming */\n                                if ((*current == 0xD) || (*current == 0xA) ||\n                                    (*current == 0x9)) {\n                                    buf[len++] = 0x20;\n                                    current++;\n                                } else\n                                    buf[len++] = *current++;\n\t\t\t\tif (len + 10 > buf_size) {\n\t\t\t\t    growBuffer(buf, 10);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tif (ent->content != NULL)\n\t\t\t    buf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if (ent != NULL) {\n\t\t    int i = xmlStrlen(ent->name);\n\t\t    const xmlChar *cur = ent->name;\n\n\t\t    /*\n\t\t     * This may look absurd but is needed to detect\n\t\t     * entities problems\n\t\t     */\n\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t\t\t(ent->content != NULL)) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Just output the reference\n\t\t     */\n\t\t    buf[len++] = '&';\n\t\t    while (len + i + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, i + 10);\n\t\t    }\n\t\t    for (;i > 0;i--)\n\t\t\tbuf[len++] = *cur++;\n\t\t    buf[len++] = ';';\n\t\t}\n\t    }\n\t} else {\n\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n\t        if ((len != 0) || (!normalize)) {\n\t\t    if ((!normalize) || (!in_space)) {\n\t\t\tCOPY_BUF(l,buf,len,0x20);\n\t\t\twhile (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t    }\n\t\t    in_space = 1;\n\t\t}\n\t    } else {\n\t        in_space = 0;\n\t\tCOPY_BUF(l,buf,len,c);\n\t\tif (len + 10 > buf_size) {\n\t\t    growBuffer(buf, 10);\n\t\t}\n\t    }\n\t    NEXTL(l);\n\t}\n\tGROW;\n\tc = CUR_CHAR(l);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        goto error;\n\n    if ((in_space) && (normalize)) {\n        /* BUG: heap buffer overflow\n         *         while (buf[len - 1] == 0x20) len--;\n         *     }\n         *     buf[len] = 0;\n         * FIXED:\n         */\n"
        },
        "LIBXML2-EF18-CVE-2017-5969": {
            "base": "#define IN_LIBXML\n#define TODO\t\t\t\t\t\t\t\t\\\n#define ROLLBACK_OR\t0\n#define ROLLBACK_PARENT\t1\n#define MAX_RECURSE 25000\n#define MAX_DEPTH ((sizeof(_xmlValidState.occurs)) * 8)\n#define CONT ctxt->vstate->cont\n#define NODE ctxt->vstate->node\n#define DEPTH ctxt->vstate->depth\n#define OCCURS ctxt->vstate->occurs\n#define STATE ctxt->vstate->state\n#define OCCURRENCE (ctxt->vstate->occurs & (1 << DEPTH))\n#define PARENT_OCCURRENCE (ctxt->vstate->occurs & ((1 << DEPTH) - 1))\n#define SET_OCCURRENCE ctxt->vstate->occurs |= (1 << DEPTH)\n#define RESET_OCCURRENCE ctxt->vstate->occurs &= ((1 << DEPTH) - 1)\n#define DEBUG_VALID_STATE(n,c) xmlValidDebug(n,c);\n#define DEBUG_VALID_STATE(n,c) xmlValidStateDebug(ctxt);\n#define DEBUG_VALID_MSG(m)\t\t\t\t\t\\\n#define DEBUG_VALID_STATE(n,c)\n#define DEBUG_VALID_MSG(m)\n#define CHECK_DTD\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_valid\n\nstatic void\nxmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {\n    if (content == NULL) return;\n\n    if (glob) xmlBufferWriteChar(buf, \"(\");\n    switch (content->type) {\n        case XML_ELEMENT_CONTENT_PCDATA:\n            xmlBufferWriteChar(buf, \"#PCDATA\");\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (content->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, content->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, content->name);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n",
            "info-manual": "#define IN_LIBXML\n#define TODO\t\t\t\t\t\t\t\t\\\n#define ROLLBACK_OR\t0\n#define ROLLBACK_PARENT\t1\n#define MAX_RECURSE 25000\n#define MAX_DEPTH ((sizeof(_xmlValidState.occurs)) * 8)\n#define CONT ctxt->vstate->cont\n#define NODE ctxt->vstate->node\n#define DEPTH ctxt->vstate->depth\n#define OCCURS ctxt->vstate->occurs\n#define STATE ctxt->vstate->state\n#define OCCURRENCE (ctxt->vstate->occurs & (1 << DEPTH))\n#define PARENT_OCCURRENCE (ctxt->vstate->occurs & ((1 << DEPTH) - 1))\n#define SET_OCCURRENCE ctxt->vstate->occurs |= (1 << DEPTH)\n#define RESET_OCCURRENCE ctxt->vstate->occurs &= ((1 << DEPTH) - 1)\n#define DEBUG_VALID_STATE(n,c) xmlValidDebug(n,c);\n#define DEBUG_VALID_STATE(n,c) xmlValidStateDebug(ctxt);\n#define DEBUG_VALID_MSG(m)\t\t\t\t\t\\\n#define DEBUG_VALID_STATE(n,c)\n#define DEBUG_VALID_MSG(m)\n#define CHECK_DTD\t\t\t\t\t\t\\\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n#define bottom_valid\n\nstatic void\nxmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {\n    if (content == NULL) return;\n\n    if (glob) xmlBufferWriteChar(buf, \"(\");\n    switch (content->type) {\n        case XML_ELEMENT_CONTENT_PCDATA:\n            xmlBufferWriteChar(buf, \"#PCDATA\");\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (content->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, content->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, content->name);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    /* BUG: SEGV on unknown address\n\t     * \t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t     * \t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t     * \t\txmlDumpElementContent(buf, content->c1, 1);\n\t     * \t    else\n\t     * \t\txmlDumpElementContent(buf, content->c1, 0);\n\t     *             xmlBufferWriteChar(buf, \" , \");\n\t     * \t    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n\t     * \t        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&\n\t     * \t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))\n\t     * \t\txmlDumpElementContent(buf, content->c2, 1);\n\t     * \t    else\n\t     * \t\txmlDumpElementContent(buf, content->c2, 0);\n\t     * \t    break;\n\t     * \tcase XML_ELEMENT_CONTENT_OR:\n\t     * \t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t     * \t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t     * \t\txmlDumpElementContent(buf, content->c1, 1);\n\t     * \t    else\n\t     * \t\txmlDumpElementContent(buf, content->c1, 0);\n\t     *             xmlBufferWriteChar(buf, \" | \");\n\t     * \t    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n\t     * \t        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&\n\t     * \t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))\n\t     * \t\txmlDumpElementContent(buf, content->c2, 1);\n\t     * \t    else\n\t     * FIXED:\n\t     */\n"
        }
    }
}