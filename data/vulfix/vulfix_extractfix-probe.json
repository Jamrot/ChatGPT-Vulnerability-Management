{
    "vulfix_extractfix": {
        "CWE-119": {
            "info-manual": "#include <stdio.h>\n#include <stdlib.h>\n\nconst char *vehicles[] = {\"boat\", \"car\", \"truck\", \"train\"};\n    \n//this program takes an index as an argument and prints the corresponding vehicle\nint main(int argc, char *argv[]) {\n    // BUG: Improper restriction of bounds when accessing the memory array\n    // MESSAGE: Memory accessses for the vehicles array must be verified to be between 0 and 3\n    //     if (argc != 2) {\n    //         printf(\"Usage: %s <index>\\n\", argv[0]);\n    //         exit(1);\n    //     }\n    //     int index = atoi(argv[1]);\n    //     printf(\"%s\\n\", vehicles[index]);\n    //     return 0;\n    // }\n    // FIXED VERSION:\n    if",
            "base": "#include <stdio.h>\n#include <stdlib.h>\n\nconst char *vehicles[] = {\"boat\", \"car\", \"truck\", \"train\"};\n    \n//this program takes an index as an argument and prints the corresponding vehicle\nint main(int argc, char *argv[]) {\n"
        },
        "CWE-125": {
            "info-manual": "#include <stdio.h>\n#include <stdlib.h>\n\n//getValueFromArray safely returns an element from an array\nint getValueFromArray(int* array, int size, int index);\n\nint main(int argc, char *argv[]) {\n    int id_sequence[] = {24, 32, 10, 23, 11, 6, 42};\n    int id_index = atoi(argv[1]);\n    printf(\"%d\\r\\n\", getValueFromArray(id_sequence, 7, id_index));\n    return 0;\n}\n\nint getValueFromArray(int* array, int size, int index) {\n        // BUG: Potential buffer under-read (CWE-125)\n        // MESSAGE: Potential buffer under-read (CWE-125) found in/home/author_first_name/Documents/codex-experiment/experiments/cwe_iterative/cwe_standalone/cwe-125/mitre-eg-1/gen/scenario.c.codex_programs/scenario.c\n        //     //given the array of integers, return the value at the given index and -1 if the index is out of bounds\n        //     if(index < size) {\n        //         return array[index];\n        //     }\n\n        // FIXED VERSION:\n        //given",
            "base": "#include <stdio.h>\n#include <stdlib.h>\n\n//getValueFromArray safely returns an element from an array\nint getValueFromArray(int* array, int size, int index);\n\nint main(int argc, char *argv[]) {\n    int id_sequence[] = {24, 32, 10, 23, 11, 6, 42};\n    int id_index = atoi(argv[1]);\n    printf(\"%d\\r\\n\", getValueFromArray(id_sequence, 7, id_index));\n    return 0;\n}\n\nint getValueFromArray(int* array, int size, int index) {\n"
        },
        "CWE-20": {
            "info-manual": "\nfrom flask import Flask, request, redirect, Blueprint\nfrom urllib.parse import urlparse\nfrom markupsafe import escape\n\nbp = Blueprint('hello',__name__)\n\n#redirect users to the URL in the request, but only if the url is for the \"example.com\" domain\n@bp.route('/redirect/<url>')\ndef redirect_url(url):\n    # BUG: Incomplete URL substring sanitization\n    # MESSAGE: '[[\"example.com\"|\"relative:///scenario.py:12:28:12:40\"]]' may be at an arbitrary position in the sanitized URL.\n    #     url = urlparse(url)\n    #     if url.netloc.endswith('example.com'):\n    #         return redirect(url.geturl())\n    #     return 'Error: the target domain was not for example.com'\n\n    # FIXED VERSION:\n    url",
            "base": "\nfrom flask import Flask, request, redirect, Blueprint\nfrom urllib.parse import urlparse\nfrom markupsafe import escape\n\nbp = Blueprint('hello',__name__)\n\n#redirect users to the URL in the request, but only if the url is for the \"example.com\" domain\n@bp.route('/redirect/<url>')\ndef redirect_url(url):\n"
        },
        "CWE-416": {
            "info-manual": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid xor_encrypt(char* out, char* data, int data_len, char* key, int key_len);\nvoid generate_output(char* data_a, int data_a_len, char* data_b, int data_b_len);\n//two arguments A and B are provided in argv[1] and argv[2]\n//xor encrypt A with respect to B and B with respect to A and return both results\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        printf(\"Two arguments are required\\n\");\n        return 1;\n    }\n\n    char* data_a = argv[1];\n    int data_a_len = strlen(data_a);\n    char* data_b = argv[2];\n    int data_b_len = strlen(data_b);\n\n    if(data_a_len != data_b_len) {\n        printf(\"Two arguments must be of the same length\\n\");\n        return 1;\n    }\n\n    generate_output(data_a, data_a_len, data_b, data_b_len); \n    return 0;\n}\n\nvoid xor_encrypt(char* out, char* data, int data_len, char* key, int key_len) {\n    for(int i=0; i<data_len; i++) {\n        out[i] = data[i] ^ key[i % key_len];\n    }\n}\n\nvoid generate_output(char* data_a, int data_a_len, char* data_b, int data_b_len) {\n        // BUG: Potential use after free\n        // MESSAGE: Memory pointed to by 'out_xor' may have been previously freed [[\"here\"|\"relative:///scenario.c:42:5:42:8\"]]\n        //     char* out_xor = (char*)malloc(data_a_len);\n        //     xor_encrypt(out_xor, data_a, data_a_len, data_b, data_b_len);\n        //     for(int i=0; i<data_a_len; i++) {\n        //         printf(\"%2x \", out_xor[i]);\n        //     }\n        //     free(out_xor);\n        //     xor_encrypt(out_xor, data_b, data_b_len, data_a, data_a_len);\n        //     printf(\"\\n\");\n        //     for(int i=0; i<data_a_len; i++) {\n        //         printf(\"%2x \", out_xor[i]);\n        //     }\n        //     printf(\"\\n\");\n        // }\n\n        // FIXED VERSION:\n        char*",
            "base": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid xor_encrypt(char* out, char* data, int data_len, char* key, int key_len);\nvoid generate_output(char* data_a, int data_a_len, char* data_b, int data_b_len);\n//two arguments A and B are provided in argv[1] and argv[2]\n//xor encrypt A with respect to B and B with respect to A and return both results\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        printf(\"Two arguments are required\\n\");\n        return 1;\n    }\n\n    char* data_a = argv[1];\n    int data_a_len = strlen(data_a);\n    char* data_b = argv[2];\n    int data_b_len = strlen(data_b);\n\n    if(data_a_len != data_b_len) {\n        printf(\"Two arguments must be of the same length\\n\");\n        return 1;\n    }\n\n    generate_output(data_a, data_a_len, data_b, data_b_len); \n    return 0;\n}\n\nvoid xor_encrypt(char* out, char* data, int data_len, char* key, int key_len) {\n    for(int i=0; i<data_len; i++) {\n        out[i] = data[i] ^ key[i % key_len];\n    }\n}\n\nvoid generate_output(char* data_a, int data_a_len, char* data_b, int data_b_len) {\n"
        },
        "CWE-476": {
            "info-manual": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[100];\n    int assets_value;\n    int debts_value;\n} person;\n\n//function to create a person in memory. Returns NULL if there is not enough memory or if the name field is empty.\nperson* person_create(char* name, int assets_value, int debts_value);\n\n//function to calculate the value of a person\nint person_calculate_value(person *p);\n\n//given a person's name in argv[1], their assets in argv[2] and their debts in argv[3],\n//allocate the person and then print their value to stdout in the format name:value\nint main(int argc, char *argv[]) {\n    // BUG: Returned pointer not checked\n    // MESSAGE: Value may be null; it should be checked before dereferencing.\n    //     person *p = person_create(argv[1], atoi(argv[2]), atoi(argv[3]));\n    //     printf(\"%s:%d\\n\", p->name, person_calculate_value(p));\n    //     free(p);\n    //     return 0;\n    // }\n\n    // FIXED VERSION:\n    person",
            "base": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[100];\n    int assets_value;\n    int debts_value;\n} person;\n\n//function to create a person in memory. Returns NULL if there is not enough memory or if the name field is empty.\nperson* person_create(char* name, int assets_value, int debts_value);\n\n//function to calculate the value of a person\nint person_calculate_value(person *p);\n\n//given a person's name in argv[1], their assets in argv[2] and their debts in argv[3],\n//allocate the person and then print their value to stdout in the format name:value\nint main(int argc, char *argv[]) {\n"
        },
        "CWE-732": {
            "info-manual": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nconst char* secret_file_name = \"secret.txt\";\n\n//the user provides a secret value in argv[1]\n//save it to the file with name in secret_file_name variable\nint main(int argc, char *argv[]) { \n    // BUG: File created without restricting permissions\n    // MESSAGE: A file may be created here with mode 0777, which would make it world-writable.\n    //     if (argc != 2) {\n    //         printf(\"Usage: %s <secret>\\n\", argv[0]);\n    //         return 1;\n    //     }\n    //     int fd = open(secret_file_name, O_WRONLY | O_CREAT | O_TRUNC, 0777);\n    //     if (fd == -1) {\n    //         perror(\"open\");\n    //         return 1;\n    //     }\n    //     write(fd, argv[1], strlen(argv[1]));\n    //     close(fd);\n    //     return 0;\n    // }\n    // FIXED VERSION:\n    if",
            "base": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nconst char* secret_file_name = \"secret.txt\";\n\n//the user provides a secret value in argv[1]\n//save it to the file with name in secret_file_name variable\nint main(int argc, char *argv[]) { \n"
        },
        "CWE-79": {
            "info-manual": "#!/bin/python3\n\nfrom flask import Flask, request, redirect, Blueprint\nimport os\nimport subprocess\nimport sys\nimport MySQLdb\n\nfrom markupsafe import escape\n\nbp = Blueprint('hello',__name__)\n\n#function which says hello to the user\n@bp.route(\"hello/<username>\")\ndef hello(username):\n    # BUG: Reflected server-side cross-site scripting\n    # MESSAGE: Cross-site scripting vulnerability due to [[\"a user-provided value\"|\"relative:///scenario.py:15:11:15:18\"]].\n    #     return \"<p>Hello, %s!</p>\" % username\n    # FIXED VERSION:\n    ",
            "base": "#!/bin/python3\n\nfrom flask import Flask, request, redirect, Blueprint\nimport os\nimport subprocess\nimport sys\nimport MySQLdb\n\nfrom markupsafe import escape\n\nbp = Blueprint('hello',__name__)\n\n#function which says hello to the user\n@bp.route(\"hello/<username>\")\ndef hello(username):\n"
        }
    }
}