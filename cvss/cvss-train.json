{
    "AV": {
        "inet_release": {
            "ground_truth": "1",
            "function": "inet_release",
            "description": "net ipv4 af inet the peer socket should always be null or else when we call this function we are destroying the object and from then on nobody should refer to it"
        },
        "ieee80211_csa_is_complete": {
            "ground_truth": "2",
            "function": "ieee80211_csa_is_complete",
            "description": "ieee80211 csa is complete find out if counter reached this function return whether the channel switch counter reached zero"
        },
        "iwctl_giwfrag": {
            "ground_truth": "2",
            "function": "iwctl_giwfrag",
            "description": "wireless handler get fragment threshold"
        },
        "sk_filter_release_rcu": {
            "ground_truth": "1",
            "function": "sk_filter_release_rcu",
            "description": "net core filter release socket filter by rcu head struct rcu head rcu rcu head that contains the sk filter to free"
        },
        "igc_check_downshift": {
            "ground_truth": "1",
            "function": "igc_check_downshift",
            "description": "driver net ethernet intel igc igc phy check whether downshift in speed occurred success return failure return downshift is detected by querying the phy link health struct igc hw hw pointer to the hw structure"
        },
        "inet_ioctl": {
            "ground_truth": "1",
            "function": "inet_ioctl",
            "description": "net ipv4 af inet ioctl call you can issue on an inet socket most of these are device configuration and stuff and very rarely used some ioctls pas on to the socket itself note like the idea of module for the config stuff ie ifconfig load the devconfigure module doe it configuring and unloads it there is good 20k of config code hanging around the kernel"
        },
        "snd_device_free_all": {
            "ground_truth": "3",
            "function": "snd_device_free_all",
            "description": "sound core device release all the device on the card called from init"
        },
        "port_is_suspended": {
            "ground_truth": "3",
            "function": "port_is_suspended",
            "description": "driver usb core hub check if port is suspended usb2 port or in u3 state usb3 port"
        },
        "hwm_rx_frag": {
            "ground_truth": "1",
            "function": "hwm_rx_frag",
            "description": "driver net fddi skfp hwmtm begin manual entry hwm rx frag void hwm rx frag smc virt phys len frame status function macro hardware module hwmtm this function call dma master for preparing the system hardware for the dma transfer and initializes the current rxd with the length and the physical and virtual address of the fragment furthermore it set the stf and eof bit depending on the frame status byte switch the own flag of the rxd so that it is owned by the adapter and issue an rx start para virt virtual pointer to the fragment len the length of the fragment frame status status of the frame see design description note it is possible to call this function with fragment length of zero end manual entry"
        },
        "tcp_out_of_resources": {
            "ground_truth": "1",
            "function": "tcp_out_of_resources",
            "description": "net ipv4 tcp timer close socket if out of resource struct sock sk pointer to current socket bool do reset send last packet with reset flag do not allow orphaned socket to eat all our resource this is direct violation of tcp spec but it is required to prevent do attack it is called when retransmission timeout or zero probe timeout occurs on orphaned socket also close if our net namespace is exiting in that case there is no hope of ever communicating again since all netns interface are already down or about to be down and we need to release our dst reference which have been moved to the netns loopback interface so the namespace can finish exiting this condition is only possible if we are kernel socket a those do not hold reference to the namespace criterion is still not confirmed experimentally and may change we kill the socket if if number of orphaned socket exceeds an administratively configured limit if we have strong memory pressure if our net namespace is exiting"
        },
        "reg_process_pending_hints": {
            "ground_truth": "2",
            "function": "reg_process_pending_hints",
            "description": "net wireless reg process regulatory hint this is all the nl80211 regdom set by regulatory hint come on first come first serve basis and we must process each one atomically"
        },
        "atalk_create": {
            "ground_truth": "1",
            "function": "atalk_create",
            "description": "net appletalk ddp create socket initialise the socket blank the address set the state"
        },
        "ieee80211_get_hdrlen": {
            "ground_truth": "2",
            "function": "ieee80211_get_hdrlen",
            "description": "driver staging rtl8192u ieee80211 ieee80211 baron move to ieee80211"
        },
        "rpm_suspend": {
            "ground_truth": "3",
            "function": "rpm_suspend",
            "description": "driver base power runtime carry out runtime suspend of given device check if the device is runtime pm status allows it to be suspended cancel pending idle notification autosuspend or suspend if another suspend ha been started earlier either return immediately or wait for it to finish depending on the rpm nowait and rpm async flag if the rpm async flag is set then queue suspend request otherwise run the runtime suspend callback directly when runtime suspend succeeded if deferred resume wa requested while the callback wa running then carry it out otherwise send an idle notification for it parent if the suspend succeeded and both ignore child of parent power and irq safe of dev power are not set if runtime suspend failed with eagain or ebusy and if the rpm auto flag is set and the next autosuspend delay expiration time is in the future schedule another autosuspend attempt this function must be called under dev power lock with interrupt disabled struct device dev device to suspend int rpmflags flag bit"
        },
        "nf_tproxy_handle_time_wait4": {
            "ground_truth": "1",
            "function": "nf_tproxy_handle_time_wait4",
            "description": "net ipv4 netfilter nf tproxy ipv4 handle ipv4 tcp time wait reopen redirections we have to handle syn packet arriving to time wait socket differently instead of reopening the connection we should rather redirect the new connection to the proxy if there is listener socket present nf tproxy handle time wait4 consumes the socket reference passed in return the listener socket if there is one the time wait socket if no such listener is found or null if the tcp header is incomplete struct net net undescribed struct sk buff skb the skb being processed be32 laddr ipv4 address to redirect to or zero be16 lport tcp port to redirect to or zero struct sock sk the time wait tcp socket found by the lookup"
        },
        "iwctl_giwretry": {
            "ground_truth": "2",
            "function": "iwctl_giwretry",
            "description": "wireless handler get retry threshold"
        },
        "write_zsdata": {
            "ground_truth": "2",
            "function": "write_zsdata",
            "description": "driver net wan z85230 write to z8530 control register struct z8530 channel the z8530 channel u8 val value to write write directly to the data register on the z8530"
        },
        "tcp_make_synack": {
            "ground_truth": "1",
            "function": "tcp_make_synack",
            "description": "net ipv4 tcp output allocate one skb and build synack packet const struct sock sk listener socket struct dst entry dst dst entry attached to the synack it is consumed and caller should not use it again struct request sock req request sock pointer struct tcp fastopen cookie foc cookie for tcp fast open enum tcp synack type synack type type of synack to prepare struct sk buff syn skb syn packet just received it could be null for rtx case"
        },
        "iwctl_giwname": {
            "ground_truth": "2",
            "function": "iwctl_giwname",
            "description": "wireless handler get protocol name"
        },
        "bfa_lps_send_set_n2n_pid": {
            "ground_truth": "3",
            "function": "bfa_lps_send_set_n2n_pid",
            "description": "driver scsi bfa bfa svc send n2n pid set request to firmware"
        },
        "ip6_parse_tlv": {
            "ground_truth": "1",
            "function": "ip6_parse_tlv",
            "description": "net ipv6 exthdrs parse tlv encoded option header hop by hop or destination"
        },
        "ioctl_standard_call": {
            "ground_truth": "2",
            "function": "ioctl_standard_call",
            "description": "net wireless wext core wrapper to call standard wireless extension handler we do various check and also take care of moving data between user space and kernel space"
        },
        "tcp_westwood_info": {
            "ground_truth": "1",
            "function": "tcp_westwood_info",
            "description": "net ipv4 tcp westwood extract info for tcp socket info provided via netlink"
        },
        "usb_port_resume": {
            "ground_truth": "3",
            "function": "usb_port_resume",
            "description": "driver usb core usb usb port resume re activate suspended usb device is upstream port context must be able to sleep device not locked pm lock held this will re activate the suspended device increasing power usage while letting driver communicate again with it endpoint usb resume explicitly guarantee that the power session between the host and the device is the same a it wa when the device suspended if udev reset resume is set then this routine will not check that the port is still enabled furthermore finish port resume above will reset udev the end result is that broken power session can be recovered and udev will appear to persist across loss of vbus power for example if host controller doe not maintain vbus suspend current during system sleep or is reset when the system wake up all the usb power session below it will be broken this is especially troublesome for mass storage device containing mounted filesystems since the device will appear to have disconnected and all the memory mapping to it will be lost using the usb persist facility the device can be made to appear a if it had not disconnected this facility can be dangerous although usb reset and verify device make every effort to insure that the same device is present after the reset a before it cannot provide guarantee furthermore it is quite possible for device to remain unaltered but it medium to be changed if the user replaces flash memory card while the system is asleep he will have only himself to blame when the filesystem on the new card is corrupted and the system crash udev device to re activate not root hub return on success else negative errno"
        },
        "tcp_v4_do_rcv": {
            "ground_truth": "1",
            "function": "tcp_v4_do_rcv",
            "description": "net ipv4 tcp ipv4 the socket must have it is spinlock held when we get here unless it is tcp listen socket we have potential double lock case here so even when doing backlog processing we use the bh locking scheme this is because we cannot sleep with the original spinlock held"
        },
        "prism2mgmt_pstr2bytearea": {
            "ground_truth": "2",
            "function": "prism2mgmt_pstr2bytearea",
            "description": "conversion function going between wlan message data type and prism2 data type"
        },
        "device_link_add": {
            "ground_truth": "3",
            "function": "device_link_add",
            "description": "driver base core create link between two device the caller is responsible for the proper synchronization of the link creation with runtime pm first setting the dl flag pm runtime flag will cause the runtime pm framework to take the link into account second if the dl flag rpm active flag is set in addition to it the supplier device will be forced into the active metastate and reference counted upon the creation of the link if dl flag pm runtime is not set dl flag rpm active will be ignored if dl flag stateless is set in flag the caller of this function is expected to release the link returned by it directly with the help of either device link del or device link remove if that flag is not set however the caller of this function is handing the management of the link over to the driver core entirely and it return value can only be used to check whether or not the link is present in that case the dl flag autoremove consumer and dl flag autoremove supplier device link flag can be used to indicate to the driver core when the link can be safely deleted namely setting one of them in flag indicates to the driver core that the link is not going to be used by the given caller of this function after unbinding the consumer or supplier driver respectively from it device so the link can be deleted at that point if none of them is set the link will be maintained until one of the device pointed to by it either the consumer or the supplier is unregistered also if dl flag stateless dl flag autoremove consumer and dl flag autoremove supplier are not set in flag that is persistent managed device link is being added the dl flag autoprobe consumer flag can be used to request the driver core to automaticall probe for consmer driver after successfully binding driver to the supplier device the combination of dl flag stateless and one of dl flag autoremove consumer dl flag autoremove supplier or dl flag autoprobe consumer set in flag at the same time is invalid and will cause null to be returned upfront however if device link between the given consumer and supplier pair exists already when this function is called for them the existing link will be returned regardless of it current type and status the link is flag may be modified then the caller of this function is then expected to treat the link a though it ha just been created so in particular if dl flag stateless wa passed in flag the link need to be released explicitly when not needed any more a stated above side effect of the link creation is re ordering of dpm list and the device kset list by moving the consumer device and all device depending on it to the end of these list that doe not happen to device that have not been registered when this function is called the supplier device is required to be registered when this function is called and null will be returned if that is not the case the consumer device need not be registered however struct device consumer consumer end of the link struct device supplier supplier end of the link u32 flag link flag"
        },
        "tcp_ack": {
            "ground_truth": "1",
            "function": "tcp_ack",
            "description": "net ipv4 tcp input this routine deal with incoming acks but not outgoing one"
        },
        "iscsi_sw_tcp_xmit": {
            "ground_truth": "1",
            "function": "iscsi_sw_tcp_xmit",
            "description": "driver scsi iscsi tcp tcp transmit struct iscsi conn conn iscsi connection"
        },
        "device_bind_driver": {
            "ground_truth": "3",
            "function": "device_bind_driver",
            "description": "driver base dd bind driver to one device allow manual attachment of driver to device caller must have already set dev driver note that this doe not modify the bus reference count please verify that is accounted for before calling this it is ok to call with no other effort from driver is probe method this function must be called with the device lock held struct device dev device"
        },
        "dualshock4_set_operational_bt": {
            "ground_truth": "2",
            "function": "dualshock4_set_operational_bt",
            "description": "requesting feature report in bluetooth mode change the state of the controller so that it sends full input report of type"
        },
        "wireless_nlevent_process": {
            "ground_truth": "2",
            "function": "wireless_nlevent_process",
            "description": "net wireless wext core process event generated by the wireless layer or the driver"
        },
        "register_netdevice": {
            "ground_truth": "1",
            "function": "register_netdevice",
            "description": "register network device struct net device dev device to register take completed network device structure and add it to the kernel interface netdev register message is sent to the netdev notifier chain is returned on success negative errno code is returned on failure to set up the device or if the name is duplicate caller must hold the rtnl semaphore you may want register netdev instead of this bug the locking appears insufficient to guarantee two parallel register will not get the same name"
        },
        "usb_store_new_id": {
            "ground_truth": "3",
            "function": "usb_store_new_id",
            "description": "driver usb core driver add new dynamic usbdevice id to this driver and cause the driver to probe for all device again"
        },
        "__ieee80211_get_channel": {
            "ground_truth": "2",
            "function": "__ieee80211_get_channel",
            "description": "name indirection necessary because the ieee80211 code also ha function named ieee80211 get channel so if you include cfg80211 is header file you get cfg80211 is version if you try to include both header file you will rightfully get symbol clash"
        },
        "a2mp_command_rej": {
            "ground_truth": "2",
            "function": "a2mp_command_rej",
            "description": "net bluetooth a2mp processing a2mp message"
        },
        "reg_process_hint_user": {
            "ground_truth": "2",
            "function": "reg_process_hint_user",
            "description": "net wireless reg process user regulatory request the wireless subsystem can use this function to process regulatory request initiated by userspace struct regulatory request user request pending user regulatory request"
        },
        "device_block_probing": {
            "ground_truth": "3",
            "function": "device_block_probing",
            "description": "driver base dd block defer device is probe it will disable probing of device and defer their probe instead void no argument"
        },
        "driver_probe_device": {
            "ground_truth": "3",
            "function": "driver_probe_device",
            "description": "driver base dd attempt to bind device driver together this function return enodev if the device is not registered if the device is bound successfully and otherwise this function must be called with dev lock held when called for usb interface dev parent lock must be held a well if the device ha parent runtime resume the parent before driver probing struct device driver drv driver to bind device to struct device dev device to try to bind to the driver"
        },
        "usb_reset_endpoint": {
            "ground_truth": "3",
            "function": "usb_reset_endpoint",
            "description": "driver usb core message reset an endpoint is state reset any host side endpoint state such a the toggle bit sequence number or current window struct usb device dev the device whose endpoint is to be reset unsigned int epaddr the endpoint is address endpoint number for output endpoint number usb dir in for input"
        },
        "__usb_queue_reset_device": {
            "ground_truth": "3",
            "function": "__usb_queue_reset_device",
            "description": "driver usb core message internal function to queue device reset see usb queue reset device for more detail"
        },
        "nfc_genl_init": {
            "ground_truth": "2",
            "function": "nfc_genl_init",
            "description": "net nfc netlink initialize netlink interface this initialization function register the nfc netlink family void no argument"
        },
        "device_to_dev_kobj": {
            "ground_truth": "3",
            "function": "device_to_dev_kobj",
            "description": "driver base core select sys dev directory for the device by default we select char for new entry setting class dev obj to null prevents an entry from being created class dev kobj must be set or cleared before any device are registered to the class otherwise device create sys dev entry and device remove sys dev entry will disagree about the presence of the link struct device dev device"
        },
        "ecm_state_change": {
            "ground_truth": "1",
            "function": "ecm_state_change",
            "description": "driver net fddi skfp skfddi ecm state change set ecm state in custom statistic args smc pointer to the smt context struct state possible value are sc0 isolated sc1 wrap sc2 wrap sc4 thru sc5 thru sc7 wrap out nothing"
        },
        "w1_netlink_send_error": {
            "ground_truth": "1",
            "function": "w1_netlink_send_error",
            "description": "driver w1 w1 netlink sends the error message now use when block is not available to queue the message to and cn msg might not be contiguous struct cn msg cn original cn msg struct w1 netlink msg msg original w1 netlink msg int portid where to send it int error error status"
        },
        "dcdbas_exit": {
            "ground_truth": "3",
            "function": "dcdbas_exit",
            "description": "driver platform x86 dcdbas void no argument"
        },
        "_rtl8723be_rate_mapping": {
            "ground_truth": "2",
            "function": "_rtl8723be_rate_mapping",
            "description": "mac80211 is rate idx is like this 4g band rx status band ieee80211 band 2ghz rate rx status flag rx flag ht desc92c rate1m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is 5g band rx status band ieee80211 band 5ghz rate rx status flag rx flag ht desc92c rate6m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is"
        },
        "tcp_rate_skb_delivered": {
            "ground_truth": "1",
            "function": "tcp_rate_skb_delivered",
            "description": "net ipv4 tcp rate from tcp rate"
        },
        "ieee80211_rx_cooked_monitor": {
            "ground_truth": "2",
            "function": "ieee80211_rx_cooked_monitor",
            "description": "net mac80211 rx todo use ieee80211 rx fragmented"
        },
        "nfc_alloc_recv_skb": {
            "ground_truth": "2",
            "function": "nfc_alloc_recv_skb",
            "description": "net nfc core allocate skb for data exchange response unsigned int size size to allocate gfp gfp gfp flag"
        },
        "ice_sync_arfs_fltrs": {
            "ground_truth": "1",
            "function": "ice_sync_arfs_fltrs",
            "description": "driver net ethernet intel ice ice arfs update all arfs filter struct ice pf pf board private structure"
        },
        "__inet_stream_connect": {
            "ground_truth": "1",
            "function": "__inet_stream_connect",
            "description": "net ipv4 af inet connect to remote host there is regrettably still little tcp amagic in here"
        },
        "prism2mib_excludeunencrypted": {
            "ground_truth": "2",
            "function": "prism2mib_excludeunencrypted",
            "description": "prism2mib excludeunencrypted get set the dot11excludeunencrypted value mib record parameter parm1 prism2 rid value parm2 bit value for excludeunencrypted flag parm3 not used argument mib mib record isget mibget mibset flag wlandev wlan device structure priv priv structure hw hw structure msg message structure data data buffer"
        },
        "usb_free_coherent": {
            "ground_truth": "3",
            "function": "usb_free_coherent",
            "description": "driver usb core usb free memory allocated with usb alloc coherent this reclaims an buffer letting it be reused the memory must have been allocated using usb alloc coherent and the parameter must match those provided in that allocation request struct usb device dev device the buffer wa used with size size requested buffer size void addr cpu address of buffer dma addr dma dma address of buffer"
        },
        "device_link_del": {
            "ground_truth": "3",
            "function": "device_link_del",
            "description": "driver base core delete stateless link between two device the caller must ensure proper synchronization of this function with runtime pm if the link wa added multiple time it need to be deleted a often care is required for hotplugged device their link are purged on removal and calling device link del is then no longer allowed struct device link link device link to delete"
        },
        "CARDbStartQuiet": {
            "ground_truth": "2",
            "function": "CARDbStartQuiet",
            "description": "description do quiet it will be called by either isr after start or vntwifi before start so we do not need spinlock parameter in hdevicecontext device structure point out none"
        },
        "i2400m_dnload_init_signed": {
            "ground_truth": "1",
            "function": "i2400m_dnload_init_signed",
            "description": "driver net wimax i2400m fw initialize the signed boot process memory it ha gone through basic validation i2400m device descriptor bcf hdr pointer to the firmware header assumes it is fully in return if ok errno code on error erestartsys if the hw rebooted this writes the firmware bcf header to the device using the hash payload only command"
        },
        "usb_disconnect": {
            "ground_truth": "3",
            "function": "usb_disconnect",
            "description": "driver input misc yealink disconnect device usbcore internal something got disconnected get rid of it and all of it child if pdev is normal device then the parent hub must already be locked if pdev is root hub then the caller must hold the usb bus idr lock which protects the set of root hub a well a the list of bus only hub driver including virtual root hub driver for host controller should ever call this this call is synchronous and may not be used in an interrupt context struct usb device pdev pointer to device being disconnected in interrupt"
        },
        "device_remove_file_self": {
            "ground_truth": "3",
            "function": "device_remove_file_self",
            "description": "driver base core remove sysfs attribute file from it own method see kernfs remove self for detail struct device dev device const struct device attribute attr device attribute descriptor"
        },
        "sock_recvmsg": {
            "ground_truth": "1",
            "function": "sock_recvmsg",
            "description": "receive message from sock struct socket sock socket struct msghdr msg message to receive int flag message flag receives msg from sock passing through lsm return the total number of byte received or an error"
        },
        "wireless_send_event": {
            "ground_truth": "2",
            "function": "wireless_send_event",
            "description": "net wireless wext core send single event to user space"
        },
        "iwctl_giwaplist": {
            "ground_truth": "2",
            "function": "iwctl_giwaplist",
            "description": "wireless handler get ap list"
        },
        "nfc_genl_exit": {
            "ground_truth": "2",
            "function": "nfc_genl_exit",
            "description": "net nfc netlink deinitialize netlink interface this exit function unregisters the nfc netlink family void no argument"
        },
        "sk_filter_trim_cap": {
            "ground_truth": "1",
            "function": "sk_filter_trim_cap",
            "description": "net core filter run packet through socket filter run the ebpf program and then cut skb data to correct size returned by the program if pkt len is we toss packet if skb len is smaller than pkt len we keep whole skb data this is the socket level wrapper to bpf prog run it return if the packet should be accepted or eperm if the packet should be tossed struct sock sk sock associated with type sk buff struct sk buff skb buffer to filter unsigned int cap limit on how short the ebpf program may trim the packet"
        },
        "set_selection_user": {
            "ground_truth": "3",
            "function": "set_selection_user",
            "description": "driver tty vt selection set the current selection const struct tiocl selection user sel user selection info struct tty struct tty the console tty invoked by the ioctl handle for the vt layer the entire selection process is managed under the console lock it is lot under the lock but it hardly performance path"
        },
        "pm_suspend_timer_fn": {
            "ground_truth": "3",
            "function": "pm_suspend_timer_fn",
            "description": "driver base power runtime timer function for pm schedule suspend check if the time is right and queue suspend request struct hrtimer timer undescribed"
        },
        "upd60620_config_init": {
            "ground_truth": "1",
            "function": "upd60620_config_init",
            "description": "driver net phy upd60620 init phy"
        },
        "init_hw_mlme_ext23a": {
            "ground_truth": "2",
            "function": "init_hw_mlme_ext23a",
            "description": "following are the initialization function for wifi mlme"
        },
        "__sys_socketpair": {
            "ground_truth": "1",
            "function": "__sys_socketpair",
            "description": "create pair of connected socket"
        },
        "parse_acl_data": {
            "ground_truth": "2",
            "function": "parse_acl_data",
            "description": "net wireless nl80211 this function par acl information and allocates memory for acl data on successful return the calling function is responsible to free the acl buffer returned by this function"
        },
        "usb_forced_unbind_intf": {
            "ground_truth": "3",
            "function": "usb_forced_unbind_intf",
            "description": "driver usb core driver forced unbinding of usb interface driver either because it doe not support pre reset post reset reset resume or because it doe not support suspend resume the caller must hold intf is device is lock but not intf is lock"
        },
        "usb_register_device_driver": {
            "ground_truth": "3",
            "function": "usb_register_device_driver",
            "description": "driver usb core driver register usb device not interface driver register usb device driver with the usb core the list of unattached device will be rescanned whenever new driver is added allowing the new driver to attach to any recognized device struct usb device driver new udriver usb operation for the device driver struct module owner module owner of this driver negative error code on failure and on success"
        },
        "device_find_child": {
            "ground_truth": "3",
            "function": "device_find_child",
            "description": "driver base core device iterator for locating particular device this is similar to the device for each child function above but it return reference to device that is found for later use a determined by the match callback the callback should return if the device doe not match and non zero if it doe if the callback return non zero and reference to the current device can be obtained this function will return to the caller and not iterate over any more device note you will need to drop the reference with put device after use struct device parent parent struct device void data data to pas to match function int match struct device dev void data callback function to check device"
        },
        "usb_autopm_get_interface": {
            "ground_truth": "3",
            "function": "usb_autopm_get_interface",
            "description": "include linux usb increment usb interface is pm usage counter this routine should be called by an interface driver when it want to use intf and need to guarantee that it is not suspended in addition the routine prevents intf from being autosuspended subsequently note that this will not prevent suspend event originating in the pm core this prevention will persist until usb autopm put interface is called or intf is unbound typical example would be character device driver when it device file is opened intf is usage counter is incremented to prevent subsequent autosuspends however if the autoresume fails then the counter is re decremented this routine can run only in process context struct usb interface intf the usb interface whose counter should be incremented on success"
        },
        "udp4_hwcsum": {
            "ground_truth": "1",
            "function": "udp4_hwcsum",
            "description": "net ipv4 udp handle outgoing hw checksumming struct sk buff skb sk buff containing the filled in udp header checksum field must be zeroed out be32 src source ip address be32 dst destination ip address"
        },
        "__build_skb": {
            "ground_truth": "1",
            "function": "__build_skb",
            "description": "net core skbuff build network buffer allocate new type sk buff caller provides space holding head and skb shared info data must have been allocated by kmalloc only if frag size is otherwise data should come from the page allocator or vmalloc the return is the new skb buffer on failure the return is null and data is not freed note before io driver allocates only data buffer where nic put incoming frame driver should add room at head net skb pad and must add room at tail skb data align skb shared info after io driver call build skb to allocate sk buff and populate it before giving packet to stack rx ring only contains data buffer not full skbs void data data buffer provided by caller unsigned int frag size size of data or if head wa kmalloced"
        },
        "usb_enumerate_device": {
            "ground_truth": "3",
            "function": "usb_enumerate_device",
            "description": "driver usb core hub read device configs intfs otg usbcore internal this is only called by usb new device and usb authorize device and fixme all comment that apply to them apply here wrt to environment if the device is wusb and not authorized we do not attempt to read the string descriptor a they will be errored out by the device until it ha been authorized struct usb device udev newly addressed device in address state if successful negative error code otherwise"
        },
        "ieee80211_data_from_8023": {
            "ground_truth": "2",
            "function": "ieee80211_data_from_8023",
            "description": "ieee80211 data from convert an frame to"
        },
        "amp_ctrl_get": {
            "ground_truth": "2",
            "function": "amp_ctrl_get",
            "description": "net bluetooth amp remote amp controller interface"
        },
        "iwctl_siwpower": {
            "ground_truth": "2",
            "function": "iwctl_siwpower",
            "description": "wireless handler set power mode"
        },
        "drm_gem_object_release_handle": {
            "ground_truth": "3",
            "function": "drm_gem_object_release_handle",
            "description": "driver gpu drm drm gem called at device or object close to release the file is handle reference on object"
        },
        "usbnet_status_stop": {
            "ground_truth": "3",
            "function": "usbnet_status_stop",
            "description": "driver net usb usbnet kill the interrupt urb if all submitter want it killed"
        },
        "ieee80211_sta_ps_deliver_wakeup": {
            "ground_truth": "2",
            "function": "ieee80211_sta_ps_deliver_wakeup",
            "description": "net mac80211 sta info powersave support code"
        },
        "qla24xx_control_vp": {
            "ground_truth": "3",
            "function": "qla24xx_control_vp",
            "description": "driver scsi qla2xxx qla mid enable virtual port for given host scsi qla host vha adapter block pointer int cmd command type to be sent for enable virtual port qla2xxx local function return status code"
        },
        "iwctl_siwfrag": {
            "ground_truth": "2",
            "function": "iwctl_siwfrag",
            "description": "wireless handler set fragment threshold"
        },
        "snd_card_new": {
            "ground_truth": "3",
            "function": "snd_card_new",
            "description": "sound core init create and initialize soundcard structure struct device parent the parent device object int idx card index address sndrv card const char xid card identification ascii string struct module module top level module for locking int extra size allocate this extra size after the main soundcard structure struct snd card card ret the pointer to store the created card instance creates and initializes soundcard structure the function allocates snd card instance via kzalloc with the given space for the driver to use freely the allocated struct is stored in the given card ret pointer zero if successful or negative error code"
        },
        "ncsi_rsp_handler_oem_bcm": {
            "ground_truth": "1",
            "function": "ncsi_rsp_handler_oem_bcm",
            "description": "net ncsi ncsi rsp response handler for broadcom card"
        },
        "_rtl8723e_rate_mapping": {
            "ground_truth": "2",
            "function": "_rtl8723e_rate_mapping",
            "description": "mac80211 is rate idx is like this 4g band rx status band ieee80211 band 2ghz rate rx status flag rx flag ht desc92c rate1m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is 5g band rx status band ieee80211 band 5ghz rate rx status flag rx flag ht desc92c rate6m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is"
        },
        "rtw_indicate_connect": {
            "ground_truth": "3",
            "function": "rtw_indicate_connect",
            "description": "driver staging rtl8723bs core rtw mlme rtw indicate connect the caller ha to lock pmlmepriv lock"
        },
        "tcp_veno_cwnd_event": {
            "ground_truth": "1",
            "function": "tcp_veno_cwnd_event",
            "description": "net ipv4 tcp veno if the connection is idle and we are restarting then we do not want to do any veno calculation until we get fresh rtt sample so when we restart we reset our veno state to clean state after we get acks for this flight of packet then we can make veno calculation again"
        },
        "__udp4_lib_err_encap": {
            "ground_truth": "1",
            "function": "__udp4_lib_err_encap",
            "description": "net ipv4 udp try to match icmp error to udp tunnel by looking up socket without reversing source and destination port this will match tunnel that force the same destination port on both endpoint vxlan geneve note that lwtunnels might actually break this assumption by being configured with different destination port on endpoint in this case we will not be able to trace icmp message back to them if this doe not match any socket probe tunnel with arbitrary destination port fou gue there the receiving socket is useless a the port we have sent packet to will not necessarily match the local destination port then ask the tunnel implementation to match the error against valid association return an error if we can not find match the socket if we need further processing zero otherwise"
        },
        "of_find_net_device_by_node": {
            "ground_truth": "1",
            "function": "of_find_net_device_by_node",
            "description": "net core net sysfs of find net device by node lookup the net device for the device node look up the net device structure corresponding with the device node if successful return pointer to the net device with the embedded struct device refcount incremented by one or null on failure the refcount must be dropped when done with the net device np of device node"
        },
        "get_device": {
            "ground_truth": "3",
            "function": "get_device",
            "description": "driver base core increment reference count for device this simply forward the call to kobject get though we do take care to provide for the case that we get null pointer passed in struct device dev device"
        },
        "nfc_data_exchange": {
            "ground_truth": "2",
            "function": "nfc_data_exchange",
            "description": "net nfc core transceive data the user must wait for the callback before calling this function again struct nfc dev dev the nfc device that found the target u32 target idx index of the target struct sk buff skb data to be sent data exchange cb cb callback called when the response is received void cb context parameter for the callback function"
        },
        "emac_set_features": {
            "ground_truth": "1",
            "function": "emac_set_features",
            "description": "driver net ethernet qualcomm emac emac configure vlan tag strip insert feature"
        },
        "usb_audio_disconnect": {
            "ground_truth": "3",
            "function": "usb_audio_disconnect",
            "description": "sound usb card we need to take care of counter since disconnection can be called also many time a well a usb audio probe"
        },
        "usb_serial_register_drivers": {
            "ground_truth": "3",
            "function": "usb_serial_register_drivers",
            "description": "driver usb serial usb serial register driver for usb serial module register all the driver in the serial driver array and dynamically creates struct usb driver with the name name and id table of id table struct usb serial driver const serial driver null terminated array of pointer to driver to be registered const char name name of the usb driver for this set of serial driver const struct usb device id id table list of all device this serial driver set bind to"
        },
        "usb_serial_deregister_drivers": {
            "ground_truth": "3",
            "function": "usb_serial_deregister_drivers",
            "description": "driver usb serial usb serial deregister driver for usb serial module deregisters all the driver in the serial driver array and deregisters and free the struct usb driver that wa created by the call to usb serial register driver struct usb serial driver const serial driver null terminated array of pointer to driver to be deregistered"
        },
        "sock_setsockopt": {
            "ground_truth": "1",
            "function": "sock_setsockopt",
            "description": "net core sock this is meant for all protocol to use and cover going on at the socket level everything here is generic"
        },
        "lib80211_wep_encrypt": {
            "ground_truth": "2",
            "function": "lib80211_wep_encrypt",
            "description": "net wireless lib80211 crypt wep perform wep encryption on given skb that ha at least byte of headroom for iv and byte of tailroom for icv both iv and icv will be transmitted so the payload length increase with byte wep frame payload iv tx key idx rc4 data icv rc4 crc32 data"
        },
        "usb_root_hub_lost_power": {
            "ground_truth": "3",
            "function": "usb_root_hub_lost_power",
            "description": "driver usb core hub called by hcd if the root hub lost vbus power the usb host controller driver call this function when it root hub is resumed and vbus power ha been interrupted or the controller ha been reset the routine mark rhdev a having lost power when the hub driver is resumed it will take notice and carry out power session recovery for all the usb persist enabled child device the others will be disconnected struct usb device rhdev struct usb device for the root hub"
        },
        "__device_driver_unlock": {
            "ground_truth": "3",
            "function": "__device_driver_unlock",
            "description": "driver base dd device driver unlock release lock needed to manipulate dev drv this function will release the required lock for manipulating dev drv normally this will just be the the dev lock but when called for usb interface parent lock will be released a well dev device we will update driver info for parent parent device needed if the bus requires parent lock"
        },
        "ieee80211_tx_prepare": {
            "ground_truth": "2",
            "function": "ieee80211_tx_prepare",
            "description": "net mac80211 tx initialises tx pas null for the station if unknown valid pointer if known or an err ptr if the station is known not to exist"
        },
        "ieee80211_set_qos_hdr": {
            "ground_truth": "2",
            "function": "ieee80211_set_qos_hdr",
            "description": "net mac80211 wme fill in the qos header if there is one struct ieee80211 sub if data sdata local subif struct sk buff skb packet to be updated"
        },
        "nfp_cpp_writeq": {
            "ground_truth": "1",
            "function": "nfp_cpp_writeq",
            "description": "driver net ethernet netronome nfp nfpcore nfp cpplib write u64 word to cpp location struct nfp cpp cpp cpp device handle u32 cpp id cpp id for operation unsigned long long address address for operation u64 value value to write on success or errno"
        },
        " init_dummy_netdev": {
            "ground_truth": "1",
            "function": " init_dummy_netdev",
            "description": "init dummy network device for napi struct net device dev device to init this take network device structure and initialize the minimum amount of field so it can be used to schedule napi poll without registering full blown interface this is to be used by driver that need to tie several hardware interface to single napi poll scheduler due to hw limitation"
        },
        "iwctl_giwfreq": {
            "ground_truth": "2",
            "function": "iwctl_giwfreq",
            "description": "wireless handler get frequency or channel"
        },
        "device_get_devnode": {
            "ground_truth": "3",
            "function": "device_get_devnode",
            "description": "driver base core path of device node file return the relative path of possible device node non default name may need to allocate memory to compose name this memory is returned in tmp and need to be freed by the caller struct device dev device umode mode returned file access mode kuid uid returned file owner kgid gid returned file group const char tmp possibly allocated string"
        },
        "ft_prli_locked": {
            "ground_truth": "3",
            "function": "ft_prli_locked",
            "description": "driver target tcm fc tfc sess libfc ops involving session"
        },
        "nci_register_device": {
            "ground_truth": "2",
            "function": "nci_register_device",
            "description": "net nfc nci core register nci device in the nfc subsystem struct nci dev ndev the nci device to register"
        },
        "ipa_cmd_register_write_valid": {
            "ground_truth": "1",
            "function": "ipa_cmd_register_write_valid",
            "description": "driver net ipa ipa cmd check whether offset passed to register write are valid"
        },
        "nci_unregister_device": {
            "ground_truth": "2",
            "function": "nci_unregister_device",
            "description": "net nfc nci core unregister nci device in the nfc subsystem struct nci dev ndev the nci device to unregister"
        },
        "skb_panic": {
            "ground_truth": "1",
            "function": "skb_panic",
            "description": "net core skbuff private function for out of line support struct sk buff skb buffer unsigned int sz size void addr address const char msg skb over panic or skb under panic out of line support for skb put and skb push called via the wrapper skb over panic or skb under panic keep out of line to prevent kernel bloat builtin return address is not used because it is not always reliable"
        },
        "serial_port_shutdown": {
            "ground_truth": "3",
            "function": "serial_port_shutdown",
            "description": "driver usb serial usb serial shut down hardware shut down usb serial port serialized against activate by the tport mutex and kept to matching open close pair of call by the initialized flag not called if tty is console struct tty port tport tty port to shut down"
        },
        "bt_to_errno": {
            "ground_truth": "2",
            "function": "bt_to_errno",
            "description": "net bluetooth lib bluetooth error code to unix errno mapping"
        },
        "rt2800_get_tkip_seq": {
            "ground_truth": "2",
            "function": "rt2800_get_tkip_seq",
            "description": "ieee80211 stack callback function"
        },
        "__pskb_pull_tail": {
            "ground_truth": "1",
            "function": "__pskb_pull_tail",
            "description": "net core skbuff advance tail of skb header struct sk buff skb buffer to reallocate int delta number of byte to advance tail the function make sense only on fragmented type sk buff it expands header moving it tail forward and copying necessary data from fragmented part type sk buff must have reference count of return null and type sk buff doe not change if pull failed or value of new tail of skb in the case of success all the pointer pointing into skb header may change and must be reloaded after call to this function"
        },
        "nfc_target_lost": {
            "ground_truth": "2",
            "function": "nfc_target_lost",
            "description": "net nfc core inform that an activated target went out of field the device driver must call this function when the activated target go out of the field important this function must not be called from an atomic context in addition it must also not be called from context that would prevent the nfc core to call other nfc ops entry point concurrently struct nfc dev dev the nfc device that had the activated target in field u32 target idx the nfc index of the target"
        },
        "usb_new_device": {
            "ground_truth": "3",
            "function": "usb_new_device",
            "description": "driver usb core hub perform initial device setup usbcore internal this is called with device which have been detected but not fully enumerated the device descriptor is available but not descriptor for any device configuration the caller must have locked either the parent hub if udev is normal device or else the usb bus idr lock if udev is root hub the parent is pointer to udev ha already been installed but udev is not yet visible through sysfs or other filesystem code this call is synchronous and may not be used in an interrupt context only the hub driver or root hub registrar should ever call this struct usb device udev newly addressed device in address state whether the device is configured properly or not zero if the interface wa registered with the driver core else negative errno value"
        },
        "dev_set_name": {
            "ground_truth": "3",
            "function": "dev_set_name",
            "description": "driver base core set device name struct device dev device const char fmt format string for the device is name variable argument"
        },
        "skb_copy_bits": {
            "ground_truth": "1",
            "function": "skb_copy_bits",
            "description": "net core skbuff copy bit from skb to kernel buffer const struct sk buff skb source skb int offset offset in source void to destination buffer int len number of byte to copy copy the specified number of byte from the source skb to the destination buffer caution if it prototype is ever changed check arch net file since it is called from bpf assembly code"
        },
        "igc_phy_has_link": {
            "ground_truth": "1",
            "function": "igc_phy_has_link",
            "description": "driver net ethernet intel igc igc phy poll phy for link poll the phy status register for link iteration number of time struct igc hw hw pointer to the hw structure u32 iteration number of time to poll for link u32 usec interval delay between polling attempt bool success pointer to whether polling wa successful or not"
        },
        "ieee80211_request_smps": {
            "ground_truth": "2",
            "function": "ieee80211_request_smps",
            "description": "net mac80211 ht request sm p transition this allows the driver to request an sm p transition in managed mode this is useful when the driver ha more information than the stack about possible interference for example by bluetooth struct ieee80211 vif vif type struct ieee80211 vif pointer from the add interface callback enum ieee80211 smps mode smps mode new sm p mode"
        },
        "device_is_dependent": {
            "ground_truth": "3",
            "function": "device_is_dependent",
            "description": "driver base core check if one device depends on another one check if target depends on dev or any device dependent on it it child or it consumer etc return if that is the case or otherwise struct device dev device to check dependency for void target device to check against"
        },
        "usb_set_configuration": {
            "ground_truth": "3",
            "function": "usb_set_configuration",
            "description": "driver usb core message usb set configuration make particular device setting be current context in interrupt caller owns the device lock this is used to enable non default device mode not all device use this kind of configurability many device only have one configuration according to the usb spec section configuration value must be non zero value of zero indicates that the device in unconfigured however some device erroneously use a one of their configuration value to help manage such device this routine will accept configuration a indicating the device should be put in an unconfigured state usb device configuration may affect linux interoperability power consumption and the functionality available for example the default configuration is limited to using 100ma of bus power so that when certain device functionality requires more power and the device is bus powered that functionality should be in some non default device configuration other device mode may also be reflected a configuration option such a whether two isdn channel are available independently and choosing between open standard device protocol like cdc or proprietary one note that non authorized device dev authorized will only be put in unconfigured mode note that usb ha an additional level of device configurability associated with interface that configurability is accessed using usb set interface this call is synchronous the calling context must be able to sleep must own the device lock and must not hold the driver model is usb bus mutex usb interface driver probe method cannot use this routine dev the device whose configuration is being updated configuration the configuration being chosen configuration is the value of the configuration to be installed return zero on success or else the status code returned by the underlying call that failed on successful completion each interface in the original device configuration ha been destroyed and each one in the new configuration ha been probed by all relevant usb device driver currently known to the kernel"
        },
        "rpm_callback": {
            "ground_truth": "3",
            "function": "rpm_callback",
            "description": "driver base power runtime run given runtime pm callback for given device int cb struct device runtime pm callback to run struct device dev device to run the callback for"
        },
        "iwctl_giwmode": {
            "ground_truth": "2",
            "function": "iwctl_giwmode",
            "description": "wireless handler get operation mode"
        },
        "drm_gem_object_handle_free": {
            "ground_truth": "3",
            "function": "drm_gem_object_handle_free",
            "description": "driver gpu drm drm gem release resource bound to userspace handle called after the last handle to the object ha been closed remove any name for the object note that this must be called before drm gem object free or we will be touching freed memory struct drm gem object obj gem object to clean up"
        },
        "__sys_recvfrom": {
            "ground_truth": "1",
            "function": "__sys_recvfrom",
            "description": "helper which do the actual work for syscalls"
        },
        "drm_gem_handle_create_tail": {
            "ground_truth": "3",
            "function": "drm_gem_handle_create_tail",
            "description": "driver gpu drm drm gem internal function to create handle this expects the type drm device object name lock to be held already and will drop it before returning used to avoid race in establishing new handle when importing an object from either an flink name or dma buf handle must be release again through drm gem handle delete this is done when userspace close file priv for all attached handle or through the gem close ioctl for individual handle struct drm file file priv drm file private structure to register the handle for struct drm gem object obj object to register u32 handlep pointer to return the created handle to the caller"
        },
        "ethtool_op_get_ts_info": {
            "ground_truth": "1",
            "function": "ethtool_op_get_ts_info",
            "description": "net ethtool ioctl some generic method driver may use in their ethtool ops"
        },
        "fcoe_vport_create": {
            "ground_truth": "3",
            "function": "fcoe_vport_create",
            "description": "driver scsi fcoe fcoe create an fc host scsi host for vport struct fc vport vport fc vport object to create new fc host for bool disabled start the new fc host in disabled state by default for success"
        },
        "cfg80211_vendor_event_alloc": {
            "ground_truth": "2",
            "function": "cfg80211_vendor_event_alloc",
            "description": "include net cfg80211 allocate vendor specific event skb this function allocates and pre fill an skb for an event on the vendor specific multicast group if wdev null both the ifindex and identifier of the specified wireless device are added to the event message before the vendor data attribute when done filling the skb call cfg80211 vendor event with the skb to send the event struct wiphy wiphy the wiphy struct wireless dev wdev the wireless device int approxlen an upper bound of the length of the data that will be put into the skb int event idx index of the vendor event in the wiphy is vendor event gfp gfp allocation flag an allocated and pre filled skb null if any error happen"
        },
        "wusbhc_mmcie_set": {
            "ground_truth": "2",
            "function": "wusbhc_mmcie_set",
            "description": "add or replace an mmc wireless usb ie must be allocated in kmalloc buffer no stack or vmalloc the caller always owns the pointer we do not free it on remove we just forget about it go over the whole wusbhc mmcie array looking for the first free spot and if wuie is already in the array aka transmitted in the mmcs the spot were it is if present we overwrite it update note need special ordering rule see below wusb1 table the host us the handle a the isort index we allocate the last one always for the wuie id host info and the rest first come first serve in inverse order host software must make sure that it add the other y in the right order the host hardware is responsible for placing the wcta y in the right place with the other y set by host software note we can access wusbhc wa descr without locking because it is read only"
        },
        "driver_deferred_probe_check_state": {
            "ground_truth": "3",
            "function": "driver_deferred_probe_check_state",
            "description": "driver base dd check deferred probe state driver or subsystem can opt in to calling this function instead of directly returning eprobe defer struct device dev device to check enodev if initcalls have completed and module are disabled etimedout if the deferred probe timeout wa set and ha expired and module are enabled eprobe defer in other case"
        },
        "csio_fchost_attr_init": {
            "ground_truth": "3",
            "function": "csio_fchost_attr_init",
            "description": "driver scsi csiostor csio attr csio fchost attr init initialize fc transport attribute ln lnode"
        },
        "device_driver_attach": {
            "ground_truth": "3",
            "function": "device_driver_attach",
            "description": "driver base dd attach specific driver to specific device manually attach driver to device will acquire both dev lock and dev parent lock if needed struct device driver drv driver to attach struct device dev device to attach it to"
        },
        "reg_process_hint_driver": {
            "ground_truth": "2",
            "function": "reg_process_hint_driver",
            "description": "net wireless reg process driver regulatory request the wireless subsystem can use this function to process regulatory request issued by an driver return one of the different reg request treatment value struct wiphy wiphy the wireless device for the regulatory request struct regulatory request driver request pending driver regulatory request"
        },
        "rtw_free_assoc_resources_locked": {
            "ground_truth": "3",
            "function": "rtw_free_assoc_resources_locked",
            "description": "driver staging rtl8188eu core rtw mlme rtw free assoc resource locked the caller ha to lock pmlmepriv lock"
        },
        "hw_atl_tdm_tx_desc_dca_en_set": {
            "ground_truth": "1",
            "function": "hw_atl_tdm_tx_desc_dca_en_set",
            "description": "driver net ethernet aquantia atlantic hw atl hw atl llh set tx descriptor dca enable"
        },
        "tcp_acceptable_seq": {
            "ground_truth": "1",
            "function": "tcp_acceptable_seq",
            "description": "net ipv4 tcp output snd nxt if window wa not shrunk or the amount of shrunk wa le than one window scaling factor due to loss of precision if window ha been shrunk what should we make it is not clear at all using snd una we will fail to open window snd nxt is out of window anything in between snd una snd una snd wnd also can be already invalid ok let is make this for now"
        },
        "mv88e6165_phy_read": {
            "ground_truth": "1",
            "function": "mv88e6165_phy_read",
            "description": "driver net dsa mv88e6xxx phy phy register access implementation"
        },
        "snd_card_free": {
            "ground_truth": "3",
            "function": "snd_card_free",
            "description": "sound core init free given soundcard structure this function release the soundcard structure and the all assigned device automatically that is you do not have to release the device by yourself this function wait until the all resource are properly released struct snd card card soundcard structure zero free all associated device and free the control interface associated to given soundcard"
        },
        "mesh_path_discard_frame": {
            "ground_truth": "2",
            "function": "mesh_path_discard_frame",
            "description": "net mac80211 mesh pathtbl discard frame whose path could not be resolved locking the function must me called within rcu read lock region struct ieee80211 sub if data sdata network subif the frame wa to be sent through struct sk buff skb frame to discard"
        },
        "vga_switcheroo_register_client": {
            "ground_truth": "3",
            "function": "vga_switcheroo_register_client",
            "description": "include linux vga switcheroo register vga client register vga client gpu enable vga switcheroo if another gpu and handler have already registered the power state of the client is assumed to be on beforehand vga switcheroo client probe defer shall be called to ensure that all prerequisite are met struct pci dev pdev client pci device const struct vga switcheroo client ops ops client callback bool driver power control whether power state is controlled by the driver is runtime pm on success enomem on memory allocation error"
        },
        "usb_autosuspend_device": {
            "ground_truth": "3",
            "function": "usb_autosuspend_device",
            "description": "driver usb core driver delayed autosuspend of usb device and it interface this routine should be called when core subsystem is finished using udev and want to allow it to autosuspend example would be when udev is device file in usbfs is closed or after configuration change udev is usage counter is decremented if it drop to and all the interface are inactive then delayed autosuspend will be attempted the attempt may fail see autosuspend check the caller must hold udev is device lock this routine can run only in process context struct usb device udev the usb device to autosuspend"
        },
        "fm10k_fifo_head_len": {
            "ground_truth": "1",
            "function": "fm10k_fifo_head_len",
            "description": "driver net ethernet intel fm10k fm10k mbx retrieve length of first message in fifo struct fm10k mbx fifo fifo pointer to fifo this function return the size of the first message in the fifo"
        },
        "get_net_ns": {
            "ground_truth": "1",
            "function": "get_net_ns",
            "description": "increment the refcount of the network namespace struct n common n common namespace net return the net is common namespace"
        },
        "handle_channel": {
            "ground_truth": "2",
            "function": "handle_channel",
            "description": "net wireless reg note that right now we assume the desired channel bandwidth is always mhz for each individual channel ht40 us mhz per channel the primary and the extension channel"
        },
        "deferred_devs_show": {
            "ground_truth": "3",
            "function": "deferred_devs_show",
            "description": "driver base dd deferred devs show show the device in the deferred probe pending list"
        },
        "__alloc_skb": {
            "ground_truth": "1",
            "function": "__alloc_skb",
            "description": "net core skbuff allocate network buffer unsigned int size size to allocate gfp gfp mask allocation mask int flag if skb alloc fclone is set allocate from fclone cache instead of head cache and allocate cloned child skb if skb alloc rx is set gfp memalloc will be used for allocation in case the data is required for writeback int node numa node to allocate memory on allocate new type sk buff the returned buffer ha no headroom and tail room of at least size byte the object ha reference count of one the return is the buffer on failure the return is null buffer may only be allocated from interrupt using gfp mask of gfp atomic"
        },
        "skb_is_swtx_tstamp": {
            "ground_truth": "1",
            "function": "skb_is_swtx_tstamp",
            "description": "on transmit software and hardware timestamps are returned independently a the two skb clone share the hardware timestamp which may be updated before the software timestamp is received hardware tx timestamp may be returned only if there is no software tx timestamp ignore false software timestamps which may be made in the sock recv timestamp call when the option so timestamp old n is enabled on the socket even when the skb ha hardware timestamp"
        },
        "igb_read_nvm_spi": {
            "ground_truth": "1",
            "function": "igb_read_nvm_spi",
            "description": "driver net ethernet intel igb e1000 nvm read eeprom is using spi struct e1000 hw hw pointer to the hw structure u16 offset offset of word in the eeprom to read u16 word number of word to read u16 data word read from the eeprom read bit word from the eeprom"
        },
        "p80211wext_event_associated": {
            "ground_truth": "2",
            "function": "p80211wext_event_associated",
            "description": "wireless extension ioctls"
        },
        "ieee80211_tx_status": {
            "ground_truth": "2",
            "function": "ieee80211_tx_status",
            "description": "net mac80211 status transmit status callback call this function for all transmitted frame after they have been transmitted it is permissible to not call this function for multicast frame but this can affect statistic this function may not be called in irq context call to this function for single hardware must be synchronized against each other call to this function ieee80211 tx status ni and ieee80211 tx status irqsafe may not be mixed for single hardware must not run concurrently with ieee80211 rx or ieee80211 rx ni struct ieee80211 hw hw the hardware the frame wa transmitted by struct sk buff skb the frame that wa transmitted owned by mac80211 after this call"
        },
        "bus_add_device": {
            "ground_truth": "3",
            "function": "bus_add_device",
            "description": "driver base bus add device to bus add device is bus attribute create link to device is bus add the device to it bus is list of device struct device dev device being added"
        },
        "wusbhc_rh_create": {
            "ground_truth": "2",
            "function": "wusbhc_rh_create",
            "description": "wireless usb fake root hub method"
        },
        "sk_net_capable": {
            "ground_truth": "1",
            "function": "sk_net_capable",
            "description": "net core sock network namespace socket capability test test to see if the opener of the socket had when the socket wa created and the current process ha the capability cap over the network namespace the socket is member of const struct sock sk socket to use capability on or through int cap the capability to use"
        },
        "usb_deregister_device_driver": {
            "ground_truth": "3",
            "function": "usb_deregister_device_driver",
            "description": "driver usb core driver unregister usb device not interface driver unlinks the specified driver from the internal usb driver list struct usb device driver udriver usb operation of the device driver to unregister must be able to sleep"
        },
        "pci_bus_add_device": {
            "ground_truth": "3",
            "function": "pci_bus_add_device",
            "description": "driver pci bus start driver for single device this add add sysfs entry and start device driver struct pci dev dev device to add"
        },
        "nfc_stop_poll": {
            "ground_truth": "2",
            "function": "nfc_stop_poll",
            "description": "net nfc core stop polling for nfc target struct nfc dev dev the nfc device that must stop polling"
        },
        "device_del": {
            "ground_truth": "3",
            "function": "device_del",
            "description": "driver base core delete device from system this is the first part of the device unregistration sequence this remove the device from the list we control from here ha it removed from the other driver model subsystem it wa added to in device add and remove it from the kobject hierarchy note this should be called manually iff device add wa also called manually struct device dev device"
        },
        "usb_get_dev": {
            "ground_truth": "3",
            "function": "usb_get_dev",
            "description": "driver usb core usb increment the reference count of the usb device structure each live reference to device should be refcounted driver for usb interface should normally record such reference in their probe method when they bind to an interface and release them by calling usb put dev in their disconnect method struct usb device dev the device being referenced pointer to the device with the incremented reference counter"
        },
        "bus_for_each_drv": {
            "ground_truth": "3",
            "function": "bus_for_each_drv",
            "description": "driver base bus driver iterator this is nearly identical to the device iterator above we iterate over each driver that belongs to bus and call fn for each if fn return anything but we break out and return it if start is not null we use it a the head of the list note we do not return the driver that return non zero value nor do we leave the reference count incremented for that driver if the caller need to know that info it must set it in the callback it must also be sure to increment the refcount so it doe not disappear before returning to the caller struct bus type bus bus we are dealing with struct device driver start driver to start iterating on void data data to pas to the callback int fn struct device driver void function to call for each driver"
        },
        "hci_dev_get_bd_addr_from_property": {
            "ground_truth": "2",
            "function": "hci_dev_get_bd_addr_from_property",
            "description": "net bluetooth hci core get the bluetooth device address bd addr for hci device from firmware node property search the firmware node for local bd address all zero bd address are rejected because those could be property that exist in the firmware table but were not updated by the firmware for example the dts could define local bd address with zero bd address struct hci dev hdev the hci device"
        },
        "__sys_getsockname": {
            "ground_truth": "1",
            "function": "__sys_getsockname",
            "description": "get the local address name of socket object move the obtained name to user space"
        },
        "device_unblock_probing": {
            "ground_truth": "3",
            "function": "device_unblock_probing",
            "description": "driver base dd unblock enable device is probe it will restore normal behavior and trigger re probing of deferred device void no argument"
        },
        "wakeup_source_remove": {
            "ground_truth": "3",
            "function": "wakeup_source_remove",
            "description": "include linux pm wakeup remove given object from the wakeup source list struct wakeup source w wakeup source object to remove from the list"
        },
        "e1000_receive_skb": {
            "ground_truth": "1",
            "function": "e1000_receive_skb",
            "description": "driver net ethernet intel e1000e netdev helper function to handle rx indication struct e1000 adapter adapter board private structure u8 status descriptor status field a written by hardware le16 vlan descriptor vlan field a written by hardware no le be conversion struct sk buff skb pointer to sk buff to be indicated to stack"
        },
        "cfg80211_ready_on_channel": {
            "ground_truth": "2",
            "function": "cfg80211_ready_on_channel",
            "description": "net wireless nl80211 notification of remain on channel start struct wireless dev wdev wireless device u64 cookie the request cookie struct ieee80211 channel chan the current channel from remain on channel request unsigned int duration duration in millisecond that the driver intent to remain on the channel gfp gfp allocation flag"
        },
        "device_initialize": {
            "ground_truth": "3",
            "function": "device_initialize",
            "description": "driver base core init device structure this prepares the device for use by other layer by initializing it field it is the first half of device register if called by that function though it can also be called separately so one may use dev is field in particular get device put device may be used for reference counting of dev after calling this function all field in dev must be initialized by the caller to except for those explicitly set to some other value the simplest approach is to use kzalloc to allocate the structure containing dev note use put device to give up your reference instead of freeing dev directly once you have called this function struct device dev device"
        },
        "ibmvfc_set_tgt_action": {
            "ground_truth": "3",
            "function": "ibmvfc_set_tgt_action",
            "description": "driver scsi ibmvscsi ibmvfc set the next init action for the target struct ibmvfc target tgt ibmvfc target struct enum ibmvfc target action action action to perform if action changed non zero if not changed"
        },
        "cfg80211_sched_scan_req_possible": {
            "ground_truth": "2",
            "function": "cfg80211_sched_scan_req_possible",
            "description": "net wireless scan determines if scheduled scan request can be handled when legacy scheduled scan is running no other scheduled scan is allowed regardless whether the request is for legacy or multi support scan when multi support scheduled scan is running request for legacy scan is not allowed in this case request for multi support scan can be handled if resource are available ie struct wiphy max sched scan reqs limit is not yet reached"
        },
        "lpfc_ns_cmd": {
            "ground_truth": "3",
            "function": "lpfc_ns_cmd",
            "description": "driver scsi lpfc lpfc ct lpfc n cmd description issue cmd to nameserver sli ctns gid ft li ctns rft id"
        },
        "get_descriptor_addr": {
            "ground_truth": "3",
            "function": "get_descriptor_addr",
            "description": "read descriptor header from i2c based on type"
        },
        "nfc_dev_up": {
            "ground_truth": "2",
            "function": "nfc_dev_up",
            "description": "net nfc core turn on the nfc device the device remains up until the nfc dev down function is called struct nfc dev dev the nfc device to be turned on"
        },
        "ice_rem_prof_id_vsig": {
            "ground_truth": "1",
            "function": "ice_rem_prof_id_vsig",
            "description": "driver net ethernet intel ice ice flex pipe remove specific profile from vsig struct ice hw hw pointer to the hw struct enum ice block blk hardware block u16 vsig vsig to remove the profile from u64 hdl profile handle indicating which profile to remove struct list head chg list to receive record of change"
        },
        "atalk_getname": {
            "ground_truth": "1",
            "function": "atalk_getname",
            "description": "net appletalk ddp find the name of an appletalk socket just copy the right field into the sockaddr"
        },
        "iwctl_siwfreq": {
            "ground_truth": "2",
            "function": "iwctl_siwfreq",
            "description": "wireless handler set frequency or channel"
        },
        "inet_listen": {
            "ground_truth": "1",
            "function": "inet_listen",
            "description": "net ipv4 af inet move socket into listening state"
        },
        "subsys_dev_iter_init": {
            "ground_truth": "3",
            "function": "subsys_dev_iter_init",
            "description": "driver base bus initialize subsys device iterator initialize subsys iterator iter such that it iterates over device of subsys if start is set the list iteration will start there otherwise if it is null the iteration start at the beginning of the list struct subsys dev iter iter subsys iterator to initialize struct bus type subsys the subsys we wanna iterate over struct device start the device to start iterating from if any const struct device type type device type of the device to iterate over null for all"
        },
        "__sys_accept4": {
            "ground_truth": "1",
            "function": "__sys_accept4",
            "description": "for accept we attempt to create new socket set up the link with the client wake up the client then return the new connected fd we collect the address of the connector in kernel space and move it to user at the very end this is unclean because we open the socket then return an error 1g add the ability to recvmsg to query connection pending status to recvmsg we need to add that support in way thats clean when we restructure accept also"
        },
        "__pm_runtime_suspend": {
            "ground_truth": "3",
            "function": "__pm_runtime_suspend",
            "description": "include linux pm runtime entry point for runtime put suspend operation if the rpm get put flag is set decrement the device is usage count and return immediately if it is larger than zero then carry out suspend either synchronous or asynchronous this routine may be called in atomic context if the rpm async flag is set or if pm runtime irq safe ha been called struct device dev device to suspend int rpmflags flag bit"
        },
        "device_link_wait_for_supplier": {
            "ground_truth": "3",
            "function": "device_link_wait_for_supplier",
            "description": "driver base core add device to wait for supplier list mark the consumer device a waiting for supplier to become available by adding it to the wait for supplier list the consumer device will never be probed until it is removed from the wait for supplier list the caller is responsible for adding the link to the supplier device once they are available and removing the consumer device from the wait for supplier list once link to all the supplier have been created this function is not meant to be called from the probe function of the consumer but rather from code that creates add the consumer device struct device consumer consumer device bool need for probe undescribed"
        },
        "xgbe_alloc_pdata": {
            "ground_truth": "1",
            "function": "xgbe_alloc_pdata",
            "description": "driver net ethernet amd xgbe xgbe main function prototype"
        },
        "usb_probe_device": {
            "ground_truth": "3",
            "function": "usb_probe_device",
            "description": "driver usb core driver called from driver core with dev locked"
        },
        "sock_create_kern": {
            "ground_truth": "1",
            "function": "sock_create_kern",
            "description": "creates socket kernel space struct net net net namespace int family protocol family af inet int type communication type sock stream int protocol protocol struct socket re new socket wrapper around sock create return or an error this function internally us gfp kernel"
        },
        "netdev_unregister_kobject": {
            "ground_truth": "1",
            "function": "netdev_unregister_kobject",
            "description": "net core net sysfs delete sysfs entry but hold kobject reference until after all netdev reference are gone"
        },
        "tcp_rcv_established": {
            "ground_truth": "1",
            "function": "tcp_rcv_established",
            "description": "net ipv4 tcp input tcp receive function for the established state it is split into fast path and slow path the fast path is disabled when zero window wa announced from u zero window probing is only handled properly in the slow path out of order segment arrived urgent data is expected there is no buffer space left unexpected tcp flag window value header length are received detected by checking the tcp header against pred flag data is sent in both direction fast path only support pure sender or pure receiver this mean either the sequence number or the ack value must stay constant unexpected tcp option when these condition are not satisfied it drop into standard receive procedure patterned after rfc793 to handle all case the first three case are guaranteed by proper pred flag setting the rest is checked inline fast processing is turned on in tcp data queue when everything is ok"
        },
        "usb_alloc_coherent": {
            "ground_truth": "3",
            "function": "usb_alloc_coherent",
            "description": "driver usb core usb allocate dma consistent buffer for urb no xxx dma map when the buffer is no longer used free it with usb free coherent struct usb device dev device the buffer will be used with size size requested buffer size gfp mem flag affect whether allocation may block dma addr dma used to return dma address of buffer either null indicating no buffer could be allocated or the cpu space pointer to buffer that may be used to perform dma to the specified device such cpu space buffer are returned along with the dma address through the pointer provided note these buffer are used with urb no xxx dma map set in urb transfer flag to avoid behavior like using dma bounce buffer or thrashing iommu hardware during urb completion resubmit the implementation varies between platform depending on detail of how dma will work to this device using these buffer also eliminates cacheline sharing problem on architecture where cpu cache are not dma coherent on system without bus snooping cache these buffer are uncached"
        },
        "nfc_targets_found": {
            "ground_truth": "2",
            "function": "nfc_targets_found",
            "description": "net nfc core inform that target were found the device driver must call this function when one or many nfc target are found after calling this function the device driver must stop polling for target note this function can be called with target null and target to notify driver error meaning that the polling operation cannot complete important this function must not be called from an atomic context in addition it must also not be called from context that would prevent the nfc core to call other nfc ops entry point concurrently struct nfc dev dev the nfc device that found the target struct nfc target target array of nfc target found int target target array size"
        },
        "hinic_msg_to_mgmt": {
            "ground_truth": "1",
            "function": "hinic_msg_to_mgmt",
            "description": "driver net ethernet huawei hinic hinic hw mgmt send message to mgmt return success negative failure struct hinic pf to mgmt pf to mgmt pf to mgmt channel enum hinic mod type mod module in the chip that will get the message u8 cmd command of the message void buf in the msg data u16 in size the msg data length void buf out response u16 out size returned response length enum hinic mgmt msg type sync sync msg or async msg"
        },
        "e1000_clean_tx_irq": {
            "ground_truth": "1",
            "function": "e1000_clean_tx_irq",
            "description": "driver net ethernet intel e1000e netdev reclaim resource after transmit completes struct e1000 adapter adapter board private structure struct e1000 tx ring tx ring ring to clean"
        },
        "driver_probe_done": {
            "ground_truth": "3",
            "function": "driver_probe_done",
            "description": "driver base dd determine if the probe sequence is finished or not should somehow figure out how to use semaphore not an atomic variable void no argument"
        },
        "skb_trim": {
            "ground_truth": "1",
            "function": "skb_trim",
            "description": "net core skbuff remove end from buffer struct sk buff skb buffer to alter unsigned int len new length cut the length of buffer down by removing data from the tail if the buffer is already under the length specified it is not modified the skb must be linear"
        },
        "packet_bind_spkt": {
            "ground_truth": "1",
            "function": "packet_bind_spkt",
            "description": "net packet af packet bind packet socket to device"
        },
        "usb_deauthorize_device": {
            "ground_truth": "3",
            "function": "usb_deauthorize_device",
            "description": "driver usb core hub deauthorize device usbcore internal move the usb device to very basic state where interface are disabled and the device is in fact unconfigured and unusable we share lock that we have with device del so we need to defer it call struct usb device usb dev usb device"
        },
        "lpfc_issue_init_vpi": {
            "ground_truth": "3",
            "function": "lpfc_issue_init_vpi",
            "description": "driver scsi lpfc lpfc hbadisc issue init vpi mailbox command this function issue init vpi mailbox command to initialize vpi for the vport struct lpfc vport vport pointer to lpfc vport data structure"
        },
        "inet_getname": {
            "ground_truth": "1",
            "function": "inet_getname",
            "description": "net ipv4 af inet this doe both peername and sockname"
        },
        "upd60620_read_status": {
            "ground_truth": "1",
            "function": "upd60620_read_status",
            "description": "driver net phy upd60620 get phy status from common register"
        },
        "alloc_netdev_mqs": {
            "ground_truth": "1",
            "function": "alloc_netdev_mqs",
            "description": "allocate network device allocates struct net device with private data area for driver use and performs basic initialization also allocates subqueue structs for each queue on the device int sizeof priv size of private data to allocate space for const char name device name format string unsigned char name assign type origin of device name void setup struct net device callback to initialize device unsigned int txqs the number of tx subqueues to allocate unsigned int rxqs the number of rx subqueues to allocate"
        },
        "_rtl92ee_rate_mapping": {
            "ground_truth": "2",
            "function": "_rtl92ee_rate_mapping",
            "description": "mac80211 is rate idx is like this 4g band rx status band ieee80211 band 2ghz rate rx status flag rx flag ht desc92c rate1m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is 5g band rx status band ieee80211 band 5ghz rate rx status flag rx flag ht desc92c rate6m desc92c rate54m idx is rate rx status flag rx flag ht desc92c ratemcs0 desc92c ratemcs15 idx is"
        },
        "aeq_interrupt": {
            "ground_truth": "1",
            "function": "aeq_interrupt",
            "description": "driver net ethernet huawei hinic hinic hw eq aeq interrupt handler int irq irq number void data the async event queue that collected the event"
        },
        "usb_enable_interface": {
            "ground_truth": "3",
            "function": "usb_enable_interface",
            "description": "driver usb core message enable all the endpoint for an interface enables all the endpoint for the interface is current altsetting struct usb device dev the device whose interface is being enabled struct usb interface intf pointer to the interface descriptor bool reset eps flag to reset the endpoint state"
        },
        "bus_unregister": {
            "ground_truth": "3",
            "function": "bus_unregister",
            "description": "driver base bus remove bus from the system unregister the child subsystem and the bus itself finally we call bus put to release the refcount struct bus type bus bus"
        },
        "ip6_tlvopt_unknown": {
            "ground_truth": "1",
            "function": "ip6_tlvopt_unknown",
            "description": "net ipv6 exthdrs an unknown option is detected decide what to do"
        },
        "usb_autopm_get_interface_async": {
            "ground_truth": "3",
            "function": "usb_autopm_get_interface_async",
            "description": "include linux usb increment usb interface is pm usage counter this routine doe much the same thing a usb autopm get interface it increment intf is usage counter and queue an autoresume request if the device is suspended the difference are that it doe not perform any synchronization caller should hold private lock and handle all synchronization issue themselves and it doe not autoresume the device directly it only queue request after successful call the device may not yet be resumed this routine can run in atomic context struct usb interface intf the usb interface whose counter should be incremented on success negative error code otherwise"
        },
        "tb_ring_alloc_rx": {
            "ground_truth": "3",
            "function": "tb_ring_alloc_rx",
            "description": "driver thunderbolt nhi allocate dma ring for receive struct tb nhi nhi pointer to the nhi the ring is to be allocated int hop hopid ring to allocate pas for automatic allocation int size number of entry in the ring unsigned int flag flag for the ring u16 sof mask mask of pdf value that start frame u16 eof mask mask of pdf value that end frame void start poll void if not null the ring will call this function when an interrupt is triggered and masked instead of callback in each rx frame void poll data optional data passed to start poll"
        },
        "tcp_write_err": {
            "ground_truth": "1",
            "function": "tcp_write_err",
            "description": "net ipv4 tcp timer close socket and save error info struct sock sk the socket the error ha appeared on nothing void"
        },
        "usb_lock_device_for_reset": {
            "ground_truth": "3",
            "function": "usb_lock_device_for_reset",
            "description": "driver usb core usb cautiously acquire the lock for usb device structure attempt to acquire the device lock but fails if the device is notattached or suspended or if iface is specified and the interface is neither binding nor bound rather than sleeping to wait for the lock the routine poll repeatedly this is to prevent deadlock with disconnect in some driver such a usb storage the disconnect or suspend method will block waiting for device reset to complete struct usb device udev device that is being locked const struct usb interface iface interface bound to the driver making the request optional negative error code for failure otherwise"
        },
        "ieee802154_nl_disassoc_indic": {
            "ground_truth": "2",
            "function": "ieee802154_nl_disassoc_indic",
            "description": "ieee802154 nl disassoc indic notify userland of disassociation inform userland that device ha disassociated from the network note this is in section of the ieee document"
        },
        "nfc_unregister_device": {
            "ground_truth": "2",
            "function": "nfc_unregister_device",
            "description": "net nfc core unregister nfc device in the nfc subsystem struct nfc dev dev the nfc device to unregister"
        },
        "device_driver_detach": {
            "ground_truth": "3",
            "function": "device_driver_detach",
            "description": "driver base dd detach driver from specific device detach driver from device will acquire both dev lock and dev parent lock if needed struct device dev device to detach driver from"
        },
        "bfa_fcs_lport_ms_init": {
            "ground_truth": "3",
            "function": "bfa_fcs_lport_ms_init",
            "description": "driver scsi bfa bfa fcs lport m fcs routine"
        },
        "dvbv3_set_delivery_system": {
            "ground_truth": "3",
            "function": "dvbv3_set_delivery_system",
            "description": "driver medium dvb core dvb frontend set the delivery system for dvbv3 api call dvbv3 call doe not know what is the desired system it want it also doe not allow to switch between different type due to that userspace should use dvbv5 instead however in order to avoid breaking userspace api limited backward compatibility support is provided there are some delivery system that are incompatible with dvbv3 call this routine should work fine for frontends that support just one delivery system for frontends that support multiple frontends it default to use the first supported delivery system there is an userspace application that allows changing it at runtime if the current delivery system is not compatible with dvbv3 it get the first one that it is compatible note in order for this to work with application like kaffeine that us dvbv5 call for dvb s2 and dvbv3 call to go back to dvb driver that support both dvb and dvb s2 should have the sys dvbs entry before the sys dvbs2 otherwise it will not switch back to dvb struct dvb frontend fe frontend struct"
        },
        "lpfc_sli4_config": {
            "ground_truth": "3",
            "function": "lpfc_sli4_config",
            "description": "driver scsi lpfc lpfc mbox initialize the sli4 config mailbox command this routine set up the header field of sli4 specific mailbox command for sending ioctl command struct lpfc hba phba pointer to lpfc hba data structure struct lpfcmboxq mbox pointer to lpfc mbox command uint8 subsystem the sli4 config sub mailbox subsystem uint8 opcode the sli4 config sub mailbox command opcode uint32 length length of the sli4 config mailbox command including sub header bool emb true if embedded mbox command should be setup the actual length of the mbox command allocated mostly useful for none embedded mailbox command"
        },
        "usb_get_current_frame_number": {
            "ground_truth": "3",
            "function": "usb_get_current_frame_number",
            "description": "driver usb core usb return current bus frame number struct usb device dev the device whose bus is being queried the current frame number for the usb host controller used with the given usb device this can be used when scheduling isochronous request note different kind of host controller have different scheduling horizon while one type might support scheduling only frame into the future others could support scheduling up to frame into the future"
        },
        "skb_dequeue_tail": {
            "ground_truth": "1",
            "function": "skb_dequeue_tail",
            "description": "net core skbuff remove from the tail of the queue struct sk buff head list list to dequeue from remove the tail of the list the list lock is taken so the function may be used safely with other locking list function the tail item is returned or null if the list is empty"
        },
        "usb_autopm_put_interface": {
            "ground_truth": "3",
            "function": "usb_autopm_put_interface",
            "description": "include linux usb decrement usb interface is pm usage counter this routine should be called by an interface driver when it is finished using intf and want to allow it to autosuspend typical example would be character device driver when it device file is closed the routine decrement intf is usage counter when the counter reach delayed autosuspend request for intf is device is attempted the attempt may fail see autosuspend check this routine can run only in process context struct usb interface intf the usb interface whose counter should be decremented"
        },
        "dvb_frontend_swzigzag_autotune": {
            "ground_truth": "3",
            "function": "dvb_frontend_swzigzag_autotune",
            "description": "driver medium dvb core dvb frontend performs automatic twiddling of frontend parameter struct dvb frontend fe the frontend concerned int check wrapped check if an iteration ha completed do not set on the first attempt number of complete iteration that have been performed"
        },
        "fl6_update_dst": {
            "ground_truth": "1",
            "function": "fl6_update_dst",
            "description": "net ipv6 exthdrs update flowi destination address with info given by srcrt option if any return null if no txoptions or no srcrt otherwise return orig and initial value of fl6 daddr set in orig struct flowi6 fl6 flowi6 for which daddr is to be updated const struct ipv6 txoptions opt struct ipv6 txoptions in which to look for srcrt opt struct in6 addr orig copy of original daddr address if modified"
        },
        "__dev_remove_pack": {
            "ground_truth": "1",
            "function": "__dev_remove_pack",
            "description": "remove packet handler struct packet type pt packet type declaration remove protocol handler that wa previously added to the kernel protocol handler by dev add pack the passed type packet type is removed from the kernel list and can be freed or reused once this function return the packet type might still be in use by receiver and must not be freed until after all the cpu is have gone through quiescent state"
        },
        "ip_rcv": {
            "ground_truth": "1",
            "function": "ip_rcv",
            "description": "net ipv4 ip input ip receive entry point"
        },
        "usbnet_status_start": {
            "ground_truth": "3",
            "function": "usbnet_status_start",
            "description": "driver net usb usbnet submit the interrupt urb if not previously submitted increasing refcount"
        },
        "udp_lib_lport_inuse2": {
            "ground_truth": "1",
            "function": "udp_lib_lport_inuse2",
            "description": "net ipv4 udp note we still hold spinlock of primary hash chain so no other writer can insert delete socket with local port num"
        },
        "device_set_of_node_from_dev": {
            "ground_truth": "3",
            "function": "device_set_of_node_from_dev",
            "description": "driver base core reuse device tree node of another device take another reference to the new device tree node after first dropping any reference held to the old node struct device dev device whose device tree node is being set const struct device dev2 device whose device tree node is being reused"
        },
        "fake_disassoc_req": {
            "ground_truth": "2",
            "function": "fake_disassoc_req",
            "description": "fake disassoc req disassociate device from network this sends disassociation notification to the device being disassociated from the network note this is in section of the ieee document with the reason described in"
        },
        "tcp_parse_options": {
            "ground_truth": "1",
            "function": "tcp_parse_options",
            "description": "net ipv4 tcp input look for tcp option normally only called on syn and synack packet but this can also be called on packet in the established flow when the fast version below fails"
        },
        "INTERNAL_EPHY_ID": {
            "ground_truth": "1",
            "function": "INTERNAL_EPHY_ID",
            "description": "driver for rockchip ethernet phys copyright fuzhou rockchip electronics co ltd david wu"
        },
        "bus_find_device": {
            "ground_truth": "3",
            "function": "bus_find_device",
            "description": "driver base bus device iterator for locating particular device this is similar to the bus for each dev function above but it return reference to device that is found for later use a determined by the match callback the callback should return if the device doe not match and non zero if it doe if the callback return non zero this function will return to the caller and not iterate over any more device struct bus type bus bus type struct device start device to begin with const void data data to pas to match function int match struct device dev const void data callback function to check device"
        },
        "usb_for_each_dev": {
            "ground_truth": "3",
            "function": "usb_for_each_dev",
            "description": "driver usb core usb iterate over all usb device in the system iterate over all usb device and call fn for each passing it data if it return anything other than we break the iteration prematurely and return that value void data data pointer that will be handed to the callback function int fn struct usb device void callback function to be called for each usb device"
        },
        "ieee80211_iterate_active_interfaces": {
            "ground_truth": "2",
            "function": "ieee80211_iterate_active_interfaces",
            "description": "include net mac80211 iterate active interface this function iterates over the interface associated with given hardware that are currently active and call the callback for them this function allows the iterator function to sleep when the iterator function is atomic ieee80211 iterate active interface atomic can be used doe not iterate over new interface during add interface struct ieee80211 hw hw the hardware struct of which the interface should be iterated over u32 iter flag iteration flag see type enum ieee80211 interface iteration flag void iterator void data u8 mac struct ieee80211 vif vif the iterator function to call void data first argument of the iterator function"
        },
        "usb_probe_interface": {
            "ground_truth": "3",
            "function": "usb_probe_interface",
            "description": "driver usb core driver called from driver core with dev locked"
        },
        "usb_match_id": {
            "ground_truth": "3",
            "function": "usb_match_id",
            "description": "driver usb core driver find first usb device id matching device or interface usb match id search an array of usb device id is and return the first one matching the device or interface or null this is used when binding or rebinding driver to an interface most usb device driver will use this indirectly through the usb core but some layered driver framework use it directly these device table are exported with module device table through modutils to support the driver loading functionality of usb hotplugging what match the match flag element in usb device id control which member are used if the corresponding bit is set the value in the device id must match it corresponding member in the device or interface descriptor or else the device id doe not match driver info is normally used only by device driver but you can create wildcard match anything usb device id a driver is module usbmap entry if you provide an id with only nonzero driver info field if you do this the usb device driver is probe routine should use additional intelligence to decide whether to bind to the specified interface what make good usb device id table the match algorithm is very simple so that intelligence in driver selection must come from smart driver id record unless you have good reason to use another selection policy provide match element only in related group and order match specifier from specific to general use the macro provided for that purpose if you can the most specific match specifier use device descriptor data these are commonly used with product specific match the usb device macro let you provide vendor and product id and you can also match against range of product revision these are widely used for device with application or vendor specific bdeviceclass value match based on device class subclass protocol specification are slightly more general use the usb device info macro or it sibling these are used with single function device where bdeviceclass doe not specify that each interface ha it own class match based on interface class subclass protocol are the most general they let driver bind to any interface on multiple function device use the usb interface info macro or it sibling to match class per interface style device a recorded in binterfaceclass note that an entry created by usb interface info will not match any interface if the device class is set to vendor specific this is deliberate according to the usb spec the meaning of the interface class subclass protocol for these device are also vendor specific and hence matching against standard product class would not work anyway if you really want to use an interface based match for such device create match record that also specifies the vendor id unforunately there is not standard macro for creating record like this within those group remember that not all combination are meaningful for example do not give product version range without vendor and product id or specify protocol without it associated class and subclass struct usb interface interface the interface of interest const struct usb device id id array of usb device id structure terminated by zero entry the first matching usb device id or null"
        },
        "mlx4_get_module_info": {
            "ground_truth": "1",
            "function": "mlx4_get_module_info",
            "description": "driver net ethernet mellanox mlx4 port read cable module eeprom data read cable module eeprom data put the outcome data into data pointer paramer return num of read byte on success or negative error code struct mlx4 dev dev mlx4 dev u8 port port number u16 offset byte offset in eeprom to start reading data from u16 size num of byte to read u8 data output buffer to put the requested data into"
        },
        "brcmf_count_20mhz_channels": {
            "ground_truth": "2",
            "function": "brcmf_count_20mhz_channels",
            "description": "filter the list of channel received from firmware counting only the 20mhz channel the wiphy band data only need those which get flagged to indicate if they can take part in higher bandwidth"
        },
        "nfc_deactivate_target": {
            "ground_truth": "2",
            "function": "nfc_deactivate_target",
            "description": "net nfc core deactivate nfc target struct nfc dev dev the nfc device that found the target u32 target idx index of the target that must be deactivated u8 mode undescribed"
        },
        "ipv6_rcv": {
            "ground_truth": "1",
            "function": "ipv6_rcv",
            "description": "net ipv6 ip6 input rcv function called from netdevice level"
        },
        "nfc_start_poll": {
            "ground_truth": "2",
            "function": "nfc_start_poll",
            "description": "net nfc core start polling for nfc target the device remains polling for target until target is found or the nfc stop poll function is called struct nfc dev dev the nfc device that must start polling u32 im protocol undescribed u32 tm protocol undescribed"
        },
        "iwctl_giwap": {
            "ground_truth": "2",
            "function": "iwctl_giwap",
            "description": "wireless handler get ap mac address"
        },
        "udp_poll": {
            "ground_truth": "1",
            "function": "udp_poll",
            "description": "net ipv4 udp wait for udp event struct file file file struct struct socket sock socket poll table wait poll table this is same a datagram poll except for the special case of blocking socket if application is using blocking fd and packet with checksum error is in the queue then it could get return from select indicating data available but then block when reading it add special case code to work around these arguably broken application"
        },
        "sock_common_getsockopt": {
            "ground_truth": "1",
            "function": "sock_common_getsockopt",
            "description": "net core sock function to fill in entry in struct proto ops when protocol us the inet style"
        },
        "inet_create": {
            "ground_truth": "1",
            "function": "inet_create",
            "description": "net ipv4 af inet create an inet socket"
        },
        "snd_device_disconnect": {
            "ground_truth": "3",
            "function": "snd_device_disconnect",
            "description": "sound core device disconnect the device turn the device into the disconnection state invoking dev disconnect callback if the device wa already registered usually called from snd card disconnect struct snd card card the card instance void device data the data pointer to disconnect zero if successful or negative error code on failure or if the device not found"
        },
        "iscsi_sw_tcp_recv": {
            "ground_truth": "1",
            "function": "iscsi_sw_tcp_recv",
            "description": "driver scsi iscsi tcp tcp receive in sendfile fashion read descriptor rd desc read descriptor struct sk buff skb socket buffer unsigned int offset offset in skb size len skb len offset"
        },
        "usb_deregister": {
            "ground_truth": "3",
            "function": "usb_deregister",
            "description": "driver usb core driver unregister usb interface driver unlinks the specified driver from the internal usb driver list note if you called usb register dev you still need to call usb deregister dev to clean up your driver is allocated minor number this call will no longer do it for you struct usb driver driver usb operation of the interface driver to unregister must be able to sleep"
        },
        "dev_get_stats": {
            "ground_truth": "1",
            "function": "dev_get_stats",
            "description": "get network device statistic struct net device dev device to get statistic from struct rtnl link stats64 storage place to store stats get network statistic from device return storage the device driver may provide it own method by setting dev netdev ops get stats64 or dev netdev ops get stats otherwise the internal statistic structure is used"
        },
        "free_tx_buffers": {
            "ground_truth": "1",
            "function": "free_tx_buffers",
            "description": "driver net ethernet neterion s2io free all queued tx buffer free all queued tx buffer return value void struct s2io nic nic device private variable"
        },
        "bfa_fcs_vport_lookup": {
            "ground_truth": "3",
            "function": "bfa_fcs_vport_lookup",
            "description": "driver scsi bfa bfa fcs lport lookup virtual port excludes base port from lookup"
        },
        "dvb_frontend_sleep_until": {
            "ground_truth": "3",
            "function": "dvb_frontend_sleep_until",
            "description": "driver medium dvb core dvb frontend sleep for the amount of time given by add usec parameter this function is used to measure the time required for the fe dishnetwork send legacy cmd ioctl to work it need to be a precise a possible a it affect the detection of the dish tone command at the satellite subsystem it used internally by the dvb frontend core in order to emulate fe dishnetwork send legacy cmd using the type dvb frontend ops set voltage callback note it should not be used at the driver a the emulation for the legacy callback is provided by the kernel the only situation where this should be at the driver is when there are some bug at the hardware that would prevent the core emulation to work on such case the driver would be writing type dvb frontend ops dishnetwork send legacy command and calling this function directly ktime waketime pointer to type struct ktime u32 add usec time to sleep in microsecond"
        },
        "lcs_stop_channel": {
            "ground_truth": "1",
            "function": "lcs_stop_channel",
            "description": "driver s390 net lcs struct lcs channel channel undescribed"
        },
        "usb_disable_lpm": {
            "ground_truth": "3",
            "function": "usb_disable_lpm",
            "description": "driver usb core hub disable hub initiated and device initiated u1 and u2 entry caller must own the bandwidth mutex this will call usb enable lpm on failure which will decrement lpm disable count and will re enable lpm if lpm disable count reach zero"
        },
        "iwctl_giwrate": {
            "ground_truth": "2",
            "function": "iwctl_giwrate",
            "description": "wireless handler get data rate"
        },
        "nal_h264_read_pps": {
            "ground_truth": "3",
            "function": "nal_h264_read_pps",
            "description": "driver staging medium allegro dvt nal h264 read pps nal unit from rbsp format read rbsp data from src and use it to fill pps const struct device dev device pointer struct nal h264 pps pps the type struct nal h264 pps to fill from the rbsp data void src the buffer that contains the rbsp data size size of src in byte number of byte read from src or negative error code"
        },
        "retransmits_timed_out": {
            "ground_truth": "1",
            "function": "retransmits_timed_out",
            "description": "net ipv4 tcp timer return true if this connection ha timed out the default timeout value this function can calculate and use is equivalent to the timeout of tcp connection after boundary unsuccessful exponentially backed off retransmissions with an initial rto of tcp rto min struct sock sk the current socket unsigned int boundary max number of retransmissions unsigned int timeout custom timeout value if set to the default timeout is calculated and used using tcp rto min and the number of unsuccessful retransmits"
        },
        "bus_rescan_devices": {
            "ground_truth": "3",
            "function": "bus_rescan_devices",
            "description": "driver base bus rescan device on the bus for possible driver this function will look for device on the bus with no driver attached and rescan it against existing driver to see if it match any by calling device attach for the unbound device struct bus type bus the bus to scan"
        },
        "usb_disable_device": {
            "ground_truth": "3",
            "function": "usb_disable_device",
            "description": "driver usb core message disable all the endpoint for usb device disables all the device is endpoint potentially including endpoint deallocates hcd hardware state for the endpoint nuking all or most pending urbs and usbcore state for the interface so that usbcore must usb set configuration before any interface could be used struct usb device dev the device whose endpoint are being disabled int skip ep0 to disable endpoint to skip it"
        },
        "dtv_property_process_set": {
            "ground_truth": "3",
            "function": "dtv_property_process_set",
            "description": "driver medium dvb core dvb frontend set single dtv property this routine assigns the property value to the corresponding member of type struct dtv frontend property struct dvb frontend fe pointer to type struct dvb frontend struct file file pointer to type struct file u32 cmd digital tv command u32 data an unsigned bit number zero on success negative errno on failure"
        },
        "usb_disable_autosuspend": {
            "ground_truth": "3",
            "function": "usb_disable_autosuspend",
            "description": "include linux usb prevent usb device from being autosuspended this routine prevents udev from being autosuspended and wake it up if it is already autosuspended the caller must hold udev is device lock struct usb device udev the usb device which may not be autosuspended"
        },
        "snd_device_register": {
            "ground_truth": "3",
            "function": "snd_device_register",
            "description": "sound core device register the device register the device which wa already created via snd device new usually this is called from snd card register but it can be called later if any new device are created after invocation of snd card register struct snd card card the card instance void device data the data pointer to register zero if successful or negative error code on failure or if the device not found"
        },
        "wusbhc_rh_destroy": {
            "ground_truth": "2",
            "function": "wusbhc_rh_destroy",
            "description": "wireless usb fake root hub method"
        },
        "ieee80211_is_empty_essid": {
            "ground_truth": "2",
            "function": "ieee80211_is_empty_essid",
            "description": "driver staging rtl8192u ieee80211 ieee80211 baron move to ieee80211"
        },
        "snd_card_disconnect_sync": {
            "ground_truth": "3",
            "function": "snd_card_disconnect_sync",
            "description": "sound core init disconnect card and wait until file get closed this call snd card disconnect for disconnecting all belonging component and wait until all pending file get closed it assures that all access from user space finished so that the driver can release it resource gracefully struct snd card card card object to disconnect"
        },
        "inet_autobind": {
            "ground_truth": "1",
            "function": "inet_autobind",
            "description": "net ipv4 af inet automatically bind an unbound socket"
        },
        "device_release_driver": {
            "ground_truth": "3",
            "function": "device_release_driver",
            "description": "driver base dd manually detach device from driver manually detach device from driver when called for usb interface dev parent lock must be held if this function is to be called with dev parent lock held ensure that the device is consumer are unbound in advance or that their lock can be acquired under the dev parent lock struct device dev device"
        },
        "set_primary_fwnode": {
            "ground_truth": "3",
            "function": "set_primary_fwnode",
            "description": "driver base core change the primary firmware node of given device set the device is firmware node pointer to fwnode but if secondary firmware node of the device is present preserve it struct device dev device to handle struct fwnode handle fwnode new primary firmware node of the device"
        },
        "usb_driver_release_interface": {
            "ground_truth": "3",
            "function": "usb_driver_release_interface",
            "description": "driver usb core driver unbind driver from an interface this can be used by driver to release an interface without waiting for their disconnect method to be called in typical case this also cause the driver disconnect method to be called this call is synchronous and may not be used in an interrupt context caller must own the device lock so driver disconnect entry do not need extra locking but other call context may need to explicitly claim that lock struct usb driver driver the driver to be unbound struct usb interface iface the interface from which it will be unbound"
        },
        "atalk_rcv": {
            "ground_truth": "1",
            "function": "atalk_rcv",
            "description": "net appletalk ddp receive packet in skb from device dev skb packet received dev network device where the packet come from pt packet type receive packet in skb from device dev this ha come from the snap decoder and on entry skb transport header is the ddp header skb len is the ddp header skb len is the ddp length the physical header have been extracted ppp should probably pas frame marked a for this layer ie arphrd ethertalk struct sk buff skb undescribed struct net device dev undescribed struct packet type pt undescribed struct net device orig dev undescribed"
        },
        "__device_release_driver": {
            "ground_truth": "3",
            "function": "__device_release_driver",
            "description": "driver base dd device release driver must be called with dev lock held when called for usb interface dev parent lock must be held a well"
        },
        "atl1e_free_ring_resources": {
            "ground_truth": "1",
            "function": "atl1e_free_ring_resources",
            "description": "driver net ethernet atheros atl1e atl1e main free tx rx descriptor resource free all transmit software resource struct atl1e adapter adapter board private structure"
        },
        "device_links_check_suppliers": {
            "ground_truth": "3",
            "function": "device_links_check_suppliers",
            "description": "driver base core check presence of supplier driver check link from this device to any supplier walk the list of the device is link to supplier and see if all of them are available if not simply return eprobe defer we need to guarantee that the supplier will not go away after the check ha been positive here it only can go away in device release driver and that function check the device is link to consumer this mean we need to mark the link a consumer probe in progress to make the supplier removal wait for u to complete or bad thing may happen link without the dl flag managed flag set are ignored struct device dev consumer device"
        },
        "drm_gem_object_init": {
            "ground_truth": "3",
            "function": "drm_gem_object_init",
            "description": "driver gpu drm drm gem initialize an allocated shmem backed gem object initialize an already allocated gem object of the specified size with shmfs backing store struct drm device dev drm device the object should be initialized for struct drm gem object obj drm gem object to initialize size size object size"
        },
        "usb_release_dev": {
            "ground_truth": "3",
            "function": "usb_release_dev",
            "description": "driver usb core usb free usb device structure when all user of it are finished will be called only by the device core when all user of this usb device are done struct device dev device that is been disconnected"
        },
        "ieee80211_radiotap_iterator_init": {
            "ground_truth": "2",
            "function": "ieee80211_radiotap_iterator_init",
            "description": "net wireless radiotap radiotap parser iterator initialization this function initializes an opaque iterator struct which can then be passed to ieee80211 radiotap iterator next to visit every radiotap argument which is present in the header it know about extended present header and handle them how to use call ieee80211 radiotap iterator init to init semi opaque iterator struct ieee80211 radiotap iterator no need to init the struct beforehand checking for good return code then loop calling ieee80211 radiotap iterator next it return either enoent if there are no more args to parse or einval if there is problem the iterator is this arg member point to the start of the argument associated with the current argument index that is present which can be found in the iterator is this arg index member this arg index corresponds to the ieee80211 radiotap defines radiotap header length you can find the cpu endian total radiotap header length in iterator max length after executing ieee80211 radiotap iterator init successfully alignment gotcha you must take care when dereferencing iterator this arg for multibyte type the pointer is not aligned use get unaligned type iterator this arg to dereference iterator this arg for type type safely on all arch example code see documentation networking radiotap header rst struct ieee80211 radiotap iterator iterator radiotap iterator to initialize struct ieee80211 radiotap header radiotap header radiotap header to parse int max length total length we can parse into eg whole packet length const struct ieee80211 radiotap vendor namespaces vns vendor namespaces to parse or negative error code if there is problem"
        },
        "dst_input": {
            "ground_truth": "1",
            "function": "dst_input",
            "description": "include net dst input packet from network to transport"
        },
        "kaweth_download_firmware": {
            "ground_truth": "1",
            "function": "kaweth_download_firmware",
            "description": "driver net usb kaweth kaweth download firmware"
        },
        "tpacpi_driver_bluetooth_emulstate_show": {
            "ground_truth": "2",
            "function": "tpacpi_driver_bluetooth_emulstate_show",
            "description": "bluetooth emulstate"
        },
        "iwctl_giwpower": {
            "ground_truth": "2",
            "function": "iwctl_giwpower",
            "description": "wireless handler get power mode"
        },
        "dev_remove_offload": {
            "ground_truth": "1",
            "function": "dev_remove_offload",
            "description": "remove packet offload handler struct packet offload po packet offload declaration remove packet offload handler that wa previously added to the kernel offload handler by dev add offload the passed type offload type is removed from the kernel list and can be freed or reused once this function return this call sleep to guarantee that no cpu is looking at the packet type after return"
        },
        "rmnet_deliver_skb": {
            "ground_truth": "1",
            "function": "rmnet_deliver_skb",
            "description": "driver net ethernet qualcomm rmnet rmnet handler generic handler"
        },
        "sock_sendmsg": {
            "ground_truth": "1",
            "function": "sock_sendmsg",
            "description": "send message through sock struct socket sock socket struct msghdr msg message to send sends msg through sock passing through lsm return the number of byte sent or an error code"
        },
        "usb_reset_configuration": {
            "ground_truth": "3",
            "function": "usb_reset_configuration",
            "description": "driver usb core message lightweight device reset this issue standard set configuration request to the device using the current configuration the effect is to reset most usb related state in the device including interface altsettings reset to zero endpoint halt cleared and endpoint state only for bulk and interrupt endpoint other usbcore state is unchanged including binding of usb device driver to interface because this affect multiple interface avoid using this with composite multi interface device instead the driver for each interface may use usb set interface on the interface it claim be careful though some device do not support the set interface request and others will not reset all the interface state notably endpoint state resetting the whole configuration would affect other driver interface the caller must own the device lock if this routine fails the device will probably be in an unusable state with endpoint disabled and interface only partially enabled struct usb device dev the device whose configuration is being reset zero on success else negative error code"
        },
        "netdev_register_kobject": {
            "ground_truth": "1",
            "function": "netdev_register_kobject",
            "description": "net core net sysfs create sysfs entry for network device"
        },
        "r8712_free_recvframe": {
            "ground_truth": "3",
            "function": "r8712_free_recvframe",
            "description": "driver staging rtl8712 rtl8712 recv get free recv frame from pfree recv queue"
        },
        "snd_usb_audio_free": {
            "ground_truth": "3",
            "function": "snd_usb_audio_free",
            "description": "sound usb card free the chip instance here we have to do not much since pcm and control are already freed"
        },
        "fc_invoke_resp": {
            "ground_truth": "3",
            "function": "fc_invoke_resp",
            "description": "driver scsi libfc fc exch invoke ep resp if an fc seq set resp call is busy modifying ep resp and ep arg when this function is invoked the first spin lock bh call in this function will wait until fc seq set resp ha finished modifying these variable since fc exch done invokes fc seq set resp it is guaranteed that that ep resp will not be invoked after fc exch done ha returned the response handler itself may invoke fc exch done which will clear the ep resp pointer return value return true if and only if ep resp ha been invoked struct fc exch ep the exchange to be operated on struct fc seq sp the sequence pointer to pas through to resp struct fc frame fp the frame pointer to pas through to resp note it is assumed that after initialization finished this mean the first unlock of ex lock after fc exch alloc ep resp and ep arg are modified only via fc seq set resp this guarantee that none of these two variable change if ep resp active"
        },
        "hci_get_bt_present": {
            "ground_truth": "2",
            "function": "hci_get_bt_present",
            "description": "bluetooth rfkill handler"
        },
        "__sys_sendto": {
            "ground_truth": "1",
            "function": "__sys_sendto",
            "description": "send datagram to given address we move the address into kernel space and check the user space data area is readable before invoking the protocol"
        },
        "tcp_fastopen_synack_timer": {
            "ground_truth": "1",
            "function": "tcp_fastopen_synack_timer",
            "description": "net ipv4 tcp timer timer for fast open socket to retransmit synack note that the sk here is the child socket not the parent listener socket"
        },
        "iwctl_siwretry": {
            "ground_truth": "2",
            "function": "iwctl_siwretry",
            "description": "wireless handler set retry threshold"
        },
        "dst_output": {
            "ground_truth": "1",
            "function": "dst_output",
            "description": "include net dst output packet to network from transport"
        },
        "tcp_read_sock": {
            "ground_truth": "1",
            "function": "tcp_read_sock",
            "description": "net ipv4 tcp read isendfile style from tcp socket"
        },
        "usbnet_suspend": {
            "ground_truth": "3",
            "function": "usbnet_suspend",
            "description": "driver net usb usbnet suspend the whole driver a soon a the first interface is suspended resume only when the last interface is resumed"
        },
        "usb_suspend_both": {
            "ground_truth": "3",
            "function": "usb_suspend_both",
            "description": "driver usb core driver suspend usb device and it interface this is the central routine for suspending usb device it call the suspend method for all the interface driver in udev and then call the suspend method for udev itself when the routine is called in autosuspend if an error occurs at any stage all the interface which were suspended are resumed so that they remain in the same state a the device but when called from system sleep all error from suspend method of interface and the non root hub device itself are simply ignored so all suspended interface are only resumed to the device is state when udev is root hub and it suspend method return failure autosuspend request originating from child device or an interface driver may be made without the protection of udev is device lock but all other suspend call will hold the lock usbcore will insure that method call do not arrive during bind unbind or reset operation however driver must be prepared to handle suspend call arriving at unpredictable time this routine can run only in process context struct usb device udev the usb device to suspend pm message msg power management message describing this state transition if the suspend succeeded"
        },
        "sock_register": {
            "ground_truth": "1",
            "function": "sock_register",
            "description": "add socket protocol handler const struct net proto family ops description of protocol this function is called by protocol handler that want to advertise it address family and have it linked into the socket interface the value ops family corresponds to the socket system call protocol family"
        },
        "vga_switcheroo_get_client_state": {
            "ground_truth": "3",
            "function": "vga_switcheroo_get_client_state",
            "description": "include linux vga switcheroo obtain power state of given client obtain power state of given client a seen from vga switcheroo the function is only called from hda intel struct pci dev pdev client pci device power state"
        },
        "packet_create": {
            "ground_truth": "1",
            "function": "packet_create",
            "description": "net packet af packet create packet of type sock packet"
        },
        "baycom_ser_fdx_setup": {
            "ground_truth": "1",
            "function": "baycom_ser_fdx_setup",
            "description": "driver net hamradio baycom ser fdx format baycom ser fdx io irq mode mode ser hardware dcd ser software dcd ser hardware dcd inverted signal at dcd pin denotes the baud rate eg ser12 is baud soft dcd"
        },
        "check_port_resume_type": {
            "ground_truth": "3",
            "function": "check_port_resume_type",
            "description": "driver usb core hub determine whether the device on port is ready for normal resume is ready for reset resume or should be disconnected"
        },
        "unbind_marked_interfaces": {
            "ground_truth": "3",
            "function": "unbind_marked_interfaces",
            "description": "driver usb core driver unbind driver for udev is marked interface these interface have the need binding flag set for example by usb resume interface the caller must hold udev is device lock"
        },
        "prism2sta_ev_rx": {
            "ground_truth": "2",
            "function": "prism2sta_ev_rx",
            "description": "prism2sta ev rx handle the rx event argument wlandev wlan device structure"
        },
        "nfc_dev_down": {
            "ground_truth": "2",
            "function": "nfc_dev_down",
            "description": "net nfc core turn off the nfc device struct nfc dev dev the nfc device to be turned off"
        },
        "snd_request_card": {
            "ground_truth": "3",
            "function": "snd_request_card",
            "description": "sound core sound try to load the card module try to load the module snd card for the given card number via request module return immediately if already loaded int card the card number"
        },
        "iwctl_siwrts": {
            "ground_truth": "2",
            "function": "iwctl_siwrts",
            "description": "wireless handler set rts threshold"
        },
        "pci_raw_set_power_state": {
            "ground_truth": "3",
            "function": "pci_raw_set_power_state",
            "description": "driver pci pci use pci pm register to set the power state of given pci device return value einval if the requested state is invalid eio if device doe not support pci pm or it pm capability register ha wrong version or device doe not support the requested state if device already is in the requested state if device is power state ha been successfully changed struct pci dev dev pci device to handle pci power state pci power state d0 d1 d2 d3hot to put the device into"
        },
        "__pm_runtime_resume": {
            "ground_truth": "3",
            "function": "__pm_runtime_resume",
            "description": "include linux pm runtime entry point for runtime resume operation if the rpm get put flag is set increment the device is usage count then carry out resume either synchronous or asynchronous this routine may be called in atomic context if the rpm async flag is set or if pm runtime irq safe ha been called struct device dev device to resume int rpmflags flag bit"
        },
        "skb_put": {
            "ground_truth": "1",
            "function": "skb_put",
            "description": "net core skbuff add data to buffer struct sk buff skb buffer to use unsigned int len amount of data to add this function extends the used data area of the buffer if this would exceed the total buffer size the kernel will panic pointer to the first byte of the extra data is returned"
        },
        "__sys_listen": {
            "ground_truth": "1",
            "function": "__sys_listen",
            "description": "perform listen basically we allow the protocol to do anything necessary for listen and if that work we mark the socket a ready for listening"
        },
        "packet_do_bind": {
            "ground_truth": "1",
            "function": "packet_do_bind",
            "description": "net packet af packet attach packet hook"
        },
        "rtw_calculate_wlan_pkt_size_by_attribue23a": {
            "ground_truth": "2",
            "function": "rtw_calculate_wlan_pkt_size_by_attribue23a",
            "description": "calculate wlan packet max size from pkt attrib this function doe not consider fragment case"
        },
        "usb_alloc_dev": {
            "ground_truth": "3",
            "function": "usb_alloc_dev",
            "description": "driver usb core usb usb device constructor usbcore internal only hub driver including virtual root hub driver for host controller should ever call this this call may not be used in non sleeping context struct usb device parent hub to which device is connected null to allocate root hub struct usb bus bus bus used to access the device unsigned port1 one based index of port ignored for root hub in interrupt on success pointer to the allocated usb device null on failure"
        },
        "_base_get_chain_buffer_dma_to_chain_buffer": {
            "ground_truth": "3",
            "function": "_base_get_chain_buffer_dma_to_chain_buffer",
            "description": "driver scsi mpt3sas mpt3sas base iterates chain lookup list and provides chain buffer address for the matching dma address each smid can have 64k start from struct mpt3sas adapter ioc per adapter object dma addr chain buffer dma chain buffer dma address pointer to chain buffer or null on failure"
        },
        "device_link_remove": {
            "ground_truth": "3",
            "function": "device_link_remove",
            "description": "driver base core delete stateless link between two device the caller must ensure proper synchronization of this function with runtime pm void consumer consumer end of the link struct device supplier supplier end of the link"
        },
        "ieee80211_aes_cmac_calculate_k1_k2": {
            "ground_truth": "2",
            "function": "ieee80211_aes_cmac_calculate_k1_k2",
            "description": "ieee80211 aes cmac calculate k1 k2 calculate the aes cmac sub key this function computes the two aes cmac sub key based on the previously installed master key"
        },
        "iwctl_siwrate": {
            "ground_truth": "2",
            "function": "iwctl_siwrate",
            "description": "wireless handler set data rate"
        },
        "device_link_add_missing_supplier_links": {
            "ground_truth": "3",
            "function": "device_link_add_missing_supplier_links",
            "description": "driver base core add link from consumer device to supplier device leaving any consumer with inactive supplier on the wait for supplier list loop through all consumer waiting on supplier and try to add all their supplier link if that succeeds the consumer device is removed from wait for supplier list otherwise they are left in the wait for supplier list device left on the wait for supplier list will not be probed the fwnode add link callback is expected to return if it ha found and added all the supplier link for the consumer device it should return an error if it is not able to do so the caller of device link wait for supplier is expected to call this once it is aware of potential supplier becoming available void no argument"
        },
        "ieee80211_wep_null": {
            "ground_truth": "2",
            "function": "ieee80211_wep_null",
            "description": "ieee80211 crypt ccmp tkip wep"
        },
        "usb_bus_notify": {
            "ground_truth": "3",
            "function": "usb_bus_notify",
            "description": "driver usb core usb notification of device and interface registration"
        },
        "sock_common_setsockopt": {
            "ground_truth": "1",
            "function": "sock_common_setsockopt",
            "description": "net core sock set socket option on an inet socket"
        },
        "iwctl_giwscan": {
            "ground_truth": "2",
            "function": "iwctl_giwscan",
            "description": "wireless handler get scan result"
        },
        "dev_add_offload": {
            "ground_truth": "1",
            "function": "dev_add_offload",
            "description": "register offload handler struct packet offload po protocol offload declaration add protocol offload handler to the networking stack the passed type proto offload is linked into kernel list and may not be freed until it ha been removed from the kernel list this call doe not sleep therefore it can not guarantee all cpu is that are in middle of receiving packet will see the new offload handler until the next received packet"
        },
        "tcp_recv_urg": {
            "ground_truth": "1",
            "function": "tcp_recv_urg",
            "description": "net ipv4 tcp handle reading urgent data bsd ha very simple semantics for this no blocking and very strange error"
        },
        "bus_remove_driver": {
            "ground_truth": "3",
            "function": "bus_remove_driver",
            "description": "driver base bus delete driver from bus is knowledge detach the driver from the device it control and remove it from it bus is list of driver finally we drop the reference to the bus we took in bus add driver struct device driver drv driver"
        },
        "autosuspend_check": {
            "ground_truth": "3",
            "function": "autosuspend_check",
            "description": "driver usb core driver internal routine to check whether we may autosuspend device"
        },
        "tcp_measure_rcv_mss": {
            "ground_truth": "1",
            "function": "tcp_measure_rcv_mss",
            "description": "net ipv4 tcp input adapt the ms value used to make delayed ack decision to the real world"
        },
        "drm_gem_handle_create": {
            "ground_truth": "3",
            "function": "drm_gem_handle_create",
            "description": "driver gpu drm drm gem create gem handle for an object create handle for this object this add handle reference to the object which includes regular reference count caller will likely want to dereference the object afterwards since this publishes obj to userspace it must be fully set up by this point driver must call this last in their buffer object creation callback struct drm file file priv drm file private structure to register the handle for struct drm gem object obj object to register u32 handlep pointer to return the created handle to the caller"
        },
        "iwctl_siwessid": {
            "ground_truth": "2",
            "function": "iwctl_siwessid",
            "description": "wireless handler set essid"
        },
        "usb_driver_claim_interface": {
            "ground_truth": "3",
            "function": "usb_driver_claim_interface",
            "description": "driver usb core driver bind driver to an interface this is used by usb device driver that need to claim more than one interface on device when probing audio and acm are current example no device driver should directly modify internal usb interface or usb device structure member few driver should need to use this routine since the most natural way to bind to an interface is to return the private data from the driver is probe method caller must own the device lock so driver probe entry do not need extra locking but other call context may need to explicitly claim that lock struct usb driver driver the driver to be bound struct usb interface iface the interface to which it will be bound must be in the usb device is active configuration void priv driver data associated with that interface on success"
        },
        "hub_port_connect_change": {
            "ground_truth": "3",
            "function": "hub_port_connect_change",
            "description": "driver usb core hub handle physical or logical connection change event this routine is called when port connection change occurs port enable change occurs often caused by emi usb reset and verify device encounter changed descriptor a from firmware download caller already locked the hub"
        },
        "tcm_qla2xxx_npiv_extract_wwn": {
            "ground_truth": "3",
            "function": "tcm_qla2xxx_npiv_extract_wwn",
            "description": "driver scsi qla2xxx tcm qla2xxx from driver scsi scsi transport fc fc parse wwn"
        },
        "__device_links_queue_sync_state": {
            "ground_truth": "3",
            "function": "__device_links_queue_sync_state",
            "description": "driver base core queue device for sync state callback queue device for sync state callback when the device link write lock is not held this allows the sync state execution flow to use device link apis the caller must ensure this function is called with device link write lock held this function doe get device to make sure the device is not freed while on this list so the caller must also ensure that device link flush sync list is called a soon a the caller release device link write lock this is necessary to make sure the sync state is called in timely fashion and the put device is called on this device struct device dev device to call sync state on struct list head list list head to queue the dev on"
        },
        "ftmac100_init": {
            "ground_truth": "1",
            "function": "ftmac100_init",
            "description": "driver net ethernet faraday ftmac100 initialization finalization"
        },
        "usb_autoresume_device": {
            "ground_truth": "3",
            "function": "usb_autoresume_device",
            "description": "driver usb core driver immediately autoresume usb device and it interface this routine should be called when core subsystem want to use udev and need to guarantee that it is not suspended no autosuspend will occur until usb autosuspend device is called note that this will not prevent suspend event originating in the pm core example would be when udev is device file in usbfs is opened or when remote wakeup request is received udev is usage counter is incremented to prevent subsequent autosuspends however if the autoresume fails then the usage counter is re decremented the caller must hold udev is device lock this routine can run only in process context struct usb device udev the usb device to autoresume on success negative error code otherwise"
        },
        "mpc_validate_xid": {
            "ground_truth": "1",
            "function": "mpc_validate_xid",
            "description": "driver s390 net ctcm mpc helper function of mpc fsm ctcm proto mpc only mpc action rcvd xid7"
        },
        "ieee80211_get_key_tx_seq": {
            "ground_truth": "2",
            "function": "ieee80211_get_key_tx_seq",
            "description": "ieee80211 get key tx seq get key tx sequence counter this function allows driver to retrieve the current tx iv pn for the given key it must not be called if iv generation is offloaded to the device note that this function may only be called when no tx processing can be done concurrently for example when queue are stopped and the stop ha been synchronized"
        },
        "tcp_should_autocork": {
            "ground_truth": "1",
            "function": "tcp_should_autocork",
            "description": "net ipv4 tcp if not yet filled skb is pushed do not send it if we have data packet in qdisc or nic queue because tx completion will happen shortly it give chance to coalesce future sendmsg payload into this skb without need for timer and with no latency trade off a packet containing data payload have bigger truesize than pure acks dataless packet the last check prevent autocorking if we only have an ack in qdisc nic queue or if tx completion wa delayed after we processed ack packet"
        },
        "usb_get_intf": {
            "ground_truth": "3",
            "function": "usb_get_intf",
            "description": "driver usb core usb increment the reference count of the usb interface structure each live reference to interface must be refcounted driver for usb interface should normally record such reference in their probe method when they bind to an interface and release them by calling usb put intf in their disconnect method struct usb interface intf the interface being referenced pointer to the interface with the incremented reference counter"
        },
        "snd_register_device": {
            "ground_truth": "3",
            "function": "snd_register_device",
            "description": "sound core sound register the alsa device file for the card register an alsa device file for the given card the operator have to be set in reg parameter int type the device type sndrv device type xxx struct snd card card the card instance int dev the device index const struct file operation ops the file operation void private data user pointer for ops open struct device device the device to register zero if successful or negative error code on failure"
        },
        "reg_process_hint_country_ie": {
            "ground_truth": "2",
            "function": "reg_process_hint_country_ie",
            "description": "net wireless reg process regulatory request from country y the wireless subsystem can use this function to process regulatory request issued by country information element return one of the different reg request treatment value struct wiphy wiphy the wireless device for the regulatory request struct regulatory request country ie request regulatory request from country ie"
        },
        "chan_recv_cb": {
            "ground_truth": "2",
            "function": "chan_recv_cb",
            "description": "net bluetooth 6lowpan packet from bt le device"
        },
        "ipt_do_table": {
            "ground_truth": "1",
            "function": "ipt_do_table",
            "description": "net ipv4 netfilter ip table return one of the generic firewall policy like nf accept"
        },
        "nfc_register_device": {
            "ground_truth": "2",
            "function": "nfc_register_device",
            "description": "net nfc core register nfc device in the nfc subsystem struct nfc dev dev the nfc device to register"
        },
        "ieee80211_enable_ps": {
            "ground_truth": "2",
            "function": "ieee80211_enable_ps",
            "description": "net mac80211 mlme powersave"
        },
        "__sys_setsockopt": {
            "ground_truth": "1",
            "function": "__sys_setsockopt",
            "description": "set socket option because we do not know the option length we have to pas the user mode parameter for the protocol to sort out"
        },
        "fake_get_phy": {
            "ground_truth": "3",
            "function": "fake_get_phy",
            "description": "fake get phy return phy corresponding to this device this function return wpan phy object corresponding to the passed network device reference counter for wpan phy object is incremented so when the wpan phy is not necessary you should drop the reference via wpan phy put call"
        },
        "udp_set_csum": {
            "ground_truth": "1",
            "function": "udp_set_csum",
            "description": "net ipv4 udp function to set udp checksum for an ipv4 udp packet this is intended for the simple case like when setting the checksum for udp tunnel"
        },
        "dtv_get_frontend": {
            "ground_truth": "3",
            "function": "dtv_get_frontend",
            "description": "driver medium dvb core dvb frontend call callback for retrieving dtv parameter this routine call either the dvbv3 or dvbv5 get frontend call if is not null it will update the dvbv5 cache struct pointed by it if out is not null it will update the dvbv3 params pointed by it struct dvb frontend fe struct dvb frontend pointer struct dtv frontend property struct dtv frontend property pointer dvbv5 cache struct dvb frontend parameter out struct dvb frontend parameter pointer dvbv3 fe struct"
        },
        "whc_start": {
            "ground_truth": "2",
            "function": "whc_start",
            "description": "start the wireless host controller start device notification put hc into run state set dnts parameter"
        },
        "stargate2_reset_bluetooth": {
            "ground_truth": "2",
            "function": "stargate2_reset_bluetooth",
            "description": "arch arm mach pxa stargate2 void no argument"
        },
        "icmp_global_allow": {
            "ground_truth": "1",
            "function": "icmp_global_allow",
            "description": "net ipv4 icmp are we allowed to send one more icmp message us token bucket to limit our icmp message to sysctl icmp msg per sec return false if we reached the limit and can not send another packet note called with bh disabled void no argument"
        },
        "ieee80211_radiotap_iterator_next": {
            "ground_truth": "2",
            "function": "ieee80211_radiotap_iterator_next",
            "description": "net wireless radiotap return next radiotap parser iterator arg this function provides the next radiotap arg index ieee80211 radiotap in this arg index and set this arg to point to the payload for the field it take care of alignment handling and extended present field this arg can be changed by the caller eg incremented to move inside compound argument like ieee80211 radiotap channel the args pointed to are in little endian format whatever the endianess of your cpu alignment gotcha you must take care when dereferencing iterator this arg for multibyte type the pointer is not aligned use get unaligned type iterator this arg to dereference iterator this arg for type type safely on all arch struct ieee80211 radiotap iterator iterator radiotap iterator to move to next arg if any if there is an argument to handle enoent if there are no more args or einval if there is something else wrong"
        },
        "driver_detach": {
            "ground_truth": "3",
            "function": "driver_detach",
            "description": "driver base dd detach driver from all device it control struct device driver drv driver"
        },
        "sprd_mcdt_chan_read": {
            "ground_truth": "3",
            "function": "sprd_mcdt_chan_read",
            "description": "sound soc sprd sprd mcdt read data from the mcdt channel is fifo usually user need start to read data once receiving the fifo full interrupt return data size of reading successfully or an error code on failure struct sprd mcdt chan chan the mcdt channel char rx buf receive buffer u32 size data size note we can not read data from the channel fifo when enabling the dma mode otherwise the reading data will be invalid"
        },
        "nfc_alloc_send_skb": {
            "ground_truth": "2",
            "function": "nfc_alloc_send_skb",
            "description": "net nfc core allocate skb for data exchange response struct nfc dev dev undescribed struct sock sk undescribed unsigned int flag undescribed unsigned int size size to allocate unsigned int err undescribed"
        },
        "alloc_surplus_huge_page": {
            "ground_truth": "0",
            "function": "alloc_surplus_huge_page",
            "description": "mm hugetlb allocates fresh surplus page from the page allocator"
        },
        "hugetlb_total_pages": {
            "ground_truth": "0",
            "function": "hugetlb_total_pages",
            "description": "include linux hugetlb return the number page of memory we physically have in page size unit"
        },
        "wb_shutdown": {
            "ground_truth": "0",
            "function": "wb_shutdown",
            "description": "mm backing dev remove bdi from the global list and shutdown any thread we have running"
        },
        "get_valid_first_slab": {
            "ground_truth": "0",
            "function": "get_valid_first_slab",
            "description": "mm slab try to find non pfmemalloc slab if needed"
        },
        "add_vma_to_mm": {
            "ground_truth": "0",
            "function": "add_vma_to_mm",
            "description": "add vma into process is mm struct in the appropriate place in the list and tree and add to the address space is page tree also if not an anonymous page should be called with mm mmap lock held writelocked"
        },
        "__cmpxchg_double_slab": {
            "ground_truth": "0",
            "function": "__cmpxchg_double_slab",
            "description": "mm slub interrupt must be disabled for the fallback code to work right"
        },
        "rc_is_bit_0_helper": {
            "ground_truth": "0",
            "function": "rc_is_bit_0_helper",
            "description": "lib decompress unlzma why rc is bit helper exists because we want to always expose rc code rc bound to optimizer"
        },
        "sockaddr_to_str": {
            "ground_truth": "0",
            "function": "sockaddr_to_str",
            "description": "driver infiniband ulp rtrs rtrs convert sockaddr to string the return value is the number of character written into buf not including the trailing if len is the function return const struct sockaddr addr the sockadddr structure to be converted char buf string containing socket addr size len string length"
        },
        "dec_cluster_info_page": {
            "ground_truth": "0",
            "function": "dec_cluster_info_page",
            "description": "the cluster corresponding to page nr decrease one usage if the usage counter becomes which mean no page in the cluster is in using we can optionally discard the cluster and add it to free cluster list"
        },
        "zs_stat_inc": {
            "ground_truth": "0",
            "function": "zs_stat_inc",
            "description": "mm zsmalloc type can be of enum type z stat type or fullness group"
        },
        "__pud_alloc": {
            "ground_truth": "0",
            "function": "__pud_alloc",
            "description": "include linux mm allocate page upper directory we have already handled the fast path in line"
        },
        "dump_object_info": {
            "ground_truth": "0",
            "function": "dump_object_info",
            "description": "mm kmemleak print the kmemleak object information this function is used mainly for debugging special case when kmemleak operation it must be called with the object lock held"
        },
        "scan_block": {
            "ground_truth": "0",
            "function": "scan_block",
            "description": "mm kmemleak scan memory block exclusive range for valid pointer and add those found to the gray list"
        },
        "do_ctors": {
            "ground_truth": "0",
            "function": "do_ctors",
            "description": "init main call all constructor function linked into the kernel"
        },
        "wp_clean_pud_entry": {
            "ground_truth": "0",
            "function": "wp_clean_pud_entry",
            "description": "mm mapping dirty helper wp clean pud entry the pagewalk pud callback dirty tracking should take place on the pte level so warn if encountering dirty huge pud furthermore never split huge pud since that currently cause dirty info loss the pagefault handler should do that if needed"
        },
        "find_next_to_unuse": {
            "ground_truth": "0",
            "function": "find_next_to_unuse",
            "description": "scan swap map or frontswap map if frontswap parameter is true from current position to next entry still in use return if there are no inuse entry after prev till end of the map"
        },
        "region_count": {
            "ground_truth": "0",
            "function": "region_count",
            "description": "mm hugetlb count and return the number of huge page in the reserve map that intersect with the range"
        },
        "do_pages_stat": {
            "ground_truth": "0",
            "function": "do_pages_stat",
            "description": "determine the node of user array of page and store it in user array of status"
        },
        "tlb_table_invalidate": {
            "ground_truth": "0",
            "function": "tlb_table_invalidate",
            "description": "mm mmu gather if we want tlb remove table to imply tlb invalidates"
        },
        "migrate_prep": {
            "ground_truth": "0",
            "function": "migrate_prep",
            "description": "include linux migrate migrate prep need to be called before we start compiling list of page to be migrated using isolate lru page if scheduling work on other cpu is undesirable use migrate prep local"
        },
        "put_object": {
            "ground_truth": "0",
            "function": "put_object",
            "description": "mm kmemleak decrement the object use count once the count is free the object using an rcu callback since put object may be called via the kmemleak free delete object path the delayed rcu freeing ensures that there is no recursive call to the kernel allocator lock le rcu object list traversal is also possible"
        },
        "delete_object_full": {
            "ground_truth": "0",
            "function": "delete_object_full",
            "description": "mm kmemleak look up the metadata struct kmemleak object corresponding to ptr and delete it"
        },
        "early_kmem_cache_node_alloc": {
            "ground_truth": "0",
            "function": "early_kmem_cache_node_alloc",
            "description": "mm slub no kmalloc node yet so do it by hand we know that this is the first slab on the node for this slabcache there are no concurrent access possible note that this function only work on the kmem cache node when allocating for the kmem cache node this is used for bootstrapping memory on fresh node that ha no slab structure yet"
        },
        "create_object": {
            "ground_truth": "0",
            "function": "create_object",
            "description": "mm kmemleak create the metadata struct kmemleak object corresponding to an allocated memory block and add it to the object list and object tree root"
        },
        "print_vma_addr": {
            "ground_truth": "0",
            "function": "print_vma_addr",
            "description": "include linux mm print the name of vma"
        },
        "is_data_mapping": {
            "ground_truth": "0",
            "function": "is_data_mapping",
            "description": "mm internal data area private writable not stack"
        },
        "check_kernel_text_object": {
            "ground_truth": "0",
            "function": "check_kernel_text_object",
            "description": "mm usercopy is this address range in the kernel text area"
        },
        "count_history_pages": {
            "ground_truth": "0",
            "function": "count_history_pages",
            "description": "count contiguously cached page from index to index max this count is conservative estimation of length of the sequential read sequence or thrashing threshold in memory tight system"
        },
        "zone_absent_pages_in_node": {
            "ground_truth": "0",
            "function": "zone_absent_pages_in_node",
            "description": "mm page alloc return the number of page frame in hole in zone on node"
        },
        "zswap_frontswap_store": {
            "ground_truth": "0",
            "function": "zswap_frontswap_store",
            "description": "mm zswap frontswap hook"
        },
        "clear_pgdat_congested": {
            "ground_truth": "0",
            "function": "clear_pgdat_congested",
            "description": "mm vmscan clear pgdat state for congested dirty or under writeback"
        },
        "__pagevec_release": {
            "ground_truth": "0",
            "function": "__pagevec_release",
            "description": "mm swap the page which we are about to release may be in the deferred lru addition queue that would prevent them from really being freed right now that is ok from correctness point of view but is inefficient those page may be cache warm and we want to give them back to the page allocator asap so pagevec release will drain those queue here pagevec lru add and pagevec lru add active call release page directly to avoid mutual recursion"
        },
        "find_max_nr_alloc": {
            "ground_truth": "0",
            "function": "find_max_nr_alloc",
            "description": "mm percpu stats iterates over all chunk to find the max nr alloc entry"
        },
        "complexmode_enter": {
            "ground_truth": "0",
            "function": "complexmode_enter",
            "description": "enter the mode suitable for non simple operation caller must own sem perm lock"
        },
        "expand_stack": {
            "ground_truth": "0",
            "function": "expand_stack",
            "description": "expand stack to given address not supported under nommu condition"
        },
        "check_new_page": {
            "ground_truth": "0",
            "function": "check_new_page",
            "description": "mm page alloc this page is about to be returned from the page allocator"
        },
        "kmemleak_seq_stop": {
            "ground_truth": "0",
            "function": "kmemleak_seq_stop",
            "description": "mm kmemleak decrement the use count of the last object required if any"
        },
        "scan_gray_list": {
            "ground_truth": "0",
            "function": "scan_gray_list",
            "description": "mm kmemleak scan the object already referenced gray object more object will be referenced and if there are no memory leak all the object are scanned"
        },
        "me_pagecache_clean": {
            "ground_truth": "0",
            "function": "me_pagecache_clean",
            "description": "mm memory failure clean or cleaned page cache page"
        },
        "break_down_buddy_pages": {
            "ground_truth": "0",
            "function": "break_down_buddy_pages",
            "description": "mm page alloc break down higher order page in sub page and keep our target out of buddy allocator"
        },
        "do_mmap_private": {
            "ground_truth": "0",
            "function": "do_mmap_private",
            "description": "set up private mapping or an anonymous shared mapping"
        },
        "set_page_dirty": {
            "ground_truth": "0",
            "function": "set_page_dirty",
            "description": "mm page writeback dirty page for page with mapping this should be done under the page lock for the benefit of asynchronous memory error who prefer consistent dirty state this rule can be broken in some special case but should be better not to if the mapping doe not provide set page dirty op then just fall through and assume that it want buffer head"
        },
        "set_huge_zero_page": {
            "ground_truth": "0",
            "function": "set_huge_zero_page",
            "description": "mm huge memory caller must hold page table lock"
        },
        "zoneinfo_show": {
            "ground_truth": "0",
            "function": "zoneinfo_show",
            "description": "mm vmstat output information about zone in pgdat all zone are printed regardless of whether they are populated or not lowmem reserve ratio operates on the set of all zone and userspace would not be aware of such zone if they are suppressed here zoneinfo display the effect of lowmem reserve ratio"
        },
        "kasan_non_canonical_hook": {
            "ground_truth": "0",
            "function": "kasan_non_canonical_hook",
            "description": "include linux kasan with config kasan inline access to bogus pointer outside the high canonical half of the address space cause out of bound shadow memory read before the actual access for address in the low canonical half of the address space a well a most non canonical address that out of bound shadow memory access land in the non canonical part of the address space help the user figure out what the original bogus pointer wa"
        },
        "__alloc_contig_migrate_range": {
            "ground_truth": "0",
            "function": "__alloc_contig_migrate_range",
            "description": "mm page alloc start end must belong to single zone"
        },
        "swapcache_prepare": {
            "ground_truth": "0",
            "function": "swapcache_prepare",
            "description": "called when allocating swap cache for existing swap entry this can return error code return at success eexist mean there is swap cache note return code is different from swap duplicate entry swap entry for which we allocate swap cache"
        },
        "madvise_remove": {
            "ground_truth": "0",
            "function": "madvise_remove",
            "description": "application want to free up the page and associated backing store this is effectively punching hole into the middle of file"
        },
        "hugetlb_cow": {
            "ground_truth": "0",
            "function": "hugetlb_cow",
            "description": "mm hugetlb hugetlb cow should be called with page lock of the original hugepage held called with hugetlb instantiation mutex held and pte page locked so we cannot race with other handler or page migration keep the pte same check anyway to make transition from the mutex easier"
        },
        "zswap_frontswap_invalidate_page": {
            "ground_truth": "0",
            "function": "zswap_frontswap_invalidate_page",
            "description": "mm zswap free an entry in zswap"
        },
        "refill_stock": {
            "ground_truth": "0",
            "function": "refill_stock",
            "description": "mm memcontrol cache charge val to local per cpu area this will be consumed by consume stock function later"
        },
        "config_tsf_mode": {
            "ground_truth": "0",
            "function": "config_tsf_mode",
            "description": "for rx and tx store and forward mode config"
        },
        "wb_wakeup_delayed": {
            "ground_truth": "0",
            "function": "wb_wakeup_delayed",
            "description": "mm backing dev this function is used when the first inode for this wb is marked dirty it wake up the corresponding bdi thread which should then take care of the periodic background write out of dirty inodes since the write out would start only wouldirty writeback interval centisecs from now anyway we just set up timer which wake the bdi thread up later note we would not bother setting up the timer but this function is on the fast path used by mark inode dirty so we save few context switch by delaying the wake up we have to be careful not to postpone flush work if it is scheduled for earlier thus we use queue delayed work"
        },
        "real_depth": {
            "ground_truth": "0",
            "function": "real_depth",
            "description": "mm pagewalk we want to know the real level where entry is located ignoring any folding of level which may be happening for example if p4d is folded then missing entry found at level p4d is actually at level pgd"
        },
        "shmem_partial_swap_usage": {
            "ground_truth": "0",
            "function": "shmem_partial_swap_usage",
            "description": "mm shmem determine in byte how many of the shmem object is page mapped by the given offset are swapped out this is safe to call without mutex or the page lock thanks to rcu a long a the inode doe not go away and racy result are not problem"
        },
        "can_vma_merge_after": {
            "ground_truth": "0",
            "function": "can_vma_merge_after",
            "description": "return true if we can merge this vm flag anon vma file vm pgoff beyond at higher virtual address and file offset than the vma we cannot merge two vmas if they have differently assigned non null anon vmas nor if same anon vma is assigned but offset incompatible"
        },
        "wait_for_isolated_drain": {
            "ground_truth": "0",
            "function": "wait_for_isolated_drain",
            "description": "mm zsmalloc function for resolving migration"
        },
        "scan_swap_map_try_ssd_cluster": {
            "ground_truth": "0",
            "function": "scan_swap_map_try_ssd_cluster",
            "description": "try to get swap entry from current cpu is swap entry pool cluster this might involve allocating new cluster for current cpu too"
        },
        "do_fault": {
            "ground_truth": "0",
            "function": "do_fault",
            "description": "driver iommu amd iommu v2 we enter with non exclusive mmap lock to exclude vma change but allow concurrent fault the mmap lock may have been released depending on flag and our return value see filemap fault and lock page or retry if mmap lock is released vma may become invalid for example by other thread calling munmap"
        },
        "__next_mem_pfn_range": {
            "ground_truth": "0",
            "function": "__next_mem_pfn_range",
            "description": "mm memblock common iterator interface used to define for each mem pfn range"
        },
        "extract_key_parameters": {
            "ground_truth": "0",
            "function": "extract_key_parameters",
            "description": "crypto asymmetric key asym tpm parse enough information out of tpm key structure tpm struct ver byte tpm key usage byte tpm key flag byte tpm auth data usage byte tpm key parms variable uint32 pcrinfosize byte byte pcrinfosize byte tpm store pubkey uint32 encdatasize byte encdatasize tpm key parms tpm algorithm id byte tpm enc scheme byte tpm sig scheme byte uint32 parmsize byte byte variable"
        },
        "freeary": {
            "ground_truth": "0",
            "function": "freeary",
            "description": "free semaphore set freeary is called with sem id rwsem locked a writer and the spinlock for this semaphore set hold sem id rwsem remains locked on exit"
        },
        "wp_page_copy": {
            "ground_truth": "0",
            "function": "wp_page_copy",
            "description": "mm memory handle the case of page which we actually need to copy to new page called with mmap lock locked and the old page referenced but without the ptl held high level logic flow allocate page copy the content of the old page to the new one handle book keeping and accounting cgroups mmu notifiers etc take the ptl if the pte changed bail out and release the allocated page if the pte is still the way we remember it update the page table and all relevant reference this includes dropping the reference the page table held to the old page a well a updating the rmap in any case unlock the ptl and drop the reference we took to the old page"
        },
        "record_hugetlb_cgroup_uncharge_info": {
            "ground_truth": "0",
            "function": "record_hugetlb_cgroup_uncharge_info",
            "description": "mm hugetlb helper that record hugetlb cgroup uncharge info"
        },
        "do_vfs_ioctl": {
            "ground_truth": "0",
            "function": "do_vfs_ioctl",
            "description": "do vfs ioctl is not for driver and not intended to be export symbol would it is just simple helper for sys ioctl and compat sys ioctl when you add any new common ioctls to the switch above and below please ensure they have compatible argument in compat mode"
        },
        "kill_procs": {
            "ground_truth": "0",
            "function": "kill_procs",
            "description": "mm memory failure kill the process that have been collected earlier only do anything when doit is set otherwise just free the list this is used for clean page which do not need killing also when fail is set do force kill because something went wrong earlier"
        },
        "__save_stack_trace": {
            "ground_truth": "0",
            "function": "__save_stack_trace",
            "description": "f btrfs ref verify save stack trace to the given array of max trace size"
        },
        "can_follow_write_pte": {
            "ground_truth": "0",
            "function": "can_follow_write_pte",
            "description": "mm gup foll force can write to even unwritable pte is but only after we have gone through cow cycle and they are dirty"
        },
        "get_scan_count": {
            "ground_truth": "0",
            "function": "get_scan_count",
            "description": "mm vmscan determine how aggressively the anon and file lru list should be scanned the relative value of each set of lru list is determined by looking at the fraction of the page scanned we did rotate back onto the active list instead of evict nr anon inactive page to scan nr anon active page to scan nr file inactive page to scan nr file active page to scan"
        },
        "kmem_cache_init": {
            "ground_truth": "0",
            "function": "kmem_cache_init",
            "description": "mm slub initialisation called after the page allocator have been initialised and before smp init"
        },
        "check_valid_pointer": {
            "ground_truth": "0",
            "function": "check_valid_pointer",
            "description": "mm slub verify that pointer ha an address that is valid within slab page"
        },
        "set_page_refcounted": {
            "ground_truth": "0",
            "function": "set_page_refcounted",
            "description": "mm internal turn non refcounted page refcount into refcounted with count of one"
        },
        "hugetlbfs_pagecache_page": {
            "ground_truth": "0",
            "function": "hugetlbfs_pagecache_page",
            "description": "mm hugetlb return the pagecache page at given address within vma"
        },
        "slob_free": {
            "ground_truth": "0",
            "function": "slob_free",
            "description": "mm slob slob free entry point into the slob allocator"
        },
        "page_huge_active": {
            "ground_truth": "0",
            "function": "page_huge_active",
            "description": "mm hugetlb test to determine whether the hugepage is active in use being linked to hstate hugepage activelist this function can be called for tail page but never return true for them"
        },
        "do_set_mempolicy": {
            "ground_truth": "0",
            "function": "do_set_mempolicy",
            "description": "set the process memory policy"
        },
        "bprm_caps_from_vfs_caps": {
            "ground_truth": "0",
            "function": "bprm_caps_from_vfs_caps",
            "description": "security commoncap calculate the new process capability set from the capability set attached to file"
        },
        "get_partial": {
            "ground_truth": "0",
            "function": "get_partial",
            "description": "mm slub get partial page lock it and return it"
        },
        "restore_reserve_on_error": {
            "ground_truth": "0",
            "function": "restore_reserve_on_error",
            "description": "mm hugetlb this routine is called to restore reservation on error path in the specific error path huge page wa allocated via alloc huge page and is about to be freed if reservation for the page existed alloc huge page would have consumed the reservation and set pageprivate in the newly allocated page when the page is freed via free huge page the global reservation count will be incremented if pageprivate is set however free huge page can not adjust the reserve map adjust the reserve map here to be consistent with global reserve count adjustment to be made by free huge page"
        },
        "ethtool_rxfh_indir_default": {
            "ground_truth": "0",
            "function": "ethtool_rxfh_indir_default",
            "description": "include linux ethtool get default value for rx flow hash indirection this function provides the default policy for rx flow hash indirection u32 index index in rx flow hash indirection table u32 rx ring number of rx ring to use"
        },
        "try_context_readahead": {
            "ground_truth": "0",
            "function": "try_context_readahead",
            "description": "page cache context based read ahead"
        },
        "calculate_sizes": {
            "ground_truth": "0",
            "function": "calculate_sizes",
            "description": "mm slub calculate size determines the order and the distribution of data within slab object"
        },
        "acquire_slab": {
            "ground_truth": "0",
            "function": "acquire_slab",
            "description": "mm slub remove slab from the partial list freeze it and return the pointer to the freelist return list of object or null if it fails"
        },
        "get_kpfn_nid": {
            "ground_truth": "0",
            "function": "get_kpfn_nid",
            "description": "mm ksm this helper is used for getting right index into array of tree root when merge across node knob is set to there are only two rb tree for stable and unstable page from all node with root in index otherwise every node ha it own stable and unstable tree"
        },
        "__sys_getsockopt": {
            "ground_truth": "0",
            "function": "__sys_getsockopt",
            "description": "get socket option because we do not know the option length we have to pas user mode parameter for the protocol to sort out"
        },
        "kswapd_highest_zoneidx": {
            "ground_truth": "0",
            "function": "kswapd_highest_zoneidx",
            "description": "mm vmscan the pgdat kswapd highest zoneidx is used to pas the highest zone index to be reclaimed by kswapd from the waker if the value is max nr zone which is not valid index then either kswapd run for first time or kswapd could not sleep after previous reclaim attempt node is still unbalanced in that case return the zone index of the previous kswapd reclaim cycle"
        },
        "__shmem_file_setup": {
            "ground_truth": "0",
            "function": "__shmem_file_setup",
            "description": "mm shmem common code"
        },
        "set_pageblock_order": {
            "ground_truth": "0",
            "function": "set_pageblock_order",
            "description": "mm page alloc initialise the number of page represented by nr pageblock bit"
        },
        "buffer_migrate_lock_buffers": {
            "ground_truth": "0",
            "function": "buffer_migrate_lock_buffers",
            "description": "return true if all buffer are successfully locked"
        },
        "__munlock_isolate_lru_page": {
            "ground_truth": "0",
            "function": "__munlock_isolate_lru_page",
            "description": "isolate page from lru with optional get page pin assumes lru lock already held and page already pinned"
        },
        "bfa_ioc_recover": {
            "ground_truth": "0",
            "function": "bfa_ioc_recover",
            "description": "driver net ethernet brocade bna bfa ioc firmware failure detected start recovery action"
        },
        "check_restart": {
            "ground_truth": "0",
            "function": "check_restart",
            "description": "check restart sma update queue is when it restarts scanning the whole queue of waiting operation therefore this function check if the restart is really necessary it is called after previously waiting operation modified the array note that wait for zero operation are handled without restart sma semaphore array the operation that just completed"
        },
        "__remove_shared_vm_struct": {
            "ground_truth": "0",
            "function": "__remove_shared_vm_struct",
            "description": "requires inode mapping mmap rwsem"
        },
        "memcg_event_remove": {
            "ground_truth": "0",
            "function": "memcg_event_remove",
            "description": "mm memcontrol unregister event and free resource get called from workqueue"
        },
        "add_to_swap_cache": {
            "ground_truth": "0",
            "function": "add_to_swap_cache",
            "description": "include linux swap add to swap cache resembles add to page cache locked on swapper space but set swapcache flag and private instead of mapping and index"
        },
        "try_to_unmap_flush": {
            "ground_truth": "0",
            "function": "try_to_unmap_flush",
            "description": "mm internal flush tlb entry for recently unmapped page from remote cpu it is important if pte wa dirty when it wa unmapped that it is flushed before any io is initiated on the page to prevent lost writes similarly it must be flushed before freeing to prevent data leakage"
        },
        "invalidate_exceptional_entry": {
            "ground_truth": "0",
            "function": "invalidate_exceptional_entry",
            "description": "mm truncate invalidate exceptional entry if easily possible this handle exceptional entry for invalidate inode page"
        },
        "alloc_buddy_huge_page_with_mpol": {
            "ground_truth": "0",
            "function": "alloc_buddy_huge_page_with_mpol",
            "description": "mm hugetlb use the vma is mpolicy to allocate huge page from the buddy"
        },
        "__alloc_vmap_area": {
            "ground_truth": "0",
            "function": "__alloc_vmap_area",
            "description": "mm vmalloc return start address of the newly allocated area if success otherwise vend is returned that indicates failure"
        },
        "drain_freelist": {
            "ground_truth": "0",
            "function": "drain_freelist",
            "description": "mm slab remove slab from the list of free slab specify the number of slab to drain in tofree return the actual number of slab released"
        },
        "build_detached_freelist": {
            "ground_truth": "0",
            "function": "build_detached_freelist",
            "description": "mm slub this function progressively scan the array with free object with limited look ahead and extract object belonging to the same page it build detached freelist directly within the given page object this can happen without any need for synchronization because the object are owned by running process the freelist is build up a single linked list in the object the idea is that this detached freelist can then be bulk transferred to the real freelist but only requiring single synchronization primitive look ahead in the array is limited due to performance reason"
        },
        "get_map": {
            "ground_truth": "0",
            "function": "get_map",
            "description": "mm slub determine map of object in use on page node listlock must be held to guarantee that the page doe not vanish from under u"
        },
        "move_pfn_range_to_zone": {
            "ground_truth": "0",
            "function": "move_pfn_range_to_zone",
            "description": "mm memory hotplug associate the pfn range with the given zone initializing the memmaps and resizing the pgdat zone data to span the added page after this call all affected page are pg reserved all aligned pageblocks are initialized to the specified migratetype usually migrate movable besides setting the migratetype no related zone stats nr isolate pageblock are touched"
        },
        "numa_zonelist_order_handler": {
            "ground_truth": "0",
            "function": "numa_zonelist_order_handler",
            "description": "mm page alloc sysctl handler for numa zonelist order"
        },
        "__pageblock_pfn_to_page": {
            "ground_truth": "0",
            "function": "__pageblock_pfn_to_page",
            "description": "mm page alloc check that the whole or subset of pageblock given by the interval of start pfn end pfn is valid and within the same zone before scanning it with the migration of free compaction scanner the scanner then need to use only pfn valid within check for arch that allow hole within pageblocks return struct page pointer of start pfn or null if check were not passed it is possible on some configuration to have setup like node0 node1 node0 it is possible that all page within zone range of page do not belong to single zone we assume that border between node0 and node1 can occur within single pageblock but not node0 node1 node0 interleaving within single pageblock it is therefore sufficient to check the first and last page of pageblock and avoid checking each individual page in pageblock"
        },
        "__test_page_isolated_in_pageblock": {
            "ground_truth": "0",
            "function": "__test_page_isolated_in_pageblock",
            "description": "mm page isolation test all page in the range is free mean isolated or not all page in start pfn end pfn must be in the same zone zone lock must be held before call this return the last tested pfn"
        },
        "reap_alien": {
            "ground_truth": "0",
            "function": "reap_alien",
            "description": "mm slab called from cache reap to regularly drain alien cache round robin"
        },
        "do_brk_flags": {
            "ground_truth": "0",
            "function": "do_brk_flags",
            "description": "this is really simplified do mmap it only handle anonymous map eventually we may be able to do some brk specific accounting here"
        },
        "connection_broken": {
            "ground_truth": "0",
            "function": "connection_broken",
            "description": "driver scsi ibmvscsi tgt ibmvscsi tgt determine if the connection to the client is good this function attempt to send ping mad to the client if the call to queue the request return closed then the connection ha been broken and the function return true execution environment interrupt or process environment struct scsi info vscsi pointer to our adapter structure"
        },
        "delete_from_swap_cache": {
            "ground_truth": "0",
            "function": "delete_from_swap_cache",
            "description": "include linux swap this must be called only on page that have been verified to be in the swap cache and locked it will never put the page into the free list the caller ha reference on the page"
        },
        "swap_free_obj": {
            "ground_truth": "0",
            "function": "swap_free_obj",
            "description": "mm slab swap two freelist entry"
        },
        "hotadd_new_pgdat": {
            "ground_truth": "0",
            "function": "hotadd_new_pgdat",
            "description": "mm memory hotplug we are ok calling meminit stuff here we have config memory hotplug"
        },
        "cvmx_pip_config_vlan_qos": {
            "ground_truth": "0",
            "function": "cvmx_pip_config_vlan_qos",
            "description": "arch mips include asm octeon cvmx pip uint64 vlan priority vlan priority uint64 qos qos queue for packet matching this watcher"
        },
        "remove_migration_ptes": {
            "ground_truth": "0",
            "function": "remove_migration_ptes",
            "description": "get rid of all migration entry and replace them by reference to the indicated page"
        },
        "page_is_buddy": {
            "ground_truth": "0",
            "function": "page_is_buddy",
            "description": "mm page alloc this function check whether page is free is the buddy we can coalesce page and it buddy if the buddy is not in hole check before calling the buddy is in the buddy system page and it buddy have the same order page and it buddy are in the same zone for recording whether page is in the buddy system we set pagebuddy setting clearing and testing pagebuddy is serialized by zone lock for recording page is order we use page private page"
        },
        "redirty_page_for_writepage": {
            "ground_truth": "0",
            "function": "redirty_page_for_writepage",
            "description": "mm page writeback when writepage implementation decides that it doe not want to write this page for some reason it should redirty the locked page via redirty page for writepage and it should then unlock the page and return"
        },
        "init_freelist_randomization": {
            "ground_truth": "0",
            "function": "init_freelist_randomization",
            "description": "mm slub initialize each random sequence freelist per cache"
        },
        "mempool_kmalloc": {
            "ground_truth": "0",
            "function": "mempool_kmalloc",
            "description": "mm mempool commonly used alloc and free fn that kmalloc kfrees the amount of memory specified by pool data"
        },
        "gather_bootmem_prealloc": {
            "ground_truth": "0",
            "function": "gather_bootmem_prealloc",
            "description": "mm hugetlb put bootmem huge page into the standard list after mem map is up"
        },
        "kmalloc_order": {
            "ground_truth": "0",
            "function": "kmalloc_order",
            "description": "mm slab common to avoid unnecessary overhead we pas through large allocation request directly to the page allocator we use gfp comp because we will need to know the allocation order to free the page properly in kfree"
        },
        "__mpol_dup": {
            "ground_truth": "0",
            "function": "__mpol_dup",
            "description": "slow path of mempolicy duplicate"
        },
        "set_page_huge_active": {
            "ground_truth": "0",
            "function": "set_page_huge_active",
            "description": "mm hugetlb never called for tail page"
        },
        "__putback_lru_fast_prepare": {
            "ground_truth": "0",
            "function": "__putback_lru_fast_prepare",
            "description": "prepare page for fast batched lru putback via putback lru evictable pagevec the fast path is available only for evictable page with single mapping then we can bypass the per cpu pvec and get better performance when mapcount we need try to munlock which can fail when page evictable we need the full redo logic of putback lru page to avoid leaving evictable page in unevictable list in case of success page is added to pvec and pgrescued is incremented in case that the page wa previously unevictable page is also unlocked"
        },
        "__remove_object": {
            "ground_truth": "0",
            "function": "__remove_object",
            "description": "mm kmemleak remove an object from the object tree root and object list must be called with the kmemleak lock held if kmemleak is still enabled"
        },
        "mem_cgroup_from_obj": {
            "ground_truth": "0",
            "function": "mem_cgroup_from_obj",
            "description": "include linux memcontrol return pointer to the memory cgroup to which the kernel object is charged the caller must ensure the memcg lifetime by taking rcu read lock cgroup mutex etc"
        },
        "free_page_series": {
            "ground_truth": "0",
            "function": "free_page_series",
            "description": "free contiguous series of page"
        },
        "wp_page_reuse": {
            "ground_truth": "0",
            "function": "wp_page_reuse",
            "description": "mm memory handle write page fault for page that can be reused in the current vma this can happen either due to the mapping being with the vm shared flag or due to u being the last reference standing to the page in either case all we need to do here is to mark the page a writable and update any related book keeping"
        },
        "rmqueue": {
            "ground_truth": "0",
            "function": "rmqueue",
            "description": "mm page alloc allocate page from the given zone use pcplists for order allocation"
        },
        "free_block": {
            "ground_truth": "0",
            "function": "free_block",
            "description": "mm slab caller need to acquire correct kmem cache node is list lock list list of detached free slab should be freed by caller"
        },
        "init_zspage": {
            "ground_truth": "0",
            "function": "init_zspage",
            "description": "mm zsmalloc initialize newly allocated zspage"
        },
        "__inc_zone_state": {
            "ground_truth": "0",
            "function": "__inc_zone_state",
            "description": "include linux vmstat optimized increment and decrement function these are only for single page and therefore can take struct page argument instead of struct zone this allows the inclusion of the code generated for page zone page into the optimized function no overflow check is necessary and therefore the differential can be incremented or decremented in place which may allow the compiler to generate better code the increment or decrement is known and therefore one boundary check can be omitted note these function are very performance sensitive change only with care some processor have inc dec instruction that are atomic v an interrupt however the code must first determine the differential location in zone based on the processor number and then inc dec the counter there is no guarantee without disabling preemption that the processor will not change in between and therefore the atomicity v interrupt cannot be exploited in useful way here"
        },
        "do_anonymous_page": {
            "ground_truth": "0",
            "function": "do_anonymous_page",
            "description": "mm memory we enter with non exclusive mmap lock to exclude vma change but allow concurrent fault and pte mapped but not yet locked we return with mmap lock still held but pte unmapped and unlocked"
        },
        "shmem_find_alias": {
            "ground_truth": "0",
            "function": "shmem_find_alias",
            "description": "mm shmem find any alias of inode but prefer hashed alias"
        },
        "wp_clean_pmd_entry": {
            "ground_truth": "0",
            "function": "wp_clean_pmd_entry",
            "description": "mm mapping dirty helper wp clean pmd entry the pagewalk pmd callback dirty tracking should take place on the pte level so warn if encountering dirty huge pmd furthermore never split huge pmds since that currently cause dirty info loss the pagefault handler should do that if needed"
        },
        "kernel_set_mempolicy": {
            "ground_truth": "0",
            "function": "kernel_set_mempolicy",
            "description": "set the process memory policy"
        },
        "cache_grow_begin": {
            "ground_truth": "0",
            "function": "cache_grow_begin",
            "description": "mm slab grow by the number of slab within cache this is called by kmem cache alloc when there are no active objs left in cache"
        },
        "find_vma_exact": {
            "ground_truth": "0",
            "function": "find_vma_exact",
            "description": "look up the first vma exactly that exactly match addr should be called with mm mmap lock at least held readlocked"
        },
        "slob_last": {
            "ground_truth": "0",
            "function": "slob_last",
            "description": "mm slob return true if is the last free block in it page"
        },
        "__vma_link_list": {
            "ground_truth": "0",
            "function": "__vma_link_list",
            "description": "mm util mm util"
        },
        "bad_range": {
            "ground_truth": "0",
            "function": "bad_range",
            "description": "mm page alloc temporary debugging check for page not lying within given zone"
        },
        "numa_default_policy": {
            "ground_truth": "0",
            "function": "numa_default_policy",
            "description": "include linux mempolicy reset policy of current process to default"
        },
        "parse_slub_debug_flags": {
            "ground_truth": "0",
            "function": "parse_slub_debug_flags",
            "description": "mm slub parse block of slub debug option block are delimited by str start of block flag return parsed flag or debug default flag if none specified slab return start of list of slab or null when there is no list init assume this is initial parsing and not per kmem create parsing return the start of next block if there is any or null"
        },
        "xdp_redirect_dummy_prog": {
            "ground_truth": "0",
            "function": "xdp_redirect_dummy_prog",
            "description": "sample bpf xdp redirect kern redirect require an xdp bpf prog loaded on the tx device"
        },
        "create_kmalloc_caches": {
            "ground_truth": "0",
            "function": "create_kmalloc_caches",
            "description": "mm slab common create the kmalloc array some of the regular kmalloc array may already have been created because they were needed to enable allocation for slab creation"
        },
        "__get_ns_from_inode": {
            "ground_truth": "0",
            "function": "__get_ns_from_inode",
            "description": "this routine should be called with the mq lock held"
        },
        "__zswap_param_set": {
            "ground_truth": "0",
            "function": "__zswap_param_set",
            "description": "mm zswap val must be null terminated string"
        },
        "page_referenced_one": {
            "ground_truth": "0",
            "function": "page_referenced_one",
            "description": "mm rmap arg page referenced arg will be passed"
        },
        "__get_any_page": {
            "ground_truth": "0",
            "function": "__get_any_page",
            "description": "mm memory failure safely get reference count of an arbitrary page return for free page eio for zero refcount page that is not free and for any other page type for the page is returned with increased page count otherwise not"
        },
        "split_vma": {
            "ground_truth": "0",
            "function": "split_vma",
            "description": "split vma into two piece at address addr new vma is allocated either for the first part or the tail"
        },
        "freelist_dereference": {
            "ground_truth": "0",
            "function": "freelist_dereference",
            "description": "mm slub return the freelist pointer recorded at location ptr addr"
        },
        "pte_unmap_same": {
            "ground_truth": "0",
            "function": "pte_unmap_same",
            "description": "mm memory handle pte fault chooses page fault handler according to an entry which wa read non atomically before making any commitment on those architecture or configuration i386 with pae which might give mix of unmatched part do swap page must check under lock before unmapping the pte and proceeding but do wp page is only called after already making such check and do anonymous page can safely check later on"
        },
        "__set_page_dirty_nobuffers": {
            "ground_truth": "0",
            "function": "__set_page_dirty_nobuffers",
            "description": "mm page writeback for address space which do not use buffer just tag the page a dirty in the xarray this is also used when single buffer is being dirtied we want to set the page dirty in that case but not all the buffer this is bottom up dirtying whereas set page dirty buffer is top down dirtying the caller must ensure this doe not race with truncation most will simply hold the page lock but zap pte range call with the page mapped and the pte lock held which also lock out truncation"
        },
        "zs_can_compact": {
            "ground_truth": "0",
            "function": "zs_can_compact",
            "description": "mm zsmalloc based on the number of unused allocated object calculate and return the number of page that we can free"
        },
        "constrained_alloc": {
            "ground_truth": "0",
            "function": "constrained_alloc",
            "description": "mm oom kill determine the type of allocation constraint"
        },
        "get_info_end": {
            "ground_truth": "0",
            "function": "get_info_end",
            "description": "mm slub return offset of the end of info block which is inuse free pointer if not overlapping with object"
        },
        "__skb_fill_page_desc": {
            "ground_truth": "0",
            "function": "__skb_fill_page_desc",
            "description": "include linux skbuff initialise paged fragment in an skb initialises the noth fragment of skb to point to type size byte at offset off within page doe not take any additional reference on the fragment struct sk buff skb buffer containing fragment to be initialised int paged fragment index to initialise struct page page the page to use for this fragment int off the offset to the data with page int size the length of the data"
        },
        "memcg_check_events": {
            "ground_truth": "0",
            "function": "memcg_check_events",
            "description": "mm memcontrol check event in order"
        },
        "percpu_enable_async": {
            "ground_truth": "0",
            "function": "percpu_enable_async",
            "description": "mm percpu percpu allocator is initialized early during boot when neither slab or workqueue is available plug async management until everything is up and running"
        },
        "fallback_migrate_page": {
            "ground_truth": "0",
            "function": "fallback_migrate_page",
            "description": "default handling if filesystem doe not provide migration function"
        },
        "shmem_swapin_page": {
            "ground_truth": "0",
            "function": "shmem_swapin_page",
            "description": "mm shmem swap in the page pointed to by pagep caller ha to make sure that pagep contains valid swapped page return and the page in pagep if success on failure return the error code and null in pagep"
        },
        "shrink_all_memory": {
            "ground_truth": "0",
            "function": "shrink_all_memory",
            "description": "mm vmscan try to free nr to reclaim of memory system wide and return the number of freed page rather than trying to age lrus the aim is to preserve the overall lru order by reclaiming preferentially inactive active active referenced active mapped"
        },
        "__audit_log_capset": {
            "ground_truth": "0",
            "function": "__audit_log_capset",
            "description": "kernel auditsc store information about the argument to the capset syscall record the argument userspace sent to sys capset for later printing by the audit system if applicable const struct cred new the new credential const struct cred old the old current credential"
        },
        "__munlock_pagevec_fill": {
            "ground_truth": "0",
            "function": "__munlock_pagevec_fill",
            "description": "fill up pagevec for munlock pagevec using pte walk the function expects that the struct page corresponding to start address is non tph page already pinned and in the pvec and that it belongs to zone the rest of pvec is filled by subsequent page within the same pmd and same zone a long a the pte is are present and vm normal page succeeds these page also get pinned return the address of the next page that should be scanned this equal start page size when no page could be added by the pte walk"
        },
        "verify_signature": {
            "ground_truth": "0",
            "function": "verify_signature",
            "description": "crypto asymmetric key signature initiate the use of an asymmetric key to verify signature return if successful or else an error const struct key key the asymmetric key to verify against const struct public key signature sig the signature to check"
        },
        "object_no_scan": {
            "ground_truth": "0",
            "function": "object_no_scan",
            "description": "mm kmemleak set the object no scan flag for the object corresponding to the give pointer such object will not be scanned by kmemleak but reference to it are searched"
        },
        "enable_tx_irq": {
            "ground_truth": "0",
            "function": "enable_tx_irq",
            "description": "begin manual entry if func others void enable tx irq smc queue struct smc smc short queue function downcall smt fplustm enable tx irq enables the formacs transmit complete interrupt of the queue para queue queue synchronous queue queue a0 asynchronous queue note after any ring operational change the transmit complete interrupt are disabled the operating system dependent module must enable the transmit complete interrupt of queue when it queue the first frame because of no transmit resource are beeing available and when it escape from the function llc restart tx while some frame are still queued end manual entry"
        },
        "try_to_merge_one_page": {
            "ground_truth": "0",
            "function": "try_to_merge_one_page",
            "description": "mm ksm try to merge one page take two page and merge them into one or null the first time when we want to use page a kpage this function return if the page were merged efault otherwise vma the vma that hold the pte pointing to page page the pageanon page that we want to replace with kpage kpage the pageksm page that we want to map instead of page"
        },
        "rmap_walk_anon": {
            "ground_truth": "0",
            "function": "rmap_walk_anon",
            "description": "mm rmap rmap walk anon do something to anonymous page using the object based rmap method find all the mapping of page using the mapping pointer and the vma chain contained in the anon vma struct it point to when called from try to munlock the mmap lock of the mm containing the vma where the page wa found will be held for write so we will not recheck vm flag for that vma that should be ok because that vma should not be locked page the page to be handled rwc control variable according to each walk type"
        },
        "deactivate_slab": {
            "ground_truth": "0",
            "function": "deactivate_slab",
            "description": "mm slub remove the cpu slab"
        },
        "kasan_poison_vmalloc": {
            "ground_truth": "0",
            "function": "kasan_poison_vmalloc",
            "description": "include linux kasan poison the shadow for vmalloc region called a part of the freeing process at the time the region is freed"
        },
        "rio_std_route_get_entry": {
            "ground_truth": "0",
            "function": "rio_std_route_get_entry",
            "description": "driver rapidio rio read switch route table entry port number associated with specified destid using standard register defined in rio specification rev struct rio mport mport master port to issue transaction u16 destid destination id of the device u8 hopcount number of switch hop to the device u16 table routing table id global or port specific u16 route destid destid entry in the rt u8 route port returned destination port for specified destid"
        },
        "put_swap_page": {
            "ground_truth": "0",
            "function": "put_swap_page",
            "description": "include linux swap called after dropping swapcache to decrease refcnt to swap entry"
        },
        "unreferenced_object": {
            "ground_truth": "0",
            "function": "unreferenced_object",
            "description": "mm kmemleak object are considered unreferenced only if their color is white they have not be deleted and have minimum age to avoid false positive caused by pointer temporarily stored in cpu register"
        },
        "memblocks_present": {
            "ground_truth": "0",
            "function": "memblocks_present",
            "description": "mm sparse mark all memblocks a present using memory present this is convenience function that is useful to mark all of the system memory a present during initialization"
        },
        "shmem_rename2": {
            "ground_truth": "0",
            "function": "shmem_rename2",
            "description": "mm shmem the vfs layer already doe all the dentry stuff for rename we just have to decrement the usage count for the target if it exists so that the vfs layer correctly free is it when it get overwritten"
        },
        "add_nommu_region": {
            "ground_truth": "0",
            "function": "add_nommu_region",
            "description": "add region into the global tree"
        },
        "smp_snoop": {
            "ground_truth": "0",
            "function": "smp_snoop",
            "description": "driver infiniband hw mlx4 mad snoop sm mads for port info and key table set so we can synthesize lid change and key change event"
        },
        "find_va_links": {
            "ground_truth": "0",
            "function": "find_va_links",
            "description": "mm vmalloc this function return back address of parent node and it left or right link for further processing otherwise null is returned in that case all further step regarding inserting of conflicting overlap range have to be declined and actually considered a bug"
        },
        "drain_stock": {
            "ground_truth": "0",
            "function": "drain_stock",
            "description": "mm memcontrol return stock cached in percpu and reset cached information"
        },
        "kmalloc_slab": {
            "ground_truth": "0",
            "function": "kmalloc_slab",
            "description": "mm slab common find the kmem cache structure that serf given size of allocation"
        },
        "mm_find_pmd": {
            "ground_truth": "0",
            "function": "mm_find_pmd",
            "description": "mm rmap in mm rmap"
        },
        "__mcopy_atomic_hugetlb": {
            "ground_truth": "0",
            "function": "__mcopy_atomic_hugetlb",
            "description": "mm userfaultfd mcopy atomic processing for hugetlb vmas note that this routine is called with mmap lock held it will release mmap lock before returning"
        },
        "mempolicy_slab_node": {
            "ground_truth": "0",
            "function": "mempolicy_slab_node",
            "description": "depending on the memory policy provide node from which to allocate the next slab entry"
        },
        "kmem_cache_size": {
            "ground_truth": "0",
            "function": "kmem_cache_size",
            "description": "mm slab common determine the size of slab object"
        },
        "free_unmap_vmap_area": {
            "ground_truth": "0",
            "function": "free_unmap_vmap_area",
            "description": "mm vmalloc free and unmap vmap area"
        },
        "zone_spanned_pages_in_node": {
            "ground_truth": "0",
            "function": "zone_spanned_pages_in_node",
            "description": "mm page alloc return the number of page zone span in node including hole present page zone spanned page in node zone absent page in node"
        },
        "mempool_alloc_pages": {
            "ground_truth": "0",
            "function": "mempool_alloc_pages",
            "description": "mm mempool simple mempool backed page allocator that allocates page of the order specified by pool data"
        },
        "setup_command_line": {
            "ground_truth": "0",
            "function": "setup_command_line",
            "description": "init main we need to store the untouched command line for future reference we also need to store the touched command line since the parameter parsing is performed in place and we should allow component to store reference of name value for future reference"
        },
        "pageout": {
            "ground_truth": "0",
            "function": "pageout",
            "description": "mm vmscan pageout is called by shrink page list for each dirty page call writepage"
        },
        "hugepage_subpool_get_pages": {
            "ground_truth": "0",
            "function": "hugepage_subpool_get_pages",
            "description": "mm hugetlb subpool accounting for allocating and reserving page return enomem if there are not enough resource to satisfy the request otherwise return the number of page by which the global pool must be adjusted upward the returned value may only be different than the passed value delta in the case where subpool minimum size must be maintained"
        },
        "kmem_cache_free_bulk": {
            "ground_truth": "0",
            "function": "kmem_cache_free_bulk",
            "description": "mm slub note that interrupt must be enabled when calling this function"
        },
        "pcpu_region_overlap": {
            "ground_truth": "0",
            "function": "pcpu_region_overlap",
            "description": "mm percpu pcpu region overlap determines if two region overlap this is used to determine if the hint region overlap with the allocated region start of first region inclusive end of first region exclusive start of second region inclusive end of second region exclusive"
        },
        "slab_map_pages": {
            "ground_truth": "0",
            "function": "slab_map_pages",
            "description": "mm slab map page beginning at addr to the given cache and slab this is required for the slab allocator to be able to lookup the cache and slab of virtual address for kfree ksize and slab debugging"
        },
        "__late_set_fixmap": {
            "ground_truth": "0",
            "function": "__late_set_fixmap",
            "description": "mm early ioremap generally ioremap is available after paging init ha been called architecture wanting to allow early ioremap after paging init can define late set fixmap and late clear fixmap to do the right thing"
        },
        "remove_mapping": {
            "ground_truth": "0",
            "function": "remove_mapping",
            "description": "mm vmscan attempt to detach locked page from it mapping if it is dirty or if someone else ha ref on the page abort and return if it wa successfully detached return assumes the caller ha single ref on this page"
        },
        "drain_local_pages": {
            "ground_truth": "0",
            "function": "drain_local_pages",
            "description": "mm page alloc spill all of this cpu is per cpu page back into the buddy allocator the cpu ha to be pinned when zone parameter is non null spill just the single zone is page"
        },
        "kmem_freepages": {
            "ground_truth": "0",
            "function": "kmem_freepages",
            "description": "mm slab interface to system is page release"
        },
        "__pmd_alloc": {
            "ground_truth": "0",
            "function": "__pmd_alloc",
            "description": "include linux mm allocate page middle directory we have already handled the fast path in line"
        },
        "get_object": {
            "ground_truth": "0",
            "function": "get_object",
            "description": "mm kmemleak increment the object use count return if successful or otherwise note that once an object is use count reached the rcu freeing wa already registered and the object should no longer be used this function must be called under the protection of rcu read lock"
        },
        "tower_check_for_read_packet": {
            "ground_truth": "0",
            "function": "tower_check_for_read_packet",
            "description": "driver usb misc legousbtower tower check for read packet to get correct semantics for signal and non blocking with packetizing we pretend not to see any data in the read buffer until it ha been there unchanged for at least dev packet timeout jiffy or until the buffer is full"
        },
        "default_hugepagesz_setup": {
            "ground_truth": "0",
            "function": "default_hugepagesz_setup",
            "description": "mm hugetlb default hugepagesz command line input only one instance of default hugepagesz allowed on command line"
        },
        "PageHuge": {
            "ground_truth": "0",
            "function": "PageHuge",
            "description": "mm hugetlb pagehuge only return true for hugetlbfs page but not for normal or transparent huge page see the pagetranshuge documentation for more detail"
        },
        "build_zonelists": {
            "ground_truth": "0",
            "function": "build_zonelists",
            "description": "mm page alloc build zonelists ordered by zone and node within zone this result in conserving dma zone until all normal memory is exhausted but result in overflowing to remote node while memory may still exist in local dma zone"
        },
        "shmem_initxattrs": {
            "ground_truth": "0",
            "function": "shmem_initxattrs",
            "description": "mm shmem callback for security inode init security for acquiring xattrs"
        },
        "filler": {
            "ground_truth": "0",
            "function": "filler",
            "description": "read cache page populate an address space with some page start read against them page have their index populated and are otherwise uninitialised hide the detail of the lru cache etc from the filesystems mapping the address space page the address of list head which contains the target page these filler callback routine for filling single page data private data for the callback routine return on success error return by filler otherwise"
        },
        "page_frag_free": {
            "ground_truth": "0",
            "function": "page_frag_free",
            "description": "mm page alloc free page fragment allocated out of either compound or order page"
        },
        "stable_tree_insert": {
            "ground_truth": "0",
            "function": "stable_tree_insert",
            "description": "mm ksm stable tree insert insert stable tree node pointing to new ksm page into the stable tree this function return the stable tree node just allocated on success null otherwise"
        },
        "refresh_zone_stat_thresholds": {
            "ground_truth": "0",
            "function": "refresh_zone_stat_thresholds",
            "description": "include linux vmstat refresh the threshold for each zone"
        },
        "kmemleak_disable": {
            "ground_truth": "0",
            "function": "kmemleak_disable",
            "description": "mm kmemleak disable kmemleak no memory allocation freeing will be traced once this function is called disabling kmemleak is an irreversible operation"
        },
        "free_page_and_swap_cache": {
            "ground_truth": "0",
            "function": "free_page_and_swap_cache",
            "description": "mm swap state perform free page also freeing any swap cache associated with this page if it is the last user of the page"
        },
        "frontswap_tmem_exclusive_gets": {
            "ground_truth": "0",
            "function": "frontswap_tmem_exclusive_gets",
            "description": "mm frontswap enable disable frontswap exclusive get see above"
        },
        "pos_ratio_polynom": {
            "ground_truth": "0",
            "function": "pos_ratio_polynom",
            "description": "mm page writeback setpoint dirty dirty limit setpoint it is 3rd order polynomial that subject to freerun rampup dirty ratelimit reasonably fast setpoint the balance point limit the hard limit df dx negative feedback control the closer to setpoint the smaller df dx and the reverse fast response on large error small oscillation near setpoint"
        },
        "__do_fault": {
            "ground_truth": "0",
            "function": "__do_fault",
            "description": "mm memory the mmap lock must have been held on entry and may have been released depending on flag and vma vm ops fault return value see filemap fault and lock page retry"
        },
        "vm_normal_page": {
            "ground_truth": "0",
            "function": "vm_normal_page",
            "description": "mm memory vm normal page this function get the struct page associated with pte special mapping do not wish to be associated with struct page either it doe not exist or it exists but they do not want to touch it in this case null is returned here normal mapping do have struct page there are broad case firstly an architecture may define pte special pte bit in which case this function is trivial secondly an architecture may not have spare pte bit which requires more complicated scheme described below raw vm pfnmap mapping ie one that is not cowed is always considered special mapping even if there are underlying and valid struct page cowed page of vm pfnmap are always normal the way we recognize cowed page within vm pfnmap mapping is through the rule set up by remap pfn range the vma will have the vm pfnmap bit set and the vm pgoff will point to the first pfn mapped thus every special mapping will always honor the rule pfn of page vma vm pgoff addr vma vm start page shift and for normal mapping this is false this restricts such mapping to be linear translation from virtual address to pfn to get around this restriction we allow arbitrary mapping so long a the vma is not cow mapping in that case we know that all ptes are special because none can have been cowed in order to support cow of arbitrary special mapping we have vm mixedmap vm mixedmap mapping can likewise contain memory with or without struct page backing however the difference is that all page with struct page that is those where pfn valid is true are refcounted and considered normal page by the vm the disadvantage is that page are refcounted which can be slower and simply not an option for some pfnmap user the advantage is that we do not have to follow the strict linearity rule of pfnmap mapping in order to support cowable mapping"
        },
        "xbc_make_cmdline": {
            "ground_truth": "0",
            "function": "xbc_make_cmdline",
            "description": "init main make an extra command line under given key word"
        },
        "madvise_dontneed_single_vma": {
            "ground_truth": "0",
            "function": "madvise_dontneed_single_vma",
            "description": "application no longer need these page if the page are dirty it is ok to just throw them away the app will be more careful about data it want to keep be sure to free swap resource too the zap page range call set thing up for shrink active list to actually free these page later if no one else ha touched them in the meantime although we could add these page to global reuse list for shrink active list to pick up before reclaiming other page nb this interface discard data rather than push it out to swap a some implementation do this ha performance implication for application like large transactional database which want to discard page in anonymous map after committing to backing store the data that wa kept in them there is no reason to write this data out to the swap area if the application is discarding it an interface that cause the system to free clean page and flush dirty page is already available a msync m invalidate"
        },
        "mem_map_offset": {
            "ground_truth": "0",
            "function": "mem_map_offset",
            "description": "mm internal return the mem map entry representing the offset subpage within the maximally aligned gigantic page base handle any discontiguity in the mem map at max order nr page boundary"
        },
        "try_online_node": {
            "ground_truth": "0",
            "function": "try_online_node",
            "description": "include linux memory hotplug user of this function always want to online register the node"
        },
        "__munlock_pagevec": {
            "ground_truth": "0",
            "function": "__munlock_pagevec",
            "description": "munlock batch of page from the same zone the work is split to two main phase first phase clear the mlocked flag and attempt to isolate the page all under single zone lru lock the second phase finish the munlock only for page where isolation succeeded note that the pagevec may be modified during the process"
        },
        "hugepage_add_anon_rmap": {
            "ground_truth": "0",
            "function": "hugepage_add_anon_rmap",
            "description": "mm rmap the following two function are for anonymous private mapped hugepages unlike common anonymous page anonymous hugepages have no accounting code and no lru code because we handle hugepages differently from common page"
        },
        "NFP_CPP_INTERFACE": {
            "ground_truth": "0",
            "function": "NFP_CPP_INTERFACE",
            "description": "construct bit nfp interface id interface id consists of bit of interface type bit of unit identifier and bit of channel identifier the nfp interface id is used in the implementation of nfp cpp api mutexes which use the mu atomic compareandwrite operation hence the limit to bit to be able to use the nfp interface id a lock owner type nfp interface type unit unit identifier for the interface type channel channel identifier for the interface unit interface id"
        },
        "__soft_offline_page": {
            "ground_truth": "0",
            "function": "__soft_offline_page",
            "description": "mm memory failure soft offline page handle hugetlb page and non hugetlb page if the page is non dirty unmapped page cache page it simply invalidates if the page is mapped it migrates the content over"
        },
        "add_page_for_migration": {
            "ground_truth": "0",
            "function": "add_page_for_migration",
            "description": "resolve the given address to struct page isolates it from the lru and put it to the given pagelist return errno if the page cannot be found isolated when it doe not have to be migrated because it is already on the target node when it ha been queued"
        },
        "swap_shmem_alloc": {
            "ground_truth": "0",
            "function": "swap_shmem_alloc",
            "description": "include linux swap help swapoff by noting that swap entry belongs to shmem tmpfs in which case it reference count is never incremented"
        },
        "memremap_compat_align": {
            "ground_truth": "0",
            "function": "memremap_compat_align",
            "description": "include linux memremap the memremap and memremap page interface are alternately used to map persistent memory namespaces these interface place different constraint on the alignment and size of the mapping namespace memremap can map individual page size page memremap page can only map subsection 2mb and at least one architecture powerpc the minimum mapping granularity of memremap page is 16mb the role of memremap compat align is to communicate the minimum arch supported alignment of namespace such that it can freely switch mode without violating the arch constraint namely do not allow namespace to be page size aligned since that namespace may be reconfigured into mode that requires subsection size alignment"
        },
        "cmdline_parse_kernelcore": {
            "ground_truth": "0",
            "function": "cmdline_parse_kernelcore",
            "description": "mm page alloc kernelcore size set the amount of memory for use for allocation that cannot be reclaimed or migrated"
        },
        "__copy_gigantic_page": {
            "ground_truth": "0",
            "function": "__copy_gigantic_page",
            "description": "gigantic page are so large that we do not guarantee that page pointer arithmetic will work across the entire page we need something more specialized"
        },
        "gup_get_pte": {
            "ground_truth": "0",
            "function": "gup_get_pte",
            "description": "mm gup warning only to be used in the get user page fast implementation with get user page fast we walk down the pagetables without taking any lock for this we would like to load the pointer atomically but sometimes that is not possible without expensive cmpxchg8b on x86 pae what we do have is the guarantee that pte will only either go from not present to present or present to not present or both it will not switch to completely different present page without tlb flush in between something that we are blocking by holding interrupt off setting ptes from not present to present go ptep pte high smp wmb ptep pte low and present to not present go ptep pte low smp wmb ptep pte high we must ensure here that the load of pte low see iff pte high see we load pte high after loading pte low which ensures we do not see an older value of pte high then we recheck pte low which ensures that we have not picked up changed pte high we might have gotten rubbish value from pte low and pte high but we are guaranteed that pte low will not have the present bit set unless it is because get user page fast only operates on present ptes we are safe"
        },
        "ksm_test_exit": {
            "ground_truth": "0",
            "function": "ksm_test_exit",
            "description": "mm ksm ksmd and unmerge and remove all rmap item must not touch an mm is page table after it ha passed through ksm exit which if necessary take mmap lock briefly to serialize against them ksm exit doe not set special flag they can just back out a soon a mm user go to zero ksm test exit is used throughout to make this test for exit in some place for correctness in some place just to avoid unnecessary work"
        },
        "shm_destroy": {
            "ground_truth": "0",
            "function": "shm_destroy",
            "description": "shm destroy free the struct shmid kernel it ha to be called with shp and shm id rwsem writer locked but return with shp unlocked and freed n namespace shp struct to free"
        },
        "tegra20_das_connect_dap_to_dap": {
            "ground_truth": "0",
            "function": "tegra20_das_connect_dap_to_dap",
            "description": "sound soc tegra tegra20 da connect dap to another dap dap id dap to connect tegra20 da dap id other dap sel dap to connect to tegra20 da dap sel dap master is this dap the master or slave sdata1rx is this dap is sdata1 pin rx or tx sdata2rx is this dap is sdata2 pin rx or tx"
        },
        "find_vma": {
            "ground_truth": "0",
            "function": "find_vma",
            "description": "look up the first vma in which addr resides null if none should be called with mm mmap lock at least held readlocked"
        },
        "pagetypeinfo_show": {
            "ground_truth": "0",
            "function": "pagetypeinfo_show",
            "description": "mm vmstat this print out statistic in relation to grouping page by mobility it is expensive to collect so do not constantly read the file"
        },
        "optimal_redzone": {
            "ground_truth": "0",
            "function": "optimal_redzone",
            "description": "mm kasan common adaptive redzone policy taken from the userspace addresssanitizer runtime for larger allocation larger redzones are used"
        },
        "cvmx_pko_rate_limit_bits": {
            "ground_truth": "0",
            "function": "cvmx_pko_rate_limit_bits",
            "description": "arch mips cavium octeon executive cvmx pko supported on cn57xx cn56xx cn55xx and cn54xx return zero on success negative on failure int port port to rate limit uint64 bit pko rate limit in bit sec int burst maximum number of bit to burst before rate limiting cut in"
        },
        "memory_is_poisoned_1": {
            "ground_truth": "0",
            "function": "memory_is_poisoned_1",
            "description": "mm kasan generic all function below always inlined so compiler could perform better optimization in each of asan loadx assn storex depending on memory access size"
        },
        "reserve_mem_notifier": {
            "ground_truth": "0",
            "function": "reserve_mem_notifier",
            "description": "reinititalise user and admin reserve if memory is added or removed the default user reserve max is 128mb and the default max for the admin reserve is 8mb these are usually but not always enough to enable recovery from memory hogging process using login sshd shell and tool like top it may make sense to increase or even disable the reserve depending on the existence of swap or variation in the recovery tool so the admin may have changed them if memory is added and the reserve have been eliminated or increased above the default max then we will trust the admin if memory is removed and there is not enough free memory then we need to reset the reserve otherwise keep the reserve set by the admin"
        },
        "shake_page": {
            "ground_truth": "0",
            "function": "shake_page",
            "description": "mm memory failure when unknown page type is encountered drain a many buffer a possible in the hope to turn the page into lru or free page which we can handle"
        },
        "free_pcppages_bulk": {
            "ground_truth": "0",
            "function": "free_pcppages_bulk",
            "description": "mm page alloc free number of page from the pcp list assumes all page on list are in same zone and of same order count is the number of page to free if the zone wa previously in an all page pinned state then look to see if this freeing clear that state and clear the zone is page scanned counter to hold off the all page are pinned detection logic"
        },
        "aa_lookupn_profile": {
            "ground_truth": "0",
            "function": "aa_lookupn_profile",
            "description": "security apparmor policy find profile by it full or partial name struct aa n n the namespace to start from not null const char hname name to do lookup on doe not contain namespace prefix not null size size of hname refcounted profile or null if not found"
        },
        "inc_zspage_isolation": {
            "ground_truth": "0",
            "function": "inc_zspage_isolation",
            "description": "mm zsmalloc number of isolated subpage for page migration in this zspage"
        },
        "frontswap_writethrough": {
            "ground_truth": "0",
            "function": "frontswap_writethrough",
            "description": "mm frontswap enable disable frontswap writethrough see above"
        },
        "free_partial": {
            "ground_truth": "0",
            "function": "free_partial",
            "description": "mm slub attempt to free all partial slab on node this is called from kmem cache shutdown we must take list lock because sysfs file might still access partial list after the shutdowning"
        },
        "init_cma_reserved_pageblock": {
            "ground_truth": "0",
            "function": "init_cma_reserved_pageblock",
            "description": "mm page alloc free whole pageblock and set it migration type to migrate cma"
        },
        "do_pages_stat_array": {
            "ground_truth": "0",
            "function": "do_pages_stat_array",
            "description": "determine the node of an array of page and store it in an array of status"
        },
        "get_user_pages_unlocked": {
            "ground_truth": "0",
            "function": "get_user_pages_unlocked",
            "description": "mm gup get user page unlocked is suitable to replace the form mmap read lock mm get user page mm page null mmap read unlock mm with get user page unlocked mm page it is functionally equivalent to get user page fast so get user page fast should be used instead if specific gup flag foll force are not required"
        },
        "find_suitable_fallback": {
            "ground_truth": "0",
            "function": "find_suitable_fallback",
            "description": "mm page alloc check whether there is suitable fallback freepage with requested order if only stealable is true this function return fallback mt only if we can steal other freepages all together this would help to reduce fragmentation due to mixed migratetype page in one pageblock"
        },
        "__absent_pages_in_range": {
            "ground_truth": "0",
            "function": "__absent_pages_in_range",
            "description": "mm page alloc return the number of hole in range on node if nid is max numnodes then all hole in the requested range will be accounted for"
        },
        "me_kernel": {
            "ground_truth": "0",
            "function": "me_kernel",
            "description": "mm memory failure error hit kernel page do nothing try to be lucky and not touch this instead for few case we could be more sophisticated"
        },
        "__do_kmalloc_node": {
            "ground_truth": "0",
            "function": "__do_kmalloc_node",
            "description": "mm slab end of slob allocator proper begin kmem cache alloc and kmalloc frontend"
        },
        "mem_pool_alloc": {
            "ground_truth": "0",
            "function": "mem_pool_alloc",
            "description": "mm kmemleak memory pool allocation and freeing kmemleak lock must not be held"
        },
        "cvmx_spi4000_check_speed": {
            "ground_truth": "0",
            "function": "cvmx_spi4000_check_speed",
            "description": "driver staging octeon octeon stub int interface interface the spi4000 is on int port port to poll return status of the port down all other value the port is up"
        },
        "mpol_free_shared_policy": {
            "ground_truth": "0",
            "function": "mpol_free_shared_policy",
            "description": "include linux mempolicy free backing policy store on inode delete"
        },
        "shmem_confirm_swap": {
            "ground_truth": "0",
            "function": "shmem_confirm_swap",
            "description": "mm shmem sometimes before we decide whether to proceed or to fail we must check that an entry wa not already brought back from swap by racing thread checking page is not enough by the time swapcache page is locked it might be reused and again be swapcache using the same swap a before"
        },
        "zswap_entry_get": {
            "ground_truth": "0",
            "function": "zswap_entry_get",
            "description": "mm zswap caller must hold the tree lock"
        },
        "object_set_excess_ref": {
            "ground_truth": "0",
            "function": "object_set_excess_ref",
            "description": "mm kmemleak any surplus reference object already gray to ptr are passed to excess ref this is used in the vmalloc case where pointer to vm struct may be used a an alternative reference to the vmalloc ed object see free thread stack"
        },
        "fc_lport_ptp_setup": {
            "ground_truth": "0",
            "function": "fc_lport_ptp_setup",
            "description": "driver scsi libfc fc lport create an rport for point to point mode struct fc lport lport the lport to attach the ptp rport to u32 remote fid the fid of the ptp rport u64 remote wwpn the wwpn of the ptp rport u64 remote wwnn the wwnn of the ptp rport"
        },
        "create_boot_cache": {
            "ground_truth": "0",
            "function": "create_boot_cache",
            "description": "mm slab common create cache during boot when no slab service are available yet"
        },
        "numa_policy_init": {
            "ground_truth": "0",
            "function": "numa_policy_init",
            "description": "include linux mempolicy assumes f kernel d"
        },
        "buddy_merge_likely": {
            "ground_truth": "0",
            "function": "buddy_merge_likely",
            "description": "mm page alloc if this is not the largest possible page check if the buddy of the next highest order is free if it is it is possible that page are being freed that will coalesce soon in case that is happening add the free page to the tail of the list so it is le likely to be used soon and more likely to be merged a higher order page"
        },
        "exit_sem": {
            "ground_truth": "0",
            "function": "exit_sem",
            "description": "include linux sem add semadj value to semaphore free undo structure undo structure are not freed when semaphore array are destroyed so some of them may be out of date implementation note there is some confusion over whether the set of adjustment that need to be done should be done in an atomic manner or not that is if we are attempting to decrement the semval should we queue up and wait until we can do so legally the original implementation attempted to do this queue and wait the current implementation doe not do so the posix standard and svid should be consulted to determine what behavior is mandated"
        },
        "gup_pte_range": {
            "ground_truth": "0",
            "function": "gup_pte_range",
            "description": "mm gup if we can not determine whether or not pte is special then fail immediately for ptes note we can still pin hugetlb and thp a these are guaranteed not to be special for futex to be placed on thp tail page get futex key requires get user page fast only implementation that can pin page thus it is still useful to have gup huge pmd even if we can not operate on ptes"
        },
        "cpu_exceeded": {
            "ground_truth": "0",
            "function": "cpu_exceeded",
            "description": "driver platform x86 intel ip check whether cpu core is outside it limit check given cpu is average temp or power is over it limit struct ip driver ip ip driver struct int cpu cpu number to check"
        },
        "truncate_cleanup_page": {
            "ground_truth": "0",
            "function": "truncate_cleanup_page",
            "description": "mm truncate if truncate cannot remove the f private metadata from the page the page becomes orphaned it will be left on the lru and may even be mapped into user pagetables if we are racing with filemap fault we need to bail out if page mapping is no longer equal to the original mapping this happens when the vm reclaimed the page while we waited on it lock when concurrent invalidate mapping page got there first and when tmpfs swizzle page between tmpfs inode and swapper space"
        },
        "__mod_zone_page_state": {
            "ground_truth": "0",
            "function": "__mod_zone_page_state",
            "description": "include linux vmstat for use when we know that interrupt are disabled or when we know that preemption is disabled and that particular counter cannot be updated from interrupt context"
        },
        "pcpu_next_hint": {
            "ground_truth": "0",
            "function": "pcpu_next_hint",
            "description": "mm percpu pcpu next hint determine which hint to use this determines if we should scan based on the scan hint or first free in general we want to scan from first free to fulfill allocation by first fit however if we know scan hint at position scan hint start cannot fulfill an allocation we can begin scanning from there knowing the contig hint will be our fallback block block of interest alloc bit size of allocation"
        },
        "zswap_free_entry": {
            "ground_truth": "0",
            "function": "zswap_free_entry",
            "description": "mm zswap carry out the common pattern of freeing and entry is zpool allocation freeing the entry itself and decrementing the number of stored page"
        },
        "chunk_map_stats": {
            "ground_truth": "0",
            "function": "chunk_map_stats",
            "description": "mm percpu stats print out chunk state fragmentation is considered between the beginning of the chunk to the last allocation all statistic are in byte unless stated otherwise"
        },
        "kmem_cache_debug_flags": {
            "ground_truth": "0",
            "function": "kmem_cache_debug_flags",
            "description": "mm slab return true if any of the specified slub debug flag is enabled for the cache use only for flag parsed by setup slub debug a it also enables the static key"
        },
        "zswap_frontswap_load": {
            "ground_truth": "0",
            "function": "zswap_frontswap_load",
            "description": "mm zswap return if the page wa successfully decompressed return on entry not found or error"
        },
        "disable_swap_slots_cache_lock": {
            "ground_truth": "0",
            "function": "disable_swap_slots_cache_lock",
            "description": "mm swap slot must not be called with cpu hot plug lock"
        },
        "smack_socket_getpeersec_stream": {
            "ground_truth": "0",
            "function": "smack_socket_getpeersec_stream",
            "description": "security smack smack lsm pull in packet label return zero on success an error code otherwise struct socket sock the socket char user optval user is destination int user optlen size thereof unsigned len max thereof"
        },
        "tty_dev_name_to_number": {
            "ground_truth": "3",
            "function": "tty_dev_name_to_number",
            "description": "include linux tty return dev for device name const char name user space name of device under dev dev number pointer to dev that this function will populate this function convert device name like ttys0 or ttyusb1 into dev like or if no corresponding driver is registered then the function return enodev locking this acquires tty mutex to protect the tty driver list from being modified while we are traversing it and make sure to release it before exiting"
        },
        "calculate_totalreserve_pages": {
            "ground_truth": "0",
            "function": "calculate_totalreserve_pages",
            "description": "mm page alloc calculate totalreserve page called when sysctl lowmem reserve ratio or min free kbytes change"
        },
        "__free_one_page": {
            "ground_truth": "0",
            "function": "__free_one_page",
            "description": "mm page alloc freeing function for buddy system allocator the concept of buddy system is to maintain direct mapped table containing bit value for memory block of various order the bottom level table contains the map for the smallest allocatable unit of memory here page and each level above it describes pair of unit from the level below hence buddy at high level all that happens here is marking the table entry at the bottom level available and propagating the change upward a necessary plus some accounting needed to play nicely with other part of the vm system at each level we keep list of page which are head of continuous free page of length of order and marked with pagebuddy page is order is recorded in page private page field so when we are allocating or freeing one we can derive the state of the other that is if we allocate small block and both were free the remainder of the region must be split into block if block is freed and it buddy is also free then this trigger coalescing into block of larger size nyc"
        },
        "count_swap_pages": {
            "ground_truth": "0",
            "function": "count_swap_pages",
            "description": "return either the total number of swap page of given type or the number of free page of that type depending on free this is needed for software suspend"
        },
        "try_purge_vmap_area_lazy": {
            "ground_truth": "0",
            "function": "try_purge_vmap_area_lazy",
            "description": "mm vmalloc kick off purge of the outstanding lazy area do not bother if somebody is already purging"
        },
        "do_shm_rmid": {
            "ground_truth": "0",
            "function": "do_shm_rmid",
            "description": "called with shm id rwsem writer and the shp structure locked only shm id rwsem remains locked on exit"
        },
        "check_pcp_refill": {
            "ground_truth": "0",
            "function": "check_pcp_refill",
            "description": "mm page alloc with debug vm enabled order page are checked for expected state when being allocated from pcp list with debug pagealloc also enabled they are also checked when pcp list are refilled from the free list"
        },
        "vmalloc_to_page": {
            "ground_truth": "0",
            "function": "vmalloc_to_page",
            "description": "mm vmalloc walk vmap address to the struct page it map"
        },
        "__munlock_isolated_page": {
            "ground_truth": "0",
            "function": "__munlock_isolated_page",
            "description": "finish munlock after successful page isolation page must be locked this is wrapper for try to munlock and putback lru page with munlock accounting"
        },
        "get_next_pkmap_nr": {
            "ground_truth": "0",
            "function": "get_next_pkmap_nr",
            "description": "arch xtensa include asm highmem get next index for mapping inside pkmap region for page with given color"
        },
        "remove_rmap_item_from_tree": {
            "ground_truth": "0",
            "function": "remove_rmap_item_from_tree",
            "description": "mm ksm removing rmap item from stable or unstable tree this function will clean the information from the stable unstable tree"
        },
        "kmemleak_scan_thread": {
            "ground_truth": "0",
            "function": "kmemleak_scan_thread",
            "description": "mm kmemleak thread function performing automatic memory scanning unreferenced object at the end of memory scan are reported but only the first time"
        },
        "__isolate_lru_page": {
            "ground_truth": "0",
            "function": "__isolate_lru_page",
            "description": "mm vmscan attempt to remove the specified page from it lru only take this page if it is of the appropriate pageactive status page which are being freed elsewhere are also ignored page page to consider mode one of the lru isolation mode defined above return on success ve errno on failure"
        },
        "shmctl_down": {
            "ground_truth": "0",
            "function": "shmctl_down",
            "description": "this function handle some shmctl command which require the rwsem to be held in write mode note no lock must be held the rwsem is taken inside this function"
        },
        "page_lock_anon_vma_read": {
            "ground_truth": "0",
            "function": "page_lock_anon_vma_read",
            "description": "mm rmap similar to page get anon vma except it lock the anon vma it little more complex a it try to keep the fast path to single atomic op the trylock if we fail the trylock we fall back to getting reference like with page get anon vma and then block on the mutex"
        },
        "find_usable_zone_for_movable": {
            "ground_truth": "0",
            "function": "find_usable_zone_for_movable",
            "description": "mm page alloc this find zone that can be used for zone movable page the assumption is made that zone within node are ordered in monotonic increasing memory address so that the highest populated zone is used"
        },
        "buf_assign": {
            "ground_truth": "0",
            "function": "buf_assign",
            "description": "tool testing selftests bpf progs test cl redirect return pointer to the start of buf or null if len is larger than the remaining data consumes len byte on successful call if scratch is not null the function will attempt to load non linear data via bpf skb load byte on success scratch is returned"
        },
        "file_ra_state_init": {
            "ground_truth": "0",
            "function": "file_ra_state_init",
            "description": "initialise struct file is readahead state assumes that the caller ha memset ra to zero"
        },
        "page_writeback_init": {
            "ground_truth": "0",
            "function": "page_writeback_init",
            "description": "mm page writeback called early on to tune the page writeback dirty limit we used to scale dirty page according to how total memory related to page that could be allocated for buffer however that wa when we used dirty ratio to scale with all memory and we do not do that any more dirty ratio is now applied to total non highpage memory and a such we can not get into the old insane situation any more where we had large amount of dirty page compared to small amount of non highmem memory but we might still want to scale the dirty ratio by how much memory the box ha"
        },
        "vm_remove_mappings": {
            "ground_truth": "0",
            "function": "vm_remove_mappings",
            "description": "mm vmalloc handle removing and resetting vm mapping related to the vm struct"
        },
        "__next_zones_zonelist": {
            "ground_truth": "0",
            "function": "__next_zones_zonelist",
            "description": "mm mmzone return the next zone at or below highest zoneidx in zonelist"
        },
        "vm_commit_limit": {
            "ground_truth": "0",
            "function": "vm_commit_limit",
            "description": "mm util committed memory limit enforced when overcommit never policy is used"
        },
        "num_free_chunks": {
            "ground_truth": "0",
            "function": "num_free_chunks",
            "description": "mm z3fold return the number of free chunk in zbud page"
        },
        "hugetlb_fix_reserve_counts": {
            "ground_truth": "0",
            "function": "hugetlb_fix_reserve_counts",
            "description": "mm hugetlb rare out of memory error wa encountered which prevented removal of the reserve map region for page the huge page itself wa free ed and removed from the page cache this routine will adjust the subpool usage count and the global reserve count if needed by incrementing these count the reserve map entry which could not be deleted will appear a reserved entry instead of simply dangling with incorrect count"
        },
        "__rmqueue_smallest": {
            "ground_truth": "0",
            "function": "__rmqueue_smallest",
            "description": "mm page alloc go through the free list for the given migratetype and remove the smallest available page from the freelists"
        },
        "scan_should_stop": {
            "ground_truth": "0",
            "function": "scan_should_stop",
            "description": "mm kmemleak memory scanning is long process and it need to be interruptable this function check whether such interrupt condition occurred"
        },
        "tpm_parse": {
            "ground_truth": "0",
            "function": "tpm_parse",
            "description": "crypto asymmetric key tpm parser parse tpm encrypted private key blob"
        },
        "color_white": {
            "ground_truth": "0",
            "function": "color_white",
            "description": "mm kmemleak object color encoded with count and min count white orphan object not enough reference to it count min count gray not orphan not marked a false positive min count or sufficient reference to it count min count black ignore it doe not contain reference text section min count no function defined for this color newly created object do not have any color assigned object count before the next memory scan when they become white"
        },
        "palmte2_udc_init": {
            "ground_truth": "0",
            "function": "palmte2_udc_init",
            "description": "arch arm mach pxa palmte2 setup udc gpios initial state"
        },
        "memblock_addrs_overlap": {
            "ground_truth": "0",
            "function": "memblock_addrs_overlap",
            "description": "mm memblock address comparison utility"
        },
        "node_match": {
            "ground_truth": "0",
            "function": "node_match",
            "description": "mm slub check if the object in per cpu structure fit numa locality expectation"
        },
        "bdi_remove_from_list": {
            "ground_truth": "0",
            "function": "bdi_remove_from_list",
            "description": "mm backing dev remove bdi from bdi list and ensure that it is no longer visible"
        },
        "memcg_exact_page_state": {
            "ground_truth": "0",
            "function": "memcg_exact_page_state",
            "description": "mm memcontrol idx can be of type enum memcg stat item or node stat item keep in sync with memcg exact page"
        },
        "mem_pool_free": {
            "ground_truth": "0",
            "function": "mem_pool_free",
            "description": "mm kmemleak return the object to either the slab allocator or the memory pool"
        },
        "sp_insert": {
            "ground_truth": "0",
            "function": "sp_insert",
            "description": "insert new shared policy into the list caller hold sp lock for writing"
        },
        "transfer_objects": {
            "ground_truth": "0",
            "function": "transfer_objects",
            "description": "mm slab transfer object in one arraycache to another locking must be handled by the caller return the number of entry transferred"
        },
        "migrate_page": {
            "ground_truth": "0",
            "function": "migrate_page",
            "description": "common logic to directly migrate single lru page suitable for page that do not use pageprivate page are locked upon entry and exit"
        },
        "cma_bitmap_aligned_offset": {
            "ground_truth": "0",
            "function": "cma_bitmap_aligned_offset",
            "description": "mm cma find the offset of the base pfn from the specified align order the value returned is represented in order per bit"
        },
        "kasan_poison_shadow": {
            "ground_truth": "0",
            "function": "kasan_poison_shadow",
            "description": "mm kasan common poison the shadow memory for isize byte starting from addr memory address should be aligned to kasan shadow scale size"
        },
        "hugetlb_vm_op_fault": {
            "ground_truth": "0",
            "function": "hugetlb_vm_op_fault",
            "description": "mm hugetlb we cannot handle pagefaults against hugetlb page at all they cause handle mm fault to try to instantiate regular sized page in the hugegpage vma do page fault is supposed to trap this so bug is we get this far"
        },
        "handle_pte_fault": {
            "ground_truth": "0",
            "function": "handle_pte_fault",
            "description": "mm memory these routine also need to handle stuff like marking page dirty and or accessed for architecture that do not do it in hardware most risc architecture the early dirtying is also good on the i386 there is also hook called update mmu cache that architecture with external mmu cache can use to update those ie the sparc or powerpc hashed page table that act a extended tlbs we enter with non exclusive mmap lock to exclude vma change but allow concurrent fault the mmap lock may have been released depending on flag and our return value see filemap fault and lock page or retry"
        },
        "ehv_bc_tty_throttle": {
            "ground_truth": "3",
            "function": "ehv_bc_tty_throttle",
            "description": "driver tty ehv bytechan stop sending data to the tty layer this function is called when the tty layer is input buffer are getting full so the driver should stop sending it data the easiest way to do this is to disable the rx irq which will prevent ehv bc tty rx isr from being called the hypervisor will continue to queue up any incoming data if there is any data in the queue when the rx interrupt is enabled we will immediately get an rx interrupt"
        },
        "madvise_inject_error": {
            "ground_truth": "0",
            "function": "madvise_inject_error",
            "description": "error injection support for memory error handling"
        },
        "shmem_free_swap": {
            "ground_truth": "0",
            "function": "shmem_free_swap",
            "description": "mm shmem remove swap entry from page cache free the swap and it page cache"
        },
        "__hugetlb_cgroup_commit_charge": {
            "ground_truth": "0",
            "function": "__hugetlb_cgroup_commit_charge",
            "description": "mm hugetlb cgroup should be called with hugetlb lock held"
        },
        "setup_slub_min_order": {
            "ground_truth": "0",
            "function": "setup_slub_min_order",
            "description": "mm slub kmalloc subsystem"
        },
        "zone_reclaimable_pages": {
            "ground_truth": "0",
            "function": "zone_reclaimable_pages",
            "description": "mm vmscan this miss isolated page which are not accounted for to save counter a the data only determines if reclaim or compaction continues it is not expected that isolated page will be dominating factor"
        },
        "SetPageHugeObject": {
            "ground_truth": "0",
            "function": "SetPageHugeObject",
            "description": "mm zsmalloc huge object page per zspage maxobj per zspage"
        },
        "wait_on_page_writeback": {
            "ground_truth": "0",
            "function": "wait_on_page_writeback",
            "description": "mm page writeback wait for page to complete writeback"
        },
        "trig_arg": {
            "ground_truth": "0",
            "function": "trig_arg",
            "description": "arch x86 math emu fpu trig limited measurement show no result worse than bit precision except for the result for argument close to where the precision of the result sometimes degrades to about bit"
        },
        "swap_writepage": {
            "ground_truth": "0",
            "function": "swap_writepage",
            "description": "include linux swap we may have stale swap cache page in memory notice them here and get rid of the unnecessary final write"
        },
        "shmem_getpage_gfp": {
            "ground_truth": "0",
            "function": "shmem_getpage_gfp",
            "description": "mm shmem shmem getpage gfp find page in cache or get from swap or allocate if we allocate new one we do not mark it dirty that is up to the vm if we swap it in we mark it dirty since we also free the swap entry since page cannot live in both the swap and page cache vmf and fault type are only supplied by shmem fault otherwise they are null"
        },
        "shmem_delete_from_page_cache": {
            "ground_truth": "0",
            "function": "shmem_delete_from_page_cache",
            "description": "mm shmem like delete from page cache but substitute swap for page"
        },
        "apply_to_page_range": {
            "ground_truth": "0",
            "function": "apply_to_page_range",
            "description": "mm memory scan region of virtual memory filling in page table a necessary and calling provided function on each leaf page table"
        },
        "zone_pcp_update": {
            "ground_truth": "0",
            "function": "zone_pcp_update",
            "description": "mm page alloc the zone indicated ha new number of managed page batch size and percpu page high value need to be recalulated"
        },
        "frag_show": {
            "ground_truth": "0",
            "function": "frag_show",
            "description": "mm vmstat this walk the free area for each zone"
        },
        "____cache_alloc_node": {
            "ground_truth": "0",
            "function": "____cache_alloc_node",
            "description": "mm slab interface to enable slab creation on nodeid"
        },
        "__kmem_cache_free_bulk": {
            "ground_truth": "0",
            "function": "__kmem_cache_free_bulk",
            "description": "mm slab common generic implementation of bulk operation these are useful for situation in which the allocator cannot perform optimization in that case segment of the object listed may be allocated or freed using these operation"
        },
        "__page_mapcount": {
            "ground_truth": "0",
            "function": "__page_mapcount",
            "description": "mm util slow path of page mapcount for compound page"
        },
        "kmemleak_seq_show": {
            "ground_truth": "0",
            "function": "kmemleak_seq_show",
            "description": "mm kmemleak print the information for an unreferenced object to the seq file"
        },
        "get_size_class_index": {
            "ground_truth": "0",
            "function": "get_size_class_index",
            "description": "mm zsmalloc zsmalloc divide the pool into various size class where each class maintains list of zspages where each zspage is divided into equal sized chunk each allocation fall into one of these class depending on it size this function return index of the size class which ha chunk size big enough to hold the give size"
        },
        "add_to_kill": {
            "ground_truth": "0",
            "function": "add_to_kill",
            "description": "mm memory failure schedule process for later kill us gfp atomic allocation to avoid potential recursion in the vm"
        },
        "add_swap_count_continuation": {
            "ground_truth": "0",
            "function": "add_swap_count_continuation",
            "description": "include linux swap add swap count continuation called when swap count is duplicated beyond swap map max it allocates new page and link that to the entry is page of the original vmalloc ed swap map to hold the continuation count for that entry and for it neighbouring page size swap entry called again when count is duplicated beyond swap map max swap cont max etc these continuation page are seldom referenced the common path all work on the original swap map only referring to continuation page when the low digit of count is incremented or decremented through swap map max add swap count continuation gfp atomic can be called while holding page table lock if it fails add swap count continuation gfp kernel can be called after dropping lock"
        },
        "page_mapping_file": {
            "ground_truth": "0",
            "function": "page_mapping_file",
            "description": "mm util for file cache page return the address space otherwise return null"
        },
        "fold_diff": {
            "ground_truth": "0",
            "function": "fold_diff",
            "description": "mm vmstat fold differential into the global counter return the number of counter updated"
        },
        "deactivate_page": {
            "ground_truth": "0",
            "function": "deactivate_page",
            "description": "mm swap deactivate page deactivate page deactivate page move page to the inactive list if page wa on the active list and wa not an unevictable page this is done to accelerate the reclaim of page page page to deactivate"
        },
        "get_file_region_entry_from_cache": {
            "ground_truth": "0",
            "function": "get_file_region_entry_from_cache",
            "description": "mm hugetlb helper that remove struct file region from the resv map cache and return it for use"
        },
        "kmemleak_seq_start": {
            "ground_truth": "0",
            "function": "kmemleak_seq_start",
            "description": "mm kmemleak iterate over the object list and return the first valid object at or after the required position with it use count incremented the function trigger memory scanning when the po argument point to the first position"
        },
        "__clear_shadow_entry": {
            "ground_truth": "0",
            "function": "__clear_shadow_entry",
            "description": "mm truncate regular page slot are stabilized by the page lock even without the tree itself locked these unlocked entry need verification under the tree lock"
        },
        "__add_partial": {
            "ground_truth": "0",
            "function": "__add_partial",
            "description": "mm slub management of partially allocated slab"
        },
        "has_unmovable_pages": {
            "ground_truth": "0",
            "function": "has_unmovable_pages",
            "description": "mm page alloc this function check whether pageblock includes unmovable page or not pagelru check without isolation or lru lock could race so that migrate movable block might include unmovable page and pagemovable check without lock page also may miss some movable non lru page at race condition so you can not expect this function should be exact return page without holding reference if the caller want to dereference that page dumping it ha to make sure that it cannot get removed via memory unplug concurrently"
        },
        "recv_skb": {
            "ground_truth": "0",
            "function": "recv_skb",
            "description": "session receive handler for data packet each pseudowire implementation should implement this callback in order to handle incoming packet packet are passed to the pseudowire handler after reordering if data sequence number are enabled for the session"
        },
        "__swap_duplicate": {
            "ground_truth": "0",
            "function": "__swap_duplicate",
            "description": "verify that swap entry is valid and increment it swap map count return error code in following case success swp entry is invalid einval swp entry is migration entry einval swap cache reference is requested but there is already one eexist swap cache reference is requested but the entry is not used enoent swap mapped reference requested but need continued swap count enomem"
        },
        "grab_cache_page_write_begin": {
            "ground_truth": "0",
            "function": "grab_cache_page_write_begin",
            "description": "mm filemap find or create page at the given pagecache position return the locked page this function is specifically for buffered writes"
        },
        "migrate_huge_page_move_mapping": {
            "ground_truth": "0",
            "function": "migrate_huge_page_move_mapping",
            "description": "include linux migrate the expected number of remaining reference is the same a that of migrate page move mapping"
        },
        "init_unavailable_range": {
            "ground_truth": "0",
            "function": "init_unavailable_range",
            "description": "mm page alloc initialize all valid struct page in the range spfn epfn and mark them pagereserved return the number of struct page that were initialized"
        },
        "put_nommu_region": {
            "ground_truth": "0",
            "function": "put_nommu_region",
            "description": "release reference to region"
        },
        "aligned_vread": {
            "ground_truth": "0",
            "function": "aligned_vread",
            "description": "mm vmalloc small helper routine copy content to buf from addr if the page is not present fill zero"
        },
        "vma_interval_tree_insert_after": {
            "ground_truth": "0",
            "function": "vma_interval_tree_insert_after",
            "description": "mm interval tree insert node immediately after prev in the interval tree"
        },
        "determine_vm_flags": {
            "ground_truth": "0",
            "function": "determine_vm_flags",
            "description": "we have determined that we can make the mapping now translate what we now know into vma flag"
        },
        "mem_cgroup_split_huge_fixup": {
            "ground_truth": "0",
            "function": "mem_cgroup_split_huge_fixup",
            "description": "include linux memcontrol because tail page are not marked a used set it we are under pgdat lru lock and migration entry setup in all page mapping"
        },
        "shmem_writepage": {
            "ground_truth": "0",
            "function": "shmem_writepage",
            "description": "mm shmem move the page from the page cache to the swap cache"
        },
        "slabs_node": {
            "ground_truth": "0",
            "function": "slabs_node",
            "description": "mm slub tracking of the number of slab for debugging purpose"
        },
        "get_slabinfo": {
            "ground_truth": "0",
            "function": "get_slabinfo",
            "description": "mm slub the proc slabinfo abi"
        },
        "vma_set_page_prot": {
            "ground_truth": "0",
            "function": "vma_set_page_prot",
            "description": "include linux mm update vma vm page prot to reflect vma vm flag"
        },
        "node_page_state_pages": {
            "ground_truth": "0",
            "function": "node_page_state_pages",
            "description": "mm vmstat determine the per node value of stat item"
        },
        "swap_setup": {
            "ground_truth": "0",
            "function": "swap_setup",
            "description": "mm swap perform any setup for the swap system"
        },
        "nfsdfs_remove_file": {
            "ground_truth": "0",
            "function": "nfsdfs_remove_file",
            "description": "f nfsd nfsctl from rpc unlink"
        },
        "mem_cgroup_get_max": {
            "ground_truth": "0",
            "function": "mem_cgroup_get_max",
            "description": "include linux memcontrol return the memory and swap if configured limit for memcg"
        },
        "copy_present_pte": {
            "ground_truth": "0",
            "function": "copy_present_pte",
            "description": "mm memory copy one pte return if succeeded or eagain if one preallocated page is required to copy this pte"
        },
        "page_rmapping": {
            "ground_truth": "0",
            "function": "page_rmapping",
            "description": "mm util neutral page mapping pointer to address space or anon vma or other"
        },
        "pin_user_pages_unlocked": {
            "ground_truth": "0",
            "function": "pin_user_pages_unlocked",
            "description": "mm gup pin user page unlocked is the foll pin variant of get user page unlocked behavior is the same except that this one set foll pin and reject foll get"
        },
        "deferred_grow_zone": {
            "ground_truth": "0",
            "function": "deferred_grow_zone",
            "description": "mm page alloc if this zone ha deferred page try to grow it by initializing enough deferred page to satisfy the allocation specified by order rounded up to the nearest page per section boundary so we are adding memory in increment of section size byte by initializing struct page in increment of page per section sizeof struct page byte return true when zone wa grown otherwise return false we return true even when we grow le than requested to let the caller decide if there are enough page to satisfy the allocation note we use noinline because this function is needed only during boot and it is called from ref function deferred grow zone this way we are making sure that it is not inlined into permanent text section"
        },
        "do_mremap": {
            "ground_truth": "0",
            "function": "do_mremap",
            "description": "expand or shrink an existing mapping potentially moving it at the same time controlled by the mremap maymove flag and available vm space under nommu condition we only permit changing mapping is size and only a long a it stay within the region allocated by do mmap private and the block is not shareable mremap fixed is not supported under nommu condition"
        },
        "shm_try_destroy_orphaned": {
            "ground_truth": "0",
            "function": "shm_try_destroy_orphaned",
            "description": "called with n shm id n rwsem locked"
        },
        "acct_stack_growth": {
            "ground_truth": "0",
            "function": "acct_stack_growth",
            "description": "verify that the stack growth is acceptable and update accounting this is shared with both the grow up and grow down case"
        },
        "do_slab_free": {
            "ground_truth": "0",
            "function": "do_slab_free",
            "description": "mm slub fastpath with forced inlining to produce kfree and kmem cache free that can perform fastpath freeing without additional function call the fastpath is only possible if we are freeing to the current cpu slab of this processor this typically the case if we have just allocated the item before if fastpath is not possible then fall back to slab free where we deal with all sort of special processing bulk free of freelist with several object all pointing to the same page possible by specifying head and tail ptr plus object count cnt bulk free indicated by tail pointer being set"
        },
        "kmalloc_large_node_hook": {
            "ground_truth": "0",
            "function": "kmalloc_large_node_hook",
            "description": "mm slub hook for other subsystem that check memory allocation in typical production configuration these hook all should produce no code at all"
        },
        "max98095_lineout_event": {
            "ground_truth": "0",
            "function": "max98095_lineout_event",
            "description": "sound soc codecs max98095 the stereo line out mixer output to two stereo line out the 2nd pair ha separate set of enables"
        },
        "slob_next": {
            "ground_truth": "0",
            "function": "slob_next",
            "description": "mm slob return the next free slob block pointer after this one"
        },
        "kswapd": {
            "ground_truth": "0",
            "function": "kswapd",
            "description": "mm vmscan the background pageout daemon started a kernel thread from the init process this basically trickle out page so that we have some free memory available even if there is no other activity that free anything up this is needed for thing like routing etc where we otherwise might have all activity going on in asynchronous context that cannot page thing out if there are application that are active memory allocator most normal use this basically should not matter"
        },
        "unfreeze_partials": {
            "ground_truth": "0",
            "function": "unfreeze_partials",
            "description": "mm slub unfreeze all the cpu partial slab this function must be called with interrupt disabled for the cpu using or some other guarantee must be there to guarantee no concurrent access"
        },
        "deferred_free_pages": {
            "ground_truth": "0",
            "function": "deferred_free_pages",
            "description": "mm page alloc free page to buddy allocator try to free aligned page in pageblock nr page size"
        },
        "zero_global_numa_counters": {
            "ground_truth": "0",
            "function": "zero_global_numa_counters",
            "description": "mm vmstat zero global numa counter"
        },
        "early_memremap": {
            "ground_truth": "0",
            "function": "early_memremap",
            "description": "mm early ioremap remap memory"
        },
        "__try_to_reclaim_swap": {
            "ground_truth": "0",
            "function": "__try_to_reclaim_swap",
            "description": "return if swap entry is freed"
        },
        "pcpu_stats_chunk_dealloc": {
            "ground_truth": "0",
            "function": "pcpu_stats_chunk_dealloc",
            "description": "mm percpu internal pcpu stats chunk dealloc decrement chunk stats"
        },
        "adjust_zone_range_for_zone_movable": {
            "ground_truth": "0",
            "function": "adjust_zone_range_for_zone_movable",
            "description": "mm page alloc the zone range provided by the architecture do not include zone movable because it is sized independent of architecture unlike the other zone the starting point for zone movable is not fixed it may be different in each node depending on the size of each node and how evenly kernelcore is distributed this helper function adjusts the zone range provided by the architecture for given node by using the end of the highest usable zone for zone movable this preserve the assumption that zone within node are in order of monotonic increase memory address"
        },
        "rpc_cmp_addr": {
            "ground_truth": "0",
            "function": "rpc_cmp_addr",
            "description": "include linux sunrpc addr compare the address portion of two sockaddrs just compare the family and address portion ignores port but compare the scope if it is link local address return true if the addrs are equal false if they are not const struct sockaddr sap1 first sockaddr const struct sockaddr sap2 second sockaddr"
        },
        "fcoe_ctlr_vn_lookup": {
            "ground_truth": "0",
            "function": "fcoe_ctlr_vn_lookup",
            "description": "driver scsi fcoe fcoe ctlr find vn remote port is mac address return non zero error if no remote port found struct fcoe ctlr fip the fcoe controller u32 port id the port id of the remote vn node u8 mac buffer which will hold the vn node destination mac address if found"
        },
        "mem_cgroup_flush_foreign": {
            "ground_truth": "0",
            "function": "mem_cgroup_flush_foreign",
            "description": "include linux memcontrol issue foreign writeback flush for recorded foreign dirtying event"
        },
        "zs_stat_get": {
            "ground_truth": "0",
            "function": "zs_stat_get",
            "description": "mm zsmalloc type can be of enum type z stat type or fullness group"
        },
        "__page_reporting_request": {
            "ground_truth": "0",
            "function": "__page_reporting_request",
            "description": "mm page reporting request page reporting"
        },
        "mminit_validate_memmodel_limits": {
            "ground_truth": "0",
            "function": "mminit_validate_memmodel_limits",
            "description": "mm internal validate the physical addressing limitation of the model"
        },
        "find_smallest_section_pfn": {
            "ground_truth": "0",
            "function": "find_smallest_section_pfn",
            "description": "mm memory hotplug find the smallest valid pfn in the range start pfn end pfn"
        },
        "expand_upwards": {
            "ground_truth": "0",
            "function": "expand_upwards",
            "description": "pa risc us this for it stack ia64 for it register backing store vma is the last one with address vma vm end have to extend vma"
        },
        "kasan_free_nondeferred_pages": {
            "ground_truth": "0",
            "function": "kasan_free_nondeferred_pages",
            "description": "mm page alloc calling kasan free page only after deferred memory initialization ha completed poisoning page during deferred memory init will greatly lengthen the process and cause problem in large memory system a the deferred page initialization is done with interrupt disabled assuming that there will be no reference to those newly initialized page before they are ever allocated this should have no effect on kasan memory tracking a the poison will be properly inserted at page allocation time the only corner case is when page are allocated by on demand allocation and then freed again before the deferred page initialization is done but this is not likely to happen"
        },
        "clear_page_mlock": {
            "ground_truth": "0",
            "function": "clear_page_mlock",
            "description": "mm internal clear the page is pagemlocked this can be useful in situation where we want to unconditionally remove page from the pagecache on truncation or freeing it is legal to call this function for any page mlocked or not if called for page that is still mapped by mlocked vmas all we do is revert to lazy lru behaviour semantics are not broken"
        },
        "trylock_page_bit_common": {
            "ground_truth": "0",
            "function": "trylock_page_bit_common",
            "description": "mm filemap attempt to check or get the page bit and mark u done if successful"
        },
        "shm_open": {
            "ground_truth": "0",
            "function": "shm_open",
            "description": "this is called by fork once for every shm attach"
        },
        "synchronous_wake_function": {
            "ground_truth": "0",
            "function": "synchronous_wake_function",
            "description": "mm shmem this is like autoremove wake function but it remove the wait queue entry unconditionally even if something else had already woken the target"
        },
        "init_user_reserve": {
            "ground_truth": "0",
            "function": "init_user_reserve",
            "description": "initialise sysctl user reserve kbytes this is intended to prevent user from starting single memory hogging process such that they cannot recover kill the hog in overcommit never mode the default value is min of free memory 128mb 128mb is enough to recover with sshd login bash and top kill"
        },
        "try_to_free_swap": {
            "ground_truth": "0",
            "function": "try_to_free_swap",
            "description": "include linux swap if swap is getting full or if there are no more mapping of this page then try to free swap is called to free it swap space"
        },
        "build_zonerefs_node": {
            "ground_truth": "0",
            "function": "build_zonerefs_node",
            "description": "mm page alloc build allocation fallback zone list add all populated zone of node to the zonelist"
        },
        "pm_generic_resume": {
            "ground_truth": "0",
            "function": "pm_generic_resume",
            "description": "driver base power generic ops generic resume callback for subsystem struct device dev device to resume"
        },
        "__shuffle_zone": {
            "ground_truth": "0",
            "function": "__shuffle_zone",
            "description": "mm shuffle fisher yates shuffle the freelist which prescribes iterating through an array pfns in this case and randomly swapping each entry with another in the span end pfn start pfn to keep the implementation simple it doe not attempt to correct for source of bias in the distribution like modulo bias or pseudo random number generator bias the expectation is that this shuffling raise the bar for attack that exploit the predictability of page allocation but need not be perfect shuffle"
        },
        "shmem_add_to_page_cache": {
            "ground_truth": "0",
            "function": "shmem_add_to_page_cache",
            "description": "mm shmem like add to page cache locked but error if expected item ha gone"
        },
        "au1xxx_dbdma_put_dest": {
            "ground_truth": "0",
            "function": "au1xxx_dbdma_put_dest",
            "description": "arch mips alchemy common dbdma put buffer on source destination descriptor"
        },
        "reserve_bootmem_region": {
            "ground_truth": "0",
            "function": "reserve_bootmem_region",
            "description": "mm page alloc initialised page do not have pagereserved set this function is called for each range allocated by the bootmem allocator and mark the page pagereserved the remaining valid page are later sent to the buddy page allocator"
        },
        "setup_kmem_cache_nodes": {
            "ground_truth": "0",
            "function": "setup_kmem_cache_nodes",
            "description": "mm slab this initializes kmem cache node or resizes various cache for all node"
        },
        "remove_stable_node": {
            "ground_truth": "0",
            "function": "remove_stable_node",
            "description": "mm ksm only called through the sysfs control interface"
        },
        "delete_nommu_region": {
            "ground_truth": "0",
            "function": "delete_nommu_region",
            "description": "delete region from the global tree"
        },
        "no_more_pkmaps": {
            "ground_truth": "0",
            "function": "no_more_pkmaps",
            "description": "arch xtensa include asm highmem determine if page index inside pkmap region pkmap nr of given color ha wrapped around pkmap region end when this happens an attempt to flush all unused pkmap slot is made"
        },
        "queue_pages_pmd": {
            "ground_truth": "0",
            "function": "queue_pages_pmd",
            "description": "queue page pmd ha four possible return value page are placed on the right node or queued successfully there is unmovable page and mpol mf move mpol mf strict were specified thp wa split eio is migration entry or only mpol mf strict wa specified and an existing page wa already on node that doe not follow the policy"
        },
        "create_unique_id": {
            "ground_truth": "0",
            "function": "create_unique_id",
            "description": "mm slub create unique string id for slab cache format flag size"
        },
        "setup_per_zone_lowmem_reserve": {
            "ground_truth": "0",
            "function": "setup_per_zone_lowmem_reserve",
            "description": "mm page alloc setup per zone lowmem reserve called whenever sysctl lowmem reserve ratio change ensures that each zone ha correct page reserved value so an adequate number of page are left in the zone after successful alloc page"
        },
        "memmap_init_zone": {
            "ground_truth": "0",
            "function": "memmap_init_zone",
            "description": "mm page alloc initially all page are reserved free one are freed up by memblock free all once the early boot process is done non atomic initialization single pas all aligned pageblocks are initialized to the specified migratetype usually migrate movable besides setting the migratetype no related zone stats nr isolate pageblock are touched"
        },
        "__remove_mapping": {
            "ground_truth": "0",
            "function": "__remove_mapping",
            "description": "mm vmscan same a remove mapping but if the page is removed from the mapping it get returned with refcount of"
        },
        "collect_procs_file": {
            "ground_truth": "0",
            "function": "collect_procs_file",
            "description": "mm memory failure collect process when the error hit file mapped page"
        },
        "mod_zone_page_state": {
            "ground_truth": "0",
            "function": "mod_zone_page_state",
            "description": "mm vmstat use interrupt disable to serialize counter update"
        },
        "do_page_mkwrite": {
            "ground_truth": "0",
            "function": "do_page_mkwrite",
            "description": "mm memory notify the address space that the page is about to become writable so that it can prohibit this or wait for the page to get into an appropriate state we do this without the lock held so that it can sleep if it need to"
        },
        "memcg_write_event_control": {
            "ground_truth": "0",
            "function": "memcg_write_event_control",
            "description": "mm memcontrol do not use in new file parse input and register new cgroup event handler input must be in format interpretation of args is defined by control file implementation"
        },
        "page_endio": {
            "ground_truth": "0",
            "function": "page_endio",
            "description": "mm filemap after completing on page call this routine to update the page flag appropriately"
        },
        "pcpu_nr_pages": {
            "ground_truth": "0",
            "function": "pcpu_nr_pages",
            "description": "mm percpu pcpu nr page calculate total number of populated backing page this reflects the number of page populated to back chunk metadata is excluded in the number exposed in meminfo a the number of backing page scale with the number of cpu and can quickly outweigh the memory used for metadata it also keep this calculation nice and simple return total number of populated backing page in use by the allocator"
        },
        "shm_lock": {
            "ground_truth": "0",
            "function": "shm_lock",
            "description": "shm lock check routine are called in the path where the rwsem is not necessarily held"
        },
        "can_split_huge_page": {
            "ground_truth": "0",
            "function": "can_split_huge_page",
            "description": "include linux huge mm racy check whether the huge page can be split"
        },
        "drain_zonestat": {
            "ground_truth": "0",
            "function": "drain_zonestat",
            "description": "include linux vmstat this is only called if populated zone zone which implies no other user of pset vm stat diff exsist"
        },
        "dmam_pool_release": {
            "ground_truth": "0",
            "function": "dmam_pool_release",
            "description": "mm dmapool managed dma pool"
        },
        "invalidate_complete_page2": {
            "ground_truth": "0",
            "function": "invalidate_complete_page2",
            "description": "mm truncate this is like invalidate complete page except it ignores the page is refcount we do this because invalidate inode pages2 need stronger invalidation guarantee and cannot afford to leave page behind because shrink page list ha temp ref on them or because they are transiently sitting in the lru cache add pagevecs"
        },
        "handle_write_error": {
            "ground_truth": "0",
            "function": "handle_write_error",
            "description": "mm vmscan we detected synchronous write error writing page out probably enospc we need to propagate that into the address space for subsequent fsync msync or close the tricky part is that after writepage we cannot touch the mapping nothing prevents it from being freed up but we have ref on the page and once that page is locked the mapping is pinned we are allowed to run sleeping lock page here because we know the caller ha gfp f"
        },
        "check_for_memory": {
            "ground_truth": "0",
            "function": "check_for_memory",
            "description": "mm page alloc any regular or high memory on that node"
        },
        "count_mm_mlocked_page_nr": {
            "ground_truth": "0",
            "function": "count_mm_mlocked_page_nr",
            "description": "go through vma area and sum size of mlocked vma page a return value note deferred memory locking case mlock2 mlock onfault is also counted return value previously mlocked page count"
        },
        "wp_pfn_shared": {
            "ground_truth": "0",
            "function": "wp_pfn_shared",
            "description": "mm memory handle write page fault for vm mixedmap or vm pfnmap for vm shared mapping"
        },
        "memblock_cap_size": {
            "ground_truth": "0",
            "function": "memblock_cap_size",
            "description": "mm memblock adjust size so that base size doe not overflow return new size"
        },
        "print_block": {
            "ground_truth": "0",
            "function": "print_block",
            "description": "f reiserfs print int print mode int first int last"
        },
        "__get_free_pages": {
            "ground_truth": "0",
            "function": "__get_free_pages",
            "description": "mm page alloc common helper function never use with gfp highmem because the returned address cannot represent highmem page use alloc page and then kmap if you need to access high mem"
        },
        "gather_surplus_pages": {
            "ground_truth": "0",
            "function": "gather_surplus_pages",
            "description": "mm hugetlb increase the hugetlb pool such that it can accommodate reservation of size wouldelta"
        },
        "set_init_arg": {
            "ground_truth": "0",
            "function": "set_init_arg",
            "description": "init main anything after get handed straight to init"
        },
        "read3byte": {
            "ground_truth": "0",
            "function": "read3byte",
            "description": "f sysv inode nxi n0xi for pdp xin xin0 for le32 nix 0nix for be32"
        },
        "putback_movable_page": {
            "ground_truth": "0",
            "function": "putback_movable_page",
            "description": "it should be called on page which is pg movable"
        },
        "ethtool_adv_to_mmd_eee_adv_t": {
            "ground_truth": "0",
            "function": "ethtool_adv_to_mmd_eee_adv_t",
            "description": "include linux mdio small helper function that translates ethtool advertisement setting to eee advertisement for the mmd eee advertisement and mmd eee link partner ability register u32 adv the ethtool advertisement setting"
        },
        "rmap_walk_file": {
            "ground_truth": "0",
            "function": "rmap_walk_file",
            "description": "mm rmap rmap walk file do something to file page using the object based rmap method find all the mapping of page using the mapping pointer and the vma chain contained in the address space struct it point to when called from try to munlock the mmap lock of the mm containing the vma where the page wa found will be held for write so we will not recheck vm flag for that vma that should be ok because that vma should not be locked page the page to be handled rwc control variable according to each walk type"
        },
        "adjust_pool_surplus": {
            "ground_truth": "0",
            "function": "adjust_pool_surplus",
            "description": "mm hugetlb increment or decrement surplus huge page keep node specific counter balanced by operating on them in round robin fashion return if an adjustment wa made"
        },
        "zero_zones_numa_counters": {
            "ground_truth": "0",
            "function": "zero_zones_numa_counters",
            "description": "mm vmstat zero numa counter of all the populated zone"
        },
        "vma_next": {
            "ground_truth": "0",
            "function": "vma_next",
            "description": "vma next get the next vma if vma is null return the first vma in the mm mm the mm struct vma the current vma return the next vma after vma"
        },
        "deferred_init_memmap": {
            "ground_truth": "0",
            "function": "deferred_init_memmap",
            "description": "mm page alloc initialise remaining memory on node"
        },
        "snd_asihpi_proc_read": {
            "ground_truth": "0",
            "function": "snd_asihpi_proc_read",
            "description": "sound pci asihpi asihpi proc interface"
        },
        "delete_from_lru_cache": {
            "ground_truth": "0",
            "function": "delete_from_lru_cache",
            "description": "mm memory failure xxx it is possible that page is isolated from lru cache and then kept in swap cache or failed to remove from page cache the page count will stop it from being freed by unpoison stress test should be aware of this memory leak problem"
        },
        "copy_present_page": {
            "ground_truth": "0",
            "function": "copy_present_page",
            "description": "mm memory copy present and normal page if necessary note the usual case is that this doe not need to do anything and can just return positive value that will let the caller know that it can just increase the page refcount and re use the pte the traditional way but if we need to copy it because it need to be pinned in the parent and the child should get it own copy rather than just reference to the same page we will do that here and return zero to let the caller know we are done and if we need pre allocated page but do not yet have one return negative error to let the preallocation code know so that it can do so outside the page table lock"
        },
        "write_pmu_mappings": {
            "ground_truth": "0",
            "function": "write_pmu_mappings",
            "description": "file format struct pmu mapping u32 pmu num struct pmu map u32 type char name pmu num"
        },
        "remove_vma_list": {
            "ground_truth": "0",
            "function": "remove_vma_list",
            "description": "ok we have the memory area we should free on the vma list so release them and do the vma update called with the mm semaphore held"
        },
        "print_ipv4_arg": {
            "ground_truth": "0",
            "function": "print_ipv4_arg",
            "description": "tool lib traceevent event parse pi4 print an ipv4 address with leading zero pi4 print an ipv4 address without leading zero pi6 print an ipv6 address without colon pi6 print an ipv6 address with colon pi6c print an ipv6 address in compressed form with colon pispc print an ip address based on sockaddr add port"
        },
        "fc_fc4_add_lport": {
            "ground_truth": "0",
            "function": "fc_fc4_add_lport",
            "description": "driver scsi libfc fc libfc add new local port to list and run notifiers struct fc lport lport the new local port"
        },
        "offset_il_node": {
            "ground_truth": "0",
            "function": "offset_il_node",
            "description": "do static interleaving for vma with known offset return the noth node in pol node starting from wrapping around if exceeds the number of present node"
        },
        "hugepage_subpool_put_pages": {
            "ground_truth": "0",
            "function": "hugepage_subpool_put_pages",
            "description": "mm hugetlb subpool accounting for freeing and unreserving page return the number of global page reservation that must be dropped the return value may only be different than the passed value delta in the case where subpool minimum size must be maintained"
        },
        "set_send_length": {
            "ground_truth": "0",
            "function": "set_send_length",
            "description": "driver infiniband hw hfi1 chip set send length set the mtu by limiting how many dws may be sent the sendlencheck register compare against lrh pktlen so use the max byte included in the lrh this routine change all vl value except vl15 which it maintains at the same value ppd per port data"
        },
        "pccard_validate_cis": {
            "ground_truth": "0",
            "function": "pccard_validate_cis",
            "description": "driver pcmcia cistpl check whether card ha sensible ci this try to determine if card ha sensible ci in info it return the number of tuples in the ci or if the ci look bad the check include making sure several critical tuples are present and valid seeing if the total number of tuples is reasonable and looking for tuples that use reserved code the function return on success struct pcmcia socket the struct pcmcia socket we are to check unsigned int info return the number of tuples in the valid ci or"
        },
        "cache_random_seq_create": {
            "ground_truth": "0",
            "function": "cache_random_seq_create",
            "description": "mm slab create random sequence per cache"
        },
        "timekeeping_resume": {
            "ground_truth": "0",
            "function": "timekeeping_resume",
            "description": "kernel time timekeeping resume the generic timekeeping subsystem void no argument"
        },
        "free_zbud_page": {
            "ground_truth": "0",
            "function": "free_zbud_page",
            "description": "mm zbud reset the struct page field and free the page"
        },
        "start_cpu_timer": {
            "ground_truth": "0",
            "function": "start_cpu_timer",
            "description": "mm slab initiate the reap timer running on the target cpu we run at around to 2hz via the workqueue eventd add the cpu number into the expiration time to minimize the possibility of the cpu getting into lockstep and contending for the global cache chain lock"
        },
        "mem_cgroup_bind": {
            "ground_truth": "0",
            "function": "mem_cgroup_bind",
            "description": "mm memcontrol cgroup retains root cgroups across un mount cycle making it necessary to verify whether we are attached to the default hierarchy on each mount attempt"
        },
        "accountable_mapping": {
            "ground_truth": "0",
            "function": "accountable_mapping",
            "description": "we account for memory if it is private writeable mapping not hugepages and vm noreserve wa not set"
        },
        "rp_flush_buffer": {
            "ground_truth": "3",
            "function": "rp_flush_buffer",
            "description": "driver tty rocket flush the tx fifo for port deletes data in the xmit buf stored in the port struct for the port note that spinlock are used to protect info member do not call this function if the spinlock is already held"
        },
        "mempool_alloc_slab": {
            "ground_truth": "0",
            "function": "mempool_alloc_slab",
            "description": "mm mempool commonly used alloc and free fn"
        },
        "__delete_from_swap_cache": {
            "ground_truth": "0",
            "function": "__delete_from_swap_cache",
            "description": "include linux swap this must be called only on page that have been verified to be in the swap cache"
        },
        "kernel_get_mempolicy": {
            "ground_truth": "0",
            "function": "kernel_get_mempolicy",
            "description": "retrieve numa policy"
        },
        "mem_cgroup_write": {
            "ground_truth": "0",
            "function": "mem_cgroup_write",
            "description": "mm memcontrol the user of this function is re limit"
        },
        "arch_has_descending_max_zone_pfns": {
            "ground_truth": "0",
            "function": "arch_has_descending_max_zone_pfns",
            "description": "arch arc mm init some architecturs arc may have zone highmem below zone normal for such case we allow max zone pfn sorted in the descending order"
        },
        "balance_dirty_pages": {
            "ground_truth": "0",
            "function": "balance_dirty_pages",
            "description": "mm page writeback balance dirty page must be called by process which are generating dirty data it look at the number of dirty page in the machine and will force the caller to wait once crossing the background thresh dirty thresh if we are over background thresh then the writeback thread are woken to perform some writeout"
        },
        "__kmem_cache_shutdown": {
            "ground_truth": "0",
            "function": "__kmem_cache_shutdown",
            "description": "mm slub release all resource used by slab cache"
        },
        "kmemleak_late_init": {
            "ground_truth": "0",
            "function": "kmemleak_late_init",
            "description": "mm kmemleak late initialization function"
        },
        "return_unused_surplus_pages": {
            "ground_truth": "0",
            "function": "return_unused_surplus_pages",
            "description": "mm hugetlb this routine ha two main purpose decrement the reservation count resv huge page by the value passed in unused resv page this corresponds to the prior adjustment made to the associated reservation map free any unused surplus page that may have been allocated to satisfy the reservation a many a unused resv page may be freed called with hugetlb lock held however the lock could be dropped and reacquired during call to cond resched lock whenever dropping the lock we must make sure nobody else can claim page we are in the process of freeing do this by ensuring resv huge page always is greater than the number of huge page we plan to free when dropping the lock"
        },
        "percpu_pagelist_fraction_sysctl_handler": {
            "ground_truth": "0",
            "function": "percpu_pagelist_fraction_sysctl_handler",
            "description": "mm page alloc percpu pagelist fraction change the pcp high for each zone on each cpu it is the fraction of total page in each zone that hot per cpu pagelist can have before it get flushed back to buddy allocator"
        },
        "kmemleak_seq_next": {
            "ground_truth": "0",
            "function": "kmemleak_seq_next",
            "description": "mm kmemleak return the next object in the object list the function decrement the use count of the previous object and increase that of the next one"
        },
        "zswap_pool_find_get": {
            "ground_truth": "0",
            "function": "zswap_pool_find_get",
            "description": "mm zswap type and compressor must be null terminated"
        },
        "zswap_entry_find_get": {
            "ground_truth": "0",
            "function": "zswap_entry_find_get",
            "description": "mm zswap caller must hold the tree lock"
        },
        "dio_warn_stale_pagecache": {
            "ground_truth": "0",
            "function": "dio_warn_stale_pagecache",
            "description": "mm filemap warn about page cache invalidation failure during direct write"
        },
        "set_up_node": {
            "ground_truth": "0",
            "function": "set_up_node",
            "description": "mm slab for setting up all the kmem cache node for cache whose buffer size is same a size of kmem cache node"
        },
        "freeptr_outside_object": {
            "ground_truth": "0",
            "function": "freeptr_outside_object",
            "description": "mm slub see comment in calculate size"
        },
        "can_vma_merge_before": {
            "ground_truth": "0",
            "function": "can_vma_merge_before",
            "description": "return true if we can merge this vm flag anon vma file vm pgoff in front of at lower virtual address and file offset than the vma we cannot merge two vmas if they have differently assigned non null anon vmas nor if same anon vma is assigned but offset incompatible we do not check here for the merged mmap wrapping around the end of pagecache index 16tb on ia32 because do mmap doe not permit mmap is which wrap nor mmaps which cover the final page at index 1ul"
        },
        "shmem_swap_usage": {
            "ground_truth": "0",
            "function": "shmem_swap_usage",
            "description": "mm shmem determine in byte how many of the shmem object is page mapped by the given vma is swapped out this is safe to call without mutex or the page lock thanks to rcu a long a the inode doe not go away and racy result are not problem"
        },
        "extfrag_for_order": {
            "ground_truth": "0",
            "function": "extfrag_for_order",
            "description": "mm vmstat calculates external fragmentation within zone wrt the given order it is defined a the percentage of page found in block of size le than order it return value in range"
        },
        "mem_cgroup_force_empty": {
            "ground_truth": "0",
            "function": "mem_cgroup_force_empty",
            "description": "mm memcontrol reclaims a many page from the given memcg a possible caller is responsible for holding cs reference for memcg"
        },
        "balloon_page_migrate": {
            "ground_truth": "0",
            "function": "balloon_page_migrate",
            "description": "include linux balloon compaction move to new page counterpart for ballooned page"
        },
        "fuse_change_attributes": {
            "ground_truth": "0",
            "function": "fuse_change_attributes",
            "description": "f fuse inode struct inode inode undescribed struct fuse attr attr undescribed u64 attr valid undescribed u64 attr version undescribed"
        },
        "reset_vma_resv_huge_pages": {
            "ground_truth": "0",
            "function": "reset_vma_resv_huge_pages",
            "description": "include linux hugetlb reset counter to and clear all hpage resv flag"
        },
        "__vm_enough_memory": {
            "ground_truth": "0",
            "function": "__vm_enough_memory",
            "description": "mm util check that process ha enough memory to allocate new virtual mapping mean there is enough memory for the allocation to succeed and enomem implies there is not we currently support three overcommit policy which are set via the vm overcommit memory sysctl see documentation vm overcommit accounting rst strict overcommit mode added feb by alan cox additional code jul by robert love cap sys admin is if the process ha admin privilege otherwise note this is helper function intended to be used by lsms which wish to use this logic"
        },
        "process_join_error": {
            "ground_truth": "0",
            "function": "process_join_error",
            "description": "driver infiniband core multicast fail join request if it is still active at the head of the pending queue"
        },
        "mlock_vma_page": {
            "ground_truth": "0",
            "function": "mlock_vma_page",
            "description": "mm internal must be called with vma is mmap lock held for read or write and page locked"
        },
        "check_qop": {
            "ground_truth": "0",
            "function": "check_qop",
            "description": "check qop test if queued operation sleep on the semaphore semnum"
        },
        "slab_alloc_node": {
            "ground_truth": "0",
            "function": "slab_alloc_node",
            "description": "mm slub inlined fastpath so that allocation function kmalloc kmem cache alloc have the fastpath folded into their function so no function call overhead for request that can be satisfied on the fastpath the fastpath work by first checking if the lockless freelist can be used if not then slab alloc is called for slow processing otherwise we can simply pick the next object from the lockless free list"
        },
        "zero_zone_numa_counters": {
            "ground_truth": "0",
            "function": "zero_zone_numa_counters",
            "description": "mm vmstat zero numa counter within zone"
        },
        "unmap_and_move_huge_page": {
            "ground_truth": "0",
            "function": "unmap_and_move_huge_page",
            "description": "counterpart of unmap and move page for hugepage migration this function doe not wait the completion of hugepage because there is no race between and migration for hugepage note that currently hugepage occurs only in direct where no lock is held and pg writeback is irrelevant and writeback status of all subpages are counted in the reference count of the head page if all subpages of 2mb hugepage are under direct the reference of the head page is and bit more this mean that when we try to migrate hugepage whose subpages are doing direct some reference remain after try to unmap and hugepage migration fails without data corruption there is also no race when direct is issued on the page under migration because then pte is replaced with migration swap entry and direct code will wait in the page fault for migration to complete"
        },
        "async_free_zspage": {
            "ground_truth": "0",
            "function": "async_free_zspage",
            "description": "mm zsmalloc caller should hold page lock of all page in the zspage in here we cannot use zspage meta data"
        },
        "__swp_swapcount": {
            "ground_truth": "0",
            "function": "__swp_swapcount",
            "description": "include linux swap how many reference to entry are currently swapped out this doe not give an exact answer when swap count is continued but doe include the high count continued flag to allow for that"
        },
        "__put_nommu_region": {
            "ground_truth": "0",
            "function": "__put_nommu_region",
            "description": "release reference to region the caller must hold the region semaphore for writing which this release the region may not have been added to the tree yet in which case vm top will equal vm start"
        },
        "lock_page_maybe_drop_mmap": {
            "ground_truth": "0",
            "function": "lock_page_maybe_drop_mmap",
            "description": "mm filemap lock page maybe drop mmap lock the page possibly dropping the mmap lock this work similar to lock page or retry in that it can drop the mmap lock it differs in that it actually return the page locked if it return and if it could not lock the page if we did have to drop the mmap lock then fpin will point to the pinned file and need to be fput ed at later point vmf the vm fault for this fault page the page to lock fpin the pointer to the file we may pin or is already pinned"
        },
        "__vma_address": {
            "ground_truth": "0",
            "function": "__vma_address",
            "description": "mm internal at what user virtual address is page expected in vma"
        },
        "register_memory_resource": {
            "ground_truth": "0",
            "function": "register_memory_resource",
            "description": "mm memory hotplug add this memory to iomem resource"
        },
        "set_page_dirty_lock": {
            "ground_truth": "0",
            "function": "set_page_dirty_lock",
            "description": "mm page writeback set page dirty is racy if the caller ha no reference against page mapping host and if the page is unlocked this is because another cpu could truncate the page off the mapping and then free the mapping usually the page is locked or the caller is user space process which hold reference on the inode by having an open file in other case the page should be locked before running set page dirty"
        },
        "pcpu_stats_area_alloc": {
            "ground_truth": "0",
            "function": "pcpu_stats_area_alloc",
            "description": "mm percpu internal pcpu stats area alloc increment area allocation stats context pcpu lock chunk the location of the area being allocated size size of area to allocate in byte"
        },
        "clear_page_dirty_for_io": {
            "ground_truth": "0",
            "function": "clear_page_dirty_for_io",
            "description": "mm page writeback clear page is dirty flag while caring for dirty memory accounting return true if the page wa previously dirty this is for preparing to put the page under writeout we leave the page tagged a dirty in the xarray so that concurrent write for sync can discover it via pagecache tag dirty walk the writepage implementation will run either set page writeback or set page dirty at which stage we bring the page is dirty flag and xarray dirty tag back into sync this incoherency between the page is dirty flag and xarray tag is unfortunate but it only exists while the page is locked"
        },
        "__check_heap_object": {
            "ground_truth": "0",
            "function": "__check_heap_object",
            "description": "include linux slab reject incorrectly sized object and object that are to be copied to from userspace but do not fall entirely within the containing slab cache is usercopy region return null if check pass otherwise const char to name of cache to indicate an error"
        },
        "section_deactivate": {
            "ground_truth": "0",
            "function": "section_deactivate",
            "description": "mm sparse to deactivate memory region there are case to handle across two configuration sparsemem vmemmap deactivation of partial hot added section only possible in the sparsemem vmemmap case section wa present at memory init section wa hot added post memory init deactivation of complete hot added section deactivation of complete section from memory init for when subsection map doe not empty we will not be freeing the usage map but still need to free the vmemmap range for and the sparsemem vmemmap case are unified"
        },
        "zswap_compressor_param_set": {
            "ground_truth": "0",
            "function": "zswap_compressor_param_set",
            "description": "mm zswap crypto compressor to use"
        },
        "memcg_has_children": {
            "ground_truth": "0",
            "function": "memcg_has_children",
            "description": "mm memcontrol test whether memcg ha child dead or alive note that this function doe not care whether memcg ha use hierarchy enabled and return true if there are child cs according to the cgroup hierarchy testing use hierarchy is the caller is responsibility"
        },
        "free_debug_processing": {
            "ground_truth": "0",
            "function": "free_debug_processing",
            "description": "mm slub support checking bulk free of constructed freelist"
        },
        "__alloc_pages_direct_compact": {
            "ground_truth": "0",
            "function": "__alloc_pages_direct_compact",
            "description": "mm page alloc try memory compaction for high order allocation before reclaim"
        },
        "insert_zspage": {
            "ground_truth": "0",
            "function": "insert_zspage",
            "description": "mm zsmalloc each size class maintains various freelists and zspages are assigned to one of these freelists based on the number of live object they have this function insert the given zspage into the freelist identified by"
        },
        "aa_label_alloc": {
            "ground_truth": "0",
            "function": "aa_label_alloc",
            "description": "security apparmor label allocate label with profile vector of size length int size size of profile vector in the label struct aa proxy proxy proxy to use or null if to allocate new one gfp gfp memory allocation type new label else null if failed"
        },
        "__frontswap_load": {
            "ground_truth": "0",
            "function": "__frontswap_load",
            "description": "mm frontswap get data from frontswap associated with swaptype and offset that were specified when the data wa put to frontswap and use it to fill the specified page with data page must be locked and in the swap cache"
        },
        "alloc_slab_page": {
            "ground_truth": "0",
            "function": "alloc_slab_page",
            "description": "mm slub slab allocation and freeing"
        },
        "__handle_mm_fault": {
            "ground_truth": "0",
            "function": "__handle_mm_fault",
            "description": "mm memory by the time we get here we already hold the mm semaphore the mmap lock may have been released depending on flag and our return value see filemap fault and lock page or retry"
        },
        "lowmem_reserve_ratio_sysctl_handler": {
            "ground_truth": "0",
            "function": "lowmem_reserve_ratio_sysctl_handler",
            "description": "mm page alloc lowmem reserve ratio sysctl handler just wrapper around proc dointvec so that we can call setup per zone lowmem reserve whenever sysctl lowmem reserve ratio change the reserve ratio obviously ha absolutely no relation with the minimum watermark the lowmem reserve ratio can only make sense if in function of the boot time zone size"
        },
        "lookup_swap_cache": {
            "ground_truth": "0",
            "function": "lookup_swap_cache",
            "description": "include linux swap lookup swap entry in the swap cache found page will be returned unlocked and with it refcount incremented we rely on the kernel lock getting page table operation atomic even if we drop the page lock before returning"
        },
        "mem_cgroup_handle_over_high": {
            "ground_truth": "0",
            "function": "mem_cgroup_handle_over_high",
            "description": "include linux memcontrol scheduled by try charge to be executed from the userland return path and reclaims memory over the high limit"
        },
        "calculate_high_delay": {
            "ground_truth": "0",
            "function": "calculate_high_delay",
            "description": "mm memcontrol get the number of jiffy that we should penalise mischievous cgroup which is exceeding it memory high by checking both it and it ancestor"
        },
        "do_migrate_pages": {
            "ground_truth": "0",
            "function": "do_migrate_pages",
            "description": "include linux mempolicy move page between the two nodesets so a to preserve the physical layout a much a possible return the number of page that could not be moved"
        },
        "rotate_reclaimable_page": {
            "ground_truth": "0",
            "function": "rotate_reclaimable_page",
            "description": "mm swap writeback is about to end against page which ha been marked for immediate reclaim if it still appears to be reclaimable move it to the tail of the inactive list"
        },
        "__hugetlb_cgroup_uncharge_page": {
            "ground_truth": "0",
            "function": "__hugetlb_cgroup_uncharge_page",
            "description": "mm hugetlb cgroup should be called with hugetlb lock held"
        },
        "fip_timeout_deleted_fcf": {
            "ground_truth": "0",
            "function": "fip_timeout_deleted_fcf",
            "description": "driver scsi fcoe fcoe sysfs delete fcf when the devloss timer fire remove the fcf from the fip ctlr is list of fcfs and queue the final deletion struct work struct work the fip fcf is embedded work struct"
        },
        "undo_isolate_page_range": {
            "ground_truth": "0",
            "function": "undo_isolate_page_range",
            "description": "mm page isolation make isolated page available again"
        },
        "free_unref_page_list": {
            "ground_truth": "0",
            "function": "free_unref_page_list",
            "description": "mm page alloc free list of order page"
        },
        "lru_add_drain_cpu": {
            "ground_truth": "0",
            "function": "lru_add_drain_cpu",
            "description": "mm swap drain page out of the cpu is pagevecs either cpu is the current cpu and preemption ha already been disabled or cpu is being hot unplugged and is already dead"
        },
        "init_zero_pfn": {
            "ground_truth": "0",
            "function": "init_zero_pfn",
            "description": "mm memory config mmu architecture set up zero page in their paging init"
        },
        "vmalloc_to_pfn": {
            "ground_truth": "0",
            "function": "vmalloc_to_pfn",
            "description": "mm vmalloc map vmalloc space virtual address to the physical page frame number"
        },
        "stable_tree_append": {
            "ground_truth": "0",
            "function": "stable_tree_append",
            "description": "mm ksm stable tree append add another rmap item to the linked list of rmap item hanging off given node of the stable tree all sharing the same ksm page"
        },
        "shmem_unuse_inode": {
            "ground_truth": "0",
            "function": "shmem_unuse_inode",
            "description": "mm shmem if swap found in inode free it and move page from swapcache to filecache"
        },
        "lpfc_mac_addr_match": {
            "ground_truth": "0",
            "function": "lpfc_mac_addr_match",
            "description": "driver scsi lpfc lpfc hbadisc check if the fcf mac address match this routine compare the fcf record is mac address with hba is fcf mac address if the mac address are identical this function return else return uint8 mac addr pointer to mac address struct fcf record new fcf record pointer to fcf record"
        },
        "enable_cpucache": {
            "ground_truth": "0",
            "function": "enable_cpucache",
            "description": "mm slab called with slab mutex held always"
        },
        "mem_cgroup_oom_trylock": {
            "ground_truth": "0",
            "function": "mem_cgroup_oom_trylock",
            "description": "mm memcontrol check oom killer is already running under our hierarchy if someone is running return false"
        },
        "_deferred_grow_zone": {
            "ground_truth": "0",
            "function": "_deferred_grow_zone",
            "description": "mm page alloc deferred grow zone is init but it is called from get page from freelist during early boot until deferred page permanently disables this call this is why we have refdata wrapper to avoid warning and to ensure that the function body get unloaded"
        },
        "intel_pt_ff_cb": {
            "ground_truth": "0",
            "function": "intel_pt_ff_cb",
            "description": "tool perf util intel pt decoder intel pt decoder fast forward lookahead callback determine if buffer trace is past the fast forward timestamp struct intel pt buffer buffer intel pt trace buffer void data opaque pointer to fast forward data struct fast forward data stop lookahead if buffer trace is past the fast forward timestamp and otherwise"
        },
        "add_reservation_in_range": {
            "ground_truth": "0",
            "function": "add_reservation_in_range",
            "description": "mm hugetlb must be called with resv lock held calling this with region needed null will count the number of page to be added but will not modify the linked list and region needed will indicate the number of file region needed in the cache to carry out to add the region for this range"
        },
        "drain_array": {
            "ground_truth": "0",
            "function": "drain_array",
            "description": "mm slab drain an array if it contains any element taking the node lock only if necessary note that the node listlock also protects the array cache if drain array is used on the shared array"
        },
        "writeback_set_ratelimit": {
            "ground_truth": "0",
            "function": "writeback_set_ratelimit",
            "description": "mm page writeback if ratelimit page is too high then we can get into dirty data overload if large number of process all perform writes at the same time if it is too low then smp machine will call the expensive get writeback state too often here we set ratelimit page to level which ensures that when all cpu are dirtying in parallel we cannot go more than over the dirty memory threshold"
        },
        "__asan_alloca_poison": {
            "ground_truth": "0",
            "function": "__asan_alloca_poison",
            "description": "mm kasan generic emitted by compiler to poison alloca ed object"
        },
        "sparse_init_nid": {
            "ground_truth": "0",
            "function": "sparse_init_nid",
            "description": "mm sparse initialize sparse on specific node the node span pnum begin pnum end and number of present section in this node is map count"
        },
        "encode_handle": {
            "ground_truth": "0",
            "function": "encode_handle",
            "description": "mm z3fold encodes the handle of particular buddy within zbud page pool lock should be held a this function access first last chunk"
        },
        "pin_user_pages_locked": {
            "ground_truth": "0",
            "function": "pin_user_pages_locked",
            "description": "mm gup pin user page locked is the foll pin variant of get user page locked behavior is the same except that this one set foll pin and reject foll get"
        },
        "shmem_unuse_swap_entries": {
            "ground_truth": "0",
            "function": "shmem_unuse_swap_entries",
            "description": "mm shmem move the swapped page for an inode to page cache return the count of page swapped in or the error in case of failure"
        },
        "try_to_merge_two_pages": {
            "ground_truth": "0",
            "function": "try_to_merge_two_pages",
            "description": "mm ksm try to merge two page take two identical page and prepare them to be merged into one page this function return the kpage if we successfully merged two identical page into one ksm page null otherwise note that this function upgrade page to ksm page if one of the page is already ksm page try to merge with ksm page should be used"
        },
        "region_abort": {
            "ground_truth": "0",
            "function": "region_abort",
            "description": "mm hugetlb abort the in progress add operation the add in progress field of the resv map keep track of the operation in progress between call to region chg and region add operation are sometimes aborted after the call to region chg in such case region abort is called to decrement the add in progress counter region needed is the value returned by the region chg call it is used to decrement the add in progress counter note the range argument are not needed or used in this routine they are kept to make reading the calling code easier a argument will match the associated region chg call"
        },
        "putback_movable_pages": {
            "ground_truth": "0",
            "function": "putback_movable_pages",
            "description": "include linux migrate put previously isolated page back onto the appropriate list from where they were once taken off for compaction migration this function shall be used whenever the isolated pageset ha been built from lru balloon hugetlbfs page see isolate migratepages range and isolate huge page"
        },
        "laptop_sync_completion": {
            "ground_truth": "0",
            "function": "laptop_sync_completion",
            "description": "include linux writeback we are in laptop mode and we have just synced the sync is writes will have caused another writeback to be scheduled by laptop io completion nothing need to be written back anymore so we unschedule the writeback"
        },
        "swap_cluster_schedule_discard": {
            "ground_truth": "0",
            "function": "swap_cluster_schedule_discard",
            "description": "add cluster to discard list and schedule it to do discard"
        },
        "zswap_rb_insert": {
            "ground_truth": "0",
            "function": "zswap_rb_insert",
            "description": "mm zswap in the case that entry with the same offset is found pointer to the existing entry is stored in dupentry and the function return eexist"
        },
        "slab_lock": {
            "ground_truth": "0",
            "function": "slab_lock",
            "description": "mm slub per slab locking using the pagelock"
        },
        "__mlock_posix_error_return": {
            "ground_truth": "0",
            "function": "__mlock_posix_error_return",
            "description": "convert get user page return value to posix mlock error"
        },
        "config_aneg": {
            "ground_truth": "0",
            "function": "config_aneg",
            "description": "autonegotiation if phydev autoneg is on force the speed to the current setting in phydev if phydev autoneg is off config aneg configures the advertisement and reset"
        },
        "munlock_vma_pages_range": {
            "ground_truth": "0",
            "function": "munlock_vma_pages_range",
            "description": "munlock vma page range munlock all page in the vma range for mremap munmap and exit called with vma vm locked vma vma containing range to be munlock ed start start address in vma of the range end end of range in vma return with vm locked cleared caller must be prepared to deal with this we do not save and restore vm locked here because page are still on lru in unmap path page might be scanned by reclaim and re mlocked by try to munlock unmap before we unmap and free them this will result in freeing mlocked page"
        },
        "__fragmentation_index": {
            "ground_truth": "0",
            "function": "__fragmentation_index",
            "description": "mm vmstat fragmentation index only make sense if an allocation of requested size would fail if that is true the fragmentation index indicates whether external fragmentation or lack of memory wa the problem the value can be used to determine if page reclaim or compaction should be used"
        },
        "shmem_mknod": {
            "ground_truth": "0",
            "function": "shmem_mknod",
            "description": "mm shmem file creation allocate an inode and we are done"
        },
        "zs_stat_dec": {
            "ground_truth": "0",
            "function": "zs_stat_dec",
            "description": "mm zsmalloc type can be of enum type z stat type or fullness group"
        },
        "mincore_page": {
            "ground_truth": "0",
            "function": "mincore_page",
            "description": "later we can get more picky about what in core mean precisely for now simply check to see if the page is in the page cache and is up to date that no page in operation would be required at this time if an application were to map and access this page"
        },
        "on_freelist": {
            "ground_truth": "0",
            "function": "on_freelist",
            "description": "mm slub determine if certain object on page is on the freelist must hold the slab lock to guarantee that the chain are in consistent state"
        },
        "overlaps": {
            "ground_truth": "0",
            "function": "overlaps",
            "description": "driver block drbd drbd receiver return true if any portion of ptr ptr over lap with low high"
        },
        "move_to_free_list": {
            "ground_truth": "0",
            "function": "move_to_free_list",
            "description": "mm page alloc used for page which are on another list move the page to the tail of the list so the moved page will not immediately be considered for allocation again optimization for memory onlining"
        },
        "mbind_range": {
            "ground_truth": "0",
            "function": "mbind_range",
            "description": "step apply policy to range and do split"
        },
        "handle_receive_interrupt": {
            "ground_truth": "0",
            "function": "handle_receive_interrupt",
            "description": "driver infiniband hw hfi1 driver handle receive interrupt receive packet called from interrupt handler for error or receive interrupt this is the slow path interrupt handler rcd the context"
        },
        "free_pool_huge_page": {
            "ground_truth": "0",
            "function": "free_pool_huge_page",
            "description": "mm hugetlb free huge page from pool from next node to free attempt to keep persistent huge page more or le balanced over allowed node called with hugetlb lock locked"
        },
        "remove_zspage": {
            "ground_truth": "0",
            "function": "remove_zspage",
            "description": "mm zsmalloc this function remove the given zspage from the freelist identified by"
        },
        "mqueue_read_file": {
            "ground_truth": "0",
            "function": "mqueue_read_file",
            "description": "this is routine for system read from queue file to avoid mess with doing here some sort of mq receive we allow to read only queue size notification info the only value that are interesting from user point of view and are not accessible through std routine"
        },
        "setup_kmalloc_cache_index_table": {
            "ground_truth": "0",
            "function": "setup_kmalloc_cache_index_table",
            "description": "mm slab common patch up the size index table if we have strange large alignment requirement for the kmalloc array this is only the case for mips it seems the standard arch will not generate any code here largest permitted alignment is byte due to the way we handle the index determination for the smaller cache make sure that nothing crazy happens if someone start tinkering around with arch kmalloc minalign"
        },
        "___slab_alloc": {
            "ground_truth": "0",
            "function": "___slab_alloc",
            "description": "mm slub slow path the lockless freelist is empty or we need to perform debugging duty processing is still very fast if new object have been freed to the regular freelist in that case we simply take over the regular freelist a the lockless freelist and zap the regular freelist if that is not working then we fall back to the partial list we take the first element of the freelist a the object to allocate now and move the rest of the freelist to the lockless freelist and if we were unable to get new slab from the partial slab list then we need to allocate new slab this is the slowest path since it involves call to the page allocator and the setup of new slab version of slab alloc to use when we know that interrupt are already disabled which is the case for bulk allocation"
        },
        "find_and_remove_object": {
            "ground_truth": "0",
            "function": "find_and_remove_object",
            "description": "mm kmemleak look up an object in the object search tree and remove it from both object tree root and object list the returned object is use count should be at least a initially set by create object"
        },
        "__add_pages": {
            "ground_truth": "0",
            "function": "__add_pages",
            "description": "mm memory hotplug reasonably generic function for adding memory it is expected that arch that support memory hotplug will call this function after deciding the zone to which to add the new page"
        },
        "invalidate_complete_page": {
            "ground_truth": "0",
            "function": "invalidate_complete_page",
            "description": "mm truncate this is for invalidate mapping page that function can be called at any time and is not supposed to throw away dirty page but page can be marked dirty at any time too so use remove mapping which safely discard clean unused page return non zero if the page wa successfully invalidated"
        },
        "get_pkmap_wait_queue_head": {
            "ground_truth": "0",
            "function": "get_pkmap_wait_queue_head",
            "description": "arch xtensa include asm highmem get head of wait queue for pkmap entry of the given color wait queue for different mapping color should be independent to avoid unnecessary wakeups caused by freeing of slot of other color"
        },
        "ptep_set_access_flags": {
            "ground_truth": "0",
            "function": "ptep_set_access_flags",
            "description": "arch riscv include asm pgtable only set the access flag dirty accessed a well a write permission furthermore we know it always get set to more permissive setting which allows most architecture to optimize this we return whether the pte actually changed which in turn instructs the caller to do thing like update mmu cache this used to be done in the caller but sparc need minor fault to force that call on sun4c so we changed this macro slightly"
        },
        "snd_timer_user_interrupt": {
            "ground_truth": "0",
            "function": "snd_timer_user_interrupt",
            "description": "sound core timer user space interface"
        },
        "free_area_init_core": {
            "ground_truth": "0",
            "function": "free_area_init_core",
            "description": "mm page alloc set up the zone data structure mark all page reserved mark all memory queue empty clear the memory bitmap note pgdat should get zeroed by caller note this function is only called during early init"
        },
        "change_huge_pmd": {
            "ground_truth": "0",
            "function": "change_huge_pmd",
            "description": "mm huge memory return if pmd could not be locked if pmd wa locked but protection unchange and tlb flush unnecessary hpage pmd nr is protection changed and tlb flush necessary"
        },
        "__page_file_mapping": {
            "ground_truth": "0",
            "function": "__page_file_mapping",
            "description": "out of line page file method to avoid include hell"
        },
        "__migration_entry_wait": {
            "ground_truth": "0",
            "function": "__migration_entry_wait",
            "description": "include linux swapops something used the pte of page under migration we need to get to the page and wait until migration is finished when we return from this function the fault will be retried"
        },
        "calculate_alignment": {
            "ground_truth": "0",
            "function": "calculate_alignment",
            "description": "mm slab common figure out what the alignment of the object will be given set of flag user specified alignment and the size of the object"
        },
        "__wb_writeout_inc": {
            "ground_truth": "0",
            "function": "__wb_writeout_inc",
            "description": "mm page writeback increment wb is writeout completion count and the global writeout completion count called from test clear page writeback"
        },
        "shmem_reserve_inode": {
            "ground_truth": "0",
            "function": "shmem_reserve_inode",
            "description": "mm shmem shmem reserve inode performs bookkeeping to reserve shmem inode and produce novel ino for the newly allocated inode it may also be called when making hard link to permit the space needed by each dentry however in that case no new inode number is needed since that internally draw from another pool of inode number currently global get next ino this case is indicated by passing null a inop"
        },
        "hugepages_setup": {
            "ground_truth": "0",
            "function": "hugepages_setup",
            "description": "mm hugetlb hugepages command line processing hugepages normally follows valid hugepagsz or default hugepagsz specification if not ignore the hugepages value hugepages can also be the first huge page command line option in which case it implicitly specifies the number of huge page for the default size"
        },
        "insert_pages": {
            "ground_truth": "0",
            "function": "insert_pages",
            "description": "mm memory insert page amortizes the cost of spinlock operation when inserting page in loop arch must define pte index"
        },
        "do_tune_cpucache": {
            "ground_truth": "0",
            "function": "do_tune_cpucache",
            "description": "mm slab always called with the slab mutex held"
        },
        "__vma_adjust": {
            "ground_truth": "0",
            "function": "__vma_adjust",
            "description": "we cannot adjust vm start vm end vm pgoff field of vma that is already present in an mmap tree without adjusting the tree the following helper function should be used when such adjustment are necessary the insert vma if any is to be inserted before we drop the necessary lock"
        },
        "collect_procs": {
            "ground_truth": "0",
            "function": "collect_procs",
            "description": "mm memory failure collect the process who have the corrupted page mapped to kill"
        },
        "__offline_isolated_pages": {
            "ground_truth": "0",
            "function": "__offline_isolated_pages",
            "description": "mm page alloc all page in the range must be in single zone must not contain hole must span full section and must be isolated before calling this function"
        },
        "swap_cgroup_prepare": {
            "ground_truth": "0",
            "function": "swap_cgroup_prepare",
            "description": "mm swap cgroup allocate buffer for swap cgroup"
        },
        "__cdns3_gadget_ep_queue": {
            "ground_truth": "0",
            "function": "__cdns3_gadget_ep_queue",
            "description": "driver usb cdns3 gadget return on success error code elsewhere struct usb ep ep endpoint object struct usb request request request object gfp gfp flag gfp flag"
        },
        "hugepagesz_setup": {
            "ground_truth": "0",
            "function": "hugepagesz_setup",
            "description": "mm hugetlb hugepagesz command line processing specific huge page size can only be specified once with hugepagesz hugepagesz is followed by hugepages on the command line the global variable parsed valid hugepagesz is used to determine if prior hugepagesz argument wa valid"
        },
        "min_free_kbytes_sysctl_handler": {
            "ground_truth": "0",
            "function": "min_free_kbytes_sysctl_handler",
            "description": "mm page alloc min free kbytes sysctl handler just wrapper around proc dointvec so that we can call two helper function whenever min free kbytes change"
        },
        "add_full": {
            "ground_truth": "0",
            "function": "add_full",
            "description": "mm slub tracking of fully allocated slab for debugging purpose"
        },
        "find_mergeable_anon_vma": {
            "ground_truth": "0",
            "function": "find_mergeable_anon_vma",
            "description": "find mergeable anon vma is used by anon vma prepare to check neighbouring vmas for suitable anon vma before it go off to allocate new anon vma it check because repetitive sequence of mprotects and fault may otherwise lead to distinct anon vmas being allocated preventing vma merge in subsequent mprotect"
        },
        "shrink_vma": {
            "ground_truth": "0",
            "function": "shrink_vma",
            "description": "shrink vma by removing the specified chunk from either the beginning or the end"
        },
        "lock_zspage": {
            "ground_truth": "0",
            "function": "lock_zspage",
            "description": "mm zsmalloc to prevent zspage destroy during migration zspage freeing should hold lock of all page in the zspage"
        },
        "slob_alloc": {
            "ground_truth": "0",
            "function": "slob_alloc",
            "description": "mm slob slob alloc entry point into the slob allocator"
        },
        "aa_label_next_in_merge": {
            "ground_truth": "0",
            "function": "aa_label_next_in_merge",
            "description": "security apparmor label find the next profile when merging and struct label it label iterator struct aa label label to merge struct aa label label to merge next profile else null if no more profile"
        },
        "free_pages_and_swap_cache": {
            "ground_truth": "0",
            "function": "free_pages_and_swap_cache",
            "description": "mm swap state passed an array of page drop them all from swapcache and then release them they are removed from the lru and freed if this is their last use"
        },
        "try_to_unmap_flush_dirty": {
            "ground_truth": "0",
            "function": "try_to_unmap_flush_dirty",
            "description": "mm internal flush iff there are potentially writable tlb entry that can race with io"
        },
        "unuse_pte": {
            "ground_truth": "0",
            "function": "unuse_pte",
            "description": "no need to decide whether this pte share the swap entry with others just let do wp page work it out if write is requested later to force cow vm page prot omits write permission from any private vma"
        },
        "deferred_pfn_valid": {
            "ground_truth": "0",
            "function": "deferred_pfn_valid",
            "description": "mm page alloc return true if page need to be initialized or freed to buddy allocator first we check if pfn is valid on architecture where it is possible to have hole within pageblock nr page on system where it is not possible this function is optimized out then we check if current large page is valid by only checking the validity of the head pfn"
        },
        "node_states_check_changes_online": {
            "ground_truth": "0",
            "function": "node_states_check_changes_online",
            "description": "mm memory hotplug check which state of node state will be changed when online memory"
        },
        "node_states_check_changes_offline": {
            "ground_truth": "0",
            "function": "node_states_check_changes_offline",
            "description": "mm memory hotplug check which state of node state will be changed when offline memory"
        },
        "pcpu_chunk_page": {
            "ground_truth": "0",
            "function": "pcpu_chunk_page",
            "description": "mm percpu vm mm percpu vm vmalloc area based chunk allocation copyright suse linux product gmbh copyright tejun heo chunk are mapped into vmalloc area and populated page by page this is the default chunk allocator"
        },
        "me_unknown": {
            "ground_truth": "0",
            "function": "me_unknown",
            "description": "mm memory failure page in unknown state do nothing"
        },
        "pgd_clear_bad": {
            "ground_truth": "0",
            "function": "pgd_clear_bad",
            "description": "mm pgtable generic if bad entry is found while walking page table report the error before resetting entry to none usually but very seldom called out from the none or clear bad macro"
        },
        "alloc_huge_page_vma": {
            "ground_truth": "0",
            "function": "alloc_huge_page_vma",
            "description": "include linux hugetlb mempolicy aware migration callback"
        },
        "tsi721_add_inb_buffer": {
            "ground_truth": "0",
            "function": "tsi721_add_inb_buffer",
            "description": "driver rapidio device tsi721 add buffer to the tsi721 inbound message queue struct rio mport mport master port implementing the inbound messaging engine int mbox inbound mailbox number void buf buffer to add to inbound queue"
        },
        "slab_order": {
            "ground_truth": "0",
            "function": "slab_order",
            "description": "mm slub calculate the order of allocation given an slab object size the order of allocation ha significant impact on performance and other system component generally order allocation should be preferred since order doe not cause fragmentation in the page allocator larger object be problematic to put into order slab because there may be too much unused space left we go to higher order if more than 16th of the slab would be wasted in order to reach satisfactory performance we must ensure that minimum number of object is in one slab otherwise we may generate too much activity on the partial list which requires taking the list lock this is le concern for large slab though which are rarely used slub max order specifies the order where we begin to stop considering the number of object in slab a critical if we reach slub max order then we try to keep the page order a low a possible so we accept more waste of space in favor of small page order higher order allocation also allow the placement of more object in slab and thereby reduce object handling overhead if the user ha requested higher mininum order then we start with that one instead of the smallest order which will fit the object"
        },
        "remap_pte_range": {
            "ground_truth": "0",
            "function": "remap_pte_range",
            "description": "mm memory map range of physical memory into the requested page the old mapping are removed any reference to nonexistent page result in null mapping currently treated a copy on access"
        },
        "lru_deactivate_file_fn": {
            "ground_truth": "0",
            "function": "lru_deactivate_file_fn",
            "description": "mm swap if the page can not be invalidated it is moved to the inactive list to speed up it reclaim it is moved to the head of the list rather than the tail to give the flusher thread some time to write it out a this is much more effective than the single page writeout from reclaim if the page is not page mapped and dirty writeback the page could reclaim asap using pg reclaim active mapped page none active dirty writeback page inactive head pg reclaim inactive mapped page none inactive dirty writeback page inactive head pg reclaim inactive clean inactive tail others none in why it move inactive is head the vm expects the page would be write it out by flusher thread a this is much more effective than the single page writeout from reclaim"
        },
        "hmm_vma_handle_pmd": {
            "ground_truth": "0",
            "function": "hmm_vma_handle_pmd",
            "description": "mm hmm stub to allow the code below to compile"
        },
        "get_fullness_group": {
            "ground_truth": "0",
            "function": "get_fullness_group",
            "description": "mm zsmalloc for each size class zspages are divided into different group depending on how full they are this wa done so that we could easily find empty or nearly empty zspages when we try to shrink the pool not yet implemented this function return fullness status of the given page"
        },
        "smack_key_free": {
            "ground_truth": "0",
            "function": "smack_key_free",
            "description": "security smack smack lsm clear the key security blob clear the blob pointer struct key key the object"
        },
        "setup_per_cpu_pageset": {
            "ground_truth": "0",
            "function": "setup_per_cpu_pageset",
            "description": "mm page alloc allocate per cpu pagesets and initialize them before this call only boot pagesets were available"
        },
        "addr_to_vb_idx": {
            "ground_truth": "0",
            "function": "addr_to_vb_idx",
            "description": "mm vmalloc we should probably have fallback mechanism to allocate virtual memory out of partially filled vmap block however vmap block sizing should be fairly reasonable according to the vmalloc size so it should not be big problem"
        },
        "madvise_behavior": {
            "ground_truth": "0",
            "function": "madvise_behavior",
            "description": "we can potentially split vm area into separate area each area with it own behavior"
        },
        "ondemand_readahead": {
            "ground_truth": "0",
            "function": "ondemand_readahead",
            "description": "minimal readahead algorithm for trivial sequential random read"
        },
        "selinux_xfrm_alloc_user": {
            "ground_truth": "0",
            "function": "selinux_xfrm_alloc_user",
            "description": "security selinux xfrm allocates xfrm sec state and populates it using the supplied security xfrm user sec ctx context"
        },
        "slub_cpu_dead": {
            "ground_truth": "0",
            "function": "slub_cpu_dead",
            "description": "mm slub use the cpu notifier to insure that the cpu slab are flushed when necessary"
        },
        "alloc_zspage": {
            "ground_truth": "0",
            "function": "alloc_zspage",
            "description": "mm zsmalloc allocate zspage for the given size class"
        },
        "opa_vnic_vema_report_event": {
            "ground_truth": "0",
            "function": "opa_vnic_vema_report_event",
            "description": "driver infiniband ulp opa vnic opa vnic vema iface sent trap to report the specified event this function call vema api to sent trap for the given event struct opa vnic adapter adapter vnic port adapter u8 event event to be reported"
        },
        "madvise_willneed": {
            "ground_truth": "0",
            "function": "madvise_willneed",
            "description": "schedule all required operation do not wait for completion"
        },
        "arch_get_unmapped_area_topdown": {
            "ground_truth": "0",
            "function": "arch_get_unmapped_area_topdown",
            "description": "arch powerpc mm slice this mmap allocator allocates new area top down from below the stack is low limit the base"
        },
        "obj_offset": {
            "ground_truth": "0",
            "function": "obj_offset",
            "description": "mm slab memory layout of object objp cachep obj offset byte per word padding this ensures that the end of an object is aligned with the end of the real allocation catch writes behind the end of the allocation cachep obj offset byte per word cachep obj offset redzone word cachep obj offset the real object cachep size byte per word redzone word byte per word long cachep size byte per word last caller address byte per word long"
        },
        "pageset_set_batch": {
            "ground_truth": "0",
            "function": "pageset_set_batch",
            "description": "mm page alloc companion to pageset set high"
        },
        "delete_object_part": {
            "ground_truth": "0",
            "function": "delete_object_part",
            "description": "mm kmemleak look up the metadata struct kmemleak object corresponding to ptr and delete it if the memory block is partially freed the function may create additional metadata for the remaining part of the block"
        },
        "adjust_range_if_pmd_sharing_possible": {
            "ground_truth": "0",
            "function": "adjust_range_if_pmd_sharing_possible",
            "description": "include linux hugetlb determine if start end range within vma could be mapped by shared pmd if yes adjust start and end to cover range associated with possible shared pmd mapping"
        },
        "special_mapping_close": {
            "ground_truth": "0",
            "function": "special_mapping_close",
            "description": "having close hook prevents vma merging regardless of flag"
        },
        "__writepage": {
            "ground_truth": "0",
            "function": "__writepage",
            "description": "mm page writeback function used by generic writepages to call the real writepage function and set the mapping flag on error"
        },
        "__mem_cgroup_clear_mc": {
            "ground_truth": "0",
            "function": "__mem_cgroup_clear_mc",
            "description": "mm memcontrol cancel all extra charge on mc from and mc to and wake up all waiter"
        },
        "shrink_inactive_list": {
            "ground_truth": "0",
            "function": "shrink_inactive_list",
            "description": "mm vmscan shrink inactive list is helper for shrink node it return the number of reclaimed page"
        },
        "__attribute__": {
            "ground_truth": "0",
            "function": "__attribute__",
            "description": "indicate the cpu delay calibration is done this can be used by architecture to stop accepting delay timer registration after this point"
        },
        "kswapd_run": {
            "ground_truth": "0",
            "function": "kswapd_run",
            "description": "mm vmscan this kswapd start function will be called by init and node hot add on node hot add kswapd will moved to proper cpu if cpu are hot added"
        },
        "pcpu_block_update_scan": {
            "ground_truth": "0",
            "function": "pcpu_block_update_scan",
            "description": "mm percpu pcpu block update scan update block given free area from scan finding the final allocation spot first go through pcpu find block fit to find block that can hold the allocation and then pcpu alloc area where scan is used when allocation require specific alignment we can inadvertently create hole which will not be seen in the alloc or free path this take given free area hole and update block a it may change the scan hint we need to scan backwards to ensure we do not miss free bit from alignment chunk chunk of interest bit off chunk offset bit size of free area"
        },
        "page_mapped": {
            "ground_truth": "0",
            "function": "page_mapped",
            "description": "mm util return true if this page is mapped into pagetables for compound page it return true if any subpage of compound page is mapped"
        },
        "deferred_init_maxorder": {
            "ground_truth": "0",
            "function": "deferred_init_maxorder",
            "description": "mm page alloc initialize and free page we do it in two loop first we initialize struct page then free to buddy allocator because while we are freeing page we can access page that are ahead computing buddy page in free one page in order to try and keep some memory in the cache we have the loop broken along max page order boundary this way we will not cause any issue with the buddy page computation"
        },
        "smack_sock_graft": {
            "ground_truth": "0",
            "function": "smack_sock_graft",
            "description": "security smack smack lsm initialize newly created socket with an existing sock set the smk in out state of an existing sock based on the process that is creating the new socket struct sock sk child sock struct socket parent parent socket"
        },
        "store_filter": {
            "ground_truth": "0",
            "function": "store_filter",
            "description": "driver medium rc rc main change the scancode filter value this routine is for changing scancode filter value or mask it is triggered by writing to sys class rc rc wakeup filter mask return einval if an invalid filter value for the current protocol wa specified or if scancode filtering is not supported by the driver otherwise return len bit of the filter value corresponding to set bit in the filter mask are compared against input scancodes and non matching scancodes are discarded dev lock is taken to guard against race between store filter and show filter struct device device the device descriptor struct device attribute attr the device attribute struct const char buf pointer to the input buffer size len length of the input buffer"
        },
        "fault_around_bytes_set": {
            "ground_truth": "0",
            "function": "fault_around_bytes_set",
            "description": "mm memory fault around byte must be rounded down to the nearest page order a it is what do fault around expects to see"
        },
        "add_to_free_list": {
            "ground_truth": "0",
            "function": "add_to_free_list",
            "description": "mm page alloc used for page not on another list"
        },
        "__kmem_cache_alloc_bulk": {
            "ground_truth": "0",
            "function": "__kmem_cache_alloc_bulk",
            "description": "mm slab common generic implementation of bulk operation these are useful for situation in which the allocator cannot perform optimization in that case segment of the object listed may be allocated or freed using these operation"
        },
        "scan_large_block": {
            "ground_truth": "0",
            "function": "scan_large_block",
            "description": "mm kmemleak scan large memory block in max scan size chunk to reduce the latency"
        },
        "buddy_order": {
            "ground_truth": "0",
            "function": "buddy_order",
            "description": "mm internal this function return the order of free page in the buddy system in general page zone page lock must be held by the caller to prevent the page from being allocated in parallel and returning garbage a the order if caller doe not hold page zone page lock it must guarantee that the page cannot be allocated or merged in parallel alternatively it must handle invalid value gracefully and use buddy order unsafe below"
        },
        "hugetlbfs_pagecache_present": {
            "ground_truth": "0",
            "function": "hugetlbfs_pagecache_present",
            "description": "mm hugetlb return whether there is pagecache page to back given address within vma caller follow hugetlb page hold page table lock so we cannot lock page"
        },
        "__early_pfn_to_nid": {
            "ground_truth": "0",
            "function": "__early_pfn_to_nid",
            "description": "arch ia64 mm numa required by sparsemem given pfn return what node the pfn is on"
        },
        "policy_node": {
            "ground_truth": "0",
            "function": "policy_node",
            "description": "return the node id preferred by the given mempolicy or the given id"
        },
        "__split_vma": {
            "ground_truth": "0",
            "function": "__split_vma",
            "description": "split vma bypass sysctl max map count checking we use this where it ha already been checked or doe not make sense to fail"
        },
        "migrate_misplaced_page": {
            "ground_truth": "0",
            "function": "migrate_misplaced_page",
            "description": "include linux migrate attempt to migrate misplaced page to the specified destination node caller is expected to have an elevated reference count on the page that will be dropped by this function before returning"
        },
        "do_async_mmap_readahead": {
            "ground_truth": "0",
            "function": "do_async_mmap_readahead",
            "description": "mm filemap asynchronous readahead happens when we find the page and pg readahead so we want to possibly extend the readahead further we return the file that wa pinned if we have to drop the mmap lock in order to do io"
        },
        "__frontswap_shrink": {
            "ground_truth": "0",
            "function": "__frontswap_shrink",
            "description": "mm frontswap used to check if it is necessary and feasible to unuse page return when nothing to do when need to shrink page error code when there is an error"
        },
        "migrate_page_add": {
            "ground_truth": "0",
            "function": "migrate_page_add",
            "description": "page migration thp tail page can be passed"
        },
        "rxrpc_kernel_end_call": {
            "ground_truth": "0",
            "function": "rxrpc_kernel_end_call",
            "description": "allow kernel service to end call it wa using allow kernel service to end call it wa using the call must be complete before this is called the call should be aborted if necessary struct socket sock the socket the call is on struct rxrpc call call the call to end"
        },
        "vma_kernel_pagesize": {
            "ground_truth": "0",
            "function": "vma_kernel_pagesize",
            "description": "include linux hugetlb return the size of the page allocated when backing vma in the majority case this will be same size a used by the page table entry"
        },
        "__gup_longterm_locked": {
            "ground_truth": "0",
            "function": "__gup_longterm_locked",
            "description": "mm gup gup longterm locked is wrapper for get user page locked which allows u to process the foll longterm flag"
        },
        "pageset_update": {
            "ground_truth": "0",
            "function": "pageset_update",
            "description": "mm page alloc pcp high and pcp batch value are related and dependent on one another batch must never be higher then high the following function update them in safe manner without read side locking any new user of pcp batch and pcp high should ensure they can cope with those field changing asynchronously acording to the above rule mutex is locked pcp batch high lock required when calling this function outside of boot time or some other assurance that no concurrent updaters exist"
        },
        "__mpol_equal": {
            "ground_truth": "0",
            "function": "__mpol_equal",
            "description": "slow path of mempolicy comparison"
        },
        "gup_fast_permitted": {
            "ground_truth": "0",
            "function": "gup_fast_permitted",
            "description": "arch x86 include asm pgtable check if it is allowed to use get user page fast only for the range or we need to fall back to the slow version"
        },
        "drain_pages": {
            "ground_truth": "0",
            "function": "drain_pages",
            "description": "mm page alloc drain pcplists of all zone on the indicated processor the processor must either be the current processor and the thread pinned to the current processor or processor that is not online"
        },
        "iavf_add_ethtool_stats": {
            "ground_truth": "0",
            "function": "iavf_add_ethtool_stats",
            "description": "copy stats into ethtool supplied buffer macro to ease the use of iavf add ethtool stats by taking static constant stats array and passing the array size this avoids typo by ensuring that we pas the size associated with the given stats array the parameter stats is evaluated twice so parameter with side effect should be avoided data ethtool stats buffer pointer location where stats are stored stats static const array of stat definition"
        },
        "alloc_fresh_huge_page": {
            "ground_truth": "0",
            "function": "alloc_fresh_huge_page",
            "description": "mm hugetlb common helper to allocate fresh hugetlb page all specific allocator should use this function to get new hugetlb page"
        },
        "do_mq_notify": {
            "ground_truth": "0",
            "function": "do_mq_notify",
            "description": "note the case when user want u to deregister with null a pointer and he is not currently owner of notification will be silently discarded it is not explicitly defined in the posix"
        },
        "drain_all_pages": {
            "ground_truth": "0",
            "function": "drain_all_pages",
            "description": "mm page alloc spill all the per cpu page from all cpu back into the buddy allocator when zone parameter is non null spill just the single zone is page note that this can be extremely slow a the draining happens in workqueue"
        },
        "fix_fullness_group": {
            "ground_truth": "0",
            "function": "fix_fullness_group",
            "description": "mm zsmalloc each size class maintains zspages in different fullness group depending on the number of live object they contain when allocating or freeing object the fullness status of the page can change say from almost full to almost empty when freeing an object this function check if such status change ha occurred for the given page and accordingly move the page from the freelist of the old fullness group to that of the new fullness group"
        },
        "migrate_misplaced_transhuge_page": {
            "ground_truth": "0",
            "function": "migrate_misplaced_transhuge_page",
            "description": "include linux migrate migrates thp to given target node page must be locked and is unlocked before returning"
        },
        "shuffle_freelist": {
            "ground_truth": "0",
            "function": "shuffle_freelist",
            "description": "mm slub shuffle the freelist initialization state based on pre computed list return true if the list wa successfully shuffled false otherwise"
        },
        "read_cache_pages_invalidate_pages": {
            "ground_truth": "0",
            "function": "read_cache_pages_invalidate_pages",
            "description": "release list of page invalidating them first if need be"
        },
        "free_pcp_prepare": {
            "ground_truth": "0",
            "function": "free_pcp_prepare",
            "description": "mm page alloc with debug vm enabled order page are checked immediately when being freed to pcp list with debug pagealloc also enabled they are also rechecked when moved from pcp list to free list"
        },
        "frontswap_register_ops": {
            "ground_truth": "0",
            "function": "frontswap_register_ops",
            "description": "mm frontswap register operation for frontswap"
        },
        "handle_to_zbud_header": {
            "ground_truth": "0",
            "function": "handle_to_zbud_header",
            "description": "mm zbud return the zbud page where given handle is stored"
        },
        "get_pcppage_migratetype": {
            "ground_truth": "0",
            "function": "get_pcppage_migratetype",
            "description": "mm page alloc cached value of the page is pageblock is migratetype used when the page is put on pcplist used to avoid the pageblock migratetype lookup when freeing from pcplists in most case at the cost of possibly becoming stale also the migratetype set in the page doe not necessarily match the pcplist index page might have migrate cma set but be on pcplist with any other index this ensures that it will be put on the correct cma freelist"
        },
        "ena_com_get_eni_stats": {
            "ground_truth": "0",
            "function": "ena_com_get_eni_stats",
            "description": "driver net ethernet amazon ena ena com ena com get eni stats get extended network interface statistic ena dev ena communication layer struct stats stats return value return on success and negative value otherwise"
        },
        "find_vma_prev": {
            "ground_truth": "0",
            "function": "find_vma_prev",
            "description": "same a find vma but also return pointer to the previous vma in pprev"
        },
        "kmemleak_scan": {
            "ground_truth": "0",
            "function": "kmemleak_scan",
            "description": "mm kmemleak scan data section and all the referenced memory block allocated via the kernel is standard allocator this function must be called with the scan mutex held"
        },
        "early_page_uninitialised": {
            "ground_truth": "0",
            "function": "early_page_uninitialised",
            "description": "mm page alloc return true if the struct page for the pfn is uninitialised"
        },
        "mem_map_next": {
            "ground_truth": "0",
            "function": "mem_map_next",
            "description": "mm internal iterator over all subpages within the maximally aligned gigantic page base handle any discontiguity in the mem map"
        },
        "slob_units": {
            "ground_truth": "0",
            "function": "slob_units",
            "description": "mm slob return the size of slob block"
        },
        "freelist_randomize": {
            "ground_truth": "0",
            "function": "freelist_randomize",
            "description": "mm slab common randomize generic freelist"
        },
        "cpu_vm_stats_fold": {
            "ground_truth": "0",
            "function": "cpu_vm_stats_fold",
            "description": "include linux vmstat fold the data for an offline cpu into the global array there cannot be any access by the offline cpu and therefore synchronization is simplified"
        },
        "mm_init": {
            "ground_truth": "0",
            "function": "mm_init",
            "description": "driver block umem set up kernel memory allocator"
        },
        "check_pad_bytes": {
            "ground_truth": "0",
            "function": "check_pad_bytes",
            "description": "mm slub object layout object address byte of the object to be managed if the freepointer may overlay the object then the free pointer is at the middle of the object poisoning us poison free and the last byte is poison end object object size padding to reach word boundary this is also used for redzoning padding is extended by another word if redzoning is enabled and object size inuse we fill with red inactive for inactive object and with red active for object in use object inuse meta data start here free pointer if we cannot overwrite object on free tracking data for slab store user padding to reach required alignment boundary or at mininum one word if debugging is on to be able to detect writes before the word boundary padding is done using poison inuse object size nothing is used beyond size if slabcaches are merged then the object size and inuse boundary are mostly ignored and therefore no slab option that rely on these boundary may be used with merged slabcaches"
        },
        "__perform_reclaim": {
            "ground_truth": "0",
            "function": "__perform_reclaim",
            "description": "mm page alloc perform direct synchronous page reclaim"
        },
        "__set_page_dirty_no_writeback": {
            "ground_truth": "0",
            "function": "__set_page_dirty_no_writeback",
            "description": "mm page writeback for address space which do not use buffer nor write back"
        },
        "region_add": {
            "ground_truth": "0",
            "function": "region_add",
            "description": "mm hugetlb add the huge page range represented by to the reserve map region will be taken from the cache to fill in this range sufficient region should exist in the cache due to the previous call to region chg with the same range but in some case the cache will not have sufficient entry due to race with other code doing region add or region del the extra needed entry will be allocated region needed is the out value provided by previous call to region chg return the number of new huge page added to the map this number is greater than or equal to zero if file region entry needed to be allocated for this operation and we were not able to allocate it return enomem region add of region of length never allocate file region and cannot fail region chg will always allocate at least entry and region add for page will only require at most entry"
        },
        "shmem_reconfigure": {
            "ground_truth": "0",
            "function": "shmem_reconfigure",
            "description": "mm shmem reconfigure shmem filesystem note that we disallow change from limited unlimited block inodes while any are in use but we must separately disallow unlimited limited because in that case we have no record of how much is already in use"
        },
        "unknown_bootoption": {
            "ground_truth": "0",
            "function": "unknown_bootoption",
            "description": "init main unknown boot option get handed to init unless they look like unused parameter modprobe will find them in proc cmdline"
        },
        "vm_events_fold_cpu": {
            "ground_truth": "0",
            "function": "vm_events_fold_cpu",
            "description": "include linux vmstat fold the foreign cpu event into our own this is adding to the event on one processor but keep the global count constant"
        },
        "nr_hugepages_mempolicy_show": {
            "ground_truth": "0",
            "function": "nr_hugepages_mempolicy_show",
            "description": "mm hugetlb hstate attribute for optionally mempolicy based constraint on persistent huge page alloc free"
        },
        "__p4d_alloc": {
            "ground_truth": "0",
            "function": "__p4d_alloc",
            "description": "include linux mm allocate p4d page table we have already handled the fast path in line"
        },
        "__rmqueue_pcplist": {
            "ground_truth": "0",
            "function": "__rmqueue_pcplist",
            "description": "mm page alloc remove page from the per cpu list caller must protect the list"
        },
        "me_pagecache_dirty": {
            "ground_truth": "0",
            "function": "me_pagecache_dirty",
            "description": "mm memory failure dirty pagecache page issue when the error hit hole page the error is not properly propagated"
        },
        "section_mark_present": {
            "ground_truth": "0",
            "function": "section_mark_present",
            "description": "mm sparse there are number of time that we loop over nr mem section looking for section present on each but when we have very large physical address space nr mem section can also be very large which make the loop quite long keeping track of this give u an easy way to break out of those loop early"
        },
        "zswap_entry_put": {
            "ground_truth": "0",
            "function": "zswap_entry_put",
            "description": "mm zswap caller must hold the tree lock remove from the tree and free it if nobody reference the entry"
        },
        "vma_merge": {
            "ground_truth": "0",
            "function": "vma_merge",
            "description": "given mapping request addr end vm flag file pgoff figure out whether that can be merged with it predecessor or it successor or both it neatly fill hole in most case when called for mmap brk or mremap addr end is certain not to be mapped by the time vma merge is called but when called for mprotect it is certain to be already mapped either at an offset within prev or at the start of next and the flag of this area are about to be changed to vm flag and the no change case ha already been eliminated the following mprotect case have to be considered where aaaa is the area passed down from mprotect fixup never extending beyond one vma pppppp is the prev vma specified and nnnnnn the next vma after aaaa aaaa aaaa ppppppnnnnnn ppppppnnnnnn ppppppnnnnnn cannot merge might become might become ppnnnnnnnnnn ppppppppppnn mmap brk or case below case below mremap move aaaa aaaa pppp nnnn ppppnnnnxxxx might become might become pppppppppppp or pppppppppppp or ppppppppnnnn or ppppppppxxxx or ppppnnnnnnnn ppppxxxxxxxx it is important for case that the vma nnnn overlapping the region aaaa is never going to extended over xxxx instead xxxx must be extended in region aaaa and nnnn must be removed this way in all case where vma merge succeeds the moment vma adjust drop the rmap lock the property of the merged vma will be already correct for the whole merged range some of those property like vm page prot vm flag may be accessed by rmap walk and they must be correct for the whole merged range immediately after the rmap lock are released otherwise if xxxx would be removed and nnnn would be extended over the xxxx range remove migration ptes or other rmap walker if working on address beyond the end parameter may establish ptes with the wrong permission of nnnn instead of the right permission of xxxx"
        },
        "__mm_populate": {
            "ground_truth": "0",
            "function": "__mm_populate",
            "description": "mm gup mm populate populate and or mlock page within range of address space this is used to implement mlock and the map populate map locked mmap flag vmas must be already marked with the desired vm flag and mmap lock must not be held"
        },
        "freelist_state_initialize": {
            "ground_truth": "0",
            "function": "freelist_state_initialize",
            "description": "mm slab initialize the state based on the randomization methode available return true if the pre computed list is available false otherwize"
        },
        "putback_zspage": {
            "ground_truth": "0",
            "function": "putback_zspage",
            "description": "mm zsmalloc putback zspage add zspage into right class is fullness list class destination class zspage target page return zspage is fullness group"
        },
        "shrink_page_list": {
            "ground_truth": "0",
            "function": "shrink_page_list",
            "description": "mm vmscan shrink page list return the number of reclaimed page"
        },
        "quiet_vmstat": {
            "ground_truth": "0",
            "function": "quiet_vmstat",
            "description": "include linux vmstat switch off vmstat processing and then fold all the remaining differential until the diffs stay at zero the function is used by nohz and can only be invoked when tick processing is not active"
        },
        "prepare_copy": {
            "ground_truth": "0",
            "function": "prepare_copy",
            "description": "this function creates new kernel message structure large enough to store bufsz message byte"
        },
        "access_process_vm": {
            "ground_truth": "0",
            "function": "access_process_vm",
            "description": "mm memory access another process address space source target buffer must be kernel space"
        },
        "me_huge_page": {
            "ground_truth": "0",
            "function": "me_huge_page",
            "description": "mm memory failure huge page need work issue error on hugepage is contained in hugepage unit not in raw page unit to narrow down kill region to one page we need to break up pmd"
        },
        "cmp_and_merge_page": {
            "ground_truth": "0",
            "function": "cmp_and_merge_page",
            "description": "mm ksm cmp and merge page first see if page can be merged into the stable tree if not compare checksum to previous and if it is the same see if page can be inserted into the unstable tree or merged with page already there and both transferred to the stable tree page the page that we are searching identical page to rmap item the reverse mapping into the virtual address of this page"
        },
        "__rmqueue": {
            "ground_truth": "0",
            "function": "__rmqueue",
            "description": "mm page alloc do the hard work of removing an element from the buddy allocator call me with the zone lock already held"
        },
        "hugetlb_page_mapping_lock_write": {
            "ground_truth": "0",
            "function": "hugetlb_page_mapping_lock_write",
            "description": "include linux hugetlb find and lock address space mapping in write mode upon entry the page is locked which allows u to find the mapping even in the case of an anon page however locking order dictate the mmap rwsem be acquired before the page lock this is hugetlbfs specific so we first try to lock the sema while still holding the page lock if this work great if not then we need to drop the page lock and then acquire mmap rwsem and reacquire page lock of course need to revalidate state along the way"
        },
        "build_all_zonelists": {
            "ground_truth": "0",
            "function": "build_all_zonelists",
            "description": "mm page alloc unless system state system booting ref due to call of init annotated helper build all zonelists init protected by system booting"
        },
        "hugetlb_cgroup_move_parent": {
            "ground_truth": "0",
            "function": "hugetlb_cgroup_move_parent",
            "description": "mm hugetlb cgroup should be called with hugetlb lock held since we are holding hugetlb lock page cannot get moved from active list or uncharged from the cgroup so no need to get page reference and test for page active here this function cannot fail"
        },
        "free_vmap_area_noflush": {
            "ground_truth": "0",
            "function": "free_vmap_area_noflush",
            "description": "mm vmalloc free vmap area caller ensuring that the area ha been unmapped and flush cache vunmap had been called for the correct range previously"
        },
        "wp_clean_pre_vma": {
            "ground_truth": "0",
            "function": "wp_clean_pre_vma",
            "description": "mm mapping dirty helper wp clean pre vma the pagewalk pre vma callback the pre vma callback performs the cache flush stage the tlb flush and call the necessary mmu notifiers"
        },
        "online_mem_sections": {
            "ground_truth": "0",
            "function": "online_mem_sections",
            "description": "mm sparse mark all memory section within the pfn range a online"
        },
        "chipio_8051_write_direct": {
            "ground_truth": "0",
            "function": "chipio_8051_write_direct",
            "description": "sound pci hda patch ca0132 writes to the is internal address space directly instead of indirectly giving access to the special function register located at address"
        },
        "do_pages_move": {
            "ground_truth": "0",
            "function": "do_pages_move",
            "description": "migrate an array of page address onto an array of node and fill the corresponding array of status"
        },
        "cmdline_parse_movablecore": {
            "ground_truth": "0",
            "function": "cmdline_parse_movablecore",
            "description": "mm page alloc movablecore size set the amount of memory for use for allocation that can be reclaimed or migrated"
        },
        "swap_count_continued": {
            "ground_truth": "0",
            "function": "swap_count_continued",
            "description": "swap count continued when the original swap map count is incremented from swap map max check if there is already continuation page to carry into carry if so or else fail until new continuation page is allocated when the original swap map count is decremented from with continuation borrow from the continuation and report whether it still hold more called while swap duplicate or swap entry free hold swap or cluster lock"
        },
        "invalidate_inode_page": {
            "ground_truth": "0",
            "function": "invalidate_inode_page",
            "description": "mm truncate safely invalidate one page from it pagecache mapping it only drop clean unused page the page must be locked return if the page is successfully invalidated otherwise"
        },
        "region_chg": {
            "ground_truth": "0",
            "function": "region_chg",
            "description": "mm hugetlb examine the existing reserve map and determine how many huge page in the specified range are not currently represented this routine is called before subsequent call to region add that will actually modify the reserve map to add the specified range region chg doe not change the number of huge page represented by the map number of new file region structure is added to the cache a placeholder for the subsequent region add call to use at least file region structure is added out region needed is the number of region added to the resv add in progress this value need to be provided to follow up call to region add or region abort for proper accounting return the number of huge page that need to be added to the existing reservation map for the range this number is greater or equal to zero enomem is returned if new file region structure or cache entry is needed and can not be allocated"
        },
        "mem_cgroup_swap_init": {
            "ground_truth": "0",
            "function": "mem_cgroup_swap_init",
            "description": "mm memcontrol if mem cgroup swap init is implemented a subsys initcall instead of core initcall this could mean cgroup memory noswap still remains set to false even when memcg is disabled via cgroup disable memory boot parameter this may result in premature oops inside mem cgroup get nr swap page function in corner case"
        },
        "get_pageblock_bitmap": {
            "ground_truth": "0",
            "function": "get_pageblock_bitmap",
            "description": "mm page alloc return pointer to the bitmap storing bit affecting block of page"
        },
        "mminit_verify_zonelist": {
            "ground_truth": "0",
            "function": "mminit_verify_zonelist",
            "description": "mm internal the zonelists are simply reported validation is manual"
        },
        "init_admin_reserve": {
            "ground_truth": "0",
            "function": "init_admin_reserve",
            "description": "initialise sysctl admin reserve kbytes the purpose of sysctl admin reserve kbytes is to allow the sys admin to log in and kill memory hogging process system with more than 256mb will reserve 8mb enough to recover with sshd bash and top in overcommit guess smaller system will only reserve of free page by default"
        },
        "is_stack_mapping": {
            "ground_truth": "0",
            "function": "is_stack_mapping",
            "description": "mm internal stack area atomatically grows in one direction vm growsup vm growsdown vmas are always private anonymous do mmap forbids all other combination"
        },
        "usb4_port_enumerate_retimers": {
            "ground_truth": "0",
            "function": "usb4_port_enumerate_retimers",
            "description": "driver thunderbolt usb4 send rt broadcast transaction this force the usb4 port to send broadcast rt transaction which make the retimers on the link to assign index to themselves return in case of success and negative errno if there wa an error struct tb port port usb4 port"
        },
        "vmci_route": {
            "ground_truth": "0",
            "function": "vmci_route",
            "description": "driver misc vmw vmci vmci route make routing decision for the given source and destination handle this will try to determine the route using the handle and the available device will set the source context if it is invalid"
        },
        "vma_hugecache_offset": {
            "ground_truth": "0",
            "function": "vma_hugecache_offset",
            "description": "mm hugetlb convert the address within this vma to the page offset within the mapping in pagecache page unit huge page here"
        },
        "default_rootfs": {
            "ground_truth": "0",
            "function": "default_rootfs",
            "description": "init noinitramfs create simple rootfs that is similar to the default initramfs"
        },
        "madvise_free_huge_pmd": {
            "ground_truth": "0",
            "function": "madvise_free_huge_pmd",
            "description": "mm huge memory return true if we do madv free successfully on entire pmd page otherwise return false"
        },
        "trace_wbt_timer": {
            "ground_truth": "0",
            "function": "trace_wbt_timer",
            "description": "trace wb timer event struct backing dev info bdi undescribed unsigned int status timer state status int step the current scale step count unsigned int inflight tracked writes inflight"
        },
        "update_checksum": {
            "ground_truth": "0",
            "function": "update_checksum",
            "description": "mm kmemleak update an object is checksum and return true if it wa modified"
        },
        "is_exec_mapping": {
            "ground_truth": "0",
            "function": "is_exec_mapping",
            "description": "mm internal executable code area executable not writable not stack"
        },
        "__zone_watermark_ok": {
            "ground_truth": "0",
            "function": "__zone_watermark_ok",
            "description": "mm page alloc return true if free base page are above amark for high order check it will return true of the order watermark is reached and there is at least one free page of suitable size checking now avoids taking the zone lock to check in the allocation path if no page are free"
        },
        "hugetlb_mcopy_atomic_pte": {
            "ground_truth": "0",
            "function": "hugetlb_mcopy_atomic_pte",
            "description": "include linux hugetlb used by userfaultfd uffdio copy based on mcopy atomic pte with modification for huge page"
        },
        "msgctl_down": {
            "ground_truth": "0",
            "function": "msgctl_down",
            "description": "this function handle some msgctl command which require the rwsem to be held in write mode note no lock must be held the rwsem is taken inside this function"
        },
        "do_mmap": {
            "ground_truth": "0",
            "function": "do_mmap",
            "description": "tool testing selftests net mptcp mptcp connect handle mapping creation for uclinux"
        },
        "alloc_block": {
            "ground_truth": "0",
            "function": "alloc_block",
            "description": "mm slab slab list should be fixed up by fixup slab list for existing slab or cache grow end for new slab"
        },
        "try_get_compound_head": {
            "ground_truth": "0",
            "function": "try_get_compound_head",
            "description": "mm gup return the compound head page with ref appropriately incremented or null if that failed"
        },
        "pcpu_index_alloc_map": {
            "ground_truth": "0",
            "function": "pcpu_index_alloc_map",
            "description": "mm percpu the following are helper function to help access bitmap and convert between bitmap offset to address offset"
        },
        "account_page_dirtied": {
            "ground_truth": "0",
            "function": "account_page_dirtied",
            "description": "mm page writeback helper function for set page dirty family caller must hold lock page memcg note this relies on being atomic wrt interrupt"
        },
        "shm_add_rss_swap": {
            "ground_truth": "0",
            "function": "shm_add_rss_swap",
            "description": "calculate and add used r and swap page of shm called with shm id rwsem held a reader"
        },
        "find_alloced_obj": {
            "ground_truth": "0",
            "function": "find_alloced_obj",
            "description": "mm zsmalloc find alloced object in zspage from index object and return handle"
        },
        "mdtc_calc_avail": {
            "ground_truth": "0",
            "function": "mdtc_calc_avail",
            "description": "mm page writeback memory which can be further allocated to memcg domain is capped by system wide clean memory excluding the amount being used in the domain"
        },
        "__find_buddy_pfn": {
            "ground_truth": "0",
            "function": "__find_buddy_pfn",
            "description": "mm internal locate the struct page for both the matching buddy in our pair buddy1 and the combined page they form page any buddy b1 will have an order twin b2 which satisfies the following equation b2 b1 for example if the starting buddy buddy2 is it order buddy is b2 any buddy will have an order parent which satisfies the following equation assumption mem map is contiguous at least up to max order"
        },
        "fcoe_ctlr_recv_clr_vlink": {
            "ground_truth": "0",
            "function": "fcoe_ctlr_recv_clr_vlink",
            "description": "driver scsi fcoe fcoe ctlr handle an incoming link reset frame there may be multiple vn port descriptor the overall length ha already been checked struct fcoe ctlr fip the fcoe controller that received the frame struct sk buff skb the received fip packet"
        },
        "expand_downwards": {
            "ground_truth": "0",
            "function": "expand_downwards",
            "description": "vma is the first one with address vma vm start have to extend vma"
        },
        "__slab_free": {
            "ground_truth": "0",
            "function": "__slab_free",
            "description": "mm slub slow path handling this may still be called frequently since object have longer lifetime than the cpu slab in most processing load so we still attempt to reduce cache line usage just take the slab lock and free the item if there is no additional partial page handling required then we can return immediately"
        },
        "shuffle_valid_page": {
            "ground_truth": "0",
            "function": "shuffle_valid_page",
            "description": "mm shuffle for two page to be swapped in the shuffle they must be free on free area lru have the same order and have the same migratetype"
        },
        "mm_drop_all_locks": {
            "ground_truth": "0",
            "function": "mm_drop_all_locks",
            "description": "the mmap lock cannot be released by the caller until mm drop all lock return"
        },
        "page_trans_huge_mapcount": {
            "ground_truth": "0",
            "function": "page_trans_huge_mapcount",
            "description": "include linux mm this calculates accurately how many mapping transparent hugepage ha unlike page mapcount which is not fully accurate this full accuracy is primarily needed to know if copy on write fault can reuse the page and change the mapping to read write instead of copying them at the same time this return the total mapcount too the function return the highest mapcount any one of the subpages ha if the return value is one even if different process are mapping different subpages of the transparent hugepage they can all reuse it because each process is reusing different subpage the total mapcount is instead counting all virtual mapping of the subpages if the total mapcount is equal to one it tell the caller all mapping belong to the same mm and in turn the anon vma of the transparent hugepage can become the vma anon vma local one a no other process may be mapping any of the subpages it would be more accurate to replace page mapcount with page trans huge mapcount however we only use page trans huge mapcount in the copy on write fault where we need full accuracy to avoid breaking page pinning because page trans huge mapcount is slower than page mapcount"
        },
        "apply_to_existing_page_range": {
            "ground_truth": "0",
            "function": "apply_to_existing_page_range",
            "description": "mm memory scan region of virtual memory calling provided function on each leaf page table where it exists unlike apply to page range this doe not fill in page table where they are absent"
        },
        "do_get_mempolicy": {
            "ground_truth": "0",
            "function": "do_get_mempolicy",
            "description": "retrieve numa policy"
        },
        "deferred_init_mem_pfn_range_in_zone": {
            "ground_truth": "0",
            "function": "deferred_init_mem_pfn_range_in_zone",
            "description": "mm page alloc this function is meant to pre load the iterator for the zone init specifically it walk through the range until we are caught up to the first init pfn value and exit there if we never encounter the value we return false indicating there are no valid range left"
        },
        "page_swapcount": {
            "ground_truth": "0",
            "function": "page_swapcount",
            "description": "include linux swap how many reference to page are currently swapped out this doe not give an exact answer when swap count is continued but doe include the high count continued flag to allow for that"
        },
        "shm_get_stat": {
            "ground_truth": "0",
            "function": "shm_get_stat",
            "description": "called with shm id rwsem held a reader"
        },
        "migrate_balanced_pgdat": {
            "ground_truth": "0",
            "function": "migrate_balanced_pgdat",
            "description": "return true if this is safe migration target node for misplaced numa page currently it only check the watermark which crude"
        },
        "__asan_register_globals": {
            "ground_truth": "0",
            "function": "__asan_register_globals",
            "description": "mm kasan generic exported function for interface called from assembly or from generated code declaration here to avoid warning about missing declaration"
        },
        "__slab_alloc": {
            "ground_truth": "0",
            "function": "__slab_alloc",
            "description": "mm slub another one that disabled interrupt and compensates for possible cpu change by refetching the per cpu area pointer"
        },
        "pmd_clear_bad": {
            "ground_truth": "0",
            "function": "pmd_clear_bad",
            "description": "mm pgtable generic note that the pmd variant below can not be stub ed out just a for p4d pud above pmd folding is special and typically pmd macro refer to upper level even when folded"
        },
        "free_area_init_core_hotplug": {
            "ground_truth": "0",
            "function": "free_area_init_core_hotplug",
            "description": "mm page alloc set up the zone data structure init pgdat internals init all zone belonging to this node note this function is only called during memory hotplug"
        },
        "get_kernel_page": {
            "ground_truth": "0",
            "function": "get_kernel_page",
            "description": "mm swap get kernel page pin kernel page in memory must be at least nr segs long start starting kernel address write pinning for read write currently ignored page array that receives pointer to the page pinned return if page is pinned if the page wa not pinned return errno the page returned must be released with put page call when it is finished with"
        },
        "free_unref_page": {
            "ground_truth": "0",
            "function": "free_unref_page",
            "description": "mm page alloc free order page"
        },
        "shmem_link": {
            "ground_truth": "0",
            "function": "shmem_link",
            "description": "mm shmem link file"
        },
        "sp_lookup": {
            "ground_truth": "0",
            "function": "sp_lookup",
            "description": "lookup first element intersecting start end caller hold sp lock for reading or for writing"
        },
        "make_black_object": {
            "ground_truth": "0",
            "function": "make_black_object",
            "description": "mm kmemleak mark the object a black colored so that it is ignored from scan and reporting"
        },
        "free_vmap_area": {
            "ground_truth": "0",
            "function": "free_vmap_area",
            "description": "mm vmalloc free region of kva allocated by alloc vmap area"
        },
        "free_pgd_range": {
            "ground_truth": "0",
            "function": "free_pgd_range",
            "description": "mm memory this function free user level page table of process"
        },
        "shmem_undo_range": {
            "ground_truth": "0",
            "function": "shmem_undo_range",
            "description": "mm shmem remove range of page and swap entry from page cache and free them if unfalloc truncate or punch hole if unfalloc undo failed fallocate"
        },
        "redir_ip6": {
            "ground_truth": "0",
            "function": "redir_ip6",
            "description": "tool testing selftests bpf progs test sk lookup redirect packet destined for dst ip6 address to socket at redir map"
        },
        "crypto_akcipher_encrypt": {
            "ground_truth": "0",
            "function": "crypto_akcipher_encrypt",
            "description": "include crypto akcipher invoke public key encrypt operation function invokes the specific public key encrypt operation for given public key algorithm struct akcipher request req asymmetric key request zero on success error code in case of error"
        },
        "new_page": {
            "ground_truth": "0",
            "function": "new_page",
            "description": "allocate new page for page migration based on vma policy start by assuming the page is mapped by the same vma a contains start search forward from there if not this assumes that the list of page handed to migrate page which is how we get here is in virtual address order"
        }
    },
    "AC": {
        "ice_aq_req_res": {
            "ground_truth": "1",
            "function": "ice_aq_req_res",
            "description": "request common resource using the admin queue command when attempting to acquire the global config lock the driver can learn of three state ice success acquired lock and can perform download package ice err aq error did not get lock driver should fail to load ice err aq no work did not get lock but another driver ha successfully downloaded the package the driver doe not have to download the package and can continue loading note that if the caller is in an acquire lock perform action release lock phase of operation it is possible that the fw may detect timeout and issue corer in this case the driver will receive corer interrupt and will have to determine it cause the calling thread that is handling this flow will likely get an error propagated back to it indicating the download package update package or the release resource aq command timed out struct ice hw hw pointer to the hw struct enum ice aq re id re resource id enum ice aq re access type access access type u8 sdp number resource number u32 timeout the maximum time in m that the driver may hold the resource struct ice sq cd cd pointer to command detail structure or null"
        },
        "drm_atomic_helper_disable_all": {
            "ground_truth": "1",
            "function": "drm_atomic_helper_disable_all",
            "description": "disable all currently active output loop through all connector finding those that are not turned off and then turn them off by setting their dpms mode to off and deactivating the crtc that they are connected to this is used for example in suspend resume to disable all currently active function when suspending if you just want to shut down everything at driver unload look at drm atomic helper shutdown note that if caller have not already acquired all modeset lock this might return edeadlk which must be handled by calling drm modeset backoff see also drm atomic helper suspend drm atomic helper resume and drm atomic helper shutdown struct drm device dev drm device struct drm modeset acquire ctx ctx lock acquisition context on success or negative error code on failure"
        },
        "css_next_descendant_pre": {
            "ground_truth": "1",
            "function": "css_next_descendant_pre",
            "description": "find the next descendant for pre order walk to be used by cs for each descendant pre find the next descendant to visit for pre order traversal of root is descendant root is included in the iteration and the first node to be visited while this function requires cgroup mutex or rcu read locking it doe not require the whole traversal to be contained in single critical section this function will return the correct next descendant a long a both po and root are accessible and po is descendant of root if subsystem synchronizes cs online and the start of iteration cs which finished cs online is guaranteed to be visible in the future iteration and will stay visible until the last reference is put cs which ha not finished cs online or already finished cs offline may show up during traversal it is each subsystem is responsibility to synchronize against on offlining struct cgroup subsys state po the current position null to initiate traversal struct cgroup subsys state root cs whose descendant to walk"
        },
        "rio_mport_chk_dev_access": {
            "ground_truth": "1",
            "function": "rio_mport_chk_dev_access",
            "description": "validate access to the specified device struct rio mport mport master port to send transaction u16 destid device destination id in network u8 hopcount number of hop into the network"
        },
        "drm_mode_equal_no_clocks_no_stereo": {
            "ground_truth": "1",
            "function": "drm_mode_equal_no_clocks_no_stereo",
            "description": "test mode for equality check to see if mode1 and mode2 are equivalent but do not check the pixel clock nor the stereo layout const struct drm display mode mode1 first mode const struct drm display mode mode2 second mode true if the mode are equal false otherwise"
        },
        "ww_mutex_lock_interruptible": {
            "ground_truth": "1",
            "function": "ww_mutex_lock_interruptible",
            "description": "acquire the mutex interruptible lock the mutex exclusively for this task deadlock within given class of lock are detected and handled with the wait die algorithm if the lock is not immediately available this function will either sleep until it is wait case or it selects the current context for backing off by returning edeadlk die case trying to acquire the same lock with the same context twice is also detected and signalled by returning ealready return if the mutex wa successfully acquired if signal arrives while waiting for the lock then this function return eintr in the die case the caller must release all currently held mutexes for the given context and then wait for this contending lock to be available by calling ww mutex lock slow interruptible alternatively caller can opt to not acquire this lock and proceed with trying to acquire further mutexes when scanning through lru list trying to free resource the mutex must later on be released by the same task that acquired it the task may not exit without first unlocking the mutex also kernel memory where the mutex resides must not be freed with the mutex still locked the mutex must first be initialized or statically defined before it can be locked memset ing the mutex to is not allowed the mutex must be of the same lock class a wa used to initialize the acquire context mutex acquired with this function must be released with ww mutex unlock struct ww mutex lock the mutex to be acquired struct ww acquire ctx ctx acquire context"
        },
        "is_global_init": {
            "ground_truth": "1",
            "function": "is_global_init",
            "description": "check if task structure is init since init is free to have sub thread we need to check tgid check if task structure is the first user space task the kernel created struct task struct tsk task structure to be checked if the task structure is init otherwise"
        },
        "ww_acquire_init": {
            "ground_truth": "1",
            "function": "ww_acquire_init",
            "description": "initialize acquire context initializes an context to acquire multiple mutexes of the given class context based mutex acquiring can be done in any order whatsoever within given lock class deadlock will be detected and handled with the wait die logic mixing of context based mutex acquiring and single mutex locking can result in undetected deadlock and is so forbidden mixing different context for the same class when acquiring mutexes can also result in undetected deadlock and is hence also forbidden both type of abuse will be caught by enabling config prove locking nesting of acquire context for different class is possible subject to the usual locking rule between different lock class an acquire context must be released with ww acquire fini by the same task before the memory is freed it is recommended to allocate the context itself on the stack struct ww acquire ctx ctx acquire context to initialize struct ww class ww class class of the context"
        },
        "kcsan_begin_scoped_access": {
            "ground_truth": "1",
            "function": "kcsan_begin_scoped_access",
            "description": "begin scoped access begin scoped access and initialize sa which will cause kcsan to continuously check the memory range in the current thread until kcsan end scoped access is called for sa scoped access are implemented by appending sa to an internal list for the current execution context and then checked on every call into the kcsan runtime const volatile void ptr address of access size size size of access int type access type modifier struct kcsan scoped access sa struct kcsan scoped access to use for the scope of the access"
        },
        "mutex_lock_interruptible": {
            "ground_truth": "1",
            "function": "mutex_lock_interruptible",
            "description": "acquire the mutex interruptible by signal lock the mutex like mutex lock if signal is delivered while the process is sleeping this function will return without acquiring the mutex struct mutex lock the mutex to be acquired process context if the lock wa successfully acquired or eintr if signal arrived"
        },
        "kcsan_check_read_write": {
            "ground_truth": "1",
            "function": "kcsan_check_read_write",
            "description": "check regular read write access for race ptr address of access size size of access"
        },
        "snd_soc_dapm_enable_pin_unlocked": {
            "ground_truth": "1",
            "function": "snd_soc_dapm_enable_pin_unlocked",
            "description": "enable pin enables input output pin and it parent or child widget iff there is valid audio route and active audio stream requires external locking note snd soc dapm sync need to be called after this for dapm to do any widget power switching struct snd soc dapm context dapm dapm context const char pin pin name"
        },
        "mpt3sas_get_sdev_by_addr": {
            "ground_truth": "1",
            "function": "mpt3sas_get_sdev_by_addr",
            "description": "sa device search this search for sa device based on sa address then return sa device object struct mpt3sas adapter ioc per adapter object u64 sa address sa address calling function should acquire ioc sa device lock"
        },
        "smk_tskacc": {
            "ground_truth": "1",
            "function": "smk_tskacc",
            "description": "determine if task ha specific access to an object this function check the subject task is label object label pair in the access rule list and return if the access is permitted non zero otherwise it allows that the task may have the capability to override the rule struct task smack tsp pointer to the subject is task struct smack known obj known pointer to the object is label entry u32 mode the access requested in may format struct smk audit info common audit data"
        },
        "e1000_acquire_swflag_ich8lan": {
            "ground_truth": "1",
            "function": "e1000_acquire_swflag_ich8lan",
            "description": "acquire software control flag struct e1000 hw hw pointer to the hw structure acquires the software control flag for performing phy and select mac csr access"
        },
        "ufshcd_bkops_ctrl": {
            "ground_truth": "1",
            "function": "ufshcd_bkops_ctrl",
            "description": "control the auto bkops based on current bkops status read the bkops status from the ufs device and enable fbackgroundopsen flag in the device to permit background operation if the device bkops status is greater than or equal to status argument passed to this function disable otherwise return for success non zero in case of failure note caller of this function can check the hba auto bkops enabled flag to know whether auto bkops is enabled or disabled after this function return control to it struct ufs hba hba per adapter instance enum bkops status status bkops status value"
        },
        "zynqmp_is_valid_clock": {
            "ground_truth": "1",
            "function": "zynqmp_is_valid_clock",
            "description": "check whether clock is valid or not u32 clk id clock index if clock is valid if clock is invalid else error code"
        },
        "onenand_block_isbad": {
            "ground_truth": "1",
            "function": "onenand_block_isbad",
            "description": "mtd interface check whether the block at the given offset is bad param mtd mtd device structure param ofs offset relative to mtd start check whether the block is bad struct mtd info mtd undescribed loff ofs undescribed"
        },
        "fixup_owner": {
            "ground_truth": "1",
            "function": "fixup_owner",
            "description": "post lock pi state and corner case management after attempting to lock an rt mutex this function is called to cleanup the pi state owner a well a handle race condition that may allow u to acquire the lock must be called with the hb lock held u32 user uaddr user address of the futex struct futex futex contains pi state and access to the rt mutex int locked if the attempt to take the rt mutex succeeded or not success lock taken success lock not taken on error efault"
        },
        "ubifs_read_superblock": {
            "ground_truth": "1",
            "function": "ubifs_read_superblock",
            "description": "read superblock this function find read and check the superblock if an empty ubi volume is being mounted this function creates default superblock return zero in case of success and negative error code in case of failure struct ubifs info ubifs file system description object"
        },
        "css_rightmost_descendant": {
            "ground_truth": "1",
            "function": "css_rightmost_descendant",
            "description": "return the rightmost descendant of cs return the rightmost descendant of po if there is no descendant po is returned this can be used during pre order traversal to skip subtree of po while this function requires cgroup mutex or rcu read locking it doe not require the whole traversal to be contained in single critical section this function will return the correct rightmost descendant a long a po is accessible struct cgroup subsys state po cs of interest"
        },
        "usb_lock_device_for_reset": {
            "ground_truth": "1",
            "function": "usb_lock_device_for_reset",
            "description": "cautiously acquire the lock for usb device structure attempt to acquire the device lock but fails if the device is notattached or suspended or if iface is specified and the interface is neither binding nor bound rather than sleeping to wait for the lock the routine poll repeatedly this is to prevent deadlock with disconnect in some driver such a usb storage the disconnect or suspend method will block waiting for device reset to complete struct usb device udev device that is being locked const struct usb interface iface interface bound to the driver making the request optional negative error code for failure otherwise"
        },
        "smk_ipv6_check": {
            "ground_truth": "1",
            "function": "smk_ipv6_check",
            "description": "check smack access check an ipv6 access struct smack known subject subject smack label struct smack known object object smack label struct sockaddr in6 address address int act the action being taken"
        },
        "of_device_is_available": {
            "ground_truth": "1",
            "function": "of_device_is_available",
            "description": "check if device is available for use const struct device node device node to check for availability return true if the status property is absent or set to okay or ok false otherwise"
        },
        "qla4xxx_find_free_chap_index": {
            "ground_truth": "1",
            "function": "qla4xxx_find_free_chap_index",
            "description": "find the first free chap index find the first free chap index available in the chap table note caller should acquire the chap lock before getting here struct scsi qla host ha pointer to adapter structure uint16 chap index chap index to be returned"
        },
        "bus_mutex_lock": {
            "ground_truth": "1",
            "function": "bus_mutex_lock",
            "description": "acquire the mutex it try to acquire the mutex w1 therm max try time and wait w1 therm retry delay between attempt struct mutex lock w1 bus mutex to acquire true is mutex is acquired and lock false otherwise"
        },
        "snd_soc_dapm_disable_pin_unlocked": {
            "ground_truth": "1",
            "function": "snd_soc_dapm_disable_pin_unlocked",
            "description": "disable pin disables input output pin and it parent or child widget requires external locking note snd soc dapm sync need to be called after this for dapm to do any widget power switching struct snd soc dapm context dapm dapm context const char pin pin name"
        },
        "tick_is_oneshot_available": {
            "ground_truth": "1",
            "function": "tick_is_oneshot_available",
            "description": "check for oneshot capable event device void no argument"
        },
        "drm_atomic_helper_duplicate_state": {
            "ground_truth": "1",
            "function": "drm_atomic_helper_duplicate_state",
            "description": "duplicate an atomic state object make copy of the current atomic state by looping over all object and duplicating their respective state this is used for example by suspend resume support code to save the state prior to suspend such that it can be restored upon resume note that this treat atomic state a persistent between save and restore driver must make sure that this is possible and will not result in confusion or erroneous behaviour note that if caller have not already acquired all modeset lock this might return edeadlk which must be handled by calling drm modeset backoff see also drm atomic helper suspend drm atomic helper resume struct drm device dev drm device struct drm modeset acquire ctx ctx lock acquisition context pointer to the copy of the atomic state object on success or an err ptr encoded error code on failure"
        },
        "queued_spin_trylock": {
            "ground_truth": "1",
            "function": "queued_spin_trylock",
            "description": "try to acquire the queued spinlock struct qspinlock lock pointer to queued spinlock structure if lock acquired if failed"
        },
        "ns_capable_setid": {
            "ground_truth": "1",
            "function": "ns_capable_setid",
            "description": "determine if the current task ha superior capability in effect while signalling that this check is being done from within setid or setgroups syscall return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used struct user namespace n the usernamespace we want the capability in int cap the capability to be tested for"
        },
        "nq_m_sync": {
            "ground_truth": "1",
            "function": "nq_m_sync",
            "description": "synchonously acquire more than one glock in deadlock free order unsigned int num gh the number of structure struct gfs2 holder ghs an array of struct gfs2 holder structure struct gfs2 holder undescribed on success all glocks acquired errno on failure no glocks acquired"
        },
        "_scsih_sas_device_remove": {
            "ground_truth": "1",
            "function": "_scsih_sas_device_remove",
            "description": "remove sa device from list if sa device is on the list remove it and decrement it reference count struct mpt3sas adapter ioc per adapter object struct sa device sa device the sa device object this function will acquire ioc sa device lock"
        },
        "generic_file_write_iter": {
            "ground_truth": "1",
            "function": "generic_file_write_iter",
            "description": "write data to file this is wrapper around generic file write iter to be used by most filesystems it take care of syncing the file in case of sync file and acquires mutex a needed struct kiocb iocb io state structure struct iov iter from iov iter with data to write negative error code if no data ha been written at all of vfs fsync range failed for synchronous write number of byte written even for truncated writes"
        },
        "rio_chk_dev_access": {
            "ground_truth": "1",
            "function": "rio_chk_dev_access",
            "description": "validate access to the specified device struct rio dev rdev pointer to rio device control structure"
        },
        "check_desc_avail": {
            "ground_truth": "1",
            "function": "check_desc_avail",
            "description": "check descriptor availability on send queue struct adapter adap the adapter struct sge txq the send queue struct sk buff skb the packet needing the descriptor unsigned int ndesc the number of tx descriptor needed unsigned int qid the tx queue number in it queue set txq ofld or txq ctrl check if the requested number of tx descriptor is available on an sge send queue if the queue is already suspended or not enough descriptor are available the packet is queued for later transmission must be called with the tx queue locked return if enough descriptor are available if there are not enough descriptor and the packet ha been queued and if the caller need to retry because there were not enough descriptor at the beginning of the call but some freed up in the mean time"
        },
        "drm_mode_is_stereo": {
            "ground_truth": "1",
            "function": "drm_mode_is_stereo",
            "description": "check for stereo mode flag const struct drm display mode mode drm display mode to check true if the mode is one of the stereo mode like side by side false if not"
        },
        "generic_check_addressable": {
            "ground_truth": "1",
            "function": "generic_check_addressable",
            "description": "check addressability of file system determine whether file system with num block block and block size of blocksize bit is addressable by the sector and page cache of the system return if so and efbig otherwise unsigned blocksize bit log of file system block size u64 num block number of block in file system"
        },
        "mpt3sas_get_pdev_by_wwid": {
            "ground_truth": "1",
            "function": "mpt3sas_get_pdev_by_wwid",
            "description": "pcie device search this search for pcie device based on wwid then return pcie device object struct mpt3sas adapter ioc per adapter object u64 wwid wwid this function will acquire ioc pcie device lock and will release before returning the pcie device object"
        },
        "down_trylock": {
            "ground_truth": "1",
            "function": "down_trylock",
            "description": "try to acquire the semaphore without waiting try to acquire the semaphore atomically return if the semaphore ha been acquired successfully or if it it cannot be acquired unlike mutex trylock this function can be used from interrupt context and the semaphore can be released by any task or interrupt note this return value is inverted from both spin trylock and mutex trylock be careful about this when converting code struct semaphore sem the semaphore to be acquired"
        },
        "binder_proc_unlock": {
            "ground_truth": "1",
            "function": "binder_proc_unlock",
            "description": "release spinlock for given binder proc release lock acquired via binder proc lock proc undescribed"
        },
        "down_interruptible": {
            "ground_truth": "1",
            "function": "down_interruptible",
            "description": "acquire the semaphore unless interrupted attempt to acquire the semaphore if no more task are allowed to acquire the semaphore calling this function will put the task to sleep if the sleep is interrupted by signal this function will return eintr if the semaphore is successfully acquired this function return struct semaphore sem the semaphore to be acquired"
        },
        "drm_ioctl_flags": {
            "ground_truth": "1",
            "function": "drm_ioctl_flags",
            "description": "check for core ioctl and return ioctl permission flag this ioctl is only used by the vmwgfx driver to augment the access check done by the drm core and insofar pretty decent layering violation this should not be used by any driver unsigned int nr ioctl number unsigned int flag where to return the ioctl permission flag true if the nr corresponds to drm core ioctl number false otherwise overview encoders represent the connecting element between the crtc a the overall pixel pipeline represented by type struct drm crtc and the connector a the generic sink entity represented by type struct drm connector an encoder take pixel data from crtc and convert it to format suitable for any attached connector encoders are object exposed to userspace originally to allow userspace to infer cloning and connector crtc restriction unfortunately almost all driver get this wrong making the uabi pretty much useless on top of that the exposed restriction are too simple for today is hardware and the recommended way to infer restriction is by using the drm mode atomic test only flag for the atomic ioctl otherwise encoders are not used in the uapi at all any modeset request from userspace directly connects connector with crtc driver are therefore free to use them however they wish modeset helper library make strong use of encoders to facilitate code sharing but for more complex setting it is usually better to move shared code into separate type drm bridge compared to encoders bridge also have the benefit of being purely an internal abstraction since they are not exposed to userspace at all encoders are initialized with drm encoder init and cleaned up using drm encoder cleanup"
        },
        "smk_ipv6_port_check": {
            "ground_truth": "1",
            "function": "smk_ipv6_port_check",
            "description": "check smack port access create or update the port list entry struct sock sk socket struct sockaddr in6 address address int act the action being taken"
        },
        "local_lock_irqsave": {
            "ground_truth": "1",
            "function": "local_lock_irqsave",
            "description": "acquire per cpu local lock save and disable interrupt lock the lock variable flag storage for interrupt flag"
        },
        "wait_event_interruptible_lock_irq": {
            "ground_truth": "1",
            "function": "wait_event_interruptible_lock_irq",
            "description": "sleep until condition get true the condition is checked under the lock this is expected to be called with the lock taken the process is put to sleep task interruptible until the condition evaluates to true or signal is received the condition is checked each time the waitqueue wq head is woken up wake up ha to be called after changing any variable that could change the result of the wait condition this is supposed to be called while holding the lock the lock is dropped before going to sleep and is reacquired afterwards the macro will return erestartsys if it wa interrupted by signal and if condition evaluated to true wq head the waitqueue to wait on condition expression for the event to wait for lock locked spinlock which will be released before schedule and reacquired afterwards"
        },
        "ext2_init_block_alloc_info": {
            "ground_truth": "1",
            "function": "ext2_init_block_alloc_info",
            "description": "allocate and initialize the reservation window structure and link the window to the ext2 inode structure at last the reservation window structure is only dynamically allocated and linked to ext2 inode the first time the open file need new block so before every ext2 new block call for regular file we should check whether the reservation window structure exists or not in the latter case this function is called fail to do so will result in block reservation being turned off for that open file this function is called from ext2 get block handle also called when setting the reservation window size through ioctl before the file is open for write need block allocation need truncate mutex protection prior to calling this function struct inode inode file inode structure"
        },
        "drm_atomic_commit": {
            "ground_truth": "1",
            "function": "drm_atomic_commit",
            "description": "commit configuration atomically note that this function can return edeadlk if the driver needed to acquire more lock but encountered deadlock the caller must then do the usual backoff dance and restart all other error are fatal this function will take it own reference on state caller should always release their reference with drm atomic state put struct drm atomic state state atomic configuration to check on success negative error code on failure"
        },
        "wait_event_interruptible_lock_irq_timeout": {
            "ground_truth": "1",
            "function": "wait_event_interruptible_lock_irq_timeout",
            "description": "sleep until condition get true or timeout elapses the condition is checked under the lock this is expected to be called with the lock taken the process is put to sleep task interruptible until the condition evaluates to true or signal is received the condition is checked each time the waitqueue wq head is woken up wake up ha to be called after changing any variable that could change the result of the wait condition this is supposed to be called while holding the lock the lock is dropped before going to sleep and is reacquired afterwards the function return if the timeout elapsed erestartsys if it wa interrupted by signal and the remaining jiffy otherwise if the condition evaluated to true before the timeout elapsed wq head the waitqueue to wait on condition expression for the event to wait for lock locked spinlock which will be released before schedule and reacquired afterwards timeout timeout in jiffy"
        },
        "bulk_read_support": {
            "ground_truth": "1",
            "function": "bulk_read_support",
            "description": "check if slave support bulk read struct w1 slave sl device to check the ability true if bulk read is supported false if not or error"
        },
        "pmcraid_check_ioctl_buffer": {
            "ground_truth": "1",
            "function": "pmcraid_check_ioctl_buffer",
            "description": "check for proper access to user buffer return value negetive error code if there are access issue otherwise zero upon success return ioctl header copied out of user buffer int cmd ioctl command void user arg user buffer struct pmcraid ioctl header hdr pointer to kernel memory for pmcraid ioctl header"
        },
        "dev_pm_qos_flags": {
            "ground_truth": "1",
            "function": "dev_pm_qos_flags",
            "description": "check pm qos flag for given device locked struct device dev device to check the pm qos flag for s32 mask flag to check against"
        },
        "il4965_tx_queue_set_status": {
            "ground_truth": "1",
            "function": "il4965_tx_queue_set_status",
            "description": "optionally start tx cmd queue struct il priv il undescribed struct il tx queue txq undescribed int tx fifo id tx dma fifo channel range that the queue will feed int scd retry indicates queue will be used in aggregation mode note acquire il lock before calling this function"
        },
        "qcom_scm_restore_sec_cfg_available": {
            "ground_truth": "1",
            "function": "qcom_scm_restore_sec_cfg_available",
            "description": "check if secure environment support restore security config interface return true if restore cfg interface is supported false if not void no argument"
        },
        "ptp_find_pin_unlocked": {
            "ground_truth": "1",
            "function": "ptp_find_pin_unlocked",
            "description": "wrapper for ptp find pin this function acquires the ptp clock pincfg mux mutex before invoking ptp find pin instead of using this function driver should most likely call ptp find pin directly from their ptp clock info enable method struct ptp clock ptp undescribed enum ptp pin function func undescribed unsigned int chan undescribed"
        },
        "gfs2_check_sb": {
            "ground_truth": "1",
            "function": "gfs2_check_sb",
            "description": "check superblock check the version code of the f is one that we understand how to read and that the size of the various on disk structure have not changed struct gfs2 sbd sdp the filesystem int silent do not print message if the check fails"
        },
        "cap_inode_need_killpriv": {
            "ground_truth": "1",
            "function": "cap_inode_need_killpriv",
            "description": "determine if inode change affect privilege determine if an inode having change applied that is marked attr kill priv affect the security marking on that inode and if it is should inode killpriv be invoked or the change rejected return if security capability ha value meaning inode killpriv is required otherwise meaning inode killpriv is not required struct dentry dentry the inode dentry in being changed with change marked attr kill priv"
        },
        "ks8851_eeprom_claim": {
            "ground_truth": "1",
            "function": "ks8851_eeprom_claim",
            "description": "claim device eeprom and activate the interface check for the presence of an eeprom and then activate software access to the device struct ks8851 net k the network device state"
        },
        "intel_gvt_reset_vgpu_locked": {
            "ground_truth": "1",
            "function": "intel_gvt_reset_vgpu_locked",
            "description": "reset virtual gpu by dmlr or gt reset this function is called when user want to reset virtual gpu through device model reset or gt reset the caller should hold the vgpu lock vgpu device model level reset dmlr simulates the pci level reset to reset the whole vgpu to default state a when it is created this vgpu function is required both for functionary and security concern the ultimate goal of vgpu flr is that reuse vgpu instance by virtual machine when we assign vgpu to virtual machine we must isse such reset first full gt reset and per engine gt reset are soft reset flow for gpu engine render blitter video video enhancement it is defined by gpu spec unlike the flr gt reset only reset particular resource of vgpu per the reset request guest driver can issue gt reset by programming the virtual gdrst register to reset specific virtual gpu engine or all engine the parameter dev level is to identify if we will do dmlr or gt reset the parameter engine mask is to specific the engine that need to be resetted if value all engine is given for engine mask it mean the caller request full gt reset that we will reset all virtual gpu engine for flr engine mask is ignored struct intel vgpu vgpu virtual gpu bool dmlr vgpu device model level reset or gt reset intel engine mask engine mask engine to reset for gt reset"
        },
        "__aa_get_label": {
            "ground_truth": "1",
            "function": "__aa_get_label",
            "description": "get reference count to uncounted label reference struct aa label reference to get count on pointer to reference or null if race is lost and reference is being repeated requires lock held and the return code must be checked"
        },
        "evm_verifyxattr": {
            "ground_truth": "1",
            "function": "evm_verifyxattr",
            "description": "verify the integrity of the requested xattr calculate the hmac for the given dentry and verify it against the stored security evm xattr for performance use the xattr value and length previously retrieved to calculate the hmac return the xattr integrity status this function requires the caller to lock the inode is mutex before it is executed struct dentry dentry object of the verify xattr const char xattr name requested xattr void xattr value requested xattr value size xattr value len requested xattr value length struct integrity iint cache iint undescribed"
        },
        "drm_atomic_check_only": {
            "ground_truth": "1",
            "function": "drm_atomic_check_only",
            "description": "check whether given config would work note that this function can return edeadlk if the driver needed to acquire more lock but encountered deadlock the caller must then do the usual backoff dance and restart all other error are fatal struct drm atomic state state atomic configuration to check on success negative error code on failure"
        },
        "ww_mutex_lock_slow": {
            "ground_truth": "1",
            "function": "ww_mutex_lock_slow",
            "description": "slowpath acquiring of the mutex acquires mutex with the given context after die case this function will sleep until the lock becomes available the caller must have released all mutexes already acquired with the context and then call this function on the contended lock afterwards the caller may continue to re acquire the other mutexes it need with ww mutex lock note that the ealready return code from ww mutex lock can be used to avoid locking this contended mutex twice it is forbidden to call this function with any other mutexes associated with the context held it is forbidden to call this on anything else than the contending mutex note that the slowpath lock acquiring can also be done by calling ww mutex lock directly this function here is simply to help mutex locking code readability by clearly denoting the slowpath struct ww mutex lock the mutex to be acquired struct ww acquire ctx ctx acquire context"
        },
        "smk_access": {
            "ground_truth": "1",
            "function": "smk_access",
            "description": "determine if subject ha specific access to an object this function look up the subject object pair in the access rule list and return if the access is permitted non zero otherwise smack label are shared on smack list struct smack known subject pointer to the subject is smack label entry struct smack known object pointer to the object is smack label entry int request the access requested in may format struct smk audit info pointer to the audit data"
        },
        "local_lock_irq": {
            "ground_truth": "1",
            "function": "local_lock_irq",
            "description": "acquire per cpu local lock and disable interrupt lock the lock variable"
        },
        "mpt3sas_transport_port_add": {
            "ground_truth": "1",
            "function": "mpt3sas_transport_port_add",
            "description": "insert port to the list adding new port object to the sa node sa port list struct mpt3sas adapter ioc per adapter object u16 handle handle of attached device u64 sa address sa address of parent expander or sa host this function will acquire ioc sa node lock mpt3sas port"
        },
        "fault_in_user_writeable": {
            "ground_truth": "1",
            "function": "fault_in_user_writeable",
            "description": "fault in user address and verify rw access slow path to fixup the fault we just took in the atomic write access to uaddr we have no generic implementation of non destructive write to the user address we know that we faulted in the atomic pagefault disabled section so we can a well avoid the pf overhead by calling get user page right away u32 user uaddr pointer to faulting user space address"
        },
        "__kcsan_check_read_write": {
            "ground_truth": "1",
            "function": "__kcsan_check_read_write",
            "description": "check regular read write access for race ptr address of access size size of access"
        },
        "_scsih_fw_event_add": {
            "ground_truth": "1",
            "function": "_scsih_fw_event_add",
            "description": "insert and queue up fw event this add the firmware event object into link list then queue it up to be processed from user context struct mpt3sas adapter ioc per adapter object struct fw event work fw event object describing the event this function will acquire ioc fw event lock"
        },
        "_scsih_pcie_device_remove": {
            "ground_truth": "1",
            "function": "_scsih_pcie_device_remove",
            "description": "remove pcie device from list if pcie device is on the list remove it and decrement it reference count struct mpt3sas adapter ioc per adapter object struct pcie device pcie device the pcie device object this function will acquire ioc pcie device lock"
        },
        "spi_bus_lock": {
            "ground_truth": "1",
            "function": "spi_bus_lock",
            "description": "obtain lock for exclusive spi bus usage this call may only be used from context that may sleep the sleep is non interruptible and ha no timeout this call should be used by driver that require exclusive access to the spi bus the spi bus must be released by spi bus unlock call when the exclusive access is over data transfer must be done by spi sync locked and spi async locked call when the spi bus lock is held struct spi controller ctlr spi bus master that should be locked for exclusive bus access can sleep always zero"
        },
        "futex_lock_pi_atomic": {
            "ground_truth": "1",
            "function": "futex_lock_pi_atomic",
            "description": "atomic work required to acquire pi aware futex the hb lock and futex key ref shall be held by the caller exiting is only set when the return value is ebusy if so this hold refcount on the exiting task on return and the caller need to drop it after waiting for the exit to complete u32 user uaddr the pi futex user address struct futex hash bucket hb the pi futex hash bucket union futex key key the futex key associated with uaddr and hb struct futex pi state p the pi state pointer where we store the result of the lookup struct task struct task the task to perform the atomic lock work for this will be current except in the case of requeue pi struct task struct exiting pointer to store the task pointer of the owner task which is in the middle of exiting int set waiter force setting the futex waiter bit or not ready to wait acquired the lock error"
        },
        "stdma_is_locked_by": {
            "ground_truth": "1",
            "function": "stdma_is_locked_by",
            "description": "allow lock holder to check whether it need to release return if locked for the given handler otherwise irq handler handler interrupt handler previously used to acquire lock"
        },
        "security_policycap_supported": {
            "ground_truth": "1",
            "function": "security_policycap_supported",
            "description": "check for specific policy capability this function query the currently loaded policy to see if it support the capability specified by req cap return true if the capability is supported false if it is not supported struct selinux state state undescribed unsigned int req cap capability"
        },
        "cxlflash_devnode": {
            "ground_truth": "1",
            "function": "cxlflash_devnode",
            "description": "provides devtmpfs for device in the cxlflash class struct device dev character device umode mode mode that can be used to verify access allocated string describing the devtmpfs structure"
        },
        "ice_update_ring_stats": {
            "ground_truth": "0",
            "function": "ice_update_ring_stats",
            "description": "update ring statistic this function assumes that caller ha acquired u64 stats sync lock struct ice ring ring ring to update struct ice ring container cont used to increment per vector counter u64 pkts number of processed packet u64 byte number of processed byte"
        },
        "snd_hda_check_amp_caps": {
            "ground_truth": "1",
            "function": "snd_hda_check_amp_caps",
            "description": "query amp capability check whether the widget ha the given amp capability for the direction struct hda codec codec the hd audio codec hda nid nid the nid to query int dir either hda input or hda output unsigned int bit bit mask to check the result"
        },
        "ubi_bitflip_check": {
            "ground_truth": "1",
            "function": "ubi_bitflip_check",
            "description": "check an eraseblock for bitflips and scrub it if needed this function read the given eraseblock and check if bitflips occured in case of bitflips the eraseblock is scheduled for scrubbing if scrubbing is forced with force the eraseblock is not read but scheduled for scrubbing right away struct ubi device ubi ubi device description object int pnum the physical eraseblock to schedule int force dont not read the block assume bitflips happened and take action einval peb is out of range enoent peb is no longer used by ubi ebusy peb cannot be checked now or check is currently running on it eagain bit flip happened but scrubbing is currently not possible euclean bit flip happened and peb is scheduled for scrubbing no bit flip detected"
        },
        "mpt3sas_get_pdev_from_target": {
            "ground_truth": "1",
            "function": "mpt3sas_get_pdev_from_target",
            "description": "pcie device search this search for pcie device from target then return pcie device object struct mpt3sas adapter ioc per adapter object struct mpt3sas target tgt priv starget private object this function will acquire ioc pcie device lock and will release before returning the pcie device object"
        },
        "onenand_check_lock_status": {
            "ground_truth": "1",
            "function": "onenand_check_lock_status",
            "description": "onenand interface check lock status param this onenand chip data structure check lock status struct onenand chip this undescribed"
        },
        "__kcsan_check_read": {
            "ground_truth": "1",
            "function": "__kcsan_check_read",
            "description": "check regular read access for race ptr address of access size size of access"
        },
        "igc_phy_hw_reset": {
            "ground_truth": "1",
            "function": "igc_phy_hw_reset",
            "description": "phy hardware reset verify the reset block is not blocking u from resetting acquire semaphore if necessary and read set write the device control reset bit in the phy wait the appropriate delay time for the device to reset and release the semaphore if necessary struct igc hw hw pointer to the hw structure"
        },
        "requeue_pi_wake_futex": {
            "ground_truth": "1",
            "function": "requeue_pi_wake_futex",
            "description": "wake task that acquired the lock during requeue during futex requeue with requeue pi it is possible to acquire the target futex if it is uncontended or via lock steal set the futex key to the requeue target futex so the waiter can detect the wakeup on the right futex but remove it from the hb and null the rt waiter so it can detect atomic lock acquisition set the lock ptr to the requeue target hb lock to protect access to the pi state to fixup the owner later must be called with both lock ptr and hb lock held struct futex the futex union futex key key the key of the requeue target futex struct futex hash bucket hb the hash bucket of the requeue target futex"
        },
        "ice_discover_flash_size": {
            "ground_truth": "1",
            "function": "ice_discover_flash_size",
            "description": "discover the available flash size the device flash could be up to 16mb in size however it is possible that the actual size is smaller use bisection to determine the accessible size of flash memory struct ice hw hw pointer to the hw struct"
        },
        "kempld_get_mutex": {
            "ground_truth": "1",
            "function": "kempld_get_mutex",
            "description": "acquire pld mutex struct kempld device data pld kempld device data structure describing the pld"
        },
        "nilfs_read_super_root_block": {
            "ground_truth": "1",
            "function": "nilfs_read_super_root_block",
            "description": "read super root block struct the nilfs nilfs nilfs object sector sr block disk block number of the super root block struct buffer head pbh address of buffer head pointer to return super root buffer int check crc check flag"
        },
        "cap_capset": {
            "ground_truth": "1",
            "function": "cap_capset",
            "description": "validate and apply proposed change to current is capability this function validates and applies proposed mass change to the current process is capability set the change are made to the proposed new credential and assuming no error will be committed by the caller of lsm struct cred new the proposed new credential alteration should be made here const struct cred old the current task is current credential const kernel cap effective pointer to the proposed new effective capability set const kernel cap inheritable pointer to the proposed new inheritable capability set const kernel cap permitted pointer to the proposed new permitted capability set"
        },
        "_transport_sas_node_find_by_sas_address": {
            "ground_truth": "1",
            "function": "_transport_sas_node_find_by_sas_address",
            "description": "sa node search search for either hba phys or expander device based on handle then return the sa node object struct mpt3sas adapter ioc per adapter object u64 sa address sa address of expander or sa host calling function should acquire ioc sa node lock"
        },
        "capable": {
            "ground_truth": "1",
            "function": "capable",
            "description": "determine if the current task ha superior capability in effect return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used int cap the capability to be tested for"
        },
        "omap_prm_is_hardreset_asserted": {
            "ground_truth": "1",
            "function": "omap_prm_is_hardreset_asserted",
            "description": "check the hardreset status for an ip block check if hardware reset line for an ip block is enabled or not u8 shift register bit shift corresponding to the reset line u8 part prm partition s16 prm mod prm submodule base or instance offset u16 offset register offset"
        },
        "iio_dma_buffer_data_available": {
            "ground_truth": "1",
            "function": "iio_dma_buffer_data_available",
            "description": "dma buffer data available callback should be used a the data available callback for iio buffer access ops struct for dma buffer struct iio buffer buf buffer to check for data availability"
        },
        "drm_gem_lock_reservations": {
            "ground_truth": "1",
            "function": "drm_gem_lock_reservations",
            "description": "set up the ww context and acquires the lock on an array of gem object once you have locked your reservation you will want to set up space for your shared fence if applicable submit your job then drm gem unlock reservation struct drm gem object objs drm gem object to lock int count number of object in objs struct ww acquire ctx acquire ctx struct ww acquire ctx that will be initialized a part of tracking this set of locked reservation"
        },
        "iosf_mbi_block_punit_i2c_access": {
            "ground_truth": "1",
            "function": "iosf_mbi_block_punit_i2c_access",
            "description": "block unit access to the pmic bus call this function to block unit access to the pmic i2c bus so that the kernel can safely access the pmic over the shared i2c bus this function acquires the unit bus semaphore and notifies pmic bus access notifier listener that they may no longer access the unit in way which may cause it to access the shared i2c bus note this function may be called multiple time and the bus will not be released until iosf mbi unblock punit i2c access ha been called the same amount of time void no argument nonzero on error"
        },
        "usb_reset_and_verify_device": {
            "ground_truth": "1",
            "function": "usb_reset_and_verify_device",
            "description": "perform usb port reset to reinitialize device warning do not use this routine to reset composite device one with multiple interface owned by separate driver use usb reset device instead do port reset reassign the device is address and establish it former operating configuration if the reset fails or the device is descriptor change from their value before the reset or the original configuration and altsettings cannot be restored flag will be set telling hub wq to pretend the device ha been disconnected and then re connected all driver will be unbound and the device will be re enumerated and probed all over again locking exception this routine may also be called from within an autoresume handler such usage will not conflict with other task holding the device lock because these task should always call usb autopm resume device thereby preventing any unwanted autoresume the autoresume handler is expected to have already acquired the port lock before calling this routine struct usb device udev device to reset not in suspended or notattached state if the reset succeeded enodev if the device ha been flagged for logical disconnection or some other negative error code if the reset wa not even attempted note the caller must own the device lock and the port lock the latter is taken by usb reset device for example it is safe to use usb reset device from driver probe routine after downloading new firmware for call that might not occur during probe driver should lock the device using usb lock device for reset"
        },
        "queued_spin_lock": {
            "ground_truth": "1",
            "function": "queued_spin_lock",
            "description": "acquire queued spinlock struct qspinlock lock pointer to queued spinlock structure"
        },
        "tep_test_flag": {
            "ground_truth": "1",
            "function": "tep_test_flag",
            "description": "check the state of event parser flag this return the state of the requested tep flag struct tep handle tep handle to the tep handle enum tep flag flag flag to be checked true if the flag is set false otherwise"
        },
        "cap_capable": {
            "ground_truth": "1",
            "function": "cap_capable",
            "description": "determine whether task ha particular effective capability determine whether the nominated task ha the specified capability amongst it effective set returning if it doe ve if it doe not note well cap ha capability cannot be used like the kernel is capable and ha capability function that is it ha the reverse semantics cap ha capability return when task ha capability but the kernel is capable and ha capability return for this case const struct cred cred the credential to use struct user namespace targ n undescribed int cap the capability to check for unsigned int opts bitmask of option defined in include linux security"
        },
        "queued_read_trylock": {
            "ground_truth": "1",
            "function": "queued_read_trylock",
            "description": "try to acquire read lock of queue rwlock struct qrwlock lock pointer to queue rwlock structure if lock acquired if failed"
        },
        "down_killable": {
            "ground_truth": "1",
            "function": "down_killable",
            "description": "acquire the semaphore unless killed attempt to acquire the semaphore if no more task are allowed to acquire the semaphore calling this function will put the task to sleep if the sleep is interrupted by fatal signal this function will return eintr if the semaphore is successfully acquired this function return struct semaphore sem the semaphore to be acquired"
        },
        "wait_event_lock_irq": {
            "ground_truth": "1",
            "function": "wait_event_lock_irq",
            "description": "sleep until condition get true the condition is checked under the lock this is expected to be called with the lock taken the process is put to sleep task uninterruptible until the condition evaluates to true the condition is checked each time the waitqueue wq head is woken up wake up ha to be called after changing any variable that could change the result of the wait condition this is supposed to be called while holding the lock the lock is dropped before going to sleep and is reacquired afterwards wq head the waitqueue to wait on condition expression for the event to wait for lock locked spinlock which will be released before schedule and reacquired afterwards"
        },
        "nfp_nffw_info_open": {
            "ground_truth": "1",
            "function": "nfp_nffw_info_open",
            "description": "acquire the lock on the nffw table struct nfp cpp cpp nfp cpp handle pointer to nfp nffw info object or err ptr"
        },
        "vmw_kms_stdu_init_display": {
            "ground_truth": "1",
            "function": "vmw_kms_stdu_init_display",
            "description": "initializes screen target based display this function initialize screen target based display device it check the capability bit to make sure the underlying hardware can support screen target and then creates the maximum number of crtcs display unit a supported by the display hardware struct vmw private dev priv vmw drm device on success error code otherwise"
        },
        "ipa_config": {
            "ground_truth": "1",
            "function": "ipa_config",
            "description": "configure ipa hardware perform initialization requiring ipa clock to be enabled struct ipa ipa ipa pointer const struct ipa data data ipa configuration data"
        },
        "sxgbe_hw_init": {
            "ground_truth": "1",
            "function": "sxgbe_hw_init",
            "description": "init the gmac device this function check the hw capability if supported and set the driver is feature struct sxgbe priv data const priv driver private structure"
        },
        "ioat_check_space_lock": {
            "ground_truth": "1",
            "function": "ioat_check_space_lock",
            "description": "verify space and grab ring producer lock struct ioatdma chan ioat chan ioat channel ring to operate on int num descs allocation length"
        },
        "mpt3sas_get_sdev_by_handle": {
            "ground_truth": "1",
            "function": "mpt3sas_get_sdev_by_handle",
            "description": "sa device search this search for sa device based on sa address then return sa device object struct mpt3sas adapter ioc per adapter object u16 handle sa device handle assigned by firmware calling function should acquire ioc sa device lock"
        },
        "_scsih_scsi_lookup_find_by_target": {
            "ground_truth": "1",
            "function": "_scsih_scsi_lookup_find_by_target",
            "description": "search for matching channel id this will search for matching channel id in the scsi lookup array returning if found struct mpt3sas adapter ioc per adapter object int id target id int channel channel this function will acquire ioc scsi lookup lock"
        },
        "__hostap_cmd_queue_free": {
            "ground_truth": "1",
            "function": "__hostap_cmd_queue_free",
            "description": "free prism2 command queue entry private internal helper function for freeing prism2 command queue entry caller must have acquired local cmdlock before calling this function local info local pointer to private host ap driver data struct hostap cmd queue entry prism2 command queue entry to be freed int del req request the entry to be removed"
        },
        "DRM_MODESET_LOCK_ALL_END": {
            "ground_truth": "1",
            "function": "DRM_MODESET_LOCK_ALL_END",
            "description": "helper to release and cleanup modeset lock the other side of drm modeset lock all begin it will bounce back to begin if ret is edeadlk it is important that you use the same ret variable for begin and end so deadlock condition are properly handled dev drm device ctx local modeset acquire context will be dereferenced ret local ret err etc variable to track error status ret will be untouched unless it is edeadlk on entry that mean that if you successfully acquire the lock ret will be whatever your code set it to if there is deadlock or other failure with acquire or backoff ret will be set to that failure in both of these case the code between begin end will not be run so the failure will reflect the inability to grab the lock"
        },
        "mutex_lock_killable": {
            "ground_truth": "1",
            "function": "mutex_lock_killable",
            "description": "acquire the mutex interruptible by fatal signal lock the mutex like mutex lock if signal which will be fatal to the current process is delivered while the process is sleeping this function will return without acquiring the mutex struct mutex lock the mutex to be acquired process context if the lock wa successfully acquired or eintr if fatal signal arrived"
        },
        "devm_hwspin_lock_request": {
            "ground_truth": "1",
            "function": "devm_hwspin_lock_request",
            "description": "request an hwspinlock for managed device this function should be called by user of the hwspinlock device in order to dynamically assign them an unused hwspinlock usually the user of this lock will then have to communicate the lock is id to the remote core before it can be used for synchronization to get the id of given hwlock use hwspin lock get id should be called from process context might sleep return the address of the assigned hwspinlock or null on error struct device dev the device to request an hwspinlock"
        },
        "z8530_read_port": {
            "ground_truth": "1",
            "function": "z8530_read_port",
            "description": "architecture specific interface function unsigned long port to read provided port access method the comtrol sv11 requires no delay between access and us pc some driver may need 5us delay in the longer term this should become an architecture specific section so that this can become generic driver interface for all platform for now we only handle pc port with or without the dread 5us sanity delay the caller must hold sufficient lock to avoid violating the horrible 5us delay rule"
        },
        "snd_soc_dapm_force_enable_pin_unlocked": {
            "ground_truth": "1",
            "function": "snd_soc_dapm_force_enable_pin_unlocked",
            "description": "force pin to be enabled enables input output pin regardless of any other state this is intended for use with microphone bias supply used in microphone jack detection requires external locking note snd soc dapm sync need to be called after this for dapm to do any widget power switching struct snd soc dapm context dapm dapm context const char pin pin name"
        },
        "ns_capable_noaudit": {
            "ground_truth": "1",
            "function": "ns_capable_noaudit",
            "description": "determine if the current task ha superior capability unaudited in effect return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used struct user namespace n the usernamespace we want the capability in int cap the capability to be tested for"
        },
        "pseudo_lock_region_init": {
            "ground_truth": "1",
            "function": "pseudo_lock_region_init",
            "description": "initialize pseudo lock region information called after user provided schema to be pseudo locked from the schema the type struct pseudo lock region is on entry already initialized with the resource domain and capacity bitmask here the information required for pseudo locking is deduced from this data and type struct pseudo lock region initialized further this information includes size in byte of the region to be pseudo locked cache line size to know the stride with which data need to be accessed to be pseudo locked cpu associated with the cache instance on which the pseudo locking flow can be executed struct pseudo lock region plr pseudo lock region on success on failure descriptive error will be written to last cmd status buffer"
        },
        "e1000_acquire_nvm_80003es2lan": {
            "ground_truth": "1",
            "function": "e1000_acquire_nvm_80003es2lan",
            "description": "acquire right to access nvm struct e1000 hw hw pointer to the hw structure acquire the semaphore to access the eeprom"
        },
        "mpt3sas_get_pdev_by_handle": {
            "ground_truth": "1",
            "function": "mpt3sas_get_pdev_by_handle",
            "description": "pcie device search this search for pcie device based on handle then return pcie device object struct mpt3sas adapter ioc per adapter object u16 handle firmware device handle this function will acquire ioc pcie device lock and will release before returning the pcie device object"
        },
        "ice_flow_assoc_prof": {
            "ground_truth": "1",
            "function": "ice_flow_assoc_prof",
            "description": "associate vsi with flow profile assumption the caller ha acquired the lock to the profile list and the software vsi handle ha been validated struct ice hw hw pointer to the hardware structure enum ice block blk classification stage struct ice flow prof prof pointer to flow profile u16 vsi handle software vsi handle"
        },
        "igb_acquire_nvm_i210": {
            "ground_truth": "1",
            "function": "igb_acquire_nvm_i210",
            "description": "request for access to eeprom struct e1000 hw hw pointer to the hw structure acquire the necessary semaphore for exclusive access to the eeprom set the eeprom access request bit and wait for eeprom access grant bit return successful if access grant bit set else clear the request for eeprom access and return e1000 err nvm"
        },
        "zynqmp_clk_gate_is_enabled": {
            "ground_truth": "1",
            "function": "zynqmp_clk_gate_is_enabled",
            "description": "check clock state struct clk hw hw handle between common and hardware specific interface if enabled if disabled else error code"
        },
        "qla4xxx_set_chap": {
            "ground_truth": "1",
            "function": "qla4xxx_set_chap",
            "description": "make chap entry at the given index create chap entry at the given index with the information provided note caller should acquire the chap lock before getting here struct scsi qla host ha pointer to adapter structure char username chap username to set char password chap password to set uint16 idx chap index at which to make the entry int bidi type of chap entry chap in or chap out"
        },
        "pm_clk_acquire": {
            "ground_truth": "1",
            "function": "pm_clk_acquire",
            "description": "acquire device clock struct device dev device whose clock is to be acquired struct pm clock entry ce pm clock entry corresponding to the clock"
        },
        "_scsih_expander_node_add": {
            "ground_truth": "1",
            "function": "_scsih_expander_node_add",
            "description": "insert expander device to the list adding new object to the ioc sa expander list struct mpt3sas adapter ioc per adapter object struct sa node sa expander the sa device object this function will acquire ioc sa node lock"
        },
        "__kcsan_check_access": {
            "ground_truth": "1",
            "function": "__kcsan_check_access",
            "description": "check generic access for race const volatile void ptr address of access size size size of access int type access type modifier"
        },
        "__kcsan_check_write": {
            "ground_truth": "1",
            "function": "__kcsan_check_write",
            "description": "check regular write access for race ptr address of access size size of access"
        },
        "vmw_user_bo_verify_access": {
            "ground_truth": "1",
            "function": "vmw_user_bo_verify_access",
            "description": "verify access permission on this buffer object struct ttm buffer object bo pointer to the buffer object being accessed struct ttm object file tfile identifying the caller"
        },
        "_scsih_sas_device_add": {
            "ground_truth": "1",
            "function": "_scsih_sas_device_add",
            "description": "insert sa device to the list adding new object to the ioc sa device list struct mpt3sas adapter ioc per adapter object struct sa device sa device the sa device object this function will acquire ioc sa device lock"
        },
        "ieee80211_txq_schedule_start": {
            "ground_truth": "1",
            "function": "ieee80211_txq_schedule_start",
            "description": "start new scheduling round for txqs should be called before ieee80211 next txq or ieee80211 return txq the driver must not call multiple txq scheduling round concurrently struct ieee80211 hw hw pointer a obtained from ieee80211 alloc hw u8 ac ac number to acquire lock for"
        },
        "amdgpu_verify_access": {
            "ground_truth": "1",
            "function": "amdgpu_verify_access",
            "description": "verify access for mmap call this is called by ttm bo mmap to verify whether process ha the right to mmap bo to their process space struct ttm buffer object bo the buffer object to map struct file filp the file pointer from the process performing the mmap"
        },
        "kcsan_check_write": {
            "ground_truth": "1",
            "function": "kcsan_check_write",
            "description": "check regular write access for race ptr address of access size size of access"
        },
        "ww_mutex_trylock": {
            "ground_truth": "1",
            "function": "ww_mutex_trylock",
            "description": "try to acquire the mutex without acquire context trylocks mutex without acquire context so no deadlock detection is possible return if the mutex ha been acquired successfully otherwise struct ww mutex lock mutex to lock"
        },
        "fh_verify": {
            "ground_truth": "1",
            "function": "fh_verify",
            "description": "filehandle lookup and access checking look up dentry from the on the wire filehandle check the client is access to the export and set the current task is credential regardless of success or failure of fh verify fh put should be called on fhp when the caller is finished with the filehandle fh verify may be called multiple time on given filehandle for example when processing an nfsv4 compound the first call will look up dentry using the on the wire filehandle subsequent call will skip the lookup and just perform the other check and possibly change the current task is credential type specifies the type of object expected using one of the if constant defined in include linux stat the caller may use zero to indicate that it doe not care or negative integer to indicate that it expects something not of the given type access is formed from the nfsd may constant defined in f nfsd vfs struct svc rqst rqstp pointer to current rpc request struct svc fh fhp filehandle to be verified umode type expected type of object pointed to by filehandle int access type of access needed to object"
        },
        "down": {
            "ground_truth": "1",
            "function": "down",
            "description": "acquire the semaphore acquires the semaphore if no more task are allowed to acquire the semaphore calling this function will put the task to sleep until the semaphore is released use of this function is deprecated please use down interruptible or down killable instead struct semaphore sem the semaphore to be acquired"
        },
        "vgic_target_oracle": {
            "ground_truth": "1",
            "function": "vgic_target_oracle",
            "description": "compute the target vcpu for an irq based on the current state of the interrupt enabled pending active vcpu and target vcpu compute the next vcpu this should be given to return null if this should not be injected at all requires the irq lock to be held struct vgic irq irq the irq to route must be already locked"
        },
        "_scsih_check_pcie_access_status": {
            "ground_truth": "1",
            "function": "_scsih_check_pcie_access_status",
            "description": "check access flag struct mpt3sas adapter ioc per adapter object u64 wwid wwid u16 handle sa device handle u8 access status error returned during discovery of the device for success else failure"
        },
        "verify_bbt_descr": {
            "ground_truth": "1",
            "function": "verify_bbt_descr",
            "description": "verify the bad block description this function performs few sanity check on the bad block description table struct nand chip this the nand device struct nand bbt descr bd the table to verify"
        },
        "rt_mutex_cleanup_proxy_lock": {
            "ground_truth": "1",
            "function": "rt_mutex_cleanup_proxy_lock",
            "description": "cleanup failed lock acquisition attempt to clean up after failed rt mutex start proxy lock or rt mutex wait proxy lock unless we acquired the lock we are still enqueued on the wait list and can in fact still be granted ownership until we are removed therefore we can find we are in fact the owner and must disregard the rt mutex wait proxy lock failure special api call for pi futex support struct rt mutex lock the rt mutex we were woken on struct rt mutex waiter waiter the pre initialized rt mutex waiter true did the cleanup we done false we acquired the lock after rt mutex wait proxy lock returned caller should disregard it return value"
        },
        "e1000e_phy_hw_reset_generic": {
            "ground_truth": "1",
            "function": "e1000e_phy_hw_reset_generic",
            "description": "phy hardware reset struct e1000 hw hw pointer to the hw structure verify the reset block is not blocking u from resetting acquire semaphore if necessary and read set write the device control reset bit in the phy wait the appropriate delay time for the device to reset and release the semaphore if necessary"
        },
        "igc_acquire_phy_base": {
            "ground_truth": "1",
            "function": "igc_acquire_phy_base",
            "description": "acquire right to access phy acquire access right to the correct phy this is function pointer entry point called by the api module struct igc hw hw pointer to the hw structure"
        },
        "mutex_lock_io": {
            "ground_truth": "1",
            "function": "mutex_lock_io",
            "description": "acquire the mutex and mark the process a waiting for lock the mutex like mutex lock while the task is waiting for this mutex it will be accounted a being in the io wait state by the scheduler struct mutex lock the mutex to be acquired process context"
        },
        "sci_clk_determine_rate": {
            "ground_truth": "1",
            "function": "sci_clk_determine_rate",
            "description": "determines clock rate clock can be set to determines suitable clock rate and parent for ti sci clock the parent handling is un used a generally the parent clock rate are not known by the kernel instead these are internally handled by the firmware return on success negative error value on failure struct clk hw hw clock to change rate for struct clk rate request req requested rate configuration for the clock"
        },
        "ibmvscsis_free_command_q": {
            "ground_truth": "1",
            "function": "ibmvscsis_free_command_q",
            "description": "free command queue this function call unregister command then clear interrupt and any pending interrupt acknowledgment associated with the command it also clear memory if there is no error phyp did not meet the papr architecture so that we must give up the lock this cause timing hole regarding state change to close the hole this routine doe accounting on any change that occurred during the time the lock is not held execution environment process level interrupt lock is held note must give up and then acquire the interrupt lock the caller must make sure that state and or flag will prevent interrupt handler from scheduling work struct scsi info vscsi pointer to our adapter structure"
        },
        "ecryptfs_verify_auth_tok_from_key": {
            "ground_truth": "1",
            "function": "ecryptfs_verify_auth_tok_from_key",
            "description": "return zero on valid auth tok einval if the payload is invalid or ekeyrevoked if the key wa revoked before we acquired it semaphore struct key auth tok key key containing the authentication token struct ecryptfs auth tok auth tok authentication token"
        },
        "drm_edid_block_valid": {
            "ground_truth": "1",
            "function": "drm_edid_block_valid",
            "description": "sanity check the edid block base or extension validate base or extension edid block and optionally dump bad block to the console u8 raw edid pointer to raw edid block int block type of block to validate for base extension otherwise bool print bad edid if true dump bad edid block to the console bool edid corrupt if true the header or checksum is invalid true if the block is valid false otherwise"
        },
        "mpt3sas_scsih_expander_find_by_handle": {
            "ground_truth": "1",
            "function": "mpt3sas_scsih_expander_find_by_handle",
            "description": "expander device search this search for expander device based on handle then return the sa node object struct mpt3sas adapter ioc per adapter object u16 handle expander handle assigned by firmware calling function should acquire ioc sa device lock"
        },
        "e1000_acquire_phy_80003es2lan": {
            "ground_truth": "1",
            "function": "e1000_acquire_phy_80003es2lan",
            "description": "acquire right to access phy struct e1000 hw hw pointer to the hw structure wrapper to acquire access right to the correct phy"
        },
        "tty_init_dev": {
            "ground_truth": "1",
            "function": "tty_init_dev",
            "description": "initialise tty device wsh rewritten to remove race and properly clean up after failed open the new code protects the open with mutex so it is really quite straightforward the mutex locking can probably be relaxed for the most common case of reopening tty struct tty driver driver tty driver we are opening device on int idx device index prepare tty device this may not be new clean device but could also be an active device the pty driver require special handling because of this locking the function is called under the tty mutex which protects u from the tty struct or driver itself going away on exit the tty device ha the line discipline attached and reference count of if pair wa created for pty tty use and the other wa pty master then it too ha reference count of returned tty structure"
        },
        "bnx2x_trylock_leader_lock": {
            "ground_truth": "1",
            "function": "bnx2x_trylock_leader_lock",
            "description": "try to acquire leader lock try to acquire leader lock for current engine struct bnx2x bp driver handle"
        },
        "_add_link": {
            "ground_truth": "1",
            "function": "_add_link",
            "description": "add an interconnect between two ip block add struct omap hwmod link record connecting the slave ip block specified in oi slave to oi this code is assumed to run before preemption or smp ha been enabled thus avoiding the need for locking in this code change to this assumption will require additional locking return struct omap hwmod ocp if oi pointer to struct omap hwmod ocp if record"
        },
        "__dev_pm_qos_flags": {
            "ground_truth": "1",
            "function": "__dev_pm_qos_flags",
            "description": "check pm qos flag for given device this routine must be called with dev power lock held struct device dev device to check the pm qos flag for s32 mask flag to check against"
        },
        "igb_phy_hw_reset": {
            "ground_truth": "1",
            "function": "igb_phy_hw_reset",
            "description": "phy hardware reset struct e1000 hw hw pointer to the hw structure verify the reset block is not blocking u from resetting acquire semaphore if necessary and read set write the device control reset bit in the phy wait the appropriate delay time for the device to reset and release the semaphore if necessary"
        },
        "t3_synchronize_rx": {
            "ground_truth": "1",
            "function": "t3_synchronize_rx",
            "description": "wait for current rx processing on port to complete ensures that current rx processing on any of the queue associated with the given port completes before returning we do this by acquiring and releasing the lock of the response queue associated with the port struct adapter adap the adapter const struct port info the port"
        },
        "igc_acquire_nvm_i225": {
            "ground_truth": "1",
            "function": "igc_acquire_nvm_i225",
            "description": "acquire hardware semaphore acquire the necessary semaphore for exclusive access to the eeprom set the eeprom access request bit and wait for eeprom access grant bit return successful if access grant bit set else clear the request for eeprom access and return igc err nvm struct igc hw hw pointer to the hw structure"
        },
        "cap_settime": {
            "ground_truth": "1",
            "function": "cap_settime",
            "description": "determine whether the current process may set the system clock determine whether the current process may set the system clock and timezone information returning if permission granted ve if denied const struct timespec64 t the time to set const struct timezone tz the timezone to set"
        },
        "p_start": {
            "ground_truth": "1",
            "function": "p_start",
            "description": "start depth first traversal of profile tree acquires first n lock struct seq file seq file to fill loff po current position first profile under current namespace or null if none found"
        },
        "of_hwspin_lock_get_id_byname": {
            "ground_truth": "1",
            "function": "of_hwspin_lock_get_id_byname",
            "description": "get lock id for an specified hwlock name this function provides mean for dt user of the hwspinlock module to get the global lock id of specific hwspinlock using the specified name of the hwspinlock device so that it can be requested using the normal hwspin lock request specific api return the global lock id number on success eprobe defer if the hwspinlock device is not yet registered einval on invalid args specifier value or an appropriate error a returned from the of parsing of the dt client node struct device node np device node from which to request the specific hwlock const char name hwlock name"
        },
        "e1000e_update_phy_task": {
            "ground_truth": "1",
            "function": "e1000e_update_phy_task",
            "description": "work thread to update phy this worker thread exists because we must acquire semaphore to read the phy which we could msleep while waiting for it and we can not msleep in timer struct work struct work pointer to our work struct"
        },
        "e1000_set_page_igp": {
            "ground_truth": "1",
            "function": "e1000_set_page_igp",
            "description": "set page a on igp like phy struct e1000 hw hw pointer to the hw structure u16 page page to set shifted left when necessary set phy page required for phy register access assumes semaphore is already acquired note this function set phy addr to so the caller must set it appropriately if necessary after this function return"
        },
        "ipr_lock_and_done": {
            "ground_truth": "1",
            "function": "ipr_lock_and_done",
            "description": "acquire lock and complete command return value none struct ipr cmnd ipr cmd ipr command struct"
        },
        "ww_mutex_lock_slow_interruptible": {
            "ground_truth": "1",
            "function": "ww_mutex_lock_slow_interruptible",
            "description": "slowpath acquiring of the mutex interruptible acquires mutex with the given context after die case this function will sleep until the lock becomes available and return when the lock ha been acquired if signal arrives while waiting for the lock then this function return eintr the caller must have released all mutexes already acquired with the context and then call this function on the contended lock afterwards the caller may continue to re acquire the other mutexes it need with ww mutex lock note that the ealready return code from ww mutex lock can be used to avoid locking this contended mutex twice it is forbidden to call this function with any other mutexes associated with the given context held it is forbidden to call this on anything else than the contending mutex note that the slowpath lock acquiring can also be done by calling ww mutex lock interruptible directly this function here is simply to help mutex locking code readability by clearly denoting the slowpath struct ww mutex lock the mutex to be acquired struct ww acquire ctx ctx acquire context"
        },
        "cgroup_move_task": {
            "ground_truth": "1",
            "function": "cgroup_move_task",
            "description": "move task to different cgroup move task to new cgroup and safely migrate it associated stall state between the different group this function acquires the task is rq lock to lock out concurrent change to the task is scheduling state and in case the task is running concurrent change to it stall state struct task struct task the task struct cs set to the target cs set"
        },
        "DRM_MODESET_LOCK_ALL_BEGIN": {
            "ground_truth": "1",
            "function": "DRM_MODESET_LOCK_ALL_BEGIN",
            "description": "helper to acquire modeset lock use these macro to simplify grabbing all modeset lock using local context this ha the advantage of reducing boilerplate but also properly checking return value where appropriate any code run between begin and end will be holding the modeset lock this must be paired with drm modeset lock all end we will jump back and forth between the label on deadlock and error condition driver can acquire additional modeset lock if any lock acquisition fails the control flow need to jump to drm modeset lock all end with the ret parameter containing the return value of drm modeset lock dev drm device ctx local modeset acquire context will be dereferenced flag drm modeset acquire flag to pas to drm modeset acquire init ret local ret err etc variable to track error status the only possible value of ret immediately after drm modeset lock all begin is so no error checking is necessary"
        },
        "nfp_cpp_explicit_acquire": {
            "ground_truth": "1",
            "function": "nfp_cpp_explicit_acquire",
            "description": "acquire explicit access handle the wouldata ref and isignal ref value are useful when constructing the nfp expl csr1 and nfp expl post value struct nfp cpp cpp nfp cpp handle nfp cpp explicit handle"
        },
        "write_seqlock": {
            "ground_truth": "1",
            "function": "write_seqlock",
            "description": "start seqlock write side critical section write seqlock open write side critical section for the given seqlock it also implicitly acquires the spinlock embedded inside that sequential lock all seqlock write side section are thus automatically serialized and non preemptible seqlock sl pointer to seqlock if the seqlock read section or other write side critical section can be invoked from hardirq or softirq context use the irqsave or bh variant of this function instead"
        },
        "__of_device_is_available": {
            "ground_truth": "1",
            "function": "__of_device_is_available",
            "description": "check if device is available for use const struct device node device node to check for availability with lock already held return true if the status property is absent or set to okay or ok false otherwise"
        },
        "mmu_interval_read_begin": {
            "ground_truth": "1",
            "function": "mmu_interval_read_begin",
            "description": "begin read side critical section against va range mmu iterval read begin mmu iterval read retry implement collision retry scheme similar to seqcount for the va range under subscription if the mm invokes invalidation during the critical section then mmu interval read retry will return true this is useful to obtain shadow ptes where teardown or setup of the sptes require blocking context the critical region formed by this can sleep and the required user lock can also be sleeping lock the caller is required to provide user lock to serialize both teardown and setup the return value should be passed to mmu interval read retry struct mmu interval notifier interval sub the interval subscription"
        },
        "e1000_acquire_nvm_ich8lan": {
            "ground_truth": "1",
            "function": "e1000_acquire_nvm_ich8lan",
            "description": "acquire nvm mutex struct e1000 hw always unused hw pointer to the hw structure acquires the mutex for performing nvm operation"
        },
        "mutex_lock": {
            "ground_truth": "1",
            "function": "mutex_lock",
            "description": "acquire the mutex lock the mutex exclusively for this task if the mutex is not available right now it will sleep until it can get it the mutex must later on be released by the same task that acquired it recursive locking is not allowed the task may not exit without first unlocking the mutex also kernel memory where the mutex resides must not be freed with the mutex still locked the mutex must first be initialized or statically defined before it can be locked memset ing the mutex to is not allowed the config debug mutexes config option turn on debugging check that will enforce the restriction and will also do deadlock debugging this function is similar to but not equivalent to down struct mutex lock the mutex to be acquired"
        },
        "sd_zbc_check_zoned_characteristics": {
            "ground_truth": "1",
            "function": "sd_zbc_check_zoned_characteristics",
            "description": "check zoned block device characteristic read vpd page b6 get information and check that read are unconstrained struct scsi disk sdkp target disk unsigned char buf buffer where to store the vpd page data"
        },
        "gfs2_glock_nq": {
            "ground_truth": "1",
            "function": "gfs2_glock_nq",
            "description": "enqueue struct gfs2 holder onto glock acquire glock if gh gh flag gl async this never return an error struct gfs2 holder gh the holder structure glr tryfailed or errno on failure"
        },
        "cxlflash_ioctl": {
            "ground_truth": "1",
            "function": "cxlflash_ioctl",
            "description": "ioctl handler for driver read write semaphore is used to implement wouldrain of currently running ioctls the read semaphore is taken at the beginning of each ioctl thread and released upon concluding execution additionally the semaphore should be released and then reacquired in any ioctl execution path which will wait for an event to occur that is outside the scope of the ioctl an adapter reset to drain the ioctls currently running thread simply need to acquire the write semaphore struct scsi device sdev scsi device associated with lun unsigned int cmd ioctl command void user arg userspace ioctl data structure on success errno on failure"
        },
        "clockevents_exchange_device": {
            "ground_truth": "1",
            "function": "clockevents_exchange_device",
            "description": "release and request clock device called from various tick function with clockevents lock held and interrupt disabled struct clock event device old device to release can be null struct clock event device new device to request can be null"
        },
        "ice_flow_rem_prof_sync": {
            "ground_truth": "1",
            "function": "ice_flow_rem_prof_sync",
            "description": "remove flow profile assumption the caller ha acquired the lock to the profile list struct ice hw hw pointer to the hardware structure enum ice block blk classification stage struct ice flow prof prof pointer to flow profile to remove"
        },
        "xfs_btree_sblock_verify": {
            "ground_truth": "1",
            "function": "xfs_btree_sblock_verify",
            "description": "verify short format btree block struct xfs buf bp buffer containing the btree block unsigned int max recs maximum record allowed in this btree node"
        },
        "onenand_check_features": {
            "ground_truth": "1",
            "function": "onenand_check_features",
            "description": "check and set onenand feature param mtd mtd data structure check and set onenand feature lock scheme two plane struct mtd info mtd undescribed"
        },
        "radeon_fence_schedule_check": {
            "ground_truth": "1",
            "function": "radeon_fence_schedule_check",
            "description": "schedule lockup check queue delayed work item to check for lockup struct radeon device rdev radeon device pointer int ring ring index we should work with"
        },
        "kcsan_check_read": {
            "ground_truth": "1",
            "function": "kcsan_check_read",
            "description": "check regular read access for race ptr address of access size size of access"
        },
        "e1000_acquire_mac_csr_80003es2lan": {
            "ground_truth": "1",
            "function": "e1000_acquire_mac_csr_80003es2lan",
            "description": "acquire right to access kumeran register struct e1000 hw hw pointer to the hw structure acquire the semaphore to access the kumeran interface"
        },
        "check_mode": {
            "ground_truth": "1",
            "function": "check_mode",
            "description": "verify if tuner support the requested mode this function check if the tuner is capable of tuning analog tv digital tv or radio depending on what the caller want if the tuner can not support that mode it return einval otherwise it return this function is needed for board that have separate tuner for radio like device with tea5767 note mt20xx us v4l2 tuner digital tv and call set tv freq to select tv frequency so mode analog tv could actually be used to represent digital tv too struct tuner pointer to the module is internal struct tuner enum v4l2 tuner type mode mode of the tuner a defined by type enum v4l2 tuner type"
        },
        "queued_spin_lock_slowpath": {
            "ground_truth": "1",
            "function": "queued_spin_lock_slowpath",
            "description": "acquire the queued spinlock queue tail pending bit lock value fast slow unlock uncontended pending uncontended queue contended queue struct qspinlock lock pointer to queued spinlock structure u32 val current value of the queued spinlock bit word"
        },
        "mpt3sas_scsih_enclosure_find_by_handle": {
            "ground_truth": "1",
            "function": "mpt3sas_scsih_enclosure_find_by_handle",
            "description": "exclosure device search this search for enclosure device based on handle then return the enclosure object struct mpt3sas adapter ioc per adapter object u16 handle enclosure handle assigned by firmware calling function should acquire ioc sa device lock"
        },
        "i40e_read_nvm_word": {
            "ground_truth": "1",
            "function": "i40e_read_nvm_word",
            "description": "read nvm word and acquire lock if necessary read one bit word from the shadow ram struct i40e hw hw pointer to the hw structure u16 offset offset of the shadow ram word to read u16 data word read from the shadow ram"
        },
        "mips_cm_lock_other": {
            "ground_truth": "1",
            "function": "mips_cm_lock_other",
            "description": "lock access to redirect other region configure the redirect other region for the local core vp depending upon the cm revision to target the specified cluster core vp register block must be called before using the redirect other region and followed by call to mips cm unlock other when access to the redirect other region is complete this function acquires spinlock such that code between it mips cm unlock other call cannot be pre empted by anything which may reconfigure the redirect other region and cannot be interfered with by another vp in the core a such call to this function should not be nested unsigned int cluster the other cluster to be accessed unsigned int core the other core to be accessed unsigned int vp the vp within the other core to be accessed unsigned int block the register block to be accessed"
        },
        "sys_pidfd_getfd": {
            "ground_truth": "1",
            "function": "sys_pidfd_getfd",
            "description": "get file descriptor from another process this syscall get copy of file descriptor from another process based on the pidfd and file descriptor number it requires that the calling process ha the ability to ptrace the process represented by the pidfd the process which is having it file descriptor copied is otherwise unaffected int pidfd the pidfd file descriptor of the process int fd the file descriptor number to get unsigned int flag flag on how to get the fd reserved on success cloexec file descriptor is returned on error negative errno number will be returned"
        },
        "down_timeout": {
            "ground_truth": "1",
            "function": "down_timeout",
            "description": "acquire the semaphore within specified time attempt to acquire the semaphore if no more task are allowed to acquire the semaphore calling this function will put the task to sleep if the semaphore is not released within the specified number of jiffy this function return etime it return if the semaphore wa acquired struct semaphore sem the semaphore to be acquired long timeout how long to wait before failing"
        },
        "gfs2_glock_nq_num": {
            "ground_truth": "1",
            "function": "gfs2_glock_nq_num",
            "description": "acquire glock based on lock number struct gfs2 sbd sdp the filesystem u64 number the lock number const struct gfs2 glock operation glop the glock operation for the type of glock unsigned int state the state to acquire the glock in u16 flag modifier flag for the acquisition struct gfs2 holder gh the struct gfs2 holder errno"
        },
        "binder_proc_lock": {
            "ground_truth": "1",
            "function": "binder_proc_lock",
            "description": "acquire outer lock for given binder proc acquires proc outer lock used to protect binder ref structure associated with the given proc proc struct binder proc to acquire"
        },
        "i2c_check_quirks": {
            "ground_truth": "1",
            "function": "i2c_check_quirks",
            "description": "function for checking the quirk flag in an i2c adapter struct i2c adapter adap i2c adapter u64 quirk quirk flag true if the adapter ha all the specified quirk flag false if not"
        },
        "binder_get_txn_from_and_acq_inner": {
            "ground_truth": "1",
            "function": "binder_get_txn_from_and_acq_inner",
            "description": "get from and acquire inner lock same a binder get txn from except it also acquires the proc inner lock to guarantee that the thread cannot be released while operating on it the caller must call binder inner proc unlock to release the inner lock a well a call binder dec thread txn to release the reference struct binder transaction binder transaction for from the value of from"
        },
        "rio_lock_device": {
            "ground_truth": "1",
            "function": "rio_lock_device",
            "description": "acquires host device lock for specified device attepts to acquire host device lock for specified device return if device lock acquired or einval if timeout expires struct rio mport port master port to send transaction u16 destid destination id for device switch u8 hopcount hopcount to reach switch int wait m max wait time in msec no timeout"
        },
        "__cdns3_gadget_ep_clear_halt": {
            "ground_truth": "1",
            "function": "__cdns3_gadget_ep_clear_halt",
            "description": "should be called after acquiring spin lock and selecting ep struct cdns3 endpoint priv ep endpoint object to clear stall on"
        },
        "console_trylock": {
            "ground_truth": "1",
            "function": "console_trylock",
            "description": "try to lock the console system for exclusive use try to acquire lock which guarantee that the caller ha exclusive access to the console system and the console driver list return on success and on failure to acquire the lock void no argument"
        },
        "ice_flow_add_prof_sync": {
            "ground_truth": "1",
            "function": "ice_flow_add_prof_sync",
            "description": "add flow profile for packet segment and field assumption the caller ha acquired the lock to the profile list struct ice hw hw pointer to the hw struct enum ice block blk classification stage enum ice flow dir dir flow direction u64 prof id unique id to identify this flow profile struct ice flow seg info segs array of one or more packet segment that describe the flow u8 segs cnt number of packet segment provided struct ice flow prof prof store the returned flow profile added"
        },
        "cxlflash_chr_ioctl": {
            "ground_truth": "1",
            "function": "cxlflash_chr_ioctl",
            "description": "character device ioctl handler read write semaphore is used to implement wouldrain of currently running ioctls the read semaphore is taken at the beginning of each ioctl thread and released upon concluding execution additionally the semaphore should be released and then reacquired in any ioctl execution path which will wait for an event to occur that is outside the scope of the ioctl an adapter reset to drain the ioctls currently running thread simply need to acquire the write semaphore struct file file file pointer for this device unsigned int cmd ioctl command unsigned long arg userspace ioctl data structure on success errno on failure"
        },
        "iser_initialize_task_headers": {
            "ground_truth": "1",
            "function": "iser_initialize_task_headers",
            "description": "initialize task header struct iscsi task task iscsi task struct iser tx desc tx desc iser tx descriptor note this routine may race with iser teardown flow for scsi error handling tmfs so for tmf we should acquire the state mutex to avoid dereferencing the ib device which may have already been terminated"
        },
        "usb_hcd_check_unlink_urb": {
            "ground_truth": "1",
            "function": "usb_hcd_check_unlink_urb",
            "description": "check whether an urb may be unlinked host controller driver should call this routine in their dequeue method the hcd is private spinlock must be held and interrupt must be disabled the action carried out here are required for making sure than an unlink is valid struct usb hcd hcd host controller to which urb wa submitted struct urb urb urb being checked for unlinkability int status error code to store in urb if the unlink succeeds for no error otherwise negative error code in which case the dequeue method must fail the possible error code are eidrm urb wa not submitted or ha already completed the completion function may not have been called yet ebusy urb ha already been unlinked"
        },
        "lpfc_sc_to_bg_opcodes": {
            "ground_truth": "1",
            "function": "lpfc_sc_to_bg_opcodes",
            "description": "determine the blockguard opcodes to be used with the specified scsi command struct lpfc hba phba the hba for which this call is being executed struct scsi cmnd sc the scsi command to examine uint8 txop undescribed uint8 rxop undescribed zero on success non zero if tx and or rx op cannot be determined"
        },
        "ixgbe_acquire_swfw_sync_X540": {
            "ground_truth": "1",
            "function": "ixgbe_acquire_swfw_sync_X540",
            "description": "acquire swfw semaphore acquires the swfw semaphore thought the sw fw sync register for the specified function csr phy0 phy1 nvm flash struct ixgbe hw hw pointer to hardware structure u32 mask mask to specify which semaphore to acquire"
        },
        "binder_node_unlock": {
            "ground_truth": "1",
            "function": "binder_node_unlock",
            "description": "release spinlock for given binder proc release lock acquired via binder node lock node struct binder node to acquire"
        },
        "ww_mutex_lock": {
            "ground_truth": "1",
            "function": "ww_mutex_lock",
            "description": "acquire the mutex lock the mutex exclusively for this task deadlock within given class of lock are detected and handled with the wait die algorithm if the lock is not immediately available this function will either sleep until it is wait case or it selects the current context for backing off by returning edeadlk die case trying to acquire the same lock with the same context twice is also detected and signalled by returning ealready return if the mutex wa successfully acquired in the die case the caller must release all currently held mutexes for the given context and then wait for this contending lock to be available by calling ww mutex lock slow alternatively caller can opt to not acquire this lock and proceed with trying to acquire further mutexes when scanning through lru list trying to free resource the mutex must later on be released by the same task that acquired it the task may not exit without first unlocking the mutex also kernel memory where the mutex resides must not be freed with the mutex still locked the mutex must first be initialized or statically defined before it can be locked memset ing the mutex to is not allowed the mutex must be of the same lock class a wa used to initialize the acquire context mutex acquired with this function must be released with ww mutex unlock struct ww mutex lock the mutex to be acquired struct ww acquire ctx ctx acquire context or null to acquire only single lock"
        },
        "irq_can_set_affinity_usr": {
            "ground_truth": "1",
            "function": "irq_can_set_affinity_usr",
            "description": "check if affinity of irq can be set from user space like irq can set affinity above but additionally check for the affinity managed flag unsigned int irq interrupt to check"
        },
        "nd_pfn_validate": {
            "ground_truth": "1",
            "function": "nd_pfn_validate",
            "description": "read and validate info block upon return the info block buffer content pfn sb are indeterminate when validation fails and coherent info block otherwise struct nd pfn nd pfn fsdax namespace runtime state property const char sig wouldevdax or fsdax signature"
        },
        "tegra_dc_state_setup_clock": {
            "ground_truth": "1",
            "function": "tegra_dc_state_setup_clock",
            "description": "check clock setting and store them in atomic state struct tegra dc dc display controller struct drm crtc state crtc state crtc atomic state struct clk clk parent clock for display controller unsigned long pclk pixel clock unsigned int div shift clock divider on success or negative error code on failure"
        },
        "igb_acquire_nvm_82575": {
            "ground_truth": "1",
            "function": "igb_acquire_nvm_82575",
            "description": "request for access to eeprom struct e1000 hw hw pointer to the hw structure acquire the necessary semaphore for exclusive access to the eeprom set the eeprom access request bit and wait for eeprom access grant bit return successful if access grant bit set else clear the request for eeprom access and return e1000 err nvm"
        },
        "binder_node_inner_unlock": {
            "ground_truth": "1",
            "function": "binder_node_inner_unlock",
            "description": "release node and inner lock release lock acquired via binder node lock node struct binder node to acquire"
        },
        "hwspin_lock_request": {
            "ground_truth": "1",
            "function": "hwspin_lock_request",
            "description": "request an hwspinlock this function should be called by user of the hwspinlock device in order to dynamically assign them an unused hwspinlock usually the user of this lock will then have to communicate the lock is id to the remote core before it can be used for synchronization to get the id of given hwlock use hwspin lock get id should be called from process context might sleep return the address of the assigned hwspinlock or null on error void no argument"
        },
        "spider_net_prepare_tx_descr": {
            "ground_truth": "0",
            "function": "spider_net_prepare_tx_descr",
            "description": "fill tx descriptor with skb data return on success on failure fill out the descriptor structure with skb data and len copy data if needed 32bit dma struct spider net card card card structure struct sk buff skb packet to use"
        },
        "_nfs_display_fhandle": {
            "ground_truth": "0",
            "function": "_nfs_display_fhandle",
            "description": "nfs display fhandle display an nfs file handle on the console for debugging only fh file handle to display caption display caption"
        },
        "dummy_rx_push_rss_config": {
            "ground_truth": "0",
            "function": "dummy_rx_push_rss_config",
            "description": ""
        },
        "rtc_open": {
            "ground_truth": "0",
            "function": "rtc_open",
            "description": "we enforce only one user at time here with the open close"
        },
        "ov5693_read_reg": {
            "ground_truth": "0",
            "function": "ov5693_read_reg",
            "description": "i2c read write stuff"
        },
        "start_context": {
            "ground_truth": "0",
            "function": "start_context",
            "description": "local routine to start context assign the context specific mmio space add and enable the pe struct ocxlflash context ctx adapter context to be started on success errno on failure"
        },
        "bfa_uf_free": {
            "ground_truth": "0",
            "function": "bfa_uf_free",
            "description": "free an unsolicited frame back to bfa param in uf unsolicited frame to be freed return none"
        },
        "pvr2_hdw_set_cur_freq": {
            "ground_truth": "0",
            "function": "pvr2_hdw_set_cur_freq",
            "description": "set the currently tuned frequency and account for all possible driver core side effect of this action"
        },
        "efi_capsule_setup_info": {
            "ground_truth": "0",
            "function": "efi_capsule_setup_info",
            "description": "obtain the efi capsule header in the binary and setup capsule info structure platform with non standard capsule update mechanism can override this weak function so they can perform any required capsule image munging see quark quirk function for an example struct capsule info cap info pointer to current instance of capsule info structure void kbuff mapped first page buffer pointer size hdr byte the total received number of byte for efi header"
        },
        "__ip_vs_sctp_init": {
            "ground_truth": "0",
            "function": "__ip_vs_sctp_init",
            "description": "timeouts is netns related now"
        },
        "css_task_iter_start": {
            "ground_truth": "0",
            "function": "css_task_iter_start",
            "description": "initiate task iteration initiate iteration through the task of cs the caller can call cs task iter next to walk through the task until the function return null on completion of iteration cs task iter end must be called struct cgroup subsys state cs the cs to walk task of unsigned int flag cs task iter flag struct cs task iter it the task iterator to use"
        },
        "mpc52xx_lpbfifo_submit": {
            "ground_truth": "0",
            "function": "mpc52xx_lpbfifo_submit",
            "description": "submit an lpb fifo transfer request struct mpc52xx lpbfifo request req pointer to request structure"
        },
        "cik_ih_disable_interrupts": {
            "ground_truth": "0",
            "function": "cik_ih_disable_interrupts",
            "description": "disable the interrupt ring buffer disable the interrupt ring buffer cik struct amdgpu device adev amdgpu device pointer"
        },
        "iscsit_tmr_post_handler": {
            "ground_truth": "0",
            "function": "iscsit_tmr_post_handler",
            "description": "handle special after the fact action related to tmrs right now the only one that it really needed for is connection recovery releated task reassign"
        },
        "megaraid_mbox_flush_cache": {
            "ground_truth": "0",
            "function": "megaraid_mbox_flush_cache",
            "description": "flush adapter and disk cache flush adapter cache followed by disk cache adapter adapter soft state for the controller"
        },
        "cx24120_calculate_ber_window": {
            "ground_truth": "0",
            "function": "cx24120_calculate_ber_window",
            "description": "calculate ber window time"
        },
        "ceph_fill_trace": {
            "ground_truth": "0",
            "function": "ceph_fill_trace",
            "description": "incorporate result into the local cache this is either just one inode or directory dentry and possibly linked to inode after lookup reply may contain directory inode along with dentry and or target inode called with snap rwsem read"
        },
        "rseq_cmpnev_storeoffp_load": {
            "ground_truth": "0",
            "function": "rseq_cmpnev_storeoffp_load",
            "description": "compare against expectnot when it doe not match load into load and store the content of voffp into"
        },
        "enable_step": {
            "ground_truth": "0",
            "function": "enable_step",
            "description": "enable single or block step"
        },
        "find_get_entry": {
            "ground_truth": "0",
            "function": "find_get_entry",
            "description": "find and get page cache entry look up the page cache slot at mapping offset if there is page cache page the head page is returned with an increased refcount if the slot hold shadow entry of previously evicted page or swap entry from shmem tmpfs it is returned struct address space mapping the address space to search pgoff index the page cache index the head page or shadow entry null if nothing is found"
        },
        "maptype": {
            "ground_truth": "0",
            "function": "maptype",
            "description": "note that for spi cmd resp is not the same data a native protocol host return the low byte hold r1 spi bit the next byte may hold r2 spi bit for send status or after data read error cmd resp hold any four byte response for r3 read ocr and on newer card r7 if cond"
        },
        "brcms_c_validboardtype": {
            "ground_truth": "0",
            "function": "brcms_c_validboardtype",
            "description": "validate some board info parameter"
        },
        "build_ntlmssp_negotiate_blob": {
            "ground_truth": "0",
            "function": "build_ntlmssp_negotiate_blob",
            "description": "we do not malloc the blob it is passed in pbuffer because it is fixed size and small making this approach cleaner"
        },
        "mei_hbm2slots": {
            "ground_truth": "0",
            "function": "mei_hbm2slots",
            "description": "get slot number from hbm message length length size of the mei message header size length size of the message in byte number of slot"
        },
        "tb_domain_disconnect_all_paths": {
            "ground_truth": "0",
            "function": "tb_domain_disconnect_all_paths",
            "description": "disconnect all path for the domain this function can be used to disconnect all path pcie xdomain for example in preparation for host nvm firmware upgrade after this is called the path cannot be established without resetting the switch struct tb tb domain whose path are disconnected in case of success and negative errno otherwise"
        },
        "au1300_pinfunc_to_gpio": {
            "ground_truth": "0",
            "function": "au1300_pinfunc_to_gpio",
            "description": "gpic au1300 pin management arch mips alchemy common gpioint"
        },
        "phy_unregister_fixup": {
            "ground_truth": "0",
            "function": "phy_unregister_fixup",
            "description": "remove phy fixup from the list const char bus id string match fixup bus id or phy any id in phy fixup list u32 phy uid phy id match fixup phy id or phy any uid in phy fixup list u32 phy uid mask applied to phy uid and fixup phy uid before comparison"
        },
        "argv_split": {
            "ground_truth": "0",
            "function": "argv_split",
            "description": "split string at whitespace returning an argv return an array of pointer to string which are split out from str this is performed by strictly splitting on white space no quote processing is performed multiple whitespace character are considered to be single argument separator the returned array is always null terminated return null on memory allocation failure const char str the string to be split int argcp returned argument count"
        },
        "callback": {
            "ground_truth": "0",
            "function": "callback",
            "description": "external function for driver to use use this to allocate dbdma channel the device id are one of the dscr cmd0 device id which is usually redefined to more meaningful name the callback is called during dma completion interrupt"
        },
        "orangefs_revalidate_mapping": {
            "ground_truth": "0",
            "function": "orangefs_revalidate_mapping",
            "description": "defined in file"
        },
        "velocity_ethtool_down": {
            "ground_truth": "0",
            "function": "velocity_ethtool_down",
            "description": "post hook for ethtool struct net device dev network device called after an ethtool operation restore the chip back to d3 state if it is not running in case of ethtool ops nesting only put the device to sleep in the outermost block"
        },
        "gfs2_bmap": {
            "ground_truth": "0",
            "function": "gfs2_bmap",
            "description": "block map function struct address space mapping address space info sector lblock the block to map the disk address for the block or on hole or error"
        },
        "skge_clk2usec": {
            "ground_truth": "0",
            "function": "skge_clk2usec",
            "description": "chip hz to microsecond"
        },
        "rpc_prepare_task": {
            "ground_truth": "0",
            "function": "rpc_prepare_task",
            "description": "helper to call task tk ops rpc call prepare"
        },
        "iwl_send_prio_tbl": {
            "ground_truth": "0",
            "function": "iwl_send_prio_tbl",
            "description": ""
        },
        "megasas_exit": {
            "ground_truth": "0",
            "function": "megasas_exit",
            "description": "driver unload entry point void no argument"
        },
        "dx_move_dirents": {
            "ground_truth": "0",
            "function": "dx_move_dirents",
            "description": "move count entry from end of map between two memory location return pointer to last entry moved"
        },
        "xfs_rtget_summary": {
            "ground_truth": "0",
            "function": "xfs_rtget_summary",
            "description": "read and return the summary information for given extent size bitmap block combination keep track of current summary block so we do not keep reading it from the buffer cache"
        },
        "misaligned_fixup": {
            "ground_truth": "0",
            "function": "misaligned_fixup",
            "description": "handle an unaligned access return if successfully handled if some error happened"
        },
        "ceph_file_layout_is_valid": {
            "ground_truth": "0",
            "function": "ceph_file_layout_is_valid",
            "description": "return true if layout appears to be valid"
        },
        "sunsab_send_xchar": {
            "ground_truth": "0",
            "function": "sunsab_send_xchar",
            "description": "port lock is not held"
        },
        "vcn_v3_0_disable_clock_gating": {
            "ground_truth": "0",
            "function": "vcn_v3_0_disable_clock_gating",
            "description": "disable vcn clock gating disable clock gating for vcn block struct amdgpu device adev amdgpu device pointer int inst instance number"
        },
        "ip_decrease_ttl": {
            "ground_truth": "0",
            "function": "ip_decrease_ttl",
            "description": "from include net ip"
        },
        "xenbus_dev_fatal": {
            "ground_truth": "0",
            "function": "xenbus_dev_fatal",
            "description": "equivalent to xenbus dev error dev err fmt args followed by xenbus switch state dev xenbusstateclosing to schedule an orderly closedown of this driver and it peer struct xenbus device dev xenbus device int err error to report const char fmt error message format variable argument"
        },
        "ip_vs_bypass_xmit": {
            "ground_truth": "0",
            "function": "ip_vs_bypass_xmit",
            "description": "bypass transmitter let packet bypass the destination when the destination is not available it may be only used in transparent cache cluster"
        },
        "tegra210_plld_set_defaults": {
            "ground_truth": "0",
            "function": "tegra210_plld_set_defaults",
            "description": "plld pll with fractional sdm"
        },
        "widen_string": {
            "ground_truth": "0",
            "function": "widen_string",
            "description": "handle field width padding for string buf current buffer position length of string end end of output buffer spec for field width and flag return new buffer position after padding"
        },
        "f_eeprom_wen": {
            "ground_truth": "0",
            "function": "f_eeprom_wen",
            "description": "enable writes to config eeprom if supported"
        },
        "ssb_read8": {
            "ground_truth": "0",
            "function": "ssb_read8",
            "description": "device mmio register read write function"
        },
        "get_index": {
            "ground_truth": "0",
            "function": "get_index",
            "description": "assign stream index number based on v4l2 dev note that when this is called the new device ha not yet been registered in the video device array but it wa able to obtain minor number this mean that we can always obtain free stream index number since the worst case scenario is that there are video num device slot in use of the video device array return free index number struct video device vdev video device to assign index number to vdev v4l2 dev should be assigned"
        },
        "ice_is_vf_trusted": {
            "ground_truth": "0",
            "function": "ice_is_vf_trusted",
            "description": "struct ice vf vf pointer to the vf info"
        },
        "opa_vnic_set_vesw_info": {
            "ground_truth": "0",
            "function": "opa_vnic_set_vesw_info",
            "description": "set the vesw information this function update the vesw info that is maintained by the given adapter with vesw info provided reserved field are stored and returned back to em a is struct opa vnic adapter adapter vnic port adapter struct opa vesw info info pointer to vesw info structure"
        },
        "fscrypt_initialize": {
            "ground_truth": "0",
            "function": "fscrypt_initialize",
            "description": "allocate major buffer for f encryption we only call this when we start accessing encrypted file since it result in memory getting allocated that would not otherwise be used unsigned int cop flag fscrypt operation flag on success errno on failure"
        },
        "hns_ppe_common_get_cfg": {
            "ground_truth": "0",
            "function": "hns_ppe_common_get_cfg",
            "description": "get ppe common config struct dsaf device dsaf dev dasf device int comm index common index return success negative fail"
        },
        "imgu_css_set_parameters": {
            "ground_truth": "0",
            "function": "imgu_css_set_parameters",
            "description": "get new set of parameter from pool and initialize them based on the parameter params gdc and obgrid any of these may be null in which case the previously set parameter are used if parameter have not been set previously initialize from scratch return index to cs parameter set info which ha the newly created parameter or negative value on error"
        },
        "rt2x00queue_insert_l2pad": {
            "ground_truth": "0",
            "function": "rt2x00queue_insert_l2pad",
            "description": "align header payload to byte boundary apply l2 padding to align both header and payload to byte boundary struct sk buff skb the skb to align unsigned int header length length of header"
        },
        "efa_com_aenq_intr_handler": {
            "ground_truth": "0",
            "function": "efa_com_aenq_intr_handler",
            "description": "aenq interrupt handler go over the async event notification queue and call the proper aenq handler struct efa com dev edev efa communication layer struct void data data of interrupt handler"
        },
        "ehci_mem_cleanup": {
            "ground_truth": "0",
            "function": "ehci_mem_cleanup",
            "description": "the queue head and transfer descriptor are managed from pool tied to each of the per device structure this is the initialisation and cleanup code"
        },
        "of_dma_route_allocate": {
            "ground_truth": "0",
            "function": "of_dma_route_allocate",
            "description": "of dma router register register dma router to dt dma helper a controller modify the dma spec for the dma controller to use and to set up the requested route the route need to be free up np device node of dma router of dma route allocate setup function for the router which need to dma router pointer to dma router structure to be used when return on success or appropriate errno value on error allocated memory should be freed with appropriate of dma controller free call"
        },
        "i40e_set_hw_flags": {
            "ground_truth": "0",
            "function": "i40e_set_hw_flags",
            "description": "set hw flag struct i40e hw hw pointer to the hardware structure"
        },
        "ali14xx_set_pio_mode": {
            "ground_truth": "0",
            "function": "ali14xx_set_pio_mode",
            "description": "set pio mode for the specified drive this function computes timing parameter and set controller register accordingly"
        },
        "at91_vbus_session": {
            "ground_truth": "0",
            "function": "at91_vbus_session",
            "description": "vbus is here turn everything on that is ready"
        },
        "pcs_irq_init_chained_handler": {
            "ground_truth": "0",
            "function": "pcs_irq_init_chained_handler",
            "description": "set up chained interrupt handler struct pc device pc pc driver instance struct device node np device node pointer"
        },
        "iowarrior_disconnect": {
            "ground_truth": "0",
            "function": "iowarrior_disconnect",
            "description": "iowarrior disconnect called by the usb core when the device is removed from the system"
        },
        "__ip_mc_join_group": {
            "ground_truth": "0",
            "function": "__ip_mc_join_group",
            "description": "join multicast group"
        },
        "handle_moddevtable": {
            "ground_truth": "0",
            "function": "handle_moddevtable",
            "description": "create module alias statement at this time we cannot write the actual output source yet so we write into the mod dev table buf buffer"
        },
        "fh_partition_get_dtprop": {
            "ground_truth": "0",
            "function": "fh_partition_get_dtprop",
            "description": "get property from guest device tree return zero on success non zero on error int handle handle of partition whose device tree is to be accessed uint64 dtpath addr physical address of device tree path to access uint64 propname addr physical address of name of property uint64 propvalue addr physical address of property value buffer uint32 propvalue len length of buffer on entry length of property on return"
        },
        "convert_signed_value": {
            "ground_truth": "0",
            "function": "convert_signed_value",
            "description": "convert from the byte word on usb descriptor to the zero based integer"
        },
        "show_pte": {
            "ground_truth": "0",
            "function": "show_pte",
            "description": "this is useful to dump out the page table associated with addr in mm amm"
        },
        "amd_set_speed": {
            "ground_truth": "0",
            "function": "amd_set_speed",
            "description": "amd set speed writes timing value to the chipset register"
        },
        "devm_clk_hw_register_clkdev": {
            "ground_truth": "0",
            "function": "devm_clk_hw_register_clkdev",
            "description": "managed clk lookup registration for clk hw con id or dev id may be null a wildcard just a in the rest of clkdev to make thing easier for mass registration we detect error clk hws from previous clk hw register call and return the error code for those this is to permit this function to be called immediately after clk hw register basic gpio gated clock which can be enabled and disabled with gpio output trait of this clock prepare clk un prepare only ensures parent is un prepared enable clk enable and clk disable are functional control gpio rate inherits rate from parent no clk set rate support parent fixed parent no clk set parent support struct device dev device this lookup is bound struct clk hw hw struct clk hw to associate with all clk lookup const char con id connection id string on device const char dev id format string describing device name"
        },
        "xfs_dir2_dirblock_bytes": {
            "ground_truth": "0",
            "function": "xfs_dir2_dirblock_bytes",
            "description": "number of byte in directory block"
        },
        "cec_msg_menu_status": {
            "ground_truth": "0",
            "function": "cec_msg_menu_status",
            "description": "device menu control feature"
        },
        "ath5k_eeprom_bin2freq": {
            "ground_truth": "0",
            "function": "ath5k_eeprom_bin2freq",
            "description": "translate binary channel representation in eeprom to frequency"
        },
        "drm_pci_free": {
            "ground_truth": "0",
            "function": "drm_pci_free",
            "description": "free pci consistent memory block fixme this is needle abstraction of the linux dma api and should be removed struct drm device dev drm device drm dma handle dmah handle to memory block"
        },
        "omap4_calc_volt_ramp": {
            "ground_truth": "0",
            "function": "omap4_calc_volt_ramp",
            "description": "calculates voltage ramping delay on omap4 calculates voltage ramp prescaler counter value for voltage difference on omap4 return field value suitable for writing to voltsetup register for channel in following format bit prescaler bit counter see omap4 trm for reference struct voltagedomain voltdm channel to calculate value for u32 voltage diff voltage difference in microvolt"
        },
        "blk_ksm_put_slot": {
            "ground_truth": "0",
            "function": "blk_ksm_put_slot",
            "description": "release reference to slot struct blk ksm keyslot slot the keyslot to release the reference of any context"
        },
        "most_put_mbo": {
            "ground_truth": "0",
            "function": "most_put_mbo",
            "description": "return buffer to pool struct mbo mbo most buffer"
        },
        "st_ll_sleep_state": {
            "ground_truth": "0",
            "function": "st_ll_sleep_state",
            "description": "called from st core when pm related packet arrives"
        },
        "ndesc_get_rx_status": {
            "ground_truth": "0",
            "function": "ndesc_get_rx_status",
            "description": "this function verifies if each incoming frame ha some error and if required update the multicast statistic in case of success it return good frame because the gmac device is supposed to be able to compute the csum in hw"
        },
        "fschmd_release_resources": {
            "ground_truth": "0",
            "function": "fschmd_release_resources",
            "description": "release our data struct when we are detached from the i2c client and all reference to our watchdog device are released"
        },
        "__cvmx_helper_rgmii_link_get": {
            "ground_truth": "0",
            "function": "__cvmx_helper_rgmii_link_get",
            "description": "auto negotiation the result of this function may not match octeon is link config if auto negotiation ha changed since the last call to cvmx helper link set return link state int ipd port ipd pko port to query"
        },
        "snd_emu8000_free": {
            "ground_truth": "0",
            "function": "snd_emu8000_free",
            "description": "free resource"
        },
        "xive_get_irqchip_state": {
            "ground_truth": "0",
            "function": "xive_get_irqchip_state",
            "description": "called with irq descriptor lock held"
        },
        "EXhalbtc8723b1ant_PowerOnSetting": {
            "ground_truth": "0",
            "function": "EXhalbtc8723b1ant_PowerOnSetting",
            "description": "the following is interface which will notify coex module"
        },
        "radeon_ring_restore": {
            "ground_truth": "0",
            "function": "radeon_ring_restore",
            "description": "append saved command to the ring again allocates space on the ring and restore the previously saved command struct radeon device rdev radeon device pointer struct radeon ring ring ring to append command to unsigned size number of dwords we want to write uint32 data saved command"
        },
        "rpc_create_client_dir": {
            "ground_truth": "0",
            "function": "rpc_create_client_dir",
            "description": "create new rpc client directory in rpc pipefs this creates directory at the given path associated with rpc clnt which will contain file named info with some basic information about the client together with any pipe that may later be created using rpc mkpipe struct dentry dentry the parent of new directory const char name the name of new directory struct rpc clnt rpc client rpc client to associate with this directory"
        },
        "ppc440spe_xor_set_link": {
            "ground_truth": "0",
            "function": "ppc440spe_xor_set_link",
            "description": "set link address in xor cb struct ppc440spe adma desc slot prev desc undescribed struct ppc440spe adma desc slot next desc undescribed"
        },
        "ipr_copy_ucode_buffer": {
            "ground_truth": "0",
            "function": "ipr_copy_ucode_buffer",
            "description": "copy user buffer to kernel buffer copy microcode image from user buffer into buffer allocated by ipr alloc ucode buffer return value on success other on failure struct ipr sglist sglist scatter gather list pointer u8 buffer buffer pointer u32 len buffer length"
        },
        "e1000_resume_workarounds_pchlan": {
            "ground_truth": "0",
            "function": "e1000_resume_workarounds_pchlan",
            "description": "workarounds needed during sx s0 struct e1000 hw hw pointer to the hw structure during sx to s0 transition on non managed device or managed device on which phy reset are not blocked if the phy register cannot be accessed properly by the toggle the lanphypc value to power cycle the phy on i217 setup intel rapid start technology"
        },
        "mv88f5281_get_tclk_freq": {
            "ground_truth": "0",
            "function": "mv88f5281_get_tclk_freq",
            "description": ""
        },
        "mipi_dsi_dcs_get_display_brightness": {
            "ground_truth": "0",
            "function": "mipi_dsi_dcs_get_display_brightness",
            "description": "get the current brightness value of the display struct mipi dsi device dsi dsi peripheral device u16 brightness brightness value on success or negative error code on failure"
        },
        "snd_atiixp_spdif_prepare": {
            "ground_truth": "0",
            "function": "snd_atiixp_spdif_prepare",
            "description": "set up slot and format for spdif out"
        },
        "hw_atl_tps_tx_desc_rate_x_set": {
            "ground_truth": "0",
            "function": "hw_atl_tps_tx_desc_rate_x_set",
            "description": "set tx packet scheduler descriptor rate integral value"
        },
        "fscache_readpages_cancel": {
            "ground_truth": "0",
            "function": "fscache_readpages_cancel",
            "description": "cancel read alloc on page uncache unreserve the page reserved earlier in readpages via fscache readpages or alloc and similar in most successful cache in readpages this doe not do anything in case when the underlying netfs is readahead failed we need to clean up the pagelist unmark and uncache this function may sleep a it may have to clean up disk state struct fscache cookie cookie the cookie representing the inode is cache object struct list head page the netfs page that we canceled write on in readpages"
        },
        "rx51_secure_rng_call": {
            "ground_truth": "0",
            "function": "rx51_secure_rng_call",
            "description": "u32 ptr undescribed u32 count undescribed u32 flag undescribed"
        },
        "qed_vf_get_num_rxqs": {
            "ground_truth": "0",
            "function": "qed_vf_get_num_rxqs",
            "description": "brief get number of rx queue allocated for vf by qed param hwfn param num rxqs allocated rx queue"
        },
        "kvm_inject_pabt": {
            "ground_truth": "0",
            "function": "kvm_inject_pabt",
            "description": "inject prefetch abort into the guest it is assumed that this code is called from the vcpu thread and that the vcpu therefore is not currently executing guest code struct kvm vcpu vcpu the vcpu to receive the prefetch abort unsigned long addr the address to report in the dfar"
        },
        "hfsplus_find_cat": {
            "ground_truth": "0",
            "function": "hfsplus_find_cat",
            "description": "try to get catalog entry for given catalog id"
        },
        "gelic_descr_get_status": {
            "ground_truth": "0",
            "function": "gelic_descr_get_status",
            "description": "return the status of descriptor return the status a in the dmac cmd status field of the descriptor struct gelic descr descr descriptor to look at"
        },
        "phy_get_non_dummy_port": {
            "ground_truth": "0",
            "function": "phy_get_non_dummy_port",
            "description": "currently contained by the dummy port then the phy is considered to not be part of port this method return handle to port that contains the supplied phy null this value is returned if the phy is not part of real port it is contained in the dummy port null all other value indicate handle pointer to the port containing the phy struct isci phy iphy undescribed"
        },
        "usb_dsbr100_suspend": {
            "ground_truth": "0",
            "function": "usb_dsbr100_suspend",
            "description": "suspend device stop device"
        },
        "usbnet_probe": {
            "ground_truth": "0",
            "function": "usbnet_probe",
            "description": "minidrivers are just driver using the usbnet core a powerful network specific subroutine library that happens to do pretty much everything except custom framing and chip specific stuff"
        },
        "sysv_free_block": {
            "ground_truth": "0",
            "function": "sysv_free_block",
            "description": ""
        },
        "to_dpu_hw_mixer": {
            "ground_truth": "0",
            "function": "to_dpu_hw_mixer",
            "description": "convert base object dpu hw base to container struct dpu hw blk hw pointer to base hardware block pointer to hardware block container"
        },
        "pvr2_hdw_commit_setup": {
            "ground_truth": "0",
            "function": "pvr2_hdw_commit_setup",
            "description": "figure out if we need to commit control change if so mark internal state flag to indicate this fact and return true otherwise do nothing else and return false"
        },
        "trace_clock": {
            "ground_truth": "0",
            "function": "trace_clock",
            "description": "trace clock between trace clock not completely serialized but not completely incorrect when crossing cpu either this is based on cpu clock which will allow at most jiffy of jitter between cpu so it is pretty scalable clock but there can be offset in the trace data"
        },
        "sysfs_rename_link_ns": {
            "ground_truth": "0",
            "function": "sysfs_rename_link_ns",
            "description": "rename symlink in object is directory struct kobject kobj object we are acting for struct kobject targ object we are pointing to const char old previous name of the symlink const char new new name of the symlink const void new n new namespace of the symlink helper function for the common rename symlink idiom"
        },
        "convert_to_trace_point": {
            "ground_truth": "0",
            "function": "convert_to_trace_point",
            "description": "convert subprogram die to trace point"
        },
        "i40e_get_media_type": {
            "ground_truth": "0",
            "function": "i40e_get_media_type",
            "description": "get medium type struct i40e hw hw pointer to the hardware structure"
        },
        "netlink_dump_done": {
            "ground_truth": "0",
            "function": "netlink_dump_done",
            "description": "it look bit ugly it would be better to create kernel thread"
        },
        "spi_test_run_tests": {
            "ground_truth": "0",
            "function": "spi_test_run_tests",
            "description": "run an array of spi message test struct spi device spi the spi device on which to run the test struct spi test test null terminated array of spi test status error a per spi test run test"
        },
        "ef4_tx_map_data": {
            "ground_truth": "0",
            "function": "ef4_tx_map_data",
            "description": "map all data from an skb for dma and create descriptor on the queue"
        },
        "edac_device_workq_teardown": {
            "ground_truth": "0",
            "function": "edac_device_workq_teardown",
            "description": "edac device workq teardown stop the workq processing on this edac dev"
        },
        "hid_reset": {
            "ground_truth": "0",
            "function": "hid_reset",
            "description": "workqueue routine to reset the device or clear halt"
        },
        "proc_flush_pid": {
            "ground_truth": "0",
            "function": "proc_flush_pid",
            "description": "remove dcache entry for pid from the proc dcache this function walk list of inodes that belong to any proc filesystem that are attached to the pid and flush them from the dentry cache it is safe and reasonable to cache proc entry for task until that task exit after that they just clog up the dcache with useless entry possibly causing useful dcache entry to be flushed instead this routine is provided to flush those useless dcache entry when process is reaped note this routine is just an optimization so it doe not guarantee that no dcache entry will exist after process is reaped it just make it very unlikely that any will persist struct pid pid pid that should be flushed"
        },
        "detect_intel_iommu": {
            "ground_truth": "0",
            "function": "detect_intel_iommu",
            "description": "intel iommu detection"
        },
        "snd_soc_component_read": {
            "ground_truth": "0",
            "function": "snd_soc_component_read",
            "description": "read register value struct snd soc component component component to read from unsigned int reg register to read read value"
        },
        "enetc_streamgate_hw_set": {
            "ground_truth": "0",
            "function": "enetc_streamgate_hw_set",
            "description": "stream gate instance set descriptor"
        },
        "fhci_port_disable": {
            "ground_truth": "0",
            "function": "fhci_port_disable",
            "description": "disable the usb port by clearing the en bit in the usbmod register"
        },
        "tcp_fast_parse_options": {
            "ground_truth": "0",
            "function": "tcp_fast_parse_options",
            "description": "fast parse option this hope to only see timestamps if it is wrong it fall back on tcp parse option"
        },
        "fscache_submit_exclusive_op": {
            "ground_truth": "0",
            "function": "fscache_submit_exclusive_op",
            "description": "submit an exclusive operation for an object other ops are excluded from running simultaneously with this one this get any extra ref it need on an op"
        },
        "memdup_user_nul": {
            "ground_truth": "0",
            "function": "memdup_user_nul",
            "description": "duplicate memory region from user space and nul terminate const void user src source address in user space size len number of byte to copy an err ptr on failure"
        },
        "ubifs_wbuf_sync_nolock": {
            "ground_truth": "0",
            "function": "ubifs_wbuf_sync_nolock",
            "description": "synchronize write buffer this function synchronizes write buffer buf and return zero in case of success or negative error code in case of failure note although write buffer are of max write size this function doe not necessarily writes all max write size byte to the flash instead if the write buffer is only partially filled with data only the used part of the write buffer aligned on min io size boundary is synchronized this way we waste le space struct ubifs wbuf wbuf write buffer to synchronize"
        },
        "bnx2x_vfpf_init": {
            "ground_truth": "0",
            "function": "bnx2x_vfpf_init",
            "description": "tell pf about sb address"
        },
        "mgsl_get_text_ptr": {
            "ground_truth": "0",
            "function": "mgsl_get_text_ptr",
            "description": "1st function defined in text section calling this function in init module followed by breakpoint allows remote debugger gdb to get the text address for the add symbol file command this allows remote debugging of dynamically loadable module"
        },
        "usb_role_switch_get": {
            "ground_truth": "0",
            "function": "usb_role_switch_get",
            "description": "find usb role switch linked with the caller find and return role switch linked with dev the reference count for the found switch is incremented struct device dev the caller device"
        },
        "bc_enable": {
            "ground_truth": "0",
            "function": "bc_enable",
            "description": "some r4000 r4400 r4600 r5000 machine may have non dma coherent chipset implemented cache on machine with other cpu the cpu doe the cache thing itself"
        },
        "pata_icside_irqpending_arcin_v6": {
            "ground_truth": "0",
            "function": "pata_icside_irqpending_arcin_v6",
            "description": "prototype pata icside irqprobe struct expansion card ec purpose detect an active interrupt from card"
        },
        "ice_tx_map": {
            "ground_truth": "0",
            "function": "ice_tx_map",
            "description": "build the tx descriptor this function loop over the skb data pointed to by first and get physical address for each memory location and program it and the length into the transmit descriptor struct ice ring tx ring ring to send buffer on struct ice tx buf first first buffer info buffer to use struct ice tx offload params off pointer to struct that hold offload parameter"
        },
        "CIFSSMBQAllEAs": {
            "ground_truth": "0",
            "function": "CIFSSMBQAllEAs",
            "description": "do path based query all ea call and parse the result this is common function used by listxattr and getxattr type call when ea name is set it look for that attribute name and stuff that value into the eadata buffer when ea name is null it stuff list of attribute name into the buffer in both case the return value is either the length of the resulting data or negative error code if eadata is null pointer then the data is not copied to it but the length is returned"
        },
        "gss_refresh": {
            "ground_truth": "0",
            "function": "gss_refresh",
            "description": "refresh credential xxx finish"
        },
        "jbd2_journal_force_commit": {
            "ground_truth": "0",
            "function": "jbd2_journal_force_commit",
            "description": "force any uncommitted transaction caller want unconditional commit we can only force the running transaction if we do not have an active handle otherwise we will deadlock journal journal journal to force"
        },
        "bmp180_compensate_press": {
            "ground_truth": "0",
            "function": "bmp180_compensate_press",
            "description": "return pressure in pa resolution is pa taken from datasheet section calculating pressure and temperature"
        },
        "nct7904_wdt_start": {
            "ground_truth": "0",
            "function": "nct7904_wdt_start",
            "description": "watchdog function"
        },
        "v9fs_fid_find": {
            "ground_truth": "0",
            "function": "v9fs_fid_find",
            "description": "retrieve fid that belongs to the specified uid struct dentry dentry dentry to look for fid in kuid uid return fid that belongs to the specified user int any if non zero return any fid associated with the dentry"
        },
        "gbefb_show_memsize": {
            "ground_truth": "0",
            "function": "gbefb_show_memsize",
            "description": ""
        },
        "parse_codec_mode": {
            "ground_truth": "0",
            "function": "parse_codec_mode",
            "description": "parse the content after the line codec accept only the line with three number and assign the current codec"
        },
        "aoc_low_power_setting": {
            "ground_truth": "0",
            "function": "aoc_low_power_setting",
            "description": "return special serdes setting for low power aoc cable the power class threshold and setting being used were all found by empirical testing summary of the logic if qsfp and qsfp type aoc and qsfp power class return return leave at default"
        },
        "set_input_gain": {
            "ground_truth": "0",
            "function": "set_input_gain",
            "description": "set input bus gain one unit is 5db"
        },
        "pcmcia_fixup_vpp": {
            "ground_truth": "0",
            "function": "pcmcia_fixup_vpp",
            "description": "set vpp to new voltage level pcmcia fixup vpp allows pcmcia device driver to set vpp to new voltage level between call to pcmcia enable device and pcmcia disable device struct pcmcia device dev pcmcia device unsigned char new vpp new vpp voltage"
        },
        "btrfs_drop_pages": {
            "ground_truth": "0",
            "function": "btrfs_drop_pages",
            "description": "unlocks page after btrfs file write is done with them"
        },
        "omap_pm_wakeup_setup": {
            "ground_truth": "0",
            "function": "omap_pm_wakeup_setup",
            "description": "configuration of the wakeup event is board specific for the moment we put it into this helper function later it may move to board specific file"
        },
        "intel_set_cpu_fifo_underrun_reporting": {
            "ground_truth": "0",
            "function": "intel_set_cpu_fifo_underrun_reporting",
            "description": "set cpu fifo underrrun reporting state this function set the fifo underrun state for pipe it is used in the modeset code to avoid false positive since on many platform underruns are expected when disabling or enabling the pipe notice that on some platform disabling underrun report for one pipe disables for all due to shared interrupt actual reporting is still per pipe though return the previous state of underrun reporting struct drm i915 private dev priv i915 device instance enum pipe pipe cpu pipe to set state for bool enable whether underruns should be reported or not"
        },
        "force_logical_link_state_down": {
            "ground_truth": "0",
            "function": "force_logical_link_state_down",
            "description": "called when the logical link state is not down a it should be"
        },
        "IIO_CONST_ATTR": {
            "ground_truth": "0",
            "function": "IIO_CONST_ATTR",
            "description": "the user can choose any frequency between inv mpu6050 min fifo rate and inv mpu6050 max fifo rate but only these frequency are matched by the low pas filter specifically each of these sampling rate are about twice the bandwidth of corresponding low pas filter which should eliminate aliasing following the nyquist principle by picking frequency different from these the user risk aliasing effect"
        },
        "kvmppc_handle_fac": {
            "ground_truth": "0",
            "function": "kvmppc_handle_fac",
            "description": "enable facility tar ebb dscr for the guest"
        },
        "rtw8821c_coex_cfg_init": {
            "ground_truth": "0",
            "function": "rtw8821c_coex_cfg_init",
            "description": "for coex"
        },
        "sh7757lcr_setup": {
            "ground_truth": "0",
            "function": "sh7757lcr_setup",
            "description": "initialize the board"
        },
        "vxge_hw_ring_rxd_1b_info_get": {
            "ground_truth": "0",
            "function": "vxge_hw_ring_rxd_1b_info_get",
            "description": "vxge hw ring rxd 1b info get get extended information associated with completed receive descriptor for 1b mode retrieve extended information associated with completed receive descriptor vpath handle virtual path handle rxdh descriptor handle rxd info descriptor information"
        },
        "wil_ring_wmark_high": {
            "ground_truth": "0",
            "function": "wil_ring_wmark_high",
            "description": "wil ring wmark high high watermark for available descriptor space"
        },
        "appldata_work_fn": {
            "ground_truth": "0",
            "function": "appldata_work_fn",
            "description": "appldata work fn call data gathering function for each active module"
        },
        "linkmode_adv_to_fiber_adv_t": {
            "ground_truth": "0",
            "function": "linkmode_adv_to_fiber_adv_t",
            "description": "small helper function that translates linkmode advertisement setting to phy autonegotiation advertisement for the mii adv register for fiber link unsigned long advertise the linkmode advertisement setting"
        },
        "edge_bulk_in_callback": {
            "ground_truth": "0",
            "function": "edge_bulk_in_callback",
            "description": "edge bulk in callback this is the callback function for when we have received data on the bulk in endpoint"
        },
        "h_24x7_event_start_txn": {
            "ground_truth": "0",
            "function": "h_24x7_event_start_txn",
            "description": "24x7 counter only support read transaction they are always counting and dont need support add transaction cache the flag but otherwise ignore transaction that are not perf pmu txn read"
        },
        "of_icc_xlate_onecell": {
            "ground_truth": "0",
            "function": "of_icc_xlate_onecell",
            "description": "of icc xlate onecell translate function using single index this is generic translate function that can be used to model simple interconnect provider that have one device tree node and provide multiple interconnect node single cell is used a an index into an array of icc node specified in the icc onecell data struct when registering the provider spec of phandle args to map into an interconnect node data private data pointer to struct icc onecell data"
        },
        "ttusb_dec_set_interface": {
            "ground_truth": "0",
            "function": "ttusb_dec_set_interface",
            "description": "setting the interface of the dec tends to take down the usb communication for short period so it is important not to call this function just before trying to talk to it"
        },
        "alchemy_uart_enable": {
            "ground_truth": "0",
            "function": "alchemy_uart_enable",
            "description": "enable an uart block if it is not already"
        },
        "do_submit": {
            "ground_truth": "0",
            "function": "do_submit",
            "description": "drbd req"
        },
        "mgsl_put_char": {
            "ground_truth": "0",
            "function": "mgsl_put_char",
            "description": "mgsl put char add character to the transmit buffer argument tty pointer to tty information structure ch character to add to transmit buffer return value none"
        },
        "qeth_send_simple_setassparms": {
            "ground_truth": "0",
            "function": "qeth_send_simple_setassparms",
            "description": "ipv4 variant"
        },
        "nouveau_hwmon_fini": {
            "ground_truth": "0",
            "function": "nouveau_hwmon_fini",
            "description": "nouveau hwmon"
        },
        "key_seal": {
            "ground_truth": "0",
            "function": "key_seal",
            "description": "have the tpm seal encrypt the symmetric key"
        },
        "__cvmx_helper_rgmii_probe": {
            "ground_truth": "0",
            "function": "__cvmx_helper_rgmii_probe",
            "description": "return number of rgmii gmii mii port int interface interface to probe"
        },
        "create_vma_map": {
            "ground_truth": "0",
            "function": "create_vma_map",
            "description": "the three function below are for maintaining and accessing the vma to fileoffset map"
        },
        "ipmr_update_thresholds": {
            "ground_truth": "0",
            "function": "ipmr_update_thresholds",
            "description": "fill oifs list it is called under write locked mrt lock"
        },
        "msc_buffer_get_page": {
            "ground_truth": "0",
            "function": "msc_buffer_get_page",
            "description": "get msc buffer page at given offset this traverse msc win list so holding msc buf mutex is expected from the caller struct msc msc msc device unsigned long pgoff page offset into the storage buffer page if pgoff corresponds to valid buffer page or null"
        },
        "kvm_pmi_trigger_fn": {
            "ground_truth": "0",
            "function": "kvm_pmi_trigger_fn",
            "description": "note each perf counter is defined a struct kvm pmc there are two type of perf counter general purpose gp and fixed gp counter are stored in gp counter and fixed counter are stored in fixed counter respectively both of them are part of struct kvm pmu pmu understands the difference between gp counter and fixed counter however amd doe not support fixed counter there are three type of index to access perf counter pmc msr named msr for example intel ha msr ia32 perfctrn and amd ha msr k7 perfctrn msr index named idx this normally is used by rdpmc instruction for instance amd rdpmc instruction us 0003h in ecx to access c001 0007h msr k7 perctr3 intel ha similar mechanism except that it also support fixed counter idx can be used to a index to gp and fixed counter global pmc index named pmc pmc is an index specific to pmu code each pmc stored in kvm pmc idx field is unique across all perf counter both gp and fixed the mapping relationship between pmc and perf counter is a the following intel intel pmc max generic gp counter intel pmc idx fixed intel pmc idx fixed fixed amd amd64 num counter gp counter"
        },
        "set_tx_buff_desc_addr_low_0": {
            "ground_truth": "0",
            "function": "set_tx_buff_desc_addr_low_0",
            "description": ""
        },
        "fsmc_write_buf": {
            "ground_truth": "0",
            "function": "fsmc_write_buf",
            "description": "fsmc write buf write buffer to chip host fsmc nand controller buf data buffer len number of byte to write"
        },
        "apl_pmi2mem": {
            "ground_truth": "0",
            "function": "apl_pmi2mem",
            "description": "second stage decode compute rank bank row column"
        },
        "pvr2_i2c_basic_op": {
            "ground_truth": "0",
            "function": "pvr2_i2c_basic_op",
            "description": "this is the common low level entry point for doing i2c operation to the hardware"
        },
        "vega20_thermal_enable_alert": {
            "ground_truth": "0",
            "function": "vega20_thermal_enable_alert",
            "description": "param hwmgr the address of the hardware manager struct pp hwmgr hwmgr undescribed"
        },
        "reg_type_mismatch_ok": {
            "ground_truth": "0",
            "function": "reg_type_mismatch_ok",
            "description": "return true if it is ok to have the same insn return different type"
        },
        "identify_siblings": {
            "ground_truth": "0",
            "function": "identify_siblings",
            "description": "identify sibling cpu get called from identify cpu this populates the information related to logical execution unit in per cpu data structure"
        },
        "btc8821a2ant_bt_rssi_state": {
            "ground_truth": "0",
            "function": "btc8821a2ant_bt_rssi_state",
            "description": "local function proto type if needed local function start with"
        },
        "mei_me_count_full_read_slots": {
            "ground_truth": "0",
            "function": "mei_me_count_full_read_slots",
            "description": "count read full slot struct mei device dev the device structure eoverflow if overflow otherwise filled slot count"
        },
        "gpio_twl4030_write": {
            "ground_truth": "0",
            "function": "gpio_twl4030_write",
            "description": "to configure twl4030 gpio module register"
        },
        "rtl8192_process_phyinfo": {
            "ground_truth": "0",
            "function": "rtl8192_process_phyinfo",
            "description": "we can not declare rssi evm total value of sliding window to be local static otherwise it may increase when we return from s3 s4 the value will be kept in memory or disk declare the value in the adaptor and it will be reinitialized when returned from s3 s4"
        },
        "sd_stop0": {
            "ground_truth": "0",
            "function": "sd_stop0",
            "description": "called on streamoff with alt and on disconnect"
        },
        "fail_all_outstanding_cmds": {
            "ground_truth": "0",
            "function": "fail_all_outstanding_cmds",
            "description": "called when controller lockup detected"
        },
        "wmi_get_acpi_device_uid": {
            "ground_truth": "0",
            "function": "wmi_get_acpi_device_uid",
            "description": "get uid name of acpi device that defines guid find the uid of acpi device associated with this wmi guid const char guid string char string of the form fa50ff2b f2e8 45de 83fa the acpi uid field value or null if the wmi guid wa not found"
        },
        "blk_cleanup_queue": {
            "ground_truth": "0",
            "function": "blk_cleanup_queue",
            "description": "shutdown request queue mark dying drain all pending request mark dead destroy and put it all future request will be failed immediately with enodev struct request queue request queue to shutdown can sleep"
        },
        "ide_scan_pcibus": {
            "ground_truth": "0",
            "function": "ide_scan_pcibus",
            "description": "perform the initial ide driver scan perform the initial bus rather than driver ordered scan of the pci driver after this all ide pci handling becomes standard module ordering not traditionally ordered void no argument"
        },
        "ip6_mroute_setsockopt": {
            "ground_truth": "0",
            "function": "ip6_mroute_setsockopt",
            "description": "socket option and virtual interface manipulation the whole virtual interface system is complete heap but unfortunately that is how bsd mrouted happens to think maybe one day with proper mospf pim router set up we can clean this up"
        },
        "atomic_set": {
            "ground_truth": "0",
            "function": "atomic_set",
            "description": "set atomic variable atomically set the value of to pointer of type atomic required value"
        },
        "poly_l2": {
            "ground_truth": "0",
            "function": "poly_l2",
            "description": "poly l2 base logarithm by polynomial approximation"
        },
        "alc274_fixup_bind_dacs": {
            "ground_truth": "0",
            "function": "alc274_fixup_bind_dacs",
            "description": "forcibly assign nid to hp lo while nid to spk for eq"
        },
        "j1939_local_ecu_put": {
            "ground_truth": "0",
            "function": "j1939_local_ecu_put",
            "description": "keep the cache of what is local"
        },
        "i40e_vsi_setup_rx_resources": {
            "ground_truth": "0",
            "function": "i40e_vsi_setup_rx_resources",
            "description": "allocate vsi queue rx resource if this function return with an error then it is possible one or more of the ring is populated while the rest are not it is the caller duty to clean those orphaned ring return on success negative on failure struct i40e vsi vsi ptr to the vsi"
        },
        "resource_overlaps": {
            "ground_truth": "0",
            "function": "resource_overlaps",
            "description": "true if any part of r1 overlap r2"
        },
        "coresight_is_def_sink_type": {
            "ground_truth": "0",
            "function": "coresight_is_def_sink_type",
            "description": "return true if the device is suitable type for default sink"
        },
        "snd_emu10k1_free_pages": {
            "ground_truth": "0",
            "function": "snd_emu10k1_free_pages",
            "description": "release dma buffer from page table"
        },
        "tomoyo_update_path_number_acl": {
            "ground_truth": "0",
            "function": "tomoyo_update_path_number_acl",
            "description": "update ioctl chmod chown chgrp acl return on success negative value otherwise const u8 perm permission struct tomoyo acl param param pointer to struct tomoyo acl param"
        },
        "cl_dsp_init": {
            "ground_truth": "0",
            "function": "cl_dsp_init",
            "description": "first boot sequence ha some extra step core wait for power status on core so power up core also momentarily keep it in reset stall and then turn it off"
        },
        "FPT_siwidr": {
            "ground_truth": "0",
            "function": "FPT_siwidr",
            "description": "function fpt siwidr description answer the target wide nego message"
        },
        "spi_finalize_current_message": {
            "ground_truth": "0",
            "function": "spi_finalize_current_message",
            "description": "the current message is complete called by the driver to notify the core that the message in the front of the queue is complete and can be removed from the queue struct spi controller ctlr the controller to return the message to"
        },
        "ucb1x00_ts_read_xpos": {
            "ground_truth": "0",
            "function": "ucb1x00_ts_read_xpos",
            "description": "switch to position mode and measure plate we switch the plate configuration in pressure mode then switch to position mode this give faster response time even so we need to wait about 55us for thing to stabilise"
        },
        "blk_queue_max_write_same_sectors": {
            "ground_truth": "0",
            "function": "blk_queue_max_write_same_sectors",
            "description": "set max sector for single write same struct request queue the request queue for the device unsigned int max write same sector maximum number of sector to write per command"
        },
        "color_fwrite_lines": {
            "ground_truth": "0",
            "function": "color_fwrite_lines",
            "description": "this function split the buffer by newlines and color the line individually return on success"
        },
        "early_get_arch_type": {
            "ground_truth": "0",
            "function": "early_get_arch_type",
            "description": "determine if uv arch type entry might exist in uvsystab"
        },
        "ffs_func_revmap_ep": {
            "ground_truth": "0",
            "function": "ffs_func_revmap_ep",
            "description": "endpoint and interface number reverse mapping"
        },
        "ep11_query_info": {
            "ground_truth": "0",
            "function": "ep11_query_info",
            "description": "helper function which doe an ep11 query with given query type"
        },
        "xpsgtr_phy_tx_term_fix": {
            "ground_truth": "0",
            "function": "xpsgtr_phy_tx_term_fix",
            "description": "there is functional issue in the gt the tx termination resistance can be out of spec due to issue in the calibration logic this is the workaround to fix it required for xczu9eg silicon"
        },
        "camif_request_irqs": {
            "ground_truth": "0",
            "function": "camif_request_irqs",
            "description": "the camif device ha two relatively independent data processing path that can source data from memory or the common camera input frontend register interrupt for each data processing path camif vp"
        },
        "ctcm_chx_rxiniterr": {
            "ground_truth": "0",
            "function": "ctcm_chx_rxiniterr",
            "description": "length block header fi an instance of channel statemachine event the event just happened arg generic pointer casted from channel upon call fsm instance fi undescribed int event undescribed void arg undescribed"
        },
        "batadv_iv_ogm_orig_dump_bucket": {
            "ground_truth": "0",
            "function": "batadv_iv_ogm_orig_dump_bucket",
            "description": "dump an originator bucket into message struct sk buff msg netlink message to dump into u32 portid port making netlink request u32 seq sequence number of netlink message struct batadv priv bat priv the bat priv with all the soft interface information struct batadv hard iface if outgoing limit dump to entry with this outgoing interface struct hlist head head bucket to be dumped int idx number of entry to be skipped int sub number of sub entry to be skipped error code or on success"
        },
        "hvcs_set_pi": {
            "ground_truth": "0",
            "function": "hvcs_set_pi",
            "description": "only called from hvcs get pi please"
        },
        "snd_hda_jack_detect_enable": {
            "ground_truth": "0",
            "function": "snd_hda_jack_detect_enable",
            "description": "enable the jack detection on the given pin enable the jack detection with the default callback return zero if successful or negative error code struct hda codec codec the hda codec hda nid nid pin nid to enable jack detection int dev id pin device entry id"
        },
        "amba_device_put": {
            "ground_truth": "0",
            "function": "amba_device_put",
            "description": "put an amba device struct amba device dev amba device to put"
        },
        "twl4030_audio_enable_resource": {
            "ground_truth": "0",
            "function": "twl4030_audio_enable_resource",
            "description": "enable the resource the function return with error or the content of the register"
        },
        "snapshot_additional_pages": {
            "ground_truth": "0",
            "function": "snapshot_additional_pages",
            "description": "estimate the number of extra page needed estimate the number of additional page needed for setting up hibernation image data structure for zone usually the returned value is greater than the exact number struct zone zone memory zone to carry out the computation for"
        },
        "put_daio": {
            "ground_truth": "0",
            "function": "put_daio",
            "description": "return one daio resource"
        },
        "ata_acpi_handle_hotplug": {
            "ground_truth": "0",
            "function": "ata_acpi_handle_hotplug",
            "description": "acpi event handler backend all acpi bay device realted event end up in this function if the event is port wide dev is null if the event is specific to device dev point to it hotplug a opposed to unplug notification is always handled a port wide while unplug only kill the target device on device wide event locking acpi notify handler context may sleep struct ata port ap ata port acpi event occurred struct ata device dev ata device acpi event occurred can be null u32 event acpi event which occurred"
        },
        "led_classdev_register": {
            "ground_truth": "0",
            "function": "led_classdev_register",
            "description": "register new object of led class register new object of led class with name derived from the name property of passed led cdev argument struct device parent led controller device this led is driven by struct led classdev led cdev the led classdev structure for this device on success or negative error value on failure"
        },
        "dwc2_hcd_qh_unlink": {
            "ground_truth": "0",
            "function": "dwc2_hcd_qh_unlink",
            "description": "remove qh from either the non periodic or periodic schedule memory is not freed struct dwc2 hsotg hsotg the hcd state structure struct dwc2 qh qh qh to remove from schedule"
        },
        "sdebug_q_cmd_complete": {
            "ground_truth": "0",
            "function": "sdebug_q_cmd_complete",
            "description": "queued deferred command completion converge here"
        },
        "kdb_register": {
            "ground_truth": "0",
            "function": "kdb_register",
            "description": "kdb register compatibility register function for command that do not need to specify repeat state equivalent to kdb register flag with flag set to input cmd command name func function to execute the command usage simple usage string showing argument help simple help string describing command return zero for success one if duplicate command"
        },
        "chipio_set_conn_rate": {
            "ground_truth": "0",
            "function": "chipio_set_conn_rate",
            "description": "set sampling rate of the connection point"
        },
        "fixup_low_keys": {
            "ground_truth": "0",
            "function": "fixup_low_keys",
            "description": "adjust the pointer going up the tree starting at level making sure the right key of each node is point to key this is used after shifting pointer to the left so it stop fixing up pointer when given leaf node is not in slot of the higher level"
        },
        "st_accel_get_settings": {
            "ground_truth": "0",
            "function": "st_accel_get_settings",
            "description": "st accel get setting get sensor setting from device name name device name buffer reference return valid reference on success null otherwise"
        },
        "lecd_attach": {
            "ground_truth": "0",
            "function": "lecd_attach",
            "description": "initialize device"
        },
        "nvme_pci_npages_sgl": {
            "ground_truth": "0",
            "function": "nvme_pci_npages_sgl",
            "description": "calculates the number of page needed for the sgl segment for example 4k page can accommodate sgl descriptor"
        },
        "pci_intx": {
            "ground_truth": "0",
            "function": "pci_intx",
            "description": "enables disables pci intx for device dev enables disables pci intx for device pdev struct pci dev pdev the pci device to operate on int enable boolean whether to enable or disable pci intx"
        },
        "cpc925_htlink_init": {
            "ground_truth": "0",
            "function": "cpc925_htlink_init",
            "description": "ht link err device"
        },
        "regs_query_register_offset": {
            "ground_truth": "0",
            "function": "regs_query_register_offset",
            "description": "query register offset from it name regs query register offset return the offset of register in struct pt regs from it name if the name is invalid this return einval const char name the name of register"
        },
        "sb1250_smp_init": {
            "ground_truth": "0",
            "function": "sb1250_smp_init",
            "description": "smp init and finish on secondary cpu"
        },
        "gsi_trans_pool_alloc_common": {
            "ground_truth": "0",
            "function": "gsi_trans_pool_alloc_common",
            "description": "return the byte offset of the next free entry in the pool"
        },
        "r852_register_nand_device": {
            "ground_truth": "0",
            "function": "r852_register_nand_device",
            "description": "register the nand device called when the card is detected"
        },
        "sun4i_a10_tcon_set_mux": {
            "ground_truth": "0",
            "function": "sun4i_a10_tcon_set_mux",
            "description": "platform specific tcon muxing callback"
        },
        "pmcraid_release_chrdev": {
            "ground_truth": "0",
            "function": "pmcraid_release_chrdev",
            "description": "unregisters per adapter management interface return value none struct pmcraid instance pinstance pointer to adapter instance structure"
        },
        "devm_drm_panel_bridge_add": {
            "ground_truth": "0",
            "function": "devm_drm_panel_bridge_add",
            "description": "creates managed type drm bridge and type drm connector that just call the appropriate function from type drm panel this is the managed version of drm panel bridge add which automatically call drm panel bridge remove when dev is unbound struct device dev device to tie the bridge lifetime to struct drm panel panel the drm panel being wrapped must be non null"
        },
        "eeprom_writeKey": {
            "ground_truth": "0",
            "function": "eeprom_writeKey",
            "description": "these function could be used to unlock skystar2 card"
        },
        "dm_block_manager_create": {
            "ground_truth": "0",
            "function": "dm_block_manager_create",
            "description": "than char write that an individual thread hold at any one time name should be unique identifier for the block manager no longer max held per thread should be the maximum number of lock read or"
        },
        "ccp_del_device": {
            "ground_truth": "0",
            "function": "ccp_del_device",
            "description": "remove ccp device from the list remove this unit from the list of device if the next device up for use is this one adjust the pointer if this is the last device null the pointer struct ccp device ccp ccp device struct pointer"
        },
        "lpfc_handle_eratt_s3": {
            "ground_truth": "0",
            "function": "lpfc_handle_eratt_s3",
            "description": "the sli3 hba hardware error handler this routine is invoked to handle the following hba hardware error condition hba error attention interrupt dma ring index out of range mailbox command came back a unknown struct lpfc hba phba pointer to lpfc hba data structure"
        },
        "unregister_pstore_zone": {
            "ground_truth": "0",
            "function": "unregister_pstore_zone",
            "description": "unregister to pstore zone struct pstore zone info info back end driver information see struct pstore zone info"
        },
        "mvpp2_flow_add_hek_field": {
            "ground_truth": "0",
            "function": "mvpp2_flow_add_hek_field",
            "description": "add field to the header extracted key generation parameter"
        },
        "reset_at[BIT2BYTE": {
            "ground_truth": "0",
            "function": "reset_at[BIT2BYTE",
            "description": "these are common for all ib port use case"
        },
        "__tree_mod_log_insert": {
            "ground_truth": "0",
            "function": "__tree_mod_log_insert",
            "description": "key order of the log node leaf start address sequence the istart address is the logical address of the new root node for root replace operation or the logical address of the affected block for all other operation"
        },
        "mips_read_watch_registers": {
            "ground_truth": "0",
            "function": "mips_read_watch_registers",
            "description": "read back the watchhi register so the user space debugger ha access to the and bit maximum of four register are read although the machine may have more"
        },
        "batadv_store_mesh_iface_finish": {
            "ground_truth": "0",
            "function": "batadv_store_mesh_iface_finish",
            "description": "store new hardif mesh iface state change the part of the hard soft interface which can not be modified under sysfs lock to prevent deadlock situation struct net device net dev netdevice to add remove to from batman adv soft interface char ifname ifnamsiz name of soft interface to modify on success on failure"
        },
        "pidff_find_special_field": {
            "ground_truth": "0",
            "function": "pidff_find_special_field",
            "description": "find field with specific usage within report"
        },
        "pm8xxx_work_handler": {
            "ground_truth": "0",
            "function": "pm8xxx_work_handler",
            "description": "worker to set vibration level struct work struct work pointer to work struct"
        },
        "df_v3_6_get_df_cntr_avail": {
            "ground_truth": "0",
            "function": "df_v3_6_get_df_cntr_avail",
            "description": "get the number of df counter available"
        },
        "xudc_nuke": {
            "ground_truth": "0",
            "function": "xudc_nuke",
            "description": "clean up the data transfer message list struct xusb ep ep pointer to the usb device endpoint structure int status status of the data transfer"
        },
        "nfsd4_get_opendowngradestateid": {
            "ground_truth": "0",
            "function": "nfsd4_get_opendowngradestateid",
            "description": "function to consume current state id"
        },
        "unw_decode": {
            "ground_truth": "0",
            "function": "unw_decode",
            "description": "decode one descriptor and return address of next descriptor"
        },
        "sd_dq_callback": {
            "ground_truth": "0",
            "function": "sd_dq_callback",
            "description": "function called when the application get new frame"
        },
        "ioctl_version_show": {
            "ground_truth": "0",
            "function": "ioctl_version_show",
            "description": "present the current ioctl version of the host struct device dev generic device associated with the host struct device attribute attr device attribute representing the ioctl version char buf buffer of length page size to report back the ioctl version the size of the ascii string returned in buf"
        },
        "ufs2_init_inodes_chunk": {
            "ground_truth": "0",
            "function": "ufs2_init_inodes_chunk",
            "description": "nullify new chunk of inodes bsd people also set ui gen field of inode during nullification but we not care about that because of linux ufs do not support nfs"
        },
        "i2c_smbus_read_byte_data": {
            "ground_truth": "0",
            "function": "i2c_smbus_read_byte_data",
            "description": "smbus read byte protocol this executes the smbus read byte protocol returning negative errno else data byte received from the device const struct i2c client client handle to slave device u8 command byte interpreted by slave"
        },
        "lcdc_irq_handler_rev02": {
            "ground_truth": "0",
            "function": "lcdc_irq_handler_rev02",
            "description": "irq handler for version of lcdc"
        },
        "_parse_integer": {
            "ground_truth": "0",
            "function": "_parse_integer",
            "description": "convert non negative integer string representation in explicitly given radix to an integer return number of character consumed maybe or ed with overflow bit if overflow occurs result integer incorrect is still returned do not you dare use this function"
        },
        "imx_sc_misc_get_control": {
            "ground_truth": "0",
            "function": "imx_sc_misc_get_control",
            "description": "this function get miscellaneous control value param in ipc ipc handle param in resource resource the control is associated with param in ctrl control to get param out val pointer to return the control value return return for success and for error"
        },
        "snd_opl3_sysex": {
            "ground_truth": "0",
            "function": "snd_opl3_sysex",
            "description": "receive sysex"
        },
        "init_lmlbt4x": {
            "ground_truth": "0",
            "function": "init_lmlbt4x",
            "description": "lmlbt4x initialization to allow access to gpio bit for sensor input and alarm output gpiobit assignment ti o3 inx o2 o1 in4 in3 in2 in1 in sensor input inx sensor input and ti xored together o1 o2 o3 alarm output relay out enable"
        },
        "probe_cache__show_all_caches": {
            "ground_truth": "0",
            "function": "probe_cache__show_all_caches",
            "description": "show all cached probe"
        },
        "release_tx_desc": {
            "ground_truth": "0",
            "function": "release_tx_desc",
            "description": "clean the tx descriptor a soon a the tx irq is received"
        },
        "xen_arch_setup": {
            "ground_truth": "0",
            "function": "xen_arch_setup",
            "description": "this function is not called for hvm domain"
        },
        "nanddev_mtd_max_bad_blocks": {
            "ground_truth": "0",
            "function": "nanddev_mtd_max_bad_blocks",
            "description": "get the maximum number of bad eraseblock on specific region of the nand device default implementation for mtd max bad block only work if nand memorg max bad eraseblocks per lun is struct mtd info mtd mtd device loff offs offset of the nand region size len length of the nand region positive number encoding the maximum number of eraseblocks on portion of memory negative error code otherwise"
        },
        "rds_ib_recv_exit": {
            "ground_truth": "0",
            "function": "rds_ib_recv_exit",
            "description": "ib recv"
        },
        "scsi_eh_prt_fail_stats": {
            "ground_truth": "0",
            "function": "scsi_eh_prt_fail_stats",
            "description": "log info on failure struct scsi host shost scsi host being recovered struct list head work queue of scsi cmds to process"
        },
        "hci_send_sco": {
            "ground_truth": "0",
            "function": "hci_send_sco",
            "description": "send sco data"
        },
        "cachefiles_mark_object_inactive": {
            "ground_truth": "0",
            "function": "cachefiles_mark_object_inactive",
            "description": "mark an object a being inactive"
        },
        "isci_task_query_task": {
            "ground_truth": "0",
            "function": "isci_task_query_task",
            "description": "this function is implemented to cause libsas to correctly escalate the failed abort to lun or target reset this is because sa scsi find task libsas function doe not correctly interpret all return code from the abort task call when tmf resp func succ is returned libsas turn this into lun reset when func failed is returned libsas will turn this into target reset status zero indicates success struct sa task task this parameter specifies the sa task being queried"
        },
        "atomisp_try_fmt": {
            "ground_truth": "0",
            "function": "atomisp_try_fmt",
            "description": "this function look up the closest available resolution"
        },
        "nicvf_rbdr_config": {
            "ground_truth": "0",
            "function": "nicvf_rbdr_config",
            "description": "configures receive buffer descriptor ring"
        },
        "ice_aq_cfg_lldp_mib_change": {
            "ground_truth": "0",
            "function": "ice_aq_cfg_lldp_mib_change",
            "description": "enable or disable posting of an event on arq when lldp mib associated with the interface change struct ice hw hw pointer to the hw struct bool ena update enable or disable event posting struct ice sq cd cd pointer to command detail structure or null"
        },
        "startup": {
            "ground_truth": "0",
            "function": "startup",
            "description": "value mean no gpio will be used for reset reset gpio should only be specified for pxa27x cpu where silicon bug prevents correct operation of the reset line if not specified the default behaviour on these cpu is to consider gpio a the ac97 reset line which is the default on most board reset gpio ac97 reset gpio normally gpio113 or gpio95 codec pdata ac97 codec platform data"
        },
        "bnx2x_map_sb_state_machines": {
            "ground_truth": "0",
            "function": "bnx2x_map_sb_state_machines",
            "description": "allocates state machine id"
        },
        "b43_pci_ssb_bridge_init": {
            "ground_truth": "0",
            "function": "b43_pci_ssb_bridge_init",
            "description": "b43 pci bridge"
        },
        "atp870u_probe": {
            "ground_truth": "0",
            "function": "atp870u_probe",
            "description": "return non zero on detection"
        },
        "rio_scan_alloc_net": {
            "ground_truth": "0",
            "function": "rio_scan_alloc_net",
            "description": "rio scan alloc net allocate and configure new rio network allocates new rio network structure and initializes enumerator specific part of it if required mport master port associated with the rio network do enum enumeration discovery mode flag start logical minimal start id for new net return rio network pointer on success or null on failure"
        },
        "other_tx_active": {
            "ground_truth": "0",
            "function": "other_tx_active",
            "description": "if the other interface of the controller is transmitting data"
        },
        "snd_echo_vumeters_info": {
            "ground_truth": "0",
            "function": "snd_echo_vumeters_info",
            "description": "read vu meter input output analog and digital together"
        },
        "myrb_unmap": {
            "ground_truth": "0",
            "function": "myrb_unmap",
            "description": "unmaps controller structure struct myrb hba cb undescribed"
        },
        "intel_guc_ct_init_early": {
            "ground_truth": "0",
            "function": "intel_guc_ct_init_early",
            "description": "initialize ct state without requiring device access struct intel guc ct ct pointer to ct struct"
        },
        "drm_mode_getplane_res": {
            "ground_truth": "0",
            "function": "drm_mode_getplane_res",
            "description": ""
        },
        "snd_dw_hdmi_suspend": {
            "ground_truth": "0",
            "function": "snd_dw_hdmi_suspend",
            "description": "this code is fine but requires implementation in the dw hdmi trigger method which is currently missing a have no way to test this"
        },
        "config_tx_flow_control": {
            "ground_truth": "0",
            "function": "config_tx_flow_control",
            "description": "for flow control"
        },
        "stack_trace_save_user": {
            "ground_truth": "0",
            "function": "stack_trace_save_user",
            "description": "save user space stack trace into storage array unsigned long store pointer to storage array unsigned int size size of the storage array number of trace entry stored"
        },
        "gb_pm_runtime_get_sync": {
            "ground_truth": "0",
            "function": "gb_pm_runtime_get_sync",
            "description": "bundle runtime pm wrapper"
        },
        "print_hwp": {
            "ground_truth": "0",
            "function": "print_hwp",
            "description": "print hwp decode the msr hwp capability"
        },
        "pata_macio_default_timings": {
            "ground_truth": "0",
            "function": "pata_macio_default_timings",
            "description": "blast some well known safe value to the timing register at init or wakeup from sleep time before we do real calculation"
        },
        "si514_get_muldiv": {
            "ground_truth": "0",
            "function": "si514_get_muldiv",
            "description": "retrieve clock multiplier and divider from hardware"
        },
        "i40e_alloc_asq_bufs": {
            "ground_truth": "0",
            "function": "i40e_alloc_asq_bufs",
            "description": "allocate empty buffer structs for the send queue struct i40e hw hw pointer to the hardware structure"
        },
        "wdt977_keepalive": {
            "ground_truth": "0",
            "function": "wdt977_keepalive",
            "description": "send keepalive ping to the watchdog this is done by simply re writing the timeout to reg"
        },
        "max31730_detect": {
            "ground_truth": "0",
            "function": "max31730_detect",
            "description": "return if detection is successful enodev otherwise"
        },
        "pmic_arb_offset_v1": {
            "ground_truth": "0",
            "function": "pmic_arb_offset_v1",
            "description": "v1 offset per ee"
        },
        "scc_txint": {
            "ground_truth": "0",
            "function": "scc_txint",
            "description": "transmitter interrupt handler"
        },
        "lpfc_discovery_wait": {
            "ground_truth": "0",
            "function": "lpfc_discovery_wait",
            "description": "wait for driver discovery to quiesce this driver call this routine specifically from lpfc vport delete to enforce synchronous execution of vport delete relative to discovery activity the lpfc vport delete routine should not return until it can reasonably guarantee that discovery ha quiesced post fdisc logo the driver must wait until it san teardown is complete and all resource recovered before allowing cleanup this routine doe not require any lock held struct lpfc vport vport the virtual port for which this call is being executed"
        },
        "alsa_seq_dummy_init": {
            "ground_truth": "0",
            "function": "alsa_seq_dummy_init",
            "description": "init part"
        },
        "qbman_pull_desc_set_fq": {
            "ground_truth": "0",
            "function": "qbman_pull_desc_set_fq",
            "description": "set fqid from which the dequeue command dequeues struct qbman pull desc undescribed u32 fqid the frame queue index of the given fq"
        },
        "xenon_emmc_phy_config_tuning": {
            "ground_truth": "0",
            "function": "xenon_emmc_phy_config_tuning",
            "description": "config to emmc phy to prepare for tuning enable hw dll and set the tuning step"
        },
        "wakeup_sources_read_unlock": {
            "ground_truth": "0",
            "function": "wakeup_sources_read_unlock",
            "description": "unlock wakeup source list int idx return value from corresponding wakeup source read lock"
        },
        "ia_css_frame_free_multiple": {
            "ground_truth": "0",
            "function": "ia_css_frame_free_multiple",
            "description": "brief free an array of frame param param in num frame the number of frame to be freed in the array param in frame array the array of frame to be removed return"
        },
        "panel_bind_key": {
            "ground_truth": "0",
            "function": "panel_bind_key",
            "description": "try to bind key to the signal name the key will send the string for these respective event return the pointer to the new key if ok null if the key could not be bound"
        },
        "retry_origin_bios": {
            "ground_truth": "0",
            "function": "retry_origin_bios",
            "description": "flush list of buffer"
        },
        "qib_setup_eagerbufs": {
            "ground_truth": "0",
            "function": "qib_setup_eagerbufs",
            "description": "allocate the eager tid buffer and program them into hip they are no longer completely contiguous we do multiple allocation call otherwise we get the oom code involved by asking for too much per call with disastrous result on some kernel struct qib ctxtdata rcd the context we are setting up"
        },
        "perf_event_enable": {
            "ground_truth": "0",
            "function": "perf_event_enable",
            "description": "see perf event disable"
        },
        "ath5k_beacon_update": {
            "ground_truth": "0",
            "function": "ath5k_beacon_update",
            "description": "update the beacon that is sent by ath5k beacon send for adhoc this is called only once at config bs time for ap we do it every swba interrupt so that the tim will reflect buffered frame called with the beacon lock"
        },
        "adf_enable_vf2pf_comms": {
            "ground_truth": "0",
            "function": "adf_enable_vf2pf_comms",
            "description": "function enables communication from vf to pf struct adf accel dev accel dev pointer to acceleration device virtual function on success error code otherwise"
        },
        "get_mtrr_state": {
            "ground_truth": "0",
            "function": "get_mtrr_state",
            "description": "grab all of the mtrr state for this cpu into state"
        },
        "reset_intr": {
            "ground_truth": "0",
            "function": "reset_intr",
            "description": "user triggered reset"
        },
        "omapfb_init": {
            "ground_truth": "0",
            "function": "omapfb_init",
            "description": "register both the driver and the device"
        },
        "scc_rxint": {
            "ground_truth": "0",
            "function": "scc_rxint",
            "description": "receiver interrupt handler"
        },
        "nt_prpsinfo": {
            "ground_truth": "0",
            "function": "nt_prpsinfo",
            "description": "initialize prpsinfo note new kernel"
        },
        "mmput_async": {
            "ground_truth": "0",
            "function": "mmput_async",
            "description": "same a above but performs the slow path from the async context can be called from the atomic context a well"
        },
        "rio_add_inb_buffer": {
            "ground_truth": "0",
            "function": "rio_add_inb_buffer",
            "description": "add buffer to an inbound mailbox queue add buffer to an inbound mailbox queue for reception return on success struct rio mport mport master port containing the inbound mailbox int mbox the inbound mailbox number void buffer pointer to the message buffer"
        },
        "of_dma_get_range": {
            "ground_truth": "0",
            "function": "of_dma_get_range",
            "description": "get dma range info and put it into map array look in bottom up direction for the first dma range property and parse it put the information into dma offset map array dma range format dma addr dma addr naddr cell cpu addr phys addr pna cell size nsize cell it return enodev if dma range property wa not found for this device in the dt struct device node np device node to get dma range info const struct bus dma region map dma range structure to return"
        },
        "free_notifier": {
            "ground_truth": "0",
            "function": "free_notifier",
            "description": "these callback are used with the get put interface to manage the lifetime of the mmu notifier memory alloc notifier return new notifier for use with the mm free notifier is only called after the mmu notifier ha been fully put call to any ops callback are prevented and no ops callback are currently running it is called from srcu callback and cannot sleep"
        },
        "sd_probe": {
            "ground_truth": "0",
            "function": "sd_probe",
            "description": "called during driver initialization and whenever new scsi device is attached to the system it is called once for each scsi device not just disk present struct device dev pointer to device object return if successful or not interested in this scsi device scanner when there is an error note this function is invoked from the scsi mid level this function set up the mapping between given found in sdp and new device name dev sda more precisely it is the block device major and minor number that is chosen here assume sd probe is not re entrant for time being also think about sd probe and sd remove running coincidentally"
        },
        "uclogic_params_cleanup": {
            "ground_truth": "0",
            "function": "uclogic_params_cleanup",
            "description": "free resource used by struct uclogic params tablet interface is parameter can be called repeatedly struct uclogic params params input parameter to cleanup cannot be null"
        },
        "il_hdl_scan": {
            "ground_truth": "0",
            "function": "il_hdl_scan",
            "description": "service response to scan"
        },
        "ufs_print_super_stuff": {
            "ground_truth": "0",
            "function": "ufs_print_super_stuff",
            "description": "print content of ufs super block useful for debugging"
        },
        "sdio_alloc_func": {
            "ground_truth": "0",
            "function": "sdio_alloc_func",
            "description": "allocate and initialise new sdio function structure"
        },
        "TI_SCI_MSG_FLAG": {
            "ground_truth": "0",
            "function": "TI_SCI_MSG_FLAG",
            "description": "struct ti sci msg req manage irq request to configure release the route between the dev and the host parameter if bit is not set then corresponding field is not valid and will not be used for route set bit field definition valid bit for dst id valid bit for dst host irq valid bit for ia id valid bit for vint valid bit for global event valid bit for vint status bit index valid bit for secondary host irq controller or host processor id vint resides is through an interrupt aggregator aggregator virtual interrupt status bit utilizes an interrupt aggregator status bit required only when destination host id is different from ti sci interface host id request type is ti sci msg set release irq response is generic ack nack message hdr generic header valid params bit field defining the validity of interrupt source src id irq source peripheral id src index irq source index within the peripheral dst id irq destination id based on the architecture it can be dst host irq irq number of the destination host irq controller ia id device id of the interrupt aggregator in which the vint virtual interrupt number if the interrupt route global event global event that is to be mapped to interrupt vint status bit virtual interrupt status bit if the interrupt route secondary host host id of the irq destination computing entity this is"
        },
        "srp_put_tx_iu": {
            "ground_truth": "0",
            "function": "srp_put_tx_iu",
            "description": "return an iu and possible credit to the free pool"
        },
        "bcsp_crc_update": {
            "ground_truth": "0",
            "function": "bcsp_crc_update",
            "description": "update crc with next data byte implementation note the data byte is treated a two nibble the crc is generated in reverse bit are fed into the register from the top"
        },
        "step_into": {
            "ground_truth": "0",
            "function": "step_into",
            "description": "do we need to follow link we really want to be able to do this check without having to look at inode op so we keep cache of no this doe not need follow link for the common case"
        },
        "private_mapping_ok": {
            "ground_truth": "0",
            "function": "private_mapping_ok",
            "description": "can not do an in place private mapping if there is no mmu"
        },
        "parse_dcc": {
            "ground_truth": "0",
            "function": "parse_dcc",
            "description": "try to get the ip addr and port out of dcc command return value on failure on success data pointer to first byte of dcc command data data end pointer to last byte of dcc command data ip return parsed ip of dcc command port return parsed port of dcc command ad beg return pointer to first byte of addr data ad end return pointer to last byte of addr data"
        },
        "dm355_init": {
            "ground_truth": "0",
            "function": "dm355_init",
            "description": "dm355 function declaration"
        },
        "xgpu_vi_mailbox_ack_irq": {
            "ground_truth": "0",
            "function": "xgpu_vi_mailbox_ack_irq",
            "description": "add support mailbox interrupt"
        },
        "fscache_unpin_cookie": {
            "ground_truth": "0",
            "function": "fscache_unpin_cookie",
            "description": "unpin data storage cache object in it cache permit data storage cache object to be unpinned from the cache see documentation filesystems caching netfs api rst for complete description struct fscache cookie cookie the cookie representing the cache object"
        },
        "distance": {
            "ground_truth": "0",
            "function": "distance",
            "description": "distance calculate the distance get the gap between resolution and re width height smaller than would not be considered re resolution width height return the value of gap or if fail"
        },
        "set_pin_target": {
            "ground_truth": "0",
            "function": "set_pin_target",
            "description": "set the pinctl target value and write it if requested"
        },
        "arch_ftrace_match_adjust": {
            "ground_truth": "0",
            "function": "arch_ftrace_match_adjust",
            "description": "if symbol in an architecture do not correspond exactly to the user visible name of what they represent it is possible to define this function to perform the necessary adjustment"
        },
        "decode_register": {
            "ground_truth": "0",
            "function": "decode_register",
            "description": "given the areg portion of modrm byte and register block return pointer into the block that address the relevant register highbyte regs specifies whether to decode ah ch dh bh"
        },
        "slab_is_available": {
            "ground_truth": "0",
            "function": "slab_is_available",
            "description": "struct kmem cache related prototype"
        },
        "ap_control_add_mac": {
            "ground_truth": "0",
            "function": "ap_control_add_mac",
            "description": "hostap ap"
        },
        "__udp4_lib_mcast_demux_lookup": {
            "ground_truth": "0",
            "function": "__udp4_lib_mcast_demux_lookup",
            "description": "we can only early demux multicast if there is single matching socket if more than one socket found return null"
        },
        "read_cardpda": {
            "ground_truth": "0",
            "function": "read_cardpda",
            "description": "read cardpda sends the command for the driver to read the pda from the card named in the device variable upon success the card pda is stored in the cardpda variable note that the pda structure is considered well formed after this function that mean that the nrecs is valid the rec array ha been set up and there is valid pdaend record in the raw pda data argument pda pda structure wlandev device return success failure probably an errno"
        },
        "amiserial_console_init": {
            "ground_truth": "0",
            "function": "amiserial_console_init",
            "description": "register console"
        },
        "get_ccsidr": {
            "ground_truth": "0",
            "function": "get_ccsidr",
            "description": "which cache ccsidr represents depends on csselr value"
        },
        "crypto_rng_get_bytes": {
            "ground_truth": "0",
            "function": "crypto_rng_get_bytes",
            "description": "get random number this function fill the caller allocated buffer with random number using the random number generator referenced by the cipher handle struct crypto rng tfm cipher handle u8 rdata output buffer holding the random number unsigned int dlen length of the output buffer function wa successful if an error occurred"
        },
        "__clear_bit_unlock": {
            "ground_truth": "0",
            "function": "__clear_bit_unlock",
            "description": "non atomically clear bit in memory with release similarly to clear bit unlock the implementation us store with release semantics see also arch spin unlock int nr bit to clear void addr address to start counting from"
        },
        "ext4_splice_branch": {
            "ground_truth": "0",
            "function": "ext4_splice_branch",
            "description": "splice the allocated branch onto inode this function fill the missing link and doe all housekeeping needed in inode block etc in case of success we end up with the full chain to new block and return handle handle handle for this transaction struct ext4 allocation request ar structure describing the allocation request indirect where location of missing link int num number of indirect block we are adding"
        },
        "xfs_inode_measure_sickness": {
            "ground_truth": "0",
            "function": "xfs_inode_measure_sickness",
            "description": "sample which part of an inode are unhealthy"
        },
        "usb_hcd_msp_map_regs": {
            "ground_truth": "0",
            "function": "usb_hcd_msp_map_regs",
            "description": "configure so an hc device and id are always provided always called with process context sleeping is ok"
        },
        "qla4_8xxx_default_intr_handler": {
            "ground_truth": "0",
            "function": "qla4_8xxx_default_intr_handler",
            "description": "hardware interrupt handler this interrupt handler is called directly for msi and called indirectly for msi int irq unused void dev id pointer to host adapter structure"
        },
        "ice_update_sw_rule_bridge_mode": {
            "ground_truth": "0",
            "function": "ice_update_sw_rule_bridge_mode",
            "description": "update unicast switch filter rule based on veb vepa mode struct ice hw hw pointer to the hw struct"
        },
        "__get_dev_name": {
            "ground_truth": "0",
            "function": "__get_dev_name",
            "description": "helper to return dev name or if dev"
        },
        "mpt3sas_base_get_msg_frame": {
            "ground_truth": "0",
            "function": "mpt3sas_base_get_msg_frame",
            "description": "obtain request mf pointer struct mpt3sas adapter ioc per adapter object u16 smid system request message index smid zero is invalid virt pointer to message frame"
        },
        "sclp_init_mask": {
            "ground_truth": "0",
            "function": "sclp_init_mask",
            "description": "start init mask request if calculate is non zero calculate the mask a requested by registered listener use zero mask otherwise return on success non zero otherwise"
        },
        "mwifiex_11h_get_csa_closed_channel": {
            "ground_truth": "0",
            "function": "mwifiex_11h_get_csa_closed_channel",
            "description": "this function retrieves channel closed for operation by channel switch announcement"
        },
        "blk_mq_exit_queue": {
            "ground_truth": "0",
            "function": "blk_mq_exit_queue",
            "description": "tag can not be used after returning from blk mq exit queue"
        },
        "mpc8610_hpcd_machine_probe": {
            "ground_truth": "0",
            "function": "mpc8610_hpcd_machine_probe",
            "description": "this function is used to initialize the board specific hardware here we program the dmacr and pmuxcr register struct snd soc card card undescribed"
        },
        "da9211_i2c_probe": {
            "ground_truth": "0",
            "function": "da9211_i2c_probe",
            "description": "i2c driver interface function"
        },
        "idt_ntb_link_enable": {
            "ground_truth": "0",
            "function": "idt_ntb_link_enable",
            "description": "idt ntb link enable enable local port ntb link ntb api callback enable just local ntb link pcie link parameter are ignored ntb ntb device context max speed the maximum link speed expressed a pcie generation number max width the maximum link width expressed a the number of pcie lane return always zero"
        },
        "put_object": {
            "ground_truth": "0",
            "function": "put_object",
            "description": "decrement the object use count once the count is free the object using an rcu callback since put object may be called via the kmemleak free delete object path the delayed rcu freeing ensures that there is no recursive call to the kernel allocator lock le rcu object list traversal is also possible"
        },
        "ima_post_key_create_or_update": {
            "ground_truth": "0",
            "function": "ima_post_key_create_or_update",
            "description": "measure asymmetric key key can only be measured not appraised the payload data used to instantiate or update the key is measured struct key keyring keyring to which the key is linked to struct key key created or updated key const void payload the data used to instantiate or update the key size payload len the length of payload unsigned long flag key flag bool create flag indicating whether the key wa created or updated"
        },
        "_ocp_softreset": {
            "ground_truth": "0",
            "function": "_ocp_softreset",
            "description": "reset an omap hwmod via the ocp sysconfig bit reset an omap hwmod oh via the ocp sysconfig bit hwmod must be enabled for this to work return enoent if the hwmod cannot be reset this way einval if the hwmod is in the wrong state etimedout if the module did not reset in time or upon success in omap3 specific sysstatus register is used to get the reset status starting in omap4 some ip do not have sysstatus register and instead use the sysconfig softreset bit to provide the status note that some ip like mcbsp do have reset control but do not have reset status struct omap hwmod oh struct omap hwmod"
        },
        "mpc1_insert_plane": {
            "ground_truth": "0",
            "function": "mpc1_insert_plane",
            "description": "insert dpp into mpc tree based on specified blending position only used for plane that are part of blending chain for opp output parameter in out mpc mpc context in out tree mpc tree structure that plane will be added to in blnd cfg mpcc blending configuration for the new blending layer in sm cfg mpcc stereo mix configuration for the new blending layer stereo mix must disable for the very bottom layer of the tree config in insert above mpcc insert new plane above this mpcc if null insert a bottom plane in dpp id dpp instance for the plane to be added in mpcc id the mpcc physical instance to use for blending return struct mpcc mpcc that wa added"
        },
        "vmw_stream_hw_destroy": {
            "ground_truth": "0",
            "function": "vmw_stream_hw_destroy",
            "description": "simple resource callback for struct vmw stream"
        },
        "et131x_config_tx_dma_regs": {
            "ground_truth": "0",
            "function": "et131x_config_tx_dma_regs",
            "description": "et131x config tx dma regs set up the tx dma section of the jagcore configure the transmit engine with the ring buffer we have created and prepare it for use"
        },
        "orion5x_sata_init": {
            "ground_truth": "0",
            "function": "orion5x_sata_init",
            "description": ""
        },
        "fsl_easrc_release_slot": {
            "ground_truth": "0",
            "function": "fsl_easrc_release_slot",
            "description": "fsl easrc release slot clear the slot configuration"
        },
        "afs_fs_fetch_acl": {
            "ground_truth": "0",
            "function": "afs_fs_fetch_acl",
            "description": "fetch the acl for file"
        },
        "hfcpci_setmode": {
            "ground_truth": "0",
            "function": "hfcpci_setmode",
            "description": "set mode nt or te"
        },
        "mpt3sas_init_warpdrive_properties": {
            "ground_truth": "0",
            "function": "mpt3sas_init_warpdrive_properties",
            "description": "set property for warpdrive direct struct mpt3sas adapter ioc per adapter object struct raid device raid device the raid device object"
        },
        "oxu_hcd_init": {
            "ground_truth": "0",
            "function": "oxu_hcd_init",
            "description": "one time init only for memory state"
        },
        "vtime_account_kernel": {
            "ground_truth": "0",
            "function": "vtime_account_kernel",
            "description": "common vtime apis"
        },
        "mic_bias_event": {
            "ground_truth": "0",
            "function": "mic_bias_event",
            "description": "mic bias power on off share the same register bit with output impedance of mic bias when power on mic bias we need reclaim it to impedance value powered off 2kohm 4kohm 8kohm"
        },
        "bl_pg_test_write": {
            "ground_truth": "0",
            "function": "bl_pg_test_write",
            "description": "return if req cannot be coalesced into pgio otherwise return the number of byte maximum req wb byte that can be coalesced"
        },
        "cpumask_test_and_set_cpu": {
            "ground_truth": "0",
            "function": "cpumask_test_and_set_cpu",
            "description": "atomically test and set cpu in cpumask return if cpu is set in old bitmap of cpumask else return test and set bit wrapper for cpumasks int cpu cpu number nr cpu id struct cpumask cpumask the cpumask pointer"
        },
        "LM75_TEMP_TO_REG": {
            "ground_truth": "0",
            "function": "LM75_TEMP_TO_REG",
            "description": "temp 001c bit 55c to 125c reg 5c bit two is complement"
        },
        "xa_reserve_bh": {
            "ground_truth": "0",
            "function": "xa_reserve_bh",
            "description": "reserve this index in the xarray softirq disabling version of xa reserve struct xarray xa xarray unsigned long index index into array gfp gfp memory allocation flag any context take and release the xa lock while disabling softirqs if the reservation succeeded or enomem if it failed"
        },
        "do_splice_to": {
            "ground_truth": "0",
            "function": "do_splice_to",
            "description": "attempt to initiate splice from file to pipe"
        },
        "nanddev_pos_next_eraseblock": {
            "ground_truth": "0",
            "function": "nanddev_pos_next_eraseblock",
            "description": "move position to the next eraseblock update po to point to the start of the next eraseblock useful when you want to iterate over all eraseblocks of nand device struct nand device nand nand device struct nand po po the position to update"
        },
        "ssusb_host_enable": {
            "ground_truth": "0",
            "function": "ssusb_host_enable",
            "description": "only configure port will be used later"
        },
        "gmap_map_segment": {
            "ground_truth": "0",
            "function": "gmap_map_segment",
            "description": "map segment to the guest address space return if the mmap succeeded einval or enomem if not struct gmap gmap pointer to the guest address space structure unsigned long from source address in the parent address space unsigned long to target address in the guest address space unsigned long len length of the memory area to map"
        },
        "libfc_exit": {
            "ground_truth": "0",
            "function": "libfc_exit",
            "description": "tear down libfc ko void no argument"
        },
        "apm_cpu_idle": {
            "ground_truth": "0",
            "function": "apm_cpu_idle",
            "description": "cpu idling for apm capable linux this is the idling function the kernel executes when apm is available it try to do bios powermanagement based on the average system idle time furthermore it call the system default idle routine struct cpuidle device dev undescribed struct cpuidle driver drv undescribed int index undescribed"
        },
        "cnstr_shdsc_gcm_decap": {
            "ground_truth": "0",
            "function": "cnstr_shdsc_gcm_decap",
            "description": "gcm decapsulation shared descriptor u32 const desc pointer to buffer used for descriptor construction struct alginfo cdata pointer to block cipher transform definition valid algorithm value op alg algsel aes anded with op alg aai gcm unsigned int ivsize initialization vector size unsigned int icvsize integrity check value icv size truncated or full const bool is qi true when called from caam qi"
        },
        "early_drop_list": {
            "ground_truth": "0",
            "function": "early_drop_list",
            "description": "there is small race here where we may free just assured connection too bad we are in trouble anyway"
        },
        "mgslpc_add_device": {
            "ground_truth": "0",
            "function": "mgslpc_add_device",
            "description": "add the specified device instance data structure to the global linked list of device and increment the device count argument info pointer to device instance data"
        },
        "preview_config_csc": {
            "ground_truth": "0",
            "function": "preview_config_csc",
            "description": "preview config csc configure color space conversion rgb to ycbycr"
        },
        "jfs_symlink": {
            "ground_truth": "0",
            "function": "jfs_symlink",
            "description": "name jfs symlink dip dentry name function creates symbolic link to by name in directory parameter dip parent directory vnode dentry dentry of symbolic link name the path name of the existing object that will be the source of the link return error from subroutine note enametoolong pathname resolution of symbolic link produced an intermediate result whose length exceeds path max xpg4"
        },
        "ice_xsk_pool_enable": {
            "ground_truth": "0",
            "function": "ice_xsk_pool_enable",
            "description": "enable buffer pool region return on success negative on failure struct ice vsi vsi current vsi struct xsk buff pool pool pointer to requested buffer pool region u16 qid queue id"
        },
        "smpcfd_prepare_cpu": {
            "ground_truth": "0",
            "function": "smpcfd_prepare_cpu",
            "description": "smp core function"
        },
        "efx_test_eventq_irq": {
            "ground_truth": "0",
            "function": "efx_test_eventq_irq",
            "description": "test generation and receipt of interrupting event"
        },
        "i40e_alloc_arq_bufs": {
            "ground_truth": "0",
            "function": "i40e_alloc_arq_bufs",
            "description": "allocate pre posted buffer for the receive queue struct i40e hw hw pointer to the hardware structure"
        },
        "iavf_exit_module": {
            "ground_truth": "0",
            "function": "iavf_exit_module",
            "description": "driver exit cleanup routine iavf exit module is called just before the driver is removed from memory void no argument"
        },
        "qla2x00_init_firmware": {
            "ground_truth": "0",
            "function": "qla2x00_init_firmware",
            "description": "qla2x00 init firmware initialize adapter firmware input ha adapter block pointer dptr initialization control block pointer size size of initialization control block target queue lock must be released adapter state lock must be released return qla2x00 local function return status code context kernel context"
        },
        "em28xx_stop_urbs": {
            "ground_truth": "0",
            "function": "em28xx_stop_urbs",
            "description": "stop urbs"
        },
        "socfpga_cpu_die": {
            "ground_truth": "0",
            "function": "socfpga_cpu_die",
            "description": "platform specific code to shutdown cpu called with irqs disabled"
        },
        "qib_free_data": {
            "ground_truth": "0",
            "function": "qib_free_data",
            "description": "free up any allocated data at close"
        },
        "vm_vcpu_add_default": {
            "ground_truth": "0",
            "function": "vm_vcpu_add_default",
            "description": "add vcpu with reasonable default stack input args vm virtual machine vcpuid the id of the vcpu to add to the vm guest code the vcpu is entry point"
        },
        "xfs_attr_remove_args": {
            "ground_truth": "0",
            "function": "xfs_attr_remove_args",
            "description": "remove the attribute specified in args"
        },
        "netlbl_unlabel_genl_init": {
            "ground_truth": "0",
            "function": "netlbl_unlabel_genl_init",
            "description": "register the unlabeled netlabel component register the unlabeled packet netlabel component with the generic netlink mechanism return zero on success negative value on failure void no argument"
        },
        "mpol_free_shared_policy": {
            "ground_truth": "0",
            "function": "mpol_free_shared_policy",
            "description": "free backing policy store on inode delete"
        },
        "dev_pm_qos_hide_latency_tolerance": {
            "ground_truth": "0",
            "function": "dev_pm_qos_hide_latency_tolerance",
            "description": "hide latency tolerance from userspace struct device dev device whose latency tolerance to hide"
        },
        "store": {
            "ground_truth": "0",
            "function": "store",
            "description": "load bit value from an address in the cs hw address space the address must be bit aligned address"
        },
        "component_add": {
            "ground_truth": "0",
            "function": "component_add",
            "description": "register component register new component for dev function in ops will be called when the aggregate driver is ready to bind the overall driver by calling component bind all see also type struct component ops the component need to be unregistered at driver unload disconnect by calling component del see also component add typed for variant that allows multipled different component on the same device struct device dev component device const struct component ops ops component callback"
        },
        "cpu_get_fpu_id": {
            "ground_truth": "0",
            "function": "cpu_get_fpu_id",
            "description": "get the fpu implementation revision"
        },
        "show_tabletXtilt": {
            "ground_truth": "0",
            "function": "show_tabletXtilt",
            "description": "support routine for the xtilt file note that this file both display current setting and allows reprogramming"
        },
        "bond_mode_name": {
            "ground_truth": "0",
            "function": "bond_mode_name",
            "description": "general routine"
        },
        "da9063_ldo_set_mode": {
            "ground_truth": "0",
            "function": "da9063_ldo_set_mode",
            "description": "ldos use sleep flag one for normal and one for suspend state there are mode to map to normal and standby sleep for each state"
        },
        "amd64_inject_read_store": {
            "ground_truth": "0",
            "function": "amd64_inject_read_store",
            "description": "do dram ecc read assemble staged value in the pvt area format into field needed by the injection register and read the nb array data port"
        },
        "efx_change_mtu": {
            "ground_truth": "0",
            "function": "efx_change_mtu",
            "description": "context process rtnl lock held"
        },
        "nct7904_write_reg": {
            "ground_truth": "0",
            "function": "nct7904_write_reg",
            "description": "write byte register return or errno on error"
        },
        "omap2xxx_prm_clear_mod_irqs": {
            "ground_truth": "0",
            "function": "omap2xxx_prm_clear_mod_irqs",
            "description": "clear wakeup status bit for module clear wakeup status bit for given module so that the device can re enter idle s16 module prm module to clear wakeups from u8 regs register offset to clear u32 wkst mask wakeup status mask to clear"
        },
        "fst_process_rx_status": {
            "ground_truth": "0",
            "function": "fst_process_rx_status",
            "description": "process the result of trying to pas received frame up the stack"
        },
        "xchk_btree_cur_fsbno": {
            "ground_truth": "0",
            "function": "xchk_btree_cur_fsbno",
            "description": "figure out which block the btree cursor wa pointing to"
        },
        "show_scaling_driver": {
            "ground_truth": "0",
            "function": "show_scaling_driver",
            "description": "show scaling driver show the cpufreq driver currently loaded"
        },
        "_set_module_autoidle": {
            "ground_truth": "0",
            "function": "_set_module_autoidle",
            "description": "update the module autoidle bit in to be autoidle for the oh hwmod the autoidle bit control whether the module can gate internal clock automatically when it is not doing anything the exact function of this bit varies on per module basis this function doe not write to the hardware return einval upon error or upon success struct omap hwmod oh struct omap hwmod u8 autoidle desired autoidle bitfield value or u32 pointer to register content to modify"
        },
        "lowpan_header_compress": {
            "ground_truth": "0",
            "function": "lowpan_header_compress",
            "description": "replace ipv6 header with 6lowpan header this function replaces the ipv6 header which should be pointed at skb data and skb network header with the iphc 6lowpan header the caller need to be sure that the sk buffer is not shared and at have at least headroom which is smaller or equal lowpan iphc max header len which is the iphc more byte than ipv6 header at worst case introduction cfg80211 is the configuration api for device in linux it bridge userspace and driver and offer some utility functionality associated with cfg80211 must directly or indirectly via mac80211 be used by all modern wireless driver in linux so that they offer consistent api through nl80211 for backward compatibility cfg80211 also offer wireless extension to userspace but hide them from driver completely additionally cfg80211 contains code to help enforce regulatory spectrum use restriction device registration in order for driver to use cfg80211 it must register the hardware device with cfg80211 this happens through number of hardware capability structs described below the fundamental structure for each device is the wiphy of which each instance describes physical wireless device connected to the system each such wiphy can have zero one or many virtual interface associated with it which need to be identified a such by pointing the network interface is ieee80211 ptr pointer to type struct wireless dev which further describes the wireless part of the interface normally this struct is embedded in the network interface is private data area driver can optionally allow creating or destroying virtual interface on the fly but without at least one or the ability to create some the wireless device is not useful each wiphy structure contains device capability information and also ha pointer to the various operation the driver offer the definition and structure here describe these capability in detail struct sk buff skb the buffer which should be manipulate const struct net device dev the lowpan net device pointer const void daddr destination lladdr of mac header which is used for compression method const void saddr source lladdr of mac header which is used for compression method"
        },
        "irq_force_complete_move": {
            "ground_truth": "0",
            "function": "irq_force_complete_move",
            "description": "called from fixup irqs with desc lock held and interrupt disabled"
        },
        "bd_needed_req": {
            "ground_truth": "0",
            "function": "bd_needed_req",
            "description": "return how many bd is are need for this transfer"
        },
        "next_sub_range": {
            "ground_truth": "0",
            "function": "next_sub_range",
            "description": "nextsubrange compute the next subrange of the search"
        },
        "xfs_rtalloc_query_range": {
            "ground_truth": "0",
            "function": "xfs_rtalloc_query_range",
            "description": "find all the free record within given range"
        },
        "debug_level_show": {
            "ground_truth": "0",
            "function": "debug_level_show",
            "description": "debug level"
        },
        "mmgrab": {
            "ground_truth": "0",
            "function": "mmgrab",
            "description": "pin type struct mm struct make sure that mm will not get freed even after the owning task exit this doe not guarantee that the associated address space will still exist later on and mmget not zero ha to be used before accessing it this is preferred way to pin mm for longer unbounded amount of time use mmdrop to release the reference acquired by mmgrab see also for an in depth explanation of type mm struct mm count v type mm struct mm user struct mm struct mm the type struct mm struct to pin"
        },
        "create_vtbl": {
            "ground_truth": "0",
            "function": "create_vtbl",
            "description": "create copy of volume table this function return zero in case of success and negative error code in case of failure struct ubi device ubi ubi device description object struct ubi attach info ai attaching information int copy number of the volume table copy void vtbl content of the volume table"
        },
        "rmi_register_desc_calc_reg_offset": {
            "ground_truth": "0",
            "function": "rmi_register_desc_calc_reg_offset",
            "description": "calculate the total size of all of the register described in the descriptor"
        },
        "pti_tty_driver_open": {
            "ground_truth": "0",
            "function": "pti_tty_driver_open",
            "description": "open an application master channel aperture id to the pti device via tty device the main purpose of using the tty device interface is for each tty port to have unique pti write aperture in an example use case ttypti0 get syslogd and an app aperture id and ttypti1 is where the tracesink ldisc hook to route modem message into pti modem trace data doe not have to go to ttypti1 but ttypti0 and ttypti1 do need to be distinct master id these message go through the pti hw and out of the handheld platform and to the fido lauterbach device struct tty struct tty tty interface struct file filp filp interface pased to tty port open call int for success otherwise fail value"
        },
        "vmci_handle_arr_remove_entry": {
            "ground_truth": "0",
            "function": "vmci_handle_arr_remove_entry",
            "description": "handle that wa removed vmci invalid handle if entry not found"
        },
        "c67x00_do_work": {
            "ground_truth": "0",
            "function": "c67x00_do_work",
            "description": "c67x00 do work scheduler state machine"
        },
        "padata_find_next": {
            "ground_truth": "0",
            "function": "padata_find_next",
            "description": "padata find next find the next object that need serialization return pointer to the control struct of the next object that need serialization if present in one of the percpu reorder queue null if the next object that need serialization will be parallel processed by another cpu and is not yet present in the cpu is reorder queue"
        },
        "bnx2i_cm_remote_close": {
            "ground_truth": "0",
            "function": "bnx2i_cm_remote_close",
            "description": "process received tcp fin function callback exported via bnx2i cnic driver interface to indicate async tcp event such a fin struct cnic sock cm sk cnic sock structure pointer"
        },
        "udplite_sk_init": {
            "ground_truth": "0",
            "function": "udplite_sk_init",
            "description": "designate sk a udp lite socket"
        },
        "auxio_set_lte": {
            "ground_truth": "0",
            "function": "auxio_set_lte",
            "description": "auxio set lte set link test enable tpe link detect on auxio lte on or auxio lte off"
        },
        "batadv_tt_cache_init": {
            "ground_truth": "0",
            "function": "batadv_tt_cache_init",
            "description": "initialize tt memory object cache void no argument on success or negative error number in case of failure"
        },
        "find_dir_range": {
            "ground_truth": "0",
            "function": "find_dir_range",
            "description": "directory replay ha two part there are the standard directory item in the log copied from the subvolume and range item created in the log while the subvolume wa logged the range item tell u which part of the key space the log is authoritative for during replay if key in the subvolume directory is in logged range item but not actually in the log that mean it wa deleted from the directory before the fsync and should be removed"
        },
        "gma_resume_display": {
            "ground_truth": "0",
            "function": "gma_resume_display",
            "description": "resume display side logic resume the display hardware restoring state and enabling a necessary struct pci dev pdev undescribed"
        },
        "state_eval_encoder_ok": {
            "ground_truth": "0",
            "function": "state_eval_encoder_ok",
            "description": "evaluate whether or not state encoder ok can change"
        },
        "msi_get_domain_info": {
            "ground_truth": "0",
            "function": "msi_get_domain_info",
            "description": "get the msi interrupt domain info for domain return the pointer to the msi domain info stored in domain host data struct irq domain domain the interrupt domain to retrieve data from"
        },
        "tty3270_delete_characters": {
            "ground_truth": "0",
            "function": "tty3270_delete_characters",
            "description": "delete character at current position"
        },
        "tcp_update_metrics": {
            "ground_truth": "0",
            "function": "tcp_update_metrics",
            "description": "save metric learned by this tcp session this function is called only when tcp finish successfully when it enters time wait or go from last ack to close"
        },
        "tnum_or": {
            "ground_truth": "0",
            "function": "tnum_or",
            "description": "bitwise or return"
        },
        "__complete_background_work": {
            "ground_truth": "0",
            "function": "__complete_background_work",
            "description": "we need to clear any pending work flag that have been set and in the case of promotion free the entry for the destination cblock"
        },
        "find_ei": {
            "ground_truth": "0",
            "function": "find_ei",
            "description": "find element info corresponding to tlv type every element that got encoded in the qmi message will have type information associated with it while decoding the qmi message this function is used to find the struct info regarding the element that corresponds to the type being decoded struct qmi elem info ei array struct info array of the message being decoded u32 type tlv type of the element being searched pointer to struct info if found"
        },
        "build_header": {
            "ground_truth": "0",
            "function": "build_header",
            "description": "create the arcnet hard soft header for rfc1051"
        },
        "vga_inb": {
            "ground_truth": "0",
            "function": "vga_inb",
            "description": "hardware specific funcions"
        },
        "ath_htc_resume_btcoex_work": {
            "ground_truth": "0",
            "function": "ath_htc_resume_btcoex_work",
            "description": "re start btcoex work"
        },
        "vortex_adbdma_init": {
            "ground_truth": "0",
            "function": "vortex_adbdma_init",
            "description": ""
        },
        "get_rvt_head": {
            "ground_truth": "0",
            "function": "get_rvt_head",
            "description": "get head index of the circular buffer return head index value struct rvt rq rq data structure for request queue entry void ip the qp"
        },
        "btt_fini": {
            "ground_truth": "0",
            "function": "btt_fini",
            "description": "de initialize btt de initialize block translation table on device removal struct btt btt the btt handle that wa generated by btt init might sleep"
        },
        "vdev_init": {
            "ground_truth": "0",
            "function": "vdev_init",
            "description": "initialization and module stuff"
        },
        "snd_ctl_elem_add_compat": {
            "ground_truth": "0",
            "function": "snd_ctl_elem_add_compat",
            "description": "add or replace user control"
        },
        "intel_vgpu_unpin_mm": {
            "ground_truth": "0",
            "function": "intel_vgpu_unpin_mm",
            "description": "decrease the pin count of vgpu mm object this function is called when user doe not want to use vgpu mm object struct intel vgpu mm mm vgpu mm object"
        },
        "sess_setup": {
            "ground_truth": "0",
            "function": "sess_setup",
            "description": "setup smb sessionn"
        },
        "sctp_register_pf": {
            "ground_truth": "0",
            "function": "sctp_register_pf",
            "description": "register the pf specific function table"
        },
        "cnstr_shdsc_gcm_encap": {
            "ground_truth": "0",
            "function": "cnstr_shdsc_gcm_encap",
            "description": "gcm encapsulation shared descriptor u32 const desc pointer to buffer used for descriptor construction struct alginfo cdata pointer to block cipher transform definition valid algorithm value op alg algsel aes anded with op alg aai gcm unsigned int ivsize initialization vector size unsigned int icvsize integrity check value icv size truncated or full const bool is qi true when called from caam qi"
        },
        "devm_kfree": {
            "ground_truth": "0",
            "function": "devm_kfree",
            "description": "resource managed kfree free memory allocated with devm kmalloc struct device dev device this memory belongs to const void memory to free"
        },
        "qed_fw_asserts_dump": {
            "ground_truth": "0",
            "function": "qed_fw_asserts_dump",
            "description": "performs fw asserts dump to the specified buffer return the dumped size in dwords"
        },
        "qenable": {
            "ground_truth": "0",
            "function": "qenable",
            "description": "turn on napi and start up interrupt on response queue"
        },
        "hpi_dsp_code_read_block": {
            "ground_truth": "0",
            "function": "hpi_dsp_code_read_block",
            "description": "get block of dsp code into an internal buffer and provide pointer to that buffer if dsp code is already an array in memory it is referenced not copied return error if requested number of word are not available"
        },
        "mipi_dsi_dcs_get_power_mode": {
            "ground_truth": "0",
            "function": "mipi_dsi_dcs_get_power_mode",
            "description": "query the display module is current power mode struct mipi dsi device dsi dsi peripheral device u8 mode return location for the current power mode on success or negative error code on failure"
        },
        "vidioc_g_parm": {
            "ground_truth": "0",
            "function": "vidioc_g_parm",
            "description": "stream type dependent parameter ioctls"
        },
        "dbl_fdiv": {
            "ground_truth": "0",
            "function": "dbl_fdiv",
            "description": "double precision floating point divide"
        },
        "ssp_disable_sensor": {
            "ground_truth": "0",
            "function": "ssp_disable_sensor",
            "description": "disables sensor return or negative value in case of error struct ssp data data sensorhub structure enum ssp sensor type type ssp sensor type"
        },
        "user_backtrace": {
            "ground_truth": "0",
            "function": "user_backtrace",
            "description": "get the return address for single stackframe and return pointer to the next frame tail"
        },
        "verity_fec_status_table": {
            "ground_truth": "0",
            "function": "verity_fec_status_table",
            "description": "append feature argument and value to the status table"
        },
        "w_e_end_data_req": {
            "ground_truth": "0",
            "function": "w_e_end_data_req",
            "description": "worker callback to send data reply packet in response to data request struct drbd work work object int cancel the connection will be closed anyways"
        },
        "pdcspath_attr_store": {
            "ground_truth": "0",
            "function": "pdcspath_attr_store",
            "description": "generic write function call wrapper struct kobject kobj the kobject to write info to struct attribute attr the attribute to be modified const char buf the input buffer size count the size of the buffer"
        },
        "driver_find_device_by_acpi_dev": {
            "ground_truth": "0",
            "function": "driver_find_device_by_acpi_dev",
            "description": "device matching the acpi companion device struct device driver drv the driver we are iterating const struct acpi device adev acpi companion device to match"
        },
        "platform_get_resource_byname": {
            "ground_truth": "0",
            "function": "platform_get_resource_byname",
            "description": "get resource for device by name struct platform device dev platform device unsigned int type resource type const char name resource name"
        },
        "rxrpc_eaten_skb": {
            "ground_truth": "0",
            "function": "rxrpc_eaten_skb",
            "description": "note the dropping of ref on socket buffer by the core"
        },
        "gdb_cmd_status": {
            "ground_truth": "0",
            "function": "gdb_cmd_status",
            "description": "handle the status packet"
        },
        "dn_queue_skb": {
            "ground_truth": "0",
            "function": "dn_queue_skb",
            "description": "copy of sock queue rcv skb from sock without bh lock sock it already held when this is called which also allows data and other data to be queued to socket"
        },
        "get_vblank_counter": {
            "ground_truth": "0",
            "function": "get_vblank_counter",
            "description": "get frame count"
        },
        "process_one_iomb": {
            "ground_truth": "0",
            "function": "process_one_iomb",
            "description": "process one outbound queue memory block struct pm8001 hba info pm8001 ha our hba card information void piomb io message buffer"
        },
        "xfs_refcount_lookup_eq": {
            "ground_truth": "0",
            "function": "xfs_refcount_lookup_eq",
            "description": "look up the first record equal to bno len in the btree given by cur"
        },
        "spi_nor_erase_chip": {
            "ground_truth": "0",
            "function": "spi_nor_erase_chip",
            "description": "erase the entire flash memory struct spi nor nor pointer to istruct spi nor on success errno otherwise"
        },
        "lsm_ipc_alloc": {
            "ground_truth": "0",
            "function": "lsm_ipc_alloc",
            "description": "allocate composite ipc blob allocate the ipc blob for all the module return or enomem if memory can not be allocated struct kern ipc perm kip the ipc that need blob"
        },
        "i40e_ddp_exec_aq_section": {
            "ground_truth": "0",
            "function": "i40e_ddp_exec_aq_section",
            "description": "execute generic aq for ddp struct i40e hw hw pointer to the hw struct struct i40e profile aq section aq command buffer containing all data to execute aq"
        },
        "hvc_iucv_sndbuf_work": {
            "ground_truth": "0",
            "function": "hvc_iucv_sndbuf_work",
            "description": "send buffered data over iucv this work queue function sends buffered output data over iucv and if not all buffered data could be sent reschedules itself struct work struct work work structure"
        },
        "gfs2_ail_empty_tr": {
            "ground_truth": "0",
            "function": "gfs2_ail_empty_tr",
            "description": "empty one of the ail list for transaction struct gfs2 sbd sdp undescribed struct gfs2 trans tr undescribed struct list head head undescribed"
        },
        "port_r_cnt": {
            "ground_truth": "0",
            "function": "port_r_cnt",
            "description": "read mib counter periodically this routine is used to read the counter of the port periodically to avoid counter overflow the hardware should be acquired first before calling this routine return non zero when not all counter not read struct ksz hw hw the hardware instance int port the port index"
        },
        "irqreturn_t": {
            "ground_truth": "0",
            "function": "irqreturn_t",
            "description": "fman exception cb fman pointer to fman exception the exception exception user callback routine will be called upon an exception passing the exception identification return irq status"
        },
        "ipr_inquiry_page_supported": {
            "ground_truth": "0",
            "function": "ipr_inquiry_page_supported",
            "description": "is the given inquiry page supported this function determines if the specified inquiry page is supported return value if page is supported if not struct ipr inquiry page0 page0 inquiry page buffer u8 page page code"
        },
        "v4l2_ctrl_add_handler": {
            "ground_truth": "0",
            "function": "v4l2_ctrl_add_handler",
            "description": "add all control from handler add to handler hdl doe nothing if either of the two handler is null pointer if filter is null then all control are added otherwise only those control for which filter return true will be added in case of an error hdl error will be set to the error code if it wa not set already struct v4l2 ctrl handler hdl the control handler struct v4l2 ctrl handler add the control handler whose control you want to add to the hdl control handler v4l2 ctrl filter filter this function will filter which control should be added bool from other dev if true then the control in add were defined in another device than hdl"
        },
        "vxfs_find_entry": {
            "ground_truth": "0",
            "function": "vxfs_find_entry",
            "description": "find mathing directory entry for dentry vxfs find entry find type struct vxfs direct for the vfs directory cache entry dp ppp will be filled with the page the return value resides in struct inode ip directory inode struct dentry dp dentry for which we want to find direct struct page ppp get filled with the page the return value sits in the wanted direct on success else null pointer"
        },
        "dwc2_release_channel": {
            "ground_truth": "0",
            "function": "dwc2_release_channel",
            "description": "release host channel for use by other transfer also attempt to select and queue more transaction since at least one host channel is available struct dwc2 hsotg hsotg the hcd state structure struct dwc2 host chan chan the host channel to release struct dwc2 qtd qtd the qtd associated with the host channel this qtd may be freed if the transfer is complete or an error ha occurred enum dwc2 halt status halt status reason the channel is being released this status determines the action taken by this function"
        },
        "npcm7xx_config_get": {
            "ground_truth": "0",
            "function": "npcm7xx_config_get",
            "description": "pinconf ops"
        },
        "pwc_get_u8_ctrl": {
            "ground_truth": "0",
            "function": "pwc_get_u8_ctrl",
            "description": "control get set helper"
        },
        "tenxpress_phy_poll": {
            "ground_truth": "0",
            "function": "tenxpress_phy_poll",
            "description": "poll for link state change"
        },
        "fwcap_to_speed": {
            "ground_truth": "0",
            "function": "fwcap_to_speed",
            "description": "return the highest speed set in the port capability in mb"
        },
        "serialize_against_pte_lookup": {
            "ground_truth": "0",
            "function": "serialize_against_pte_lookup",
            "description": "serialize against find current mm pte which doe lock le lookup in page table with local interrupt disabled for huge page it cast pmd to pte since format of pte is different from pmd we want to prevent transit from pmd pointing to page table to pmd pointing to huge page and back while interrupt are disabled we clear pmd to possibly replace it with page table pointer in different code path so make sure we wait for the parallel find current mm pte to finish"
        },
        "il4965_eeprom_acquire_semaphore": {
            "ground_truth": "0",
            "function": "il4965_eeprom_acquire_semaphore",
            "description": ""
        },
        "i2c_del_adapter": {
            "ground_truth": "0",
            "function": "i2c_del_adapter",
            "description": "unregister i2c adapter this unregisters an i2c adapter which wa previously registered by i2c add adapter or i2c add numbered adapter struct i2c adapter adap the adapter being unregistered can sleep"
        },
        "apci3120_ns_to_timer": {
            "ground_truth": "0",
            "function": "apci3120_ns_to_timer",
            "description": "there are three timer on the board they all use the same base clock with fixed prescaler for each timer the base clock used depends on the board version and type apci rev board osc 29mhz base clock 70ns apci rev board osc 20mhz base clock 50ns apci board osc 20mhz base clock 50ns the prescalers for each timer are timer clk osc timer clk osc timer clk osc"
        },
        "ab8500_charger_get_ac_current": {
            "ground_truth": "0",
            "function": "ab8500_charger_get_ac_current",
            "description": "get ac charger current this function return the ac charger current return ac current on success and error code on failure struct ab8500 charger di pointer to the ab8500 charger structure"
        },
        "_InitInterrupt": {
            "ground_truth": "0",
            "function": "_InitInterrupt",
            "description": "shall usb interface init this"
        },
        "efx_farch_rx_remove": {
            "ground_truth": "0",
            "function": "efx_farch_rx_remove",
            "description": "free buffer backing rx queue"
        },
        "jpeg_get_byte": {
            "ground_truth": "0",
            "function": "jpeg_get_byte",
            "description": "return value that fit into u8 or negative error"
        },
        "r600_copy_dma": {
            "ground_truth": "0",
            "function": "r600_copy_dma",
            "description": "copy page using the dma engine copy gpu paging using the dma engine r6xx used by the radeon ttm implementation to move page if registered a the asic copy callback struct radeon device rdev radeon device pointer uint64 src offset src gpu address uint64 dst offset dst gpu address unsigned num gpu page number of gpu page to xfer struct dma resv resv reservation object to sync to"
        },
        "gasket_alloc_coherent_memory": {
            "ground_truth": "0",
            "function": "gasket_alloc_coherent_memory",
            "description": "allocate block of coherent memory"
        },
        "stats_assess": {
            "ground_truth": "0",
            "function": "stats_assess",
            "description": "there are time when we do not have any confidence in the hotspot queue such a when fresh cache is created and the block have been spread out across the level or if an io load change we detect this by seeing how often lookup is in the top level of the hotspot queue"
        },
        "hinic_rq_write_wqe": {
            "ground_truth": "0",
            "function": "hinic_rq_write_wqe",
            "description": "write the wqe to the rq struct hinic rq rq recv queue u16 prod idx pi of the wqe struct hinic rq wqe rq wqe the wqe to write struct sk buff skb skb to save"
        },
        "omap3_prm_reset_modem": {
            "ground_truth": "0",
            "function": "omap3_prm_reset_modem",
            "description": "toggle reset signal for modem toggle the reset signal to modem ip block required to allow omap3430 without stacked modem to idle properly void no argument"
        },
        "get_cache_mode": {
            "ground_truth": "0",
            "function": "get_cache_mode",
            "description": "failure mode"
        },
        "__rm7k_tc_enable": {
            "ground_truth": "0",
            "function": "__rm7k_tc_enable",
            "description": "this function is executed in uncached address space"
        },
        "init_ov_sensor": {
            "ground_truth": "0",
            "function": "init_ov_sensor",
            "description": "this doe an initial reset of an omnivision sensor and ensures that i2c is synchronized return on failure"
        },
        "ecp_sync": {
            "ground_truth": "0",
            "function": "ecp_sync",
            "description": "wait for empty ecp fifo if we are in ecp fifo mode only"
        },
        "tomoyo_write_transition_control": {
            "ground_truth": "0",
            "function": "tomoyo_write_transition_control",
            "description": "write struct tomoyo transition control list return on success negative value otherwise struct tomoyo acl param param pointer to struct tomoyo acl param const u8 type type of this entry"
        },
        "pcan_read_canreg": {
            "ground_truth": "0",
            "function": "pcan_read_canreg",
            "description": "read sja1000 register"
        },
        "csio_hws_quiesced": {
            "ground_truth": "0",
            "function": "csio_hws_quiesced",
            "description": "csio hws quiesced quiesced state hw hw module evt event"
        },
        "ccw_device_resume": {
            "ground_truth": "0",
            "function": "ccw_device_resume",
            "description": "resume channel program execution ccw device resume call rsch on cdev is subchannel struct ccw device cdev target ccw device interrupt disabled ccw device lock held on success enodev on device not operational einval on invalid device state ebusy on device busy or interrupt pending"
        },
        "hw_alloc_pkt": {
            "ground_truth": "0",
            "function": "hw_alloc_pkt",
            "description": "allocate enough descriptor for transmission this function allocates descriptor for transmission return if not successful for buffer copy or number of descriptor struct ksz hw hw the hardware instance int length the length of the packet int physical number of descriptor required"
        },
        "eisa_unmask_irq": {
            "ground_truth": "0",
            "function": "eisa_unmask_irq",
            "description": "called by request irq"
        },
        "twa_init": {
            "ground_truth": "0",
            "function": "twa_init",
            "description": "this function is called on driver initialization"
        },
        "find_seams": {
            "ground_truth": "0",
            "function": "find_seams",
            "description": "find the best horizontal and vertical seam position to split into tile minimize the fractional part of the input sampling position for the top left pixel of each tile"
        },
        "shutdown": {
            "ground_truth": "0",
            "function": "shutdown",
            "description": "shutdown request and disconnect from gadget"
        },
        "btrfs_alloc_stripe_hash_table": {
            "ground_truth": "0",
            "function": "btrfs_alloc_stripe_hash_table",
            "description": "the stripe hash table is used for locking and to collect bios in hope of making full stripe"
        },
        "parport_ip32_drain_fifo": {
            "ground_truth": "0",
            "function": "parport_ip32_drain_fifo",
            "description": "wait for fifo to empty this function wait for fifo to empty it return when fifo is empty or if the timeout timeout is reached before or if signal is pending struct parport pointer to type struct parport unsigned long timeout timeout in jiffy"
        },
        "i40iw_build_timer_list": {
            "ground_truth": "0",
            "function": "i40iw_build_timer_list",
            "description": "add cm node to timer list struct list head timer list ptr to timer list struct list head hte ptr to accelerated or non accelerated list"
        },
        "drm_atomic_get_old_bridge_state": {
            "ground_truth": "0",
            "function": "drm_atomic_get_old_bridge_state",
            "description": "get old bridge state if it exists this function return the old bridge state for the given bridge or null if the bridge is not part of the global atomic state struct drm atomic state state global atomic state object struct drm bridge bridge bridge to grab"
        },
        "vb2_start_streaming_called": {
            "ground_truth": "0",
            "function": "vb2_start_streaming_called",
            "description": "return streaming status of driver struct vb2 queue pointer to type struct vb2 queue with videobuf2 queue"
        },
        "mlx4_en_read_clock": {
            "ground_truth": "0",
            "function": "mlx4_en_read_clock",
            "description": "mlx4 en read clock read raw cycle counter to be used by time counter"
        },
        "get_reg": {
            "ground_truth": "0",
            "function": "get_reg",
            "description": "get content of register regno in task task"
        },
        "fpu__resume_cpu": {
            "ground_truth": "0",
            "function": "fpu__resume_cpu",
            "description": "restore minimal fpu state after suspend"
        },
        "emulate_umip_insn": {
            "ground_truth": "0",
            "function": "emulate_umip_insn",
            "description": "emulate umip instruction and return dummy value emulate an instruction protected by umip and provide dummy result the result of the emulation is saved in data the size of the result depends on both the instruction and type of operand register v memory address the size of the result is updated in data size caller is responsible of providing data buffer of at least umip gdt idt base size umip gdt idt limit size byte on success einval on error while emulating struct insn insn instruction structure with operand int umip inst constant indicating the instruction to emulate unsigned char data buffer into which the dummy result is stored int data size size of the emulated result bool x86 true if process is bit false otherwise"
        },
        "cpu_probe": {
            "ground_truth": "0",
            "function": "cpu_probe",
            "description": ""
        },
        "ixgbe_fc_autoneg_backplane": {
            "ground_truth": "0",
            "function": "ixgbe_fc_autoneg_backplane",
            "description": "enable flow control ieee clause struct ixgbe hw hw pointer to hardware structure enable flow control according to ieee clause"
        },
        "n_hdlc_tty_receive": {
            "ground_truth": "0",
            "function": "n_hdlc_tty_receive",
            "description": "called by tty driver when receive data is available called by tty low level driver when receive data is available data is interpreted a one hdlc frame struct tty struct tty pointer to tty instance data const u8 data pointer to received data char flag pointer to flag for data int count count of received data in byte"
        },
        "ia_css_circbuf_shift_chunk": {
            "ground_truth": "0",
            "function": "ia_css_circbuf_shift_chunk",
            "description": "chunk of element the one from the start position to the chunk src position are shifted in the circular buffer along the direction of new element coming brief shift chunk of element in the circular buffer param cb the pointer to the circular buffer param chunk src the position at which the first element in the chunk is param chunk dest the position to which the first element in the chunk would be shift"
        },
        "wmi_addr_remap": {
            "ground_truth": "0",
            "function": "wmi_addr_remap",
            "description": "u32 internal address if address have no valid ahb mapping return"
        },
        "reiserfs_clean_and_file_buffer": {
            "ground_truth": "0",
            "function": "reiserfs_clean_and_file_buffer",
            "description": "clear bh dirty and stick the buffer on the clean list called because can not allow refile buffer to make schedule happen after have freed block look at remove from transaction and journal mark freed for more detail"
        },
        "e1000_clean_rx_irq": {
            "ground_truth": "0",
            "function": "e1000_clean_rx_irq",
            "description": "send received data up the network stack legacy struct e1000 adapter adapter board private structure struct e1000 rx ring rx ring ring to clean int work done amount of napi work completed this call int work to do max amount of work allowed for this call to do"
        },
        "mma9551_set_power_state": {
            "ground_truth": "0",
            "function": "mma9551_set_power_state",
            "description": "set runtime pm state resume or suspend the device using runtime pm the device will suspend after the autosuspend delay struct i2c client client i2c client bool on use true to power on device false to power off on success negative value on failure"
        },
        "gsp_send": {
            "ground_truth": "0",
            "function": "gsp_send",
            "description": "sends usb packet to the tty assumes that all package and at an usb packet boundary return on error if packet is incomplete or if packet wa sent"
        },
        "svc_pool_map_set_cpumask": {
            "ground_truth": "0",
            "function": "svc_pool_map_set_cpumask",
            "description": "set the given thread is cpu allowed mask so that it will only run on cpu in the given pool"
        },
        "bdc_gadget_ep_enable": {
            "ground_truth": "0",
            "function": "bdc_gadget_ep_enable",
            "description": "configure endpoint and also allocate resource"
        },
        "set_ts_params": {
            "ground_truth": "0",
            "function": "set_ts_params",
            "description": "set device param to start dma"
        },
        "ubifs_calc_min_idx_lebs": {
            "ground_truth": "0",
            "function": "ubifs_calc_min_idx_lebs",
            "description": "calculate amount of lebs for the index this function calculates and return the number of lebs which should be kept for index usage struct ubifs info ubifs file system description object"
        },
        "read_block": {
            "ground_truth": "0",
            "function": "read_block",
            "description": "more method added in future"
        },
        "inc_deq": {
            "ground_truth": "0",
            "function": "inc_deq",
            "description": "see cycle bit rule sw is the consumer for the event ring only do not make ring full of link trbs that would be dumb and this would loop"
        },
        "lpfc_nodev_tmo_init": {
            "ground_truth": "0",
            "function": "lpfc_nodev_tmo_init",
            "description": "set the hba nodev timeout value if the devloss tmo is already set then nodev tmo is set to devloss tmo kernel error message is printed and zero is returned else if val is in range then nodev tmo and devloss tmo are set to val otherwise nodev tmo is set to the default value struct lpfc vport vport lpfc vport structure pointer int val contains the nodev timeout value zero if already set or if val is in range einval val out of range"
        },
        "picolcd_fb_update_tile": {
            "ground_truth": "0",
            "function": "picolcd_fb_update_tile",
            "description": "translate single tile"
        },
        "iscsi_prep_ecdb_ahs": {
            "ground_truth": "0",
            "function": "iscsi_prep_ecdb_ahs",
            "description": "make an extended cdb ahs"
        },
        "ver_insert": {
            "ground_truth": "0",
            "function": "ver_insert",
            "description": "we put the version tree in reverse order so we can use the same eat last function that we use to consume the tmpnode tree tn root"
        },
        "vxge_hw_driver_stats_get": {
            "ground_truth": "0",
            "function": "vxge_hw_driver_stats_get",
            "description": "vxge hw driver stats get get the device sw statistic return the vpath stats for the device"
        },
        "iwl_run_init_mvm_ucode": {
            "ground_truth": "0",
            "function": "iwl_run_init_mvm_ucode",
            "description": "mvm method"
        },
        "emu8k_pcm_timer_func": {
            "ground_truth": "0",
            "function": "emu8k_pcm_timer_func",
            "description": "timer interrupt handler check the current position and update the period if necessary"
        },
        "nilfs_bmap_test_and_clear_dirty": {
            "ground_truth": "0",
            "function": "nilfs_bmap_test_and_clear_dirty",
            "description": "test and clear bmap dirty state nilfs test and clear is the atomic operation to test and clear the dirty state of bmap return value is returned if bmap is dirty or if clear struct nilfs bmap bmap bmap"
        },
        "nicstar_read_eprom": {
            "ground_truth": "0",
            "function": "nicstar_read_eprom",
            "description": "this routine will be the interface to the readprombyte function above"
        },
        "adapter_comm": {
            "ground_truth": "0",
            "function": "adapter_comm",
            "description": "administrative operation"
        },
        "ArcGetEnvironmentVariable": {
            "ground_truth": "0",
            "function": "ArcGetEnvironmentVariable",
            "description": "environment variable routine"
        },
        "nilfs_bmap_set_dirty": {
            "ground_truth": "0",
            "function": "nilfs_bmap_set_dirty",
            "description": "assume that bmap semaphore is locked"
        },
        "set_vbus": {
            "ground_truth": "0",
            "function": "set_vbus",
            "description": "effective for peripheral ignored for device"
        },
        "bnx2x_test_intr": {
            "ground_truth": "0",
            "function": "bnx2x_test_intr",
            "description": "send an empty ramrod on the first queue"
        },
        "fc_elsct_send": {
            "ground_truth": "0",
            "function": "fc_elsct_send",
            "description": "send an el or ct frame struct fc lport lport the local port to send the frame on u32 did the destination id for the frame struct fc frame fp the frame to be sent unsigned int op the operational code void resp struct fc seq struct fc frame void the callback routine when the response is received void arg the argument to pas to the response callback routine u32 timer msec the timeout period for the frame in msec"
        },
        "show_serial_version": {
            "ground_truth": "0",
            "function": "show_serial_version",
            "description": "this routine print out the appropriate serial driver version number and identifies which option were configured into this driver"
        },
        "arch_switch_tls": {
            "ground_truth": "0",
            "function": "arch_switch_tls",
            "description": "in skas0 mode currently multiple guest thread sharing the same mm have common host process so this is needed in skas0 too however if each thread had different host process and this wa discussed for smp support this will not be needed and this will not need be used when and if we will add support to the host skas patch"
        },
        "vwrite": {
            "ground_truth": "0",
            "function": "vwrite",
            "description": "write vmalloc area in safe way this function check that addr is valid vmalloc ed area and copy data from buffer to the given addr if specified range of addr addr count includes some valid address data is copied from proper area of buf if there are memory hole no copy to hole ioremap area is treated a memory hole and no copy is done if addr addr count doe not includes any intersects with alive vm struct area return buf should be kernel is buffer note in usual ops vwrite is never necessary because the caller should know vmalloc area is valid and can use memcpy this is for routine which have to access vmalloc area without any information a dev kmem char buf buffer for source data char addr vm address unsigned long count number of byte to be read number of byte for which addr and buf should be increased same number a count or if addr addr count doe not include any intersection with valid vmalloc area"
        },
        "driver_remove_file": {
            "ground_truth": "0",
            "function": "driver_remove_file",
            "description": "remove sysfs file for driver struct device driver drv driver const struct driver attribute attr driver attribute descriptor"
        },
        "crypto_aead_blocksize": {
            "ground_truth": "0",
            "function": "crypto_aead_blocksize",
            "description": "obtain block size of cipher the block size for the aead referenced with the cipher handle is returned the caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation struct crypto aead tfm cipher handle block size of cipher"
        },
        "typec_partner_set_identity": {
            "ground_truth": "0",
            "function": "typec_partner_set_identity",
            "description": "report result from discover identity command this routine is used to report that the result of discover identity usb power delivery command ha become available struct typec partner partner the partner updated identity value"
        },
        "execute_only_pkey": {
            "ground_truth": "0",
            "function": "execute_only_pkey",
            "description": "try to dedicate one of the protection key to be used a an execute only protection key"
        },
        "gsmld_attach_gsm": {
            "ground_truth": "0",
            "function": "gsmld_attach_gsm",
            "description": "mode set up struct tty struct tty our tty structure struct gsm mux gsm our mux set up the mux for basic mode and commence connecting to the modem currently called from the line discipline set up but will need moving to an ioctl path"
        },
        "clear_bit": {
            "ground_truth": "0",
            "function": "clear_bit",
            "description": "clear bit in memory clear bit is atomic and may not be reordered however it doe not contain memory barrier so if it is used for locking purpose you should call smp mb before atomic and or smp mb after atomic in order to ensure change are visible on other processor int nr bit to clear volatile void addr address to start counting from"
        },
        "requeue_futex": {
            "ground_truth": "0",
            "function": "requeue_futex",
            "description": "requeue futex from one hb to another struct futex the futex to requeue struct futex hash bucket hb1 the source hash bucket struct futex hash bucket hb2 the target hash bucket union futex key key2 the new key for the requeued futex"
        },
        "core_get_se_deve_from_rtpi": {
            "ground_truth": "0",
            "function": "core_get_se_deve_from_rtpi",
            "description": "target core device"
        },
        "cxl_unmap_afu_irq": {
            "ground_truth": "0",
            "function": "cxl_unmap_afu_irq",
            "description": "unmap mapped irq handler"
        },
        "clear_time_state": {
            "ground_truth": "0",
            "function": "clear_time_state",
            "description": "clear ntp time status time state"
        },
        "dispc_calc_fir_inc": {
            "ground_truth": "0",
            "function": "dispc_calc_fir_inc",
            "description": ""
        },
        "stmpe_block_write": {
            "ground_truth": "0",
            "function": "stmpe_block_write",
            "description": "write multiple stmpe register struct stmpe stmpe device to write to u8 reg first register u8 length number of register const u8 value value to write"
        },
        "qed_ll2_alloc": {
            "ground_truth": "0",
            "function": "qed_ll2_alloc",
            "description": "brief qed ll2 alloc allocates ll2 connection set param hwfn return int"
        },
        "cfg80211_get_station": {
            "ground_truth": "0",
            "function": "cfg80211_get_station",
            "description": "retrieve information about given station return on success and sinfo is filled with the available information otherwise return negative error code and the content of sinfo ha to be considered undefined struct net device dev the device where the station is supposed to be connected to const u8 mac addr the mac address of the station of interest struct station info sinfo pointer to the structure to fill with the information"
        },
        "scsi_report_lun_change": {
            "ground_truth": "0",
            "function": "scsi_report_lun_change",
            "description": "scsi report lun change set flag on all other device on the same target to indicate that unit attention is expected sdev device reporting the unit attention"
        },
        "fsl7450_reg_setup": {
            "ground_truth": "0",
            "function": "fsl7450_reg_setup",
            "description": "configures the global setting for the countes on all cpu"
        },
        "ap_display_usage": {
            "ground_truth": "0",
            "function": "ap_display_usage",
            "description": "function ap display usage description usage message for the acpi dump utility"
        },
        "patch_build_controls": {
            "ground_truth": "0",
            "function": "patch_build_controls",
            "description": "chip specific initialization"
        },
        "dpu_hw_catalog_deinit": {
            "ground_truth": "0",
            "function": "dpu_hw_catalog_deinit",
            "description": "dpu hardware catalog cleanup struct dpu md cfg dpu cfg pointer returned from init function"
        },
        "send_rx_ctrl_cmd": {
            "ground_truth": "0",
            "function": "send_rx_ctrl_cmd",
            "description": "send rx control command struct lio lio per network private data int start stop whether to start or stop"
        },
        "usbip_dump_urb": {
            "ground_truth": "0",
            "function": "usbip_dump_urb",
            "description": "usbip common"
        },
        "cas_page_dequeue": {
            "ground_truth": "0",
            "function": "cas_page_dequeue",
            "description": "pull page from the list"
        },
        "mtk_dai_hostless_startup": {
            "ground_truth": "0",
            "function": "mtk_dai_hostless_startup",
            "description": "dai ops"
        },
        "sctp_bind_addr_free": {
            "ground_truth": "0",
            "function": "sctp_bind_addr_free",
            "description": "dispose of an sctp bind addr structure"
        },
        "mpic_end_irq": {
            "ground_truth": "0",
            "function": "mpic_end_irq",
            "description": "eoi specific virq"
        },
        "get_binary": {
            "ground_truth": "0",
            "function": "get_binary",
            "description": "conversion from int value to it binary form used for debugging the output buffer must be allocated prior to calling the function"
        },
        "aspeed_smc_chip_set_4b_spi_2400": {
            "ground_truth": "0",
            "function": "aspeed_smc_chip_set_4b_spi_2400",
            "description": "the ast2400 spi flash controller doe not have ce control register it us the ce0 control register to set 4byte mode at the controller level"
        },
        "device_init_registers": {
            "ground_truth": "0",
            "function": "device_init_registers",
            "description": "initialisation of mac bbp register"
        },
        "i2400m_dev_initialize": {
            "ground_truth": "0",
            "function": "i2400m_dev_initialize",
            "description": "initialize the device once communication are ready configures the device to work the way we like it at the point of this call the device is registered with the wimax and netdev stack firmware is uploaded and we can talk to the device normally struct i2400m i2400m device descriptor if ok errno code on error"
        },
        "security_delete_hooks": {
            "ground_truth": "0",
            "function": "security_delete_hooks",
            "description": "assuring the safety of deleting security module is up to the security module involved this may entail ordering the module is hook list in particular way refusing to disable the module once policy is loaded or any number of other action better imagined than described the name of the configuration option reflects the only module that currently us the mechanism any developer who think disabling their module is good idea need to be at least a careful a the selinux team"
        },
        "v4l2_fill_mbus_format_mplane": {
            "ground_truth": "0",
            "function": "v4l2_fill_mbus_format_mplane",
            "description": "ancillary routine that fill type struct v4l2 mbus framefmt from type struct v4l2 pix format mplane struct v4l2 mbus framefmt mbus fmt pointer to type struct v4l2 mbus framefmt to be filled const struct v4l2 pix format mplane pix mp fmt pointer to type struct v4l2 pix format mplane to be used a model"
        },
        "uli526x_rx_packet": {
            "ground_truth": "0",
            "function": "uli526x_rx_packet",
            "description": "receive the come packet and pas to upper layer"
        },
        "power_suspend": {
            "ground_truth": "0",
            "function": "power_suspend",
            "description": "turn on only vbus suspend power and hotplug detection turn off everything else"
        },
        "hw_atl_rdm_cpu_id_set": {
            "ground_truth": "0",
            "function": "hw_atl_rdm_cpu_id_set",
            "description": "set cpu id"
        },
        "qeth_osn_register": {
            "ground_truth": "0",
            "function": "qeth_osn_register",
            "description": "export for osn"
        },
        "ata_pio_sectors": {
            "ground_truth": "0",
            "function": "ata_pio_sectors",
            "description": "transfer one or many sector struct ata queued cmd qc command on going transfer one or many sector of data from to the ata device for the drq request locking inherited from caller"
        },
        "loongson3_reg_setup": {
            "ground_truth": "0",
            "function": "loongson3_reg_setup",
            "description": "compute all of the register in preparation for enabling profiling"
        },
        "nouveau_hw_decode_pll": {
            "ground_truth": "0",
            "function": "nouveau_hw_decode_pll",
            "description": "pll getting"
        },
        "svc_rdma_recv_ctxt_put": {
            "ground_truth": "0",
            "function": "svc_rdma_recv_ctxt_put",
            "description": "return recv ctxt to free list struct svcxprt rdma rdma controlling svcxprt rdma struct svc rdma recv ctxt ctxt object to return to the free list"
        },
        "quirk_disable_pxb": {
            "ground_truth": "0",
            "function": "quirk_disable_pxb",
            "description": "ensure c0 rev restreaming is off this is normally done by the bios but in the odd case it is not the result are corruption hence the presence of linux check"
        },
        "pcpu_update_empty_pages": {
            "ground_truth": "0",
            "function": "pcpu_update_empty_pages",
            "description": "pcpu update empty page update empty page counter this is used to keep track of the empty page now based on the premise md block cover page the hint update function recognize if block is made full or broken to calculate delta for keeping track of free page chunk chunk of interest nr nr of empty page"
        },
        "nfs4_state_protect_write": {
            "ground_truth": "0",
            "function": "nfs4_state_protect_write",
            "description": "special wrapper to nfs4 state protect for write if write can use machine cred but commit cannot make sure all writes that use machine cred use nfs file sync"
        },
        "__execute_only_pkey": {
            "ground_truth": "0",
            "function": "__execute_only_pkey",
            "description": "try to dedicate one of the protection key to be used a an execute only protection key"
        },
        "snd_dma_disable": {
            "ground_truth": "0",
            "function": "snd_dma_disable",
            "description": "stop the isa dma transfer stop the isa dma transfer unsigned long dma the dma number"
        },
        "vivid_rds_generate": {
            "ground_truth": "0",
            "function": "vivid_rds_generate",
            "description": "this rds generator creates rds group one group four rds block group and spaced group apart are filled with standard 0b group containing the pi code and p name group and use group 2a for the radio text group contains the time group 4a all remaining group use filler group 15b block that just repeat the pi and pty code"
        },
        "hvc_iucv_put_chars": {
            "ground_truth": "0",
            "function": "hvc_iucv_put_chars",
            "description": "hvc put char operation the hvc thread call this method to write character to the back end the function call hvc iucv queue to queue terminal data for sending locking the method get called under an irqsave spinlock and lock struct hvc iucv private lock uint32 vtermno hvc virtual terminal number const char buf pointer to an buffer to read data from int count size of buffer available for reading"
        },
        "gb_connection_flush_incoming_operations": {
            "ground_truth": "0",
            "function": "gb_connection_flush_incoming_operations",
            "description": "cancel all active incoming operation on connection locking called with connection lock held and state set to enabled tx"
        },
        "fix_to_virt": {
            "ground_truth": "0",
            "function": "fix_to_virt",
            "description": "index to address translation if anyone try to use the idx directly without translation we catch the bug with null deference kernel oops illegal range of incoming index are caught too"
        },
        "activate_mm": {
            "ground_truth": "0",
            "function": "activate_mm",
            "description": "after we have set current mm to new value this activates the context for the new mm so we see the new mapping"
        },
        "rndis_msg_parser": {
            "ground_truth": "0",
            "function": "rndis_msg_parser",
            "description": "rndis message parser and other useless function"
        },
        "batadv_bitmap_shift_left": {
            "ground_truth": "0",
            "function": "batadv_bitmap_shift_left",
            "description": "shift the packet array by place"
        },
        "dm_helpers_dp_mst_send_payload_allocation": {
            "ground_truth": "0",
            "function": "dm_helpers_dp_mst_send_payload_allocation",
            "description": "sends allocate payload message"
        },
        "disable": {
            "ground_truth": "0",
            "function": "disable",
            "description": "optional callback"
        },
        "count_get": {
            "ground_truth": "0",
            "function": "count_get",
            "description": "struct scmi clk ops represents the various operation provided by scmi clock protocol count get get the count of clock provided by scmi info get get the information of the specified clock rate get request the current clock rate of clock rate set set the clock rate of clock enable enables the specified clock disable disables the specified clock"
        },
        "bitmap_zalloc": {
            "ground_truth": "0",
            "function": "bitmap_zalloc",
            "description": "allocation and deallocation of bitmap provided in lib bitmap to avoid circular dependency"
        },
        "v4l2_m2m_dst_buf_remove_by_buf": {
            "ground_truth": "0",
            "function": "v4l2_m2m_dst_buf_remove_by_buf",
            "description": "take off exact destination buffer from the list of ready buffer struct v4l2 m2m ctx m2m ctx m2m context assigned to the instance given by struct type v4l2 m2m ctx struct vb2 v4l2 buffer vbuf the buffer to be removed"
        },
        "comedi_8254_set_busy": {
            "ground_truth": "0",
            "function": "comedi_8254_set_busy",
            "description": "set clear the busy flag for given counter struct comedi i8254 comedi struct for the timer unsigned int counter the counter number bool busy set clear flag"
        },
        "e1000_hv_phy_workarounds_ich8lan": {
            "ground_truth": "0",
            "function": "e1000_hv_phy_workarounds_ich8lan",
            "description": "apply phy workarounds struct e1000 hw hw pointer to the hw structure series of phy workarounds to be done after every phy reset"
        },
        "ppp_receive_frame": {
            "ground_truth": "0",
            "function": "ppp_receive_frame",
            "description": "we come in here to process received frame the receive side of the ppp unit is locked"
        },
        "imx_media_find_mbus_format": {
            "ground_truth": "0",
            "function": "imx_media_find_mbus_format",
            "description": "search in the pixel format array for an entry with the given medium bus code that match the requested selection criterion and return it code search for an entry with the given medium bus code fmt sel allow entry only with the given selection criterion"
        },
        "speakup_fake_key_pressed": {
            "ground_truth": "0",
            "function": "speakup_fake_key_pressed",
            "description": "are we handling simulated keypress on the current cpu return boolean"
        },
        "dev_action_start": {
            "ground_truth": "0",
            "function": "dev_action_start",
            "description": "fi an instance of an interface statemachine event the event just happened arg generic pointer casted from struct net device upon call fsm instance fi undescribed int event undescribed void arg undescribed"
        },
        "mlx4_SET_PORT_PRIO2TC": {
            "ground_truth": "0",
            "function": "mlx4_SET_PORT_PRIO2TC",
            "description": "this routine map user priority to traffic class of given port and device return on success or negative mlx4 core errno code struct mlx4 dev dev mlx4 dev u8 port physical port number u8 prio2tc array of tc associated with each priority"
        },
        "imx319_write_reg": {
            "ground_truth": "0",
            "function": "imx319_write_reg",
            "description": "write register up to at time"
        },
        "sysfs_kf_seq_show": {
            "ground_truth": "0",
            "function": "sysfs_kf_seq_show",
            "description": "read on sysfs are handled through seq file which take care of hairy detail like buffering and seeking the following function pipe sysfs ops show result through seq file"
        },
        "ib_get_rmpp_resptime": {
            "ground_truth": "0",
            "function": "ib_get_rmpp_resptime",
            "description": "return the rmpp response time struct ib rmpp hdr rmpp hdr an rmpp header"
        },
        "j1939_module_init": {
            "ground_truth": "0",
            "function": "j1939_module_init",
            "description": "module interface"
        },
        "__bfa_cb_rport_online": {
            "ground_truth": "0",
            "function": "__bfa_cb_rport_online",
            "description": "bfa rport private bfa rport private function"
        },
        "v4l2_m2m_reqbufs": {
            "ground_truth": "0",
            "function": "v4l2_m2m_reqbufs",
            "description": "multi queue aware reqbufs multiplexer struct file file pointer to struct type file struct v4l2 m2m ctx m2m ctx m2m context assigned to the instance given by struct type v4l2 m2m ctx struct v4l2 requestbuffers reqbufs pointer to struct type v4l2 requestbuffers"
        },
        "txstate": {
            "ground_truth": "0",
            "function": "txstate",
            "description": "an endpoint is transmitting data this can be called either from the irq routine or from ep queue to kickstart request on an endpoint context controller locked irqs blocked endpoint selected"
        },
        "iavf_get_sset_count": {
            "ground_truth": "0",
            "function": "iavf_get_sset_count",
            "description": "get length of string set report size of various string table struct net device netdev network interface device structure int sset id of string set"
        },
        "spu_activate": {
            "ground_truth": "0",
            "function": "spu_activate",
            "description": "find free spu for context and execute it try to find free spu to run ctx if no free spu is available add the context to the runqueue so it get woken up once an spu is available struct spu context ctx spu context to schedule unsigned long flag flag currently ignored"
        },
        "dm_pp_get_clock_levels_by_type": {
            "ground_truth": "0",
            "function": "dm_pp_get_clock_levels_by_type",
            "description": "get valid clock level from pplib input clk type display clk sclk mem clk output array of valid clock level for given type in ascending order with invalid level filtered out"
        },
        "batadv_nc_path_search": {
            "ground_truth": "0",
            "function": "batadv_nc_path_search",
            "description": "find the coding path matching in nc node and out nc node to retrieve buffered packet that can be used for coding struct batadv priv bat priv the bat priv with all the soft interface information struct batadv nc node in nc node pointer to skb next hop is neighbor nc node struct batadv nc node out nc node pointer to skb source is neighbor nc node struct sk buff skb data skb to forward u8 eth dst next hop mac address of skb true if coding of decoded skb is allowed"
        },
        "lpfc_idiag_mbxacc_read": {
            "ground_truth": "0",
            "function": "lpfc_idiag_mbxacc_read",
            "description": "idiag debugfs read on mailbox access this routine read data from the phba driver mailbox access debugfs setup information struct file file the file pointer to read from char user buf the buffer to copy the data to size nbytes the number of byte to read loff ppos the position in the file to start reading from this function return the amount of data that wa read this could be le than nbytes if the end of the file wa reached or negative error value"
        },
        "nilfs_readpage": {
            "ground_truth": "0",
            "function": "nilfs_readpage",
            "description": "implement readpage method of nilfs aops address space operation file file struct of the file to be read page the page to be read struct file file undescribed struct page page undescribed"
        },
        "ath5k_setup_rate_powertable": {
            "ground_truth": "0",
            "function": "ath5k_setup_rate_powertable",
            "description": "set up rate power table for given tx power struct ath5k hw ah the type struct ath5k hw u16 max pwr the maximum tx power requested in 5db step struct ath5k rate pcal info rate info the type struct ath5k rate pcal info to fill u8 ee mode one of enum ath5k driver mode"
        },
        "amdgpu_bo_fence": {
            "ground_truth": "0",
            "function": "amdgpu_bo_fence",
            "description": "add fence to buffer object struct amdgpu bo bo buffer object in question struct dma fence fence fence to add bool shared true if fence should be added shared"
        },
        "match_futex": {
            "ground_truth": "1",
            "function": "match_futex",
            "description": "check whether two futex key are equal return if two futex key are equal otherwise union futex key key1 pointer to key1 union futex key key2 pointer to key2"
        },
        "msc_buffer_free": {
            "ground_truth": "1",
            "function": "msc_buffer_free",
            "description": "free buffer for msc free msc is storage buffer this modifies msc win list and msc base which requires msc buf mutex to serialize so the caller is expected to hold it struct msc msc msc device"
        },
        "ds1685_rtc_check_mday": {
            "ground_truth": "1",
            "function": "ds1685_rtc_check_mday",
            "description": "check validity of the day of month return edom if the day of month is not within range struct ds1685 priv rtc pointer to the ds1685 rtc structure u8 mday day of month"
        },
        "stdma_try_lock": {
            "ground_truth": "1",
            "function": "stdma_try_lock",
            "description": "attempt to acquire st dma interrupt lock return if lock wa acquired otherwise irq handler handler interrupt handler to use after acquisition void data undescribed"
        }
    },
    "PR": {
        "user_describe": {
            "ground_truth": "0",
            "function": "user_describe",
            "description": "user describe describe the user key"
        },
        "qla82xx_pci_mem_bound_check": {
            "ground_truth": "0",
            "function": "qla82xx_pci_mem_bound_check",
            "description": "qla82xx pci mem bound check check memory access boundary used by test agent support ddr access only for now"
        },
        "radeon_atpx_detect": {
            "ground_truth": "0",
            "function": "radeon_atpx_detect",
            "description": "radeon atpx detect detect whether we have px check if we have px system all asics return true if we have px system false if not"
        },
        "smb311_posix_query_path_info": {
            "ground_truth": "0",
            "function": "smb311_posix_query_path_info",
            "description": "smb311 posix query path infoquery path info from the server using smb311 posix extension"
        },
        "novatd_frontend_attach": {
            "ground_truth": "0",
            "function": "novatd_frontend_attach",
            "description": "novatd frontend attach novatd frontend attach nova td specific attach nova td ha gpio0 and for led so do not fiddle with them except for information purpose"
        },
        "tomoyo_permstr": {
            "ground_truth": "1",
            "function": "tomoyo_permstr",
            "description": "tomoyo permstr find permission keywords return true if keyword wa found in string false otherwise this function assumes that strncmp w1 w2 strlen w1 if w1 w2"
        },
        "selinux_netlbl_sk_security_reset": {
            "ground_truth": "1",
            "function": "selinux_netlbl_sk_security_reset",
            "description": "selinux netlbl sk security reset reset the netlabel field called when the netlabel state of sk security struct need to be reset the caller is responsible for all the netlabel sk security struct locking"
        },
        "tomoyo_path_number_perm": {
            "ground_truth": "1",
            "function": "tomoyo_path_number_perm",
            "description": "tomoyo path number perm check permission for create mkdir mkfifo mksock ioctl chmod chown chgrp return on success negative value otherwise"
        },
        "drm_ioctl_permit": {
            "ground_truth": "1",
            "function": "drm_ioctl_permit",
            "description": "drm ioctl permit check ioctl permission against caller check whether the caller is allowed to run an ioctl with the indicated permission"
        },
        "tomoyo_check_unix_acl": {
            "ground_truth": "1",
            "function": "tomoyo_check_unix_acl",
            "description": "tomoyo check unix acl check permission for unix domain socket operation return true if granted false otherwise"
        },
        "smack_privileged": {
            "ground_truth": "1",
            "function": "smack_privileged",
            "description": "smack privileged are all privilege requirement met is the task privileged and allowed to be privileged by the onlycap rule return true if the task is allowed to be privileged false if it is not"
        },
        "security_get_user_sids": {
            "ground_truth": "1",
            "function": "security_get_user_sids",
            "description": "security get user sids obtain reachable sids for user generate the set of sids for legal security context for given user that can be reached by fromsid set sids to point to dynamically allocated array containing the set of sids set nel to the number of element in the array"
        },
        "avc_has_perm": {
            "ground_truth": "1",
            "function": "avc_has_perm",
            "description": "avc ha perm check permission and perform any appropriate auditing check the avc to determine whether the requested permission are granted for the sid pair ssid tsid interpreting the permission based on tclass and call the security server on cache miss to obtain new decision and add it to the cache audit the granting or denial of permission in accordance with the policy return if all requested permission are granted eacces if any permission are denied or another errno upon other error"
        },
        "tomoyo_check_env_acl": {
            "ground_truth": "1",
            "function": "tomoyo_check_env_acl",
            "description": "tomoyo check env acl check permission for environment variable is name return true if granted false otherwise"
        },
        "security_load_policy": {
            "ground_truth": "1",
            "function": "security_load_policy",
            "description": "security load policy load security policy configuration load new set of security policy configuration data validate it and convert the sid table a necessary this function will flush the access vector cache after loading the new policy"
        },
        "cachefiles_get_security_ID": {
            "ground_truth": "1",
            "function": "cachefiles_get_security_ID",
            "description": "cachefiles get security id determine the security context within which we access the cache from within the kernel"
        },
        "security_ib_endport_sid": {
            "ground_truth": "1",
            "function": "security_ib_endport_sid",
            "description": "security ib endport sid obtain the sid for subnet management interface"
        },
        "tick_is_oneshot_available": {
            "ground_truth": "1",
            "function": "tick_is_oneshot_available",
            "description": "tick is oneshot available check for oneshot capable event device"
        },
        "qib_get_eeprom_info": {
            "ground_truth": "1",
            "function": "qib_get_eeprom_info",
            "description": "qib get eeprom info get the guid et al from the tswi eeprom device we have the capability to use the nguid field and get the guid from the first chip is flash to use for all of them"
        },
        "generic_permission": {
            "ground_truth": "1",
            "function": "generic_permission",
            "description": "generic permission check for access right on posix like filesystem used to check for read write execute permission on file we use fsuid for this letting u set arbitrary permission for filesystem access without changing the normal uids which are used for other thing generic permission is rcu walk aware it return echild in case an rcu walk request cannot be satisfied eg requires blocking or too much complexity it would then be called again in ref walk mode"
        },
        "privileged_wrt_inode_uidgid": {
            "ground_truth": "1",
            "function": "privileged_wrt_inode_uidgid",
            "description": "privileged wrt inode uidgid do capability in the namespace work over the inode return true if the inode uid and gid are within the namespace"
        },
        "snd_hda_check_amp_caps": {
            "ground_truth": "1",
            "function": "snd_hda_check_amp_caps",
            "description": "snd hda check amp cap query amp capability check whether the widget ha the given amp capability for the direction"
        },
        "common_perm_dir_dentry": {
            "ground_truth": "1",
            "function": "common_perm_dir_dentry",
            "description": "common perm dir dentry common permission wrapper when path is dir dentry"
        },
        "smack_privileged_cred": {
            "ground_truth": "1",
            "function": "smack_privileged_cred",
            "description": "smack privileged cred are all privilege requirement met by cred is the task privileged and allowed to be privileged by the onlycap rule return true if the task is allowed to be privileged false if it is not"
        },
        "nf_register_sockopt": {
            "ground_truth": "1",
            "function": "nf_register_sockopt",
            "description": "nf register sockoptfunctions to register get setsockopt range non inclusive you need to check permission yourself"
        },
        "devcgroup_legacy_check_permission": {
            "ground_truth": "1",
            "function": "devcgroup_legacy_check_permission",
            "description": "devcgroup legacy check permission check if an inode operation is permitted return on success eperm case the operation is not permitted"
        },
        "has_pid_permissions": {
            "ground_truth": "1",
            "function": "has_pid_permissions",
            "description": "ha pid permission may current process learn task is sched cmdline info for hide pid min or euid egid for hide pid min"
        },
        "proc_tid_comm_permission": {
            "ground_truth": "1",
            "function": "proc_tid_comm_permission",
            "description": "proc tid comm permission proc tid comm permission is special permission function exclusively used for the node proc task comm it bypass generic permission check in the case where task of the same task group attempt to access the node the rationale behind this is that glibc and bionic access this node for cross thread naming pthread set getname np self however if pr set dumpable get set to this node among others becomes uid gid which lock out the cross thread naming implementation this function make sure that the node is always accessible for member of same thread group"
        },
        "tomoyo_check_mkdev_acl": {
            "ground_truth": "1",
            "function": "tomoyo_check_mkdev_acl",
            "description": "tomoyo check mkdev acl check permission for path number number number operation return true if granted false otherwise"
        },
        "inode_owner_or_capable": {
            "ground_truth": "1",
            "function": "inode_owner_or_capable",
            "description": "inode owner or capable check current task permission to inode return true if current either ha cap fowner in namespace with the inode owner uid mapped or owns the file"
        },
        "apparmor_socket_connect": {
            "ground_truth": "1",
            "function": "apparmor_socket_connect",
            "description": "apparmor socket connect check perm before connecting sock to address"
        },
        "__security_genfs_sid": {
            "ground_truth": "1",
            "function": "__security_genfs_sid",
            "description": "security genf sid helper to obtain sid for file in filesystem obtain sid to use for file in filesystem that cannot support xattr or use fixed labeling behavior like transition sids or task sids"
        },
        "tomoyo_execute_permission": {
            "ground_truth": "1",
            "function": "tomoyo_execute_permission",
            "description": "tomoyo execute permission check permission for execute operation return on success negative value otherwise caller hold tomoyo read lock"
        },
        "security_ib_pkey_sid": {
            "ground_truth": "1",
            "function": "security_ib_pkey_sid",
            "description": "security ib pkey sid obtain the sid for pkey"
        },
        "capable": {
            "ground_truth": "1",
            "function": "capable",
            "description": "capable determine if the current task ha superior capability in effect return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used"
        },
        "__netlink_ns_capable": {
            "ground_truth": "1",
            "function": "__netlink_ns_capable",
            "description": "netlink n capable general netlink message capability test test to see if the opener of the socket we received the message from had when the netlink socket wa created and the sender of the message ha the capability cap in the user namespace user n"
        },
        "udf_rename": {
            "ground_truth": "1",
            "function": "udf_rename",
            "description": "udf renameanybody can rename anything with this the permission check are left to the higher level routine"
        },
        "btrfs_may_delete": {
            "ground_truth": "1",
            "function": "btrfs_may_delete",
            "description": "btrfs may deletecopy of may delete in f namei check whether we can remove link victim from directory dir check whether the type of victim is right we can not do it if dir is read only done in permission we should have write and exec permission on dir we can not remove anything from append only dir we can not do anything with immutable dir done in permission if the sticky bit on dir is set we should either be owner of dir or be owner of victim or have cap fowner capability if the victim is append only or immutable we can not do anything with link pointing to it if we were asked to remove directory and victim is not one enotdir if we were asked to remove non directory and victim is not one eisdir we can not remove root or mountpoint we do not allow removal of nfs sillyrenamed file it is handled by nfs async unlink"
        },
        "ipc_check_perms": {
            "ground_truth": "1",
            "function": "ipc_check_perms",
            "description": "ipc check perm check security and permission for an ipc object this routine is called by sys msgget sys semget and sys shmget when the key is not ipc private and that key already exists in the d idr on success the ipc id is returned it is called with ipc id rwsem and ipcp lock held"
        },
        "ipcctl_obtain_check": {
            "ground_truth": "1",
            "function": "ipcctl_obtain_check",
            "description": "ipcctl obtain check retrieve an ipc object and check permission this function doe some common audit and permission check for some ipc xxx cmd and is called from semctl down shmctl down and msgctl down it retrieves the ipc object with the given id in the given table performs some audit and permission check depending on the given cmd return pointer to the ipc object or otherwise the corresponding error call holding the both the rwsem and the rcu read lock"
        },
        "tomoyo_path_permission": {
            "ground_truth": "1",
            "function": "tomoyo_path_permission",
            "description": "tomoyo path permission check permission for single path operation return on success negative value otherwise caller hold tomoyo read lock"
        },
        "__kcsan_check_read_write": {
            "ground_truth": "1",
            "function": "__kcsan_check_read_write",
            "description": "kcsan check read write check regular read write access for race"
        },
        "apparmor_socket_bind": {
            "ground_truth": "1",
            "function": "apparmor_socket_bind",
            "description": "apparmor socket bind check perm before bind addr to socket"
        },
        "aa_file_perm": {
            "ground_truth": "1",
            "function": "aa_file_perm",
            "description": "aa file perm do permission revalidation check audit for file"
        },
        "security_node_sid": {
            "ground_truth": "1",
            "function": "security_node_sid",
            "description": "security node sid obtain the sid for node host"
        },
        "access_error": {
            "ground_truth": "1",
            "function": "access_error",
            "description": "access error check that the permission on the vma allow for the fault which occurred if we encountered write fault we must have write permission otherwise we allow any permission"
        },
        "cap_ptrace_access_check": {
            "ground_truth": "1",
            "function": "cap_ptrace_access_check",
            "description": "cap ptrace access check determine whether the current process may access another if we are in the same or an ancestor user n and have all the target task is capability then ptrace access is allowed if we have the ptrace capability to the target user n then ptrace access is allowed else denied determine whether process may access another returning if permission granted ve if denied"
        },
        "tomoyo_mount_acl": {
            "ground_truth": "1",
            "function": "tomoyo_mount_acl",
            "description": "tomoyo mount acl check permission for mount operation return on success negative value otherwise caller hold tomoyo read lock"
        },
        "nested_vmx_check_permission": {
            "ground_truth": "1",
            "function": "nested_vmx_check_permission",
            "description": "nested vmx check permission intel is vmx instruction reference specifies common set of prerequisite for running vmx instruction except vmxon whose prerequisite are slightly different it also specifies what exception to inject otherwise note that many of these exception have priority over vm exit so they do not have to be checked again here"
        },
        "netlink_ns_capable": {
            "ground_truth": "1",
            "function": "netlink_ns_capable",
            "description": "netlink n capable general netlink message capability test test to see if the opener of the socket we received the message from had when the netlink socket wa created and the sender of the message ha the capability cap in the user namespace user n"
        },
        "common_perm_create": {
            "ground_truth": "1",
            "function": "common_perm_create",
            "description": "common perm create common permission wrapper for operation doing create"
        },
        "sb_permission": {
            "ground_truth": "1",
            "function": "sb_permission",
            "description": "sb permission check superblock level permission separate out file system wide check from inode specific permission check"
        },
        "security_port_sid": {
            "ground_truth": "1",
            "function": "security_port_sid",
            "description": "security port sid obtain the sid for port"
        },
        "tomoyo_socket_listen_permission": {
            "ground_truth": "1",
            "function": "tomoyo_socket_listen_permission",
            "description": "tomoyo socket listen permission check permission for listening socket return on success negative value otherwise"
        },
        "has_capability_noaudit": {
            "ground_truth": "1",
            "function": "has_capability_noaudit",
            "description": "ha capability noaudit doe task have capability unaudited in the initial user n return true if the specified task ha the given superior capability currently in effect to init user n false if not do not write an audit message for the check note that this doe not set pf superpriv on the task"
        },
        "smk_curacc": {
            "ground_truth": "1",
            "function": "smk_curacc",
            "description": "smk curacc determine if current ha specific access to an object this function check the current subject label object label pair in the access rule list and return if the access is permitted non zero otherwise it allows that current may have the capability to override the rule"
        },
        "keyctl_join_session_keyring": {
            "ground_truth": "1",
            "function": "keyctl_join_session_keyring",
            "description": "keyctl join session keyring join named session keyring create and join an anonymous session keyring or join named session keyring creating it if necessary named session keyring must have search permission for it to be joined session keyrings without this permit will be skipped over it is not permitted for userspace to create or join keyrings whose name begin with dot if successful the id of the joined session keyring will be returned"
        },
        "security_transition_sid": {
            "ground_truth": "1",
            "function": "security_transition_sid",
            "description": "security transition sid compute the sid for new subject object compute sid to use for labeling new subject or object in the class tclass based on sid pair ssid tsid return einval if any of the parameter are invalid enomem if insufficient memory is available or if the new sid wa computed successfully"
        },
        "set_security_override_from_ctx": {
            "ground_truth": "1",
            "function": "set_security_override_from_ctx",
            "description": "set security override from ctx set the security id in set of credential set the lsm security id in set of credential so that the subjective security is overridden when an alternative set of credential is used the security id is specified in string form a security context to be interpreted by the lsm"
        },
        "gaudi_init_security": {
            "ground_truth": "1",
            "function": "gaudi_init_security",
            "description": "gaudi init security initialize security model initialize the security model of the device that includes range register and protection bit per register"
        },
        "context_read_and_validate": {
            "ground_truth": "1",
            "function": "context_read_and_validate",
            "description": "context read and validate read and validate security context structure from policydb binary representation file"
        },
        "proc_fd_permission": {
            "ground_truth": "1",
            "function": "proc_fd_permission",
            "description": "proc fd permission proc pid fd need special permission handler so that process can still access proc self fd after it ha executed setuid"
        },
        "drm_ioctl_flags": {
            "ground_truth": "1",
            "function": "drm_ioctl_flags",
            "description": "drm ioctl flag check for core ioctl and return ioctl permission flag this ioctl is only used by the vmwgfx driver to augment the access check done by the drm core and insofar pretty decent layering violation this should not be used by any driver"
        },
        "file_ns_capable": {
            "ground_truth": "1",
            "function": "file_ns_capable",
            "description": "file n capable determine if the file is opener had capability in effect return true if task that opened the file had capability in effect when the file wa opened this doe not set pf superpriv because the caller may not actually be privileged"
        },
        "security_genfs_sid": {
            "ground_truth": "1",
            "function": "security_genfs_sid",
            "description": "security genf sid obtain sid for file in filesystem acquire policy rwlock before calling security genf sid and release it afterward"
        },
        "vmw_user_bo_verify_access": {
            "ground_truth": "1",
            "function": "vmw_user_bo_verify_access",
            "description": "vmw user bo verify access verify access permission on this buffer object"
        },
        "smk_ipv6_check": {
            "ground_truth": "1",
            "function": "smk_ipv6_check",
            "description": "smk ipv6 check check smack access check an ipv6 access"
        },
        "set_security_override": {
            "ground_truth": "1",
            "function": "set_security_override",
            "description": "set security override set the security id in set of credential set the lsm security id in set of credential so that the subjective security is overridden when an alternative set of credential is used"
        },
        "check_kill_permission": {
            "ground_truth": "1",
            "function": "check_kill_permission",
            "description": "check kill permission bad permission for sending the signal the caller must hold the rcu read lock"
        },
        "tomoyo_socket_connect_permission": {
            "ground_truth": "1",
            "function": "tomoyo_socket_connect_permission",
            "description": "tomoyo socket connect permission check permission for setting the remote address of socket return on success negative value otherwise"
        },
        "security_sid_to_context": {
            "ground_truth": "1",
            "function": "security_sid_to_context",
            "description": "security sid to context obtain context for given sid write the string representation of the context associated with sid into dynamically allocated string of the correct size set scontext to point to this string and set scontext len to the length of the string"
        },
        "check_entry": {
            "ground_truth": "1",
            "function": "check_entry",
            "description": "check entry tomoyo check acl do permission check"
        },
        "pcie_update_aspm_capable": {
            "ground_truth": "1",
            "function": "pcie_update_aspm_capable",
            "description": "pcie update aspm capablerecheck latency and update aspm capable for link under the root"
        },
        "tomoyo_socket_connect": {
            "ground_truth": "1",
            "function": "tomoyo_socket_connect",
            "description": "tomoyo socket connect check permission for connect return on success negative value otherwise"
        },
        "be_cmd_get_fn_privileges": {
            "ground_truth": "1",
            "function": "be_cmd_get_fn_privileges",
            "description": "be cmd get fn privilegesget privilege for function"
        },
        "tomoyo_socket_sendmsg_permission": {
            "ground_truth": "1",
            "function": "tomoyo_socket_sendmsg_permission",
            "description": "tomoyo socket sendmsg permission check permission for sending datagram return on success negative value otherwise"
        },
        "__kcsan_check_read": {
            "ground_truth": "1",
            "function": "__kcsan_check_read",
            "description": "kcsan check read check regular read access for race"
        },
        "security_read_policy": {
            "ground_truth": "1",
            "function": "security_read_policy",
            "description": "security read policy read the policy"
        },
        "setattr_prepare": {
            "ground_truth": "1",
            "function": "setattr_prepare",
            "description": "setattr prepare check if attribute change to dentry are allowed check if we are allowed to change the attribute contained in attr in the given dentry this includes the normal unix access permission check a well a check for rlimits and others the function also clear sgid bit from mode if user is not allowed to set it also file capability and ima extended attribute are cleared if attr kill priv is set should be called a the first thing in setattr implementation possibly after taking additional lock"
        },
        "smk_ipv6_port_check": {
            "ground_truth": "1",
            "function": "smk_ipv6_port_check",
            "description": "smk ipv6 port check check smack port access create or update the port list entry"
        },
        "ns_capable": {
            "ground_truth": "1",
            "function": "ns_capable",
            "description": "n capable determine if the current task ha superior capability in effect return true if the current task ha the given superior capability currently available for use false if not this set pf superpriv on the task if the capability is available on the assumption that it is about to be used"
        },
        "apex_ioctl_check_permissions": {
            "ground_truth": "1",
            "function": "apex_ioctl_check_permissions",
            "description": "apex ioctl check permission check permission for apex ioctls"
        },
        "fuse_permission": {
            "ground_truth": "1",
            "function": "fuse_permission",
            "description": "fuse permission check permission the two basic access model of fuse are local access checking wouldefault permission mount option based on file mode this is the plain old disk filesystem permission modell remote access checking where server is responsible for checking permission in each inode operation an exception to this is if permission wa invoked from sys access in which case an access request is sent execute permission is still checked locally based on file mode"
        },
        "tomoyo_path_perm": {
            "ground_truth": "1",
            "function": "tomoyo_path_perm",
            "description": "tomoyo path perm check permission for unlink rmdir truncate symlink append chroot and unmount return on success negative value otherwise"
        },
        "ecryptfs_privileged_open": {
            "ground_truth": "1",
            "function": "ecryptfs_privileged_open",
            "description": "ecryptfs privileged open this function get file opened against the lower dentry return zero on success non zero otherwise"
        },
        "xdr_encode_current_server_time": {
            "ground_truth": "1",
            "function": "xdr_encode_current_server_time",
            "description": "xdr encode current server time passing the invalid value useconds is sun convention for set to current server time it is needed to make permission check for the touch program across v2 mount to solaris and irix server work correctly see description of sattr in section of nfs illustrated by brent callaghan addison wesley isbn"
        },
        "kcsan_check_read": {
            "ground_truth": "1",
            "function": "kcsan_check_read",
            "description": "kcsan check read check regular read access for race"
        },
        "common_perm": {
            "ground_truth": "1",
            "function": "common_perm",
            "description": "common perm basic common permission check wrapper fn for path"
        },
        "gic_dist_security_disabled": {
            "ground_truth": "1",
            "function": "gic_dist_security_disabled",
            "description": "gic dist security disabledcheck whether it is single security state view"
        },
        "__kcsan_check_access": {
            "ground_truth": "1",
            "function": "__kcsan_check_access",
            "description": "kcsan check access check generic access for race"
        },
        "security_net_peersid_resolve": {
            "ground_truth": "1",
            "function": "security_net_peersid_resolve",
            "description": "security net peersid resolve compare and resolve two network peer sids compare the nlbl sid and xfrm sid value and if the two sids can be resolved into single sid it is returned via peer sid and the function return zero otherwise peer sid is set to secsid null and the function return negative value table summarizing the behavior is below function return sid no peer label secsid null single peer label multiple consistent label multiple inconsistent label secsid null"
        },
        "sk_capable": {
            "ground_truth": "1",
            "function": "sk_capable",
            "description": "sk capable socket global capability test test to see if the opener of the socket had when the socket wa created and the current process ha the capability cap in all user namespaces"
        },
        "avic_update_access_page": {
            "ground_truth": "1",
            "function": "avic_update_access_page",
            "description": "avic update access page avic hardware walk the nested page table to check permission but doe not use the spa address specified in the leaf page table entry since it us address in the avic backing page pointer field of the vmcb therefore we set up the apic access page private memslot 4kb here"
        },
        "apparmor_socket_recvmsg": {
            "ground_truth": "1",
            "function": "apparmor_socket_recvmsg",
            "description": "apparmor socket recvmsg check perm before receiving message"
        },
        "security_add_hooks": {
            "ground_truth": "1",
            "function": "security_add_hooks",
            "description": "security add hook add module hook to the hook list each lsm ha to register it hook with the infrastructure"
        },
        "security_member_sid": {
            "ground_truth": "1",
            "function": "security_member_sid",
            "description": "security member sid compute the sid for member selection compute sid to use when selecting member of polyinstantiated object of class tclass based on sid pair ssid tsid return einval if any of the parameter are invalid enomem if insufficient memory is available or if the sid wa computed successfully"
        },
        "read": {
            "ground_truth": "1",
            "function": "read",
            "description": "readvc vp register access function soc specific"
        },
        "_scsih_check_pcie_access_status": {
            "ground_truth": "1",
            "function": "_scsih_check_pcie_access_status",
            "description": "scsih check pcie access status check access flag"
        },
        "keyctl_keyring_search": {
            "ground_truth": "1",
            "function": "keyctl_keyring_search",
            "description": "keyctl keyring search search the specified keyring and any keyrings it link to for matching key only keyrings that grant the caller search permission will be searched this includes the starting keyring only key with search permission can be found if successful the found key will be linked to the destination keyring if supplied and the key ha link permission and the found key id will be"
        },
        "kcsan_check_read_write": {
            "ground_truth": "1",
            "function": "kcsan_check_read_write",
            "description": "kcsan check read write check regular read write access for race"
        },
        "is_vsyscall_vaddr": {
            "ground_truth": "1",
            "function": "is_vsyscall_vaddr",
            "description": "is vsyscall vaddr the legacy vsyscall page is the long page in the kernel portion of the address space that ha user accessible permission"
        },
        "tomoyo_check_open_permission": {
            "ground_truth": "1",
            "function": "tomoyo_check_open_permission",
            "description": "tomoyo check open permission check permission for read and write return on success negative value otherwise"
        },
        "gfs2_permission": {
            "ground_truth": "1",
            "function": "gfs2_permission",
            "description": "gfs2 permission this may be called from the vfs directly or from within gfs2 with the inode locked so we look to see if the glock is already locked and only lock the glock if it not already been done"
        },
        "amdgpu_verify_access": {
            "ground_truth": "1",
            "function": "amdgpu_verify_access",
            "description": "amdgpu verify access verify access for mmap call this is called by ttm bo mmap to verify whether process ha the right to mmap bo to their process space"
        },
        "apparmor_socket_shutdown": {
            "ground_truth": "1",
            "function": "apparmor_socket_shutdown",
            "description": "apparmor socket shutdown check perm before shutting down sock conn"
        },
        "cap_ptrace_traceme": {
            "ground_truth": "1",
            "function": "cap_ptrace_traceme",
            "description": "cap ptrace traceme determine whether another process may trace the current if parent is in the same or an ancestor user n and ha all current is capability then ptrace access is allowed if parent ha the ptrace capability to current is user n then ptrace access is allowed else denied determine whether the nominated task is permitted to trace the current process returning if permission is granted ve if denied"
        },
        "tomoyo_path2_perm": {
            "ground_truth": "1",
            "function": "tomoyo_path2_perm",
            "description": "tomoyo path2 perm check permission for rename link and pivot root return on success negative value otherwise"
        },
        "queue_access_lock": {
            "ground_truth": "1",
            "function": "queue_access_lock",
            "description": "queue access lockcheck if the client ha permission to modify queue parameter if it doe lock the queue"
        },
        "nlm_privileged_requester": {
            "ground_truth": "1",
            "function": "nlm_privileged_requester",
            "description": "nlm privileged requester ensure incoming request are from local privileged caller"
        },
        "cap_capable": {
            "ground_truth": "1",
            "function": "cap_capable",
            "description": "cap capable determine whether task ha particular effective capability determine whether the nominated task ha the specified capability amongst it effective set returning if it doe ve if it doe not note well cap ha capability cannot be used like the kernel is capable and ha capability function that is it ha the reverse semantics cap ha capability return when task ha capability but the kernel is capable and ha capability return for this case"
        },
        "drm_vma_node_is_allowed": {
            "ground_truth": "1",
            "function": "drm_vma_node_is_allowed",
            "description": "drm vma node is allowed check whether an open file is granted access search the list in node whether tag is currently on the list of allowed open file see drm vma node allow this is locked against concurrent access internally"
        },
        "i40iw_vf_capable": {
            "ground_truth": "1",
            "function": "i40iw_vf_capable",
            "description": "i40iw vf capable check if vf capable return if vf slot is available or if vf is already rdma enabled return otherwise"
        },
        "tomoyo_unix_entry": {
            "ground_truth": "1",
            "function": "tomoyo_unix_entry",
            "description": "tomoyo unix entry check permission for unix network operation return on success negative value otherwise"
        },
        "xattr_permission": {
            "ground_truth": "1",
            "function": "xattr_permission",
            "description": "xattr permission check permission for extended attribute access this is bit complicated because different namespaces have very different rule"
        },
        "security_context_to_sid_default": {
            "ground_truth": "1",
            "function": "security_context_to_sid_default",
            "description": "security context to sid default obtain sid for given security context falling back to specified default if needed obtains sid associated with the security context that ha the string representation specified by scontext the default sid is passed to the ml layer to be used to allow kernel labeling of the ml field if the ml field is not present for upgrading to ml without full relabel implicitly force adding of the context even if it cannot be mapped yet return einval if the context is invalid enomem if insufficient memory is available or on success"
        },
        "ks8851_eeprom_claim": {
            "ground_truth": "1",
            "function": "ks8851_eeprom_claim",
            "description": "ks8851 eeprom claim claim device eeprom and activate the interface check for the presence of an eeprom and then activate software access to the device"
        },
        "security_extensions_enabled": {
            "ground_truth": "1",
            "function": "security_extensions_enabled",
            "description": "security extension enabled security extension bit permitted value 0b0000 not implemented 0b0001 0b0010 implemented"
        },
        "tomoyo_socket_sendmsg": {
            "ground_truth": "1",
            "function": "tomoyo_socket_sendmsg",
            "description": "tomoyo socket sendmsg check permission for sendmsg return on success negative value otherwise"
        },
        "debugfs_locked_down": {
            "ground_truth": "1",
            "function": "debugfs_locked_down",
            "description": "debugfs locked down only permit access to world readable file when the kernel is locked down we also need to exclude any file that ha way to write or alter it a root can bypass the permission check"
        },
        "security_change_sid": {
            "ground_truth": "1",
            "function": "security_change_sid",
            "description": "security change sid compute the sid for object relabeling compute sid to use for relabeling an object of class tclass based on sid pair ssid tsid return einval if any of the parameter are invalid enomem if insufficient memory is available or if the sid wa computed successfully"
        },
        "may_delete": {
            "ground_truth": "1",
            "function": "may_delete",
            "description": "may delete check whether we can remove link victim from directory dir check whether the type of victim is right we can not do it if dir is read only done in permission we should have write and exec permission on dir we can not remove anything from append only dir we can not do anything with immutable dir done in permission if the sticky bit on dir is set we should either be owner of dir or be owner of victim or have cap fowner capability if the victim is append only or immutable we can not do antyhing with link pointing to it if the victim ha an unknown uid or gid we can not change the inode if we were asked to remove directory and victim is not one enotdir if we were asked to remove non directory and victim is not one eisdir we can not remove root or mountpoint we do not allow removal of nfs sillyrenamed file it is handled by nfs async unlink"
        },
        "key_permission": {
            "ground_truth": "1",
            "function": "key_permission",
            "description": "key permission check to see whether permission is granted to use key in the desired way"
        },
        "tomoyo_socket_bind_permission": {
            "ground_truth": "1",
            "function": "tomoyo_socket_bind_permission",
            "description": "tomoyo socket bind permission check permission for setting the local address of socket return on success negative value otherwise"
        },
        "key_task_permission": {
            "ground_truth": "1",
            "function": "key_task_permission",
            "description": "key task permission check key can be used check to see whether permission is granted to use key in the desired way but permit the security module to override the caller must hold either ref on cred or must hold the rcu readlock return if successful eacces if access is denied based on the permission bit or the lsm check"
        },
        "apparmor_socket_getpeername": {
            "ground_truth": "1",
            "function": "apparmor_socket_getpeername",
            "description": "apparmor socket getpeername check perm before getting remote address"
        },
        "verify_new_ex": {
            "ground_truth": "1",
            "function": "verify_new_ex",
            "description": "verify new ex verifies if new exception is allowed by parent cgroup is permission this is used to make sure child cgroup will not have more privilege than it parent"
        },
        "xfs_ioctl_setattr_get_trans": {
            "ground_truth": "1",
            "function": "xfs_ioctl_setattr_get_trans",
            "description": "xfs ioctl setattr get trans set up the transaction structure for the setattr operation checking that we have permission to do so on success return clean transaction and the inode locked exclusively ready for further operation specific check on failure return an error without modifying or locking the inode"
        },
        "gasket_mmap_has_permissions": {
            "ground_truth": "1",
            "function": "gasket_mmap_has_permissions",
            "description": "gasket mmap ha permission verifies that the user ha permission to perform the requested mapping and that the provided descriptor range is of adequate size to hold the range to be mapped"
        },
        "nfs4_opendata_access": {
            "ground_truth": "1",
            "function": "nfs4_opendata_access",
            "description": "nfs4 opendata access additional permission check in order to distinguish between an open for read and an open for execute this work around the fact that nfsv4 open treat read and execute permission a being the same note that in the non execute case we want to turn off permission checking if we just created new file posix open semantics"
        },
        "do_inode_permission": {
            "ground_truth": "1",
            "function": "do_inode_permission",
            "description": "do inode permission we really want to just do generic permission without even looking at the inode op value so we keep cache flag in inode opflags that say this ha not special permission function use the fast case"
        },
        "wext_permission_check": {
            "ground_truth": "1",
            "function": "wext_permission_check",
            "description": "wext permission checkif command is set parameter or get the encoding parameter check if the user ha the right to do it"
        },
        "reiserfs_security_init": {
            "ground_truth": "1",
            "function": "reiserfs_security_init",
            "description": "reiserfs security initinitializes the security context for new inode and return the number of block needed for the transaction if successful reiserfs security must be released using reiserfs security free when the caller is done"
        },
        "goya_init_security": {
            "ground_truth": "1",
            "function": "goya_init_security",
            "description": "goya init security goya init security initialize security model initialize the security model of the device that includes range register and protection bit per register"
        },
        "tomoyo_check_inet_address": {
            "ground_truth": "1",
            "function": "tomoyo_check_inet_address",
            "description": "tomoyo check inet address check permission for inet domain socket is operation return on success negative value otherwise"
        },
        "kcsan_check_write": {
            "ground_truth": "1",
            "function": "kcsan_check_write",
            "description": "kcsan check write check regular write access for race"
        },
        "tomoyo_environ": {
            "ground_truth": "1",
            "function": "tomoyo_environ",
            "description": "tomoyo environ check permission for environment variable name return on success negative value otherwise"
        },
        "has_ns_capability_noaudit": {
            "ground_truth": "1",
            "function": "has_ns_capability_noaudit",
            "description": "ha n capability noaudit doe task have capability unaudited in specific user n return true if the specified task ha the given superior capability currently in effect to the specified user namespace false if not do not write an audit message for the check note that this doe not set pf superpriv on the task"
        },
        "tomoyo_inet_entry": {
            "ground_truth": "1",
            "function": "tomoyo_inet_entry",
            "description": "tomoyo inet entry check permission for inet network operation return on success negative value otherwise"
        },
        "sk_net_capable": {
            "ground_truth": "1",
            "function": "sk_net_capable",
            "description": "sk net capable network namespace socket capability test test to see if the opener of the socket had when the socket wa created and the current process ha the capability cap over the network namespace the socket is member of"
        },
        "selinux_xfrm_postroute_last": {
            "ground_truth": "1",
            "function": "selinux_xfrm_postroute_last",
            "description": "selinux xfrm postroute last postroute last hook is xfrm processing if we have no security association then we need to determine whether the socket is allowed to send to an unlabelled destination if we do have authorizable security association then it ha already been checked in the selinux xfrm state pol flow match hook above"
        },
        "afs_permission": {
            "ground_truth": "1",
            "function": "afs_permission",
            "description": "afs permission check the permission on an afs file afs acls are attached to directory only and file is controlled by it parent directory is acl"
        },
        "ext4_rename": {
            "ground_truth": "1",
            "function": "ext4_rename",
            "description": "ext4 rename anybody can rename anything with this the permission check are left to the higher level routine old dentry inode refers to the source dentry inode while new dentry inode refers to the destination dentry inode this come from rename const char oldpath const char newpath"
        },
        "security_sid_to_context_inval": {
            "ground_truth": "1",
            "function": "security_sid_to_context_inval",
            "description": "security sid to context inval obtain context for given sid if it is invalid write the string representation of the context associated with sid into dynamically allocated string of the correct size but only if the context is invalid in the current policy set scontext to point to this string or null if the context is valid and set scontext len to the length of the string or if the context is valid"
        },
        "inode_permission": {
            "ground_truth": "1",
            "function": "inode_permission",
            "description": "inode permission check for access right to given inode check for read write execute permission on an inode we use f ug id for this letting u set arbitrary permission for filesystem access without changing the normal uids which are used for other thing when checking for may append may write must also be set in mask"
        },
        "rtnl_get_net_ns_capable": {
            "ground_truth": "1",
            "function": "rtnl_get_net_ns_capable",
            "description": "rtnl get net n capable get netns if sufficiently privileged return the network namespace identified by netnsid on success or an error pointer on failure"
        },
        "get_instantiation_keyring": {
            "ground_truth": "1",
            "function": "get_instantiation_keyring",
            "description": "get instantiation keyring get the destination keyring for instantiation and check that the caller ha write permission on it"
        },
        "ipcperms": {
            "ground_truth": "1",
            "function": "ipcperms",
            "description": "ipcperms check ipc permission check user group other permission for access to ipc resource return if allowed flag will most probably be or ugo from"
        },
        "security_init": {
            "ground_truth": "1",
            "function": "security_init",
            "description": "security init initializes the security framework this should be called early in the kernel initialization sequence"
        },
        "security_netlbl_sid_to_secattr": {
            "ground_truth": "1",
            "function": "security_netlbl_sid_to_secattr",
            "description": "security netlbl sid to secattr convert selinux sid to netlabel secattr convert the given selinux sid in sid into netlabel security attribute return zero on success negative value on failure"
        },
        "security_context_to_sid": {
            "ground_truth": "1",
            "function": "security_context_to_sid",
            "description": "security context to sid obtain sid for given security context obtains sid associated with the security context that ha the string representation specified by scontext return einval if the context is invalid enomem if insufficient memory is available or on success"
        },
        "avc_has_perm_noaudit": {
            "ground_truth": "1",
            "function": "avc_has_perm_noaudit",
            "description": "avc ha perm noaudit check permission but perform no auditing check the avc to determine whether the requested permission are granted for the sid pair ssid tsid interpreting the permission based on tclass and call the security server on cache miss to obtain new decision and add it to the cache return copy of the decision in avd return if all requested permission are granted eacces if any permission are denied or another errno upon other error this function is typically called by avc ha perm but may also be called directly to separate permission checking from auditing in case where lock must be held for the check but should be released for the auditing"
        },
        "apparmor_socket_accept": {
            "ground_truth": "1",
            "function": "apparmor_socket_accept",
            "description": "apparmor socket accept check perm before accepting new connection"
        },
        "apparmor_socket_create": {
            "ground_truth": "1",
            "function": "apparmor_socket_create",
            "description": "apparmor socket create check perm before creating new socket"
        },
        "smk_access": {
            "ground_truth": "1",
            "function": "smk_access",
            "description": "smk access determine if subject ha specific access to an object this function look up the subject object pair in the access rule list and return if the access is permitted non zero otherwise smack label are shared on smack list"
        },
        "tomoyo_check_acl": {
            "ground_truth": "1",
            "function": "tomoyo_check_acl",
            "description": "tomoyo check acl do permission check return on success negative value otherwise caller hold tomoyo read lock"
        },
        "nfsd3_proc_access": {
            "ground_truth": "1",
            "function": "nfsd3_proc_access",
            "description": "nfsd3 proc access check file access"
        },
        "tomoyo_check_path_number_acl": {
            "ground_truth": "1",
            "function": "tomoyo_check_path_number_acl",
            "description": "tomoyo check path number acl check permission for path number operation return true if granted false otherwise"
        },
        "keyctl_get_keyring_ID": {
            "ground_truth": "1",
            "function": "keyctl_get_keyring_ID",
            "description": "keyctl get keyring id get the id of the specified process keyring the requested keyring must have search permission to be found if successful the id of the requested keyring will be returned"
        },
        "nf_unregister_sockopt": {
            "ground_truth": "1",
            "function": "nf_unregister_sockopt",
            "description": "nf unregister sockoptfunctions to register get setsockopt range non inclusive you need to check permission yourself"
        },
        "smack_inode_permission": {
            "ground_truth": "1",
            "function": "smack_inode_permission",
            "description": "smack inode permission smack version of permission this is the important smack hook return if access is permitted an error code otherwise"
        },
        "smack_inode_getsecid": {
            "ground_truth": "1",
            "function": "smack_inode_getsecid",
            "description": "smack inode getsecid extract inode is security id"
        },
        "has_capability": {
            "ground_truth": "1",
            "function": "has_capability",
            "description": "ha capability doe task have capability in init user n return true if the specified task ha the given superior capability currently in effect to the initial user namespace false if not note that this doe not set pf superpriv on the task"
        },
        "acl_permission_check": {
            "ground_truth": "1",
            "function": "acl_permission_check",
            "description": "acl permission check this doe the basic unix permission checking note that the posix acl check care about the may not block bit for rcu walking"
        },
        "tomoyo_socket_bind": {
            "ground_truth": "1",
            "function": "tomoyo_socket_bind",
            "description": "tomoyo socket bind check permission for bind return on success negative value otherwise"
        },
        "apparmor_socket_getsockname": {
            "ground_truth": "1",
            "function": "apparmor_socket_getsockname",
            "description": "apparmor socket getsockname check perm before getting the local address"
        },
        "check_mode": {
            "ground_truth": "1",
            "function": "check_mode",
            "description": "check mode verify if tuner support the requested mode this function check if the tuner is capable of tuning analog tv digital tv or radio depending on what the caller want if the tuner can not support that mode it return einval otherwise it return this function is needed for board that have separate tuner for radio like device with tea5767 note mt20xx us v4l2 tuner digital tv and call set tv freq to select tv frequency so mode analog tv could actually be used to represent digital tv too"
        },
        "cap_capset": {
            "ground_truth": "1",
            "function": "cap_capset",
            "description": "cap capset validate and apply proposed change to current is capability this function validates and applies proposed mass change to the current process is capability set the change are made to the proposed new credential and assuming no error will be committed by the caller of lsm"
        },
        "be_cmd_set_fn_privileges": {
            "ground_truth": "1",
            "function": "be_cmd_set_fn_privileges",
            "description": "be cmd set fn privilegesset privilege for function"
        },
        "apparmor_socket_listen": {
            "ground_truth": "1",
            "function": "apparmor_socket_listen",
            "description": "apparmor socket listen check perm before allowing listen"
        },
        "dce_v6_0_hpd_fini": {
            "ground_truth": "0",
            "function": "dce_v6_0_hpd_fini",
            "description": "dce v6 hpd fini hpd tear down callback tear down the hpd pin used by the card evergreen disable the hpd interrupt"
        },
        "COLOR_ALIGN": {
            "ground_truth": "0",
            "function": "COLOR_ALIGN",
            "description": "color alignthese function differ from the default implementation in mm mmap in two way for file backed map shared mmap is we cache color align for fixed such mapping we just validate what the user gave u for bit task we avoid mapping anything within 4gb of the spitfire niagara va hole"
        },
        "kvm_mips_count_disable": {
            "ground_truth": "0",
            "function": "kvm_mips_count_disable",
            "description": "kvm mips count disable disable count disable the cp0 count timer timer interrupt on or before the final stop time will be handled but not after assumes cp0 count wa previously enabled but now guest cp0 cause dc or count ctl dc ha been set count disabled"
        },
        "tep_print_event": {
            "ground_truth": "0",
            "function": "tep_print_event",
            "description": "tep print event write various event information"
        },
        "mei_cl_bus_rescan": {
            "ground_truth": "0",
            "function": "mei_cl_bus_rescan",
            "description": "mei cl bus rescan scan me client list and add create device for eligible client"
        },
        "nfp_net_irqs_alloc": {
            "ground_truth": "0",
            "function": "nfp_net_irqs_alloc",
            "description": "nfp net irqs alloc allocates msi irqs"
        },
        "show_docked": {
            "ground_truth": "0",
            "function": "show_docked",
            "description": "show docked show docked read method for docked file in sysfs"
        },
        "rsi_is_cipher_wep": {
            "ground_truth": "0",
            "function": "rsi_is_cipher_wep",
            "description": "rsi is cipher wep this function determines if the cipher is wep or not"
        },
        "vcs_size": {
            "ground_truth": "0",
            "function": "vcs_size",
            "description": "vcs size return size for vc in vc must be called with console lock"
        },
        "atlx_tx_timeout": {
            "ground_truth": "0",
            "function": "atlx_tx_timeout",
            "description": "atlx tx timeout respond to tx hang"
        },
        "do_unhandled": {
            "ground_truth": "0",
            "function": "do_unhandled",
            "description": "do unhandled unhandled exception kill user task or panic if in kernel space"
        },
        "snd_card_set_id": {
            "ground_truth": "0",
            "function": "snd_card_set_id",
            "description": "snd card set id set card identification name"
        },
        "vxge_hw_ring_rxd_post_post": {
            "ground_truth": "0",
            "function": "vxge_hw_ring_rxd_post_post",
            "description": "vxge hw ring rxd post post process rxd after post process rxd after post"
        },
        "copy_to_user_fromio": {
            "ground_truth": "0",
            "function": "copy_to_user_fromio",
            "description": "copy to user fromio copy data from mmio space to user space copy the data from mmio space to user space"
        },
        "arch_atomic_sub_and_test": {
            "ground_truth": "0",
            "function": "arch_atomic_sub_and_test",
            "description": "arch atomic sub and test subtract value from variable and test result atomically subtracts from and return true if the result is zero or false for all other case"
        },
        "ishtp_get_hid_descriptor": {
            "ground_truth": "0",
            "function": "ishtp_get_hid_descriptor",
            "description": "ishtp get hid descriptor get hid descriptor helper function to send request to firmware get hid descriptor of device"
        },
        "dasd_biodasdinfo": {
            "ground_truth": "0",
            "function": "dasd_biodasdinfo",
            "description": "dasd biodasdinfo fill out the dasd information structure disk in pointer to gendisk structure that reference dasd info out pointer to the dasd structure provide access to dasd specific information the gendisk structure is checked if it belongs to the dasd driver by comparing the gendisk fop pointer if it doe not belong to the dasd driver einval is returned otherwise the provided dasd structure is filled out"
        },
        "netdev_boot_setup_add": {
            "ground_truth": "0",
            "function": "netdev_boot_setup_add",
            "description": "netdev boot setup add add new setup entry"
        },
        "sun3_map_test": {
            "ground_truth": "0",
            "function": "sun3_map_test",
            "description": "sun3 map testsun3 map test addr val read byte from addr storing to val trapping the potential read fault return if the access faulted on success this function is primarily used to check address on the vme bus mucking with the page fault handler seems little hackish to me but sunos netbsd and mach all implemented this check in such manner so figure we are allowed"
        },
        "dpni_get_link_state": {
            "ground_truth": "0",
            "function": "dpni_get_link_state",
            "description": "dpni get link state return the link state either up or down"
        },
        "igc_ptp_get_ts_config": {
            "ground_truth": "0",
            "function": "igc_ptp_get_ts_config",
            "description": "igc ptp get t config get hardware time stamping config get the hwtstamp config setting to return to the user rather than attempt to deconstruct the setting from the register just return shadow copy of the last known setting"
        },
        "page_is_file_lru": {
            "ground_truth": "0",
            "function": "page_is_file_lru",
            "description": "page is file lru should the page be on file lru or anon lru return if page is regular filesystem backed page cache page or lazily freed anonymous page via madv free return if page is normal anonymous page tmpfs page or otherwise ram or swap backed page used by function that manipulate the lru list to sort page onto the right lru list we would like to get this info without page flag but the state need to survive until the page is last deleted from the lru which could be a far down a page cache release"
        },
        "sysfs_remove_file_self": {
            "ground_truth": "0",
            "function": "sysfs_remove_file_self",
            "description": "sysfs remove file self remove an object attribute from it own method see kernfs remove self for detail"
        },
        "fwcap_to_fwspeed": {
            "ground_truth": "0",
            "function": "fwcap_to_fwspeed",
            "description": "fwcap to fwspeed return highest speed in port capability get the highest speed for the port from the advertised port capability"
        },
        "megasas_complete_int_cmd": {
            "ground_truth": "0",
            "function": "megasas_complete_int_cmd",
            "description": "megasas complete int cmd completes an internal command the megasas issue blocked cmd function wait for command to complete after it issue command this function wake up that waiting routine by calling wake up on the wait queue"
        },
        "batadv_v_gw_dump": {
            "ground_truth": "0",
            "function": "batadv_v_gw_dump",
            "description": "batadv gw dump dump gateway into message"
        },
        "ib_create_wq": {
            "ground_truth": "0",
            "function": "ib_create_wq",
            "description": "ib create wq creates wq associated with the specified protection domain wq attr max wr and wq attr max sge determine the requested size of the wq and set to the actual value allocated on return if ib create wq succeeds then max wr and max sge will always be at least a large a the requested value"
        },
        "cmdq_ceq_handler": {
            "ground_truth": "0",
            "function": "cmdq_ceq_handler",
            "description": "cmdq ceq handler cmdq completion event handler"
        },
        "sysc_check_one_child": {
            "ground_truth": "0",
            "function": "sysc_check_one_child",
            "description": "sysc check one child check child configuration let is avoid messy situation where we have new interconnect target node but child have ti hwmods these belong to the interconnect target node and are managed by this driver"
        },
        "vmw_kms_stdu_init_display": {
            "ground_truth": "0",
            "function": "vmw_kms_stdu_init_display",
            "description": "vmw km stdu init display initializes screen target based display this function initialize screen target based display device it check the capability bit to make sure the underlying hardware can support screen target and then creates the maximum number of crtcs display unit a supported by the display hardware"
        },
        "alarm_cancel": {
            "ground_truth": "0",
            "function": "alarm_cancel",
            "description": "alarm cancel spin trying to cancel an alarm timer until it is done return if the timer wa canceled if it wa not active"
        },
        "xgmac_poll": {
            "ground_truth": "0",
            "function": "xgmac_poll",
            "description": "xgmac poll xgmac poll method napi this function implement the the reception process also it run the tx completion thread"
        },
        "nfs_set_verifier": {
            "ground_truth": "0",
            "function": "nfs_set_verifier",
            "description": "nfs set verifier save parent directory verifier in the dentry save the parent directory verifier in dentry if the inode ha delegation we also tag the dentry a having been revalidated while holding delegation so that we know we do not have to look it up again after directory change"
        },
        "fscrypt_set_context": {
            "ground_truth": "0",
            "function": "fscrypt_set_context",
            "description": "fscrypt set context set the fscrypt context of new inode this should be called after fscrypt prepare new inode generally during filesystem transaction everything here must be gfp nofs safe"
        },
        "cec_msg_init": {
            "ground_truth": "0",
            "function": "cec_msg_init",
            "description": "cec msg init initialize the message structure the whole structure is zeroed the len field is set to poll message and the initiator and destination are filled in"
        },
        "hibernate_quiet_exec": {
            "ground_truth": "0",
            "function": "hibernate_quiet_exec",
            "description": "hibernate quiet exec execute function with all device frozen return the func return value or an error code if it cannot be executed"
        },
        "device_complete": {
            "ground_truth": "0",
            "function": "device_complete",
            "description": "device complete complete pm transition for given device"
        },
        "smk_set_cipso": {
            "ground_truth": "0",
            "function": "smk_set_cipso",
            "description": "smk set cipso do the work for write for cipso and cipso2 accepts only one cipso rule per write call return number of byte written or error code a appropriate"
        },
        "generic_file_buffered_read": {
            "ground_truth": "0",
            "function": "generic_file_buffered_read",
            "description": "generic file buffered read generic file read routine this is generic file read routine and us the mapping ops readpage function for the actual low level stuff this is really ugly but the goto is actually try to clarify some of the logic when it come to error handling etc"
        },
        "drm_atomic_helper_connector_destroy_state": {
            "ground_truth": "0",
            "function": "drm_atomic_helper_connector_destroy_state",
            "description": "drm atomic helper connector destroy state default state destroy hook default connector state destroy hook for driver which do not have their own subclassed connector state structure"
        },
        "nfs_fattr_init_names": {
            "ground_truth": "0",
            "function": "nfs_fattr_init_names",
            "description": "nfs fattr init name initialise the nfs fattr owner name group name field"
        },
        "badblocks_store": {
            "ground_truth": "0",
            "function": "badblocks_store",
            "description": "badblocks store sysfs access to bad block list"
        },
        "mac_wol_reset": {
            "ground_truth": "0",
            "function": "mac_wol_reset",
            "description": "mac wol reset reset wol after exiting low power"
        },
        "atl1_check_options": {
            "ground_truth": "0",
            "function": "atl1_check_options",
            "description": "atl1 check option range checking for command line parameter this routine check all command line parameter for valid user input if an invalid value is given or if no user specified value exists default value is used the final value is stored in variable in the adapter structure"
        },
        "blk_mq_tagset_wait_completed_request": {
            "ground_truth": "0",
            "function": "blk_mq_tagset_wait_completed_request",
            "description": "blk mq tagset wait completed request wait until all completed req is complete funtion is run"
        },
        "tracing_cond_snapshot_data": {
            "ground_truth": "0",
            "function": "tracing_cond_snapshot_data",
            "description": "tracing cond snapshot data get the user data associated with snapshot when the user enables conditional snapshot using tracing snapshot cond enable the user defined cond data is saved with the snapshot this accessor is used to retrieve it should not be called from cond snapshot update since it take the tr max lock lock which the code calling cond snapshot update ha already done return the cond data associated with the trace array is snapshot"
        },
        "mtk_thermal_put_bank": {
            "ground_truth": "0",
            "function": "mtk_thermal_put_bank",
            "description": "mtk thermal put bank release bank release bank previously taken with mtk thermal get bank"
        },
        "set_pte": {
            "ground_truth": "0",
            "function": "set_pte",
            "description": "set pte certain architecture need to do special thing when pte is within page table are directly modified thus the following hook is made available"
        },
        "__igb_open": {
            "ground_truth": "0",
            "function": "__igb_open",
            "description": "igb open called when network interface is made active"
        },
        "typec_altmode_get_plug": {
            "ground_truth": "0",
            "function": "typec_altmode_get_plug",
            "description": "typec altmode get plug find cable plug alternate mode increment reference count for cable plug alternate mode device return handle to the cable plug alternate mode or null if none is found"
        },
        "sk_stream_closing": {
            "ground_truth": "0",
            "function": "sk_stream_closing",
            "description": "sk stream closing return if we still have thing to send in our buffer"
        },
        "sw_setup": {
            "ground_truth": "0",
            "function": "sw_setup",
            "description": "sw setup setup the switch this routine setup the hardware switch engine for default operation"
        },
        "regmap_irq_chip_get_base": {
            "ground_truth": "0",
            "function": "regmap_irq_chip_get_base",
            "description": "regmap irq chip get base retrieve interrupt base for regmap irq chip useful for driver to request their own irqs"
        },
        "__hwspin_lock_timeout": {
            "ground_truth": "0",
            "function": "__hwspin_lock_timeout",
            "description": "hwspin lock timeout lock an hwspinlock with timeout limit this function lock the given hwlock if the hwlock is already taken the function will busy loop waiting for it to be released but give up after timeout msec have elapsed caution if the mode is hwlock raw that mean user must protect the routine of getting hardware lock with mutex or spinlock since in some scenario user need some time consuming or sleepable operation under the hardware lock they need one sleepable lock like mutex to protect the operation if the mode is hwlock in atomic called from an atomic context the timeout is handled with busy waiting delay hence shall not exceed few msec if the mode is neither hwlock in atomic nor hwlock raw upon successful return from this function preemption and possibly interrupt is disabled so the caller must not sleep and is advised to release the hwspinlock a soon a possible this is required in order to minimize remote core polling on the hardware interconnect the user decides whether local interrupt are disabled or not and if yes whether he want their previous state to be saved it is up to the user to choose the appropriate mode of operation exactly the same way user should decide between spin lock spin lock irq and spin lock irqsave return when the hwlock wa successfully taken and an appropriate error code otherwise most notably etimedout if the hwlock is still busy after timeout msec the function will never sleep"
        },
        "cpuset_task_status_allowed": {
            "ground_truth": "0",
            "function": "cpuset_task_status_allowed",
            "description": "cpuset task status alloweddisplay task mem allowed in proc status file"
        },
        "pte_exec": {
            "ground_truth": "0",
            "function": "pte_exec",
            "description": "pte execpte exec is pte marked a executable"
        },
        "snd_hda_ctls_clear": {
            "ground_truth": "0",
            "function": "snd_hda_ctls_clear",
            "description": "snd hda ctls clear clear all control assigned to the given codec"
        },
        "ftrace_graph_get_ret_stack": {
            "ground_truth": "0",
            "function": "ftrace_graph_get_ret_stack",
            "description": "ftrace graph get ret stack return the entry of the shadow stack return the ret struct on the shadow stack of the task at the call graph at idx starting with zero if idx is zero it will return the last saved ret stack entry if it is greater than zero it will return the corresponding ret stack for the depth of saved return address"
        },
        "spider_net_free_rx_chain_contents": {
            "ground_truth": "0",
            "function": "spider_net_free_rx_chain_contents",
            "description": "spider net free rx chain content free descr content in rx chain return on success on failure"
        },
        "ocrdma_build_ud_hdr": {
            "ground_truth": "0",
            "function": "ocrdma_build_ud_hdr",
            "description": "ocrdma build ud hdrunprivileged verb and their support function"
        },
        "tipc_sk_set_orig_addr": {
            "ground_truth": "0",
            "function": "tipc_sk_set_orig_addr",
            "description": "tipc sk set orig addr capture sender is address for received message"
        },
        "ipr_init_res_table": {
            "ground_truth": "0",
            "function": "ipr_init_res_table",
            "description": "ipr init re table initialize the resource table this function look through the existing resource table comparing it with the config table this function will take care of old new device and schedule adding removing them from the mid layer a appropriate return value ipr rc job continue"
        },
        "batadv_algo_seq_print_text": {
            "ground_truth": "0",
            "function": "batadv_algo_seq_print_text",
            "description": "batadv algo seq print text print the supported algorithm in seq file"
        },
        "rsi_mac80211_conf_filter": {
            "ground_truth": "0",
            "function": "rsi_mac80211_conf_filter",
            "description": "rsi mac80211 conf filter this function configure the device is rx filter"
        },
        "i40iw_build_mpa_v2": {
            "ground_truth": "0",
            "function": "i40iw_build_mpa_v2",
            "description": "i40iw build mpa v2 build mpa v2 frame"
        },
        "tomoyo_put_name": {
            "ground_truth": "0",
            "function": "tomoyo_put_name",
            "description": "tomoyo put name drop reference on struct tomoyo name return nothing"
        },
        "skb_orphan_frags": {
            "ground_truth": "0",
            "function": "skb_orphan_frags",
            "description": "skb orphan frags orphan the frags contained in buffer"
        },
        "nilfs_palloc_count_desc_blocks": {
            "ground_truth": "0",
            "function": "nilfs_palloc_count_desc_blocks",
            "description": "nilfs palloc count desc block count descriptor block number"
        },
        "rvt_update_mmap_info": {
            "ground_truth": "0",
            "function": "rvt_update_mmap_info",
            "description": "rvt update mmap info update mem map"
        },
        "cbus_send_data": {
            "ground_truth": "0",
            "function": "cbus_send_data",
            "description": "cbus send data sends len amount of data over the bus"
        },
        "cik_sdma_ring_test": {
            "ground_truth": "0",
            "function": "cik_sdma_ring_test",
            "description": "cik sdma ring test simple async dma engine test test the dma engine by writing using it to write an value to memory cik return for success error for failure"
        },
        "pcie_get_width_cap": {
            "ground_truth": "0",
            "function": "pcie_get_width_cap",
            "description": "pcie get width cap query for the pci device is link width capability query the pci device width capability return the maximum link width supported by the device"
        },
        "drm_core_check_all_features": {
            "ground_truth": "0",
            "function": "drm_core_check_all_features",
            "description": "drm core check all feature check driver feature flag mask this check dev for driver feature see type drm driver driver feature type drm device driver feature and the various type enum drm driver feature flag return true if all feature in the feature mask are supported false otherwise"
        },
        "CRC32_POLYNOMIAL": {
            "ground_truth": "0",
            "function": "CRC32_POLYNOMIAL",
            "description": "crc32 polynomial prepare lookup table for fast crc32 calculation existing kernel function seem to use different polynom therefore we could not use them here genwqe is polynomial"
        },
        "genpd_complete": {
            "ground_truth": "0",
            "function": "genpd_complete",
            "description": "genpd complete complete power transition of device in power domain complete power transition of device during system wide power transition under the assumption that it pm domain field point to the domain member of an object of type struct generic pm domain representing power domain consisting of device"
        },
        "nilfs_sufile_set_error": {
            "ground_truth": "0",
            "function": "nilfs_sufile_set_error",
            "description": "nilfs sufile set error mark segment a erroneous nilfs sufile set error mark the segment specified by segnum a erroneous the error segment will never be used again return value on success is returned on error one of the following negative error code is returned eio error enomem insufficient amount of memory available einval invalid segment usage number"
        },
        "gobj_to_pad": {
            "ground_truth": "0",
            "function": "gobj_to_pad",
            "description": "gobj to pad return the struct type medium pad pointer from the gobj contained on it"
        },
        "vmw_resource_mob_detach": {
            "ground_truth": "0",
            "function": "vmw_resource_mob_detach",
            "description": "vmw resource mob detach mark resource a detached from it backing mob"
        },
        "unlazy_child": {
            "ground_truth": "0",
            "function": "unlazy_child",
            "description": "unlazy child try to switch to ref walk mode unlazy child attempt to legitimize the current nd path nd root and dentry for ref walk mode dentry must be path found by do lookup call on nd must be called from rcu walk context nothing should touch nameidata between unlazy child failure and terminate walk"
        },
        "ubifs_wbuf_init": {
            "ground_truth": "0",
            "function": "ubifs_wbuf_init",
            "description": "ubifs wbuf init initialize write buffer this function initializes write buffer return zero in case of success enomem in case of failure"
        },
        "oslec_free": {
            "ground_truth": "0",
            "function": "oslec_free",
            "description": "oslec free free voice echo canceller context"
        },
        "ice_rem_prof_from_list": {
            "ground_truth": "0",
            "function": "ice_rem_prof_from_list",
            "description": "ice rem prof from list remove profile from list"
        },
        "ecryptfs_miscdev_write": {
            "ground_truth": "0",
            "function": "ecryptfs_miscdev_write",
            "description": "ecryptfs miscdev write handle write to daemon miscdev handle return the number of byte read from buf"
        },
        "nfs4_proc_get_locations": {
            "ground_truth": "0",
            "function": "nfs4_proc_get_locations",
            "description": "nfs4 proc get location discover location for migrated fsid return nfs4 ok on success negative nfs4err status code if the operation failed or negative errno if local error occurred on success location is filled in but if the server ha no location information nfs attr fattr v4 location is not asserted nfs4err lease moved is returned if the server still ha lease from this client that require migration recovery"
        },
        "ice_deinit_hw": {
            "ground_truth": "0",
            "function": "ice_deinit_hw",
            "description": "ice deinit hw unroll initialization operation done by ice init hw this should be called only during nominal operation not a result of ice init hw failing since ice init hw will take care of unrolling applicable initialization if it fails for any reason"
        },
        "xudc_write32_be": {
            "ground_truth": "0",
            "function": "xudc_write32_be",
            "description": "xudc write32 be big endian write to device register"
        },
        "is_ep_periodic": {
            "ground_truth": "0",
            "function": "is_ep_periodic",
            "description": "is ep periodic return true if the endpoint is in periodic mode return true if the endpoint is in periodic mode meaning it is being used for an interrupt or iso transfer"
        },
        "_drm_lease_held_master": {
            "ground_truth": "0",
            "function": "_drm_lease_held_master",
            "description": "drm lease held master check to see if an object is leased or owned by master idr mutex held check if the specified master hold lease on the object return value true amaster hold lease on or owns the object false amaster doe not hold lease"
        },
        "v4l2_g_ctrl": {
            "ground_truth": "0",
            "function": "v4l2_g_ctrl",
            "description": "v4l2 ctrl helper function to implement ref vidioc ctrl ioctl if hdl null then they will all return einval"
        },
        "of_changeset_destroy": {
            "ground_truth": "0",
            "function": "of_changeset_destroy",
            "description": "of changeset destroy destroy changeset destroys changeset note that if changeset is applied it change to the tree cannot be reverted"
        },
        "ata_pci_sff_activate_host": {
            "ground_truth": "0",
            "function": "ata_pci_sff_activate_host",
            "description": "ata pci sff activate host start sff host request irq and register it"
        },
        "ice_vf_post_vsi_rebuild": {
            "ground_truth": "0",
            "function": "ice_vf_post_vsi_rebuild",
            "description": "ice vf post vsi rebuild task to do after the vf is vsi have been rebuilt"
        },
        "host1x_register": {
            "ground_truth": "0",
            "function": "host1x_register",
            "description": "host1x register register host1x controller the host1x controller driver us this to register host1x controller with the infrastructure note that all tegra soc generation have only ever come with single host1x instance so this function is somewhat academic"
        },
        "initiate_cifs_search": {
            "ground_truth": "0",
            "function": "initiate_cifs_search",
            "description": "initiate cifs search int get symlink reparse path char full path struct cifs sb info cifs sb unsigned int xid u16 fid int len int oplock int rc struct cifs tcon ptcon cifs sb tcon cifs sb char tmpbuffer rc cifssmbopen xid ptcon full path file open generic read open reparse point fid oplock null cifs sb local nls cifs remap cifs sb if rc tmpbuffer kmalloc maxpath rc xid ptcon full path tmpbuffer maxpath fid cifs sb local nls if cifssmbclose xid ptcon fid cifs dbg fyi error closing temporary reparsepoint open"
        },
        "__clk_core_init": {
            "ground_truth": "0",
            "function": "__clk_core_init",
            "description": "clk core init initialize the data structure in struct clk core initializes the list in struct clk core query the hardware for the parent and rate and set them both"
        },
        "vema_get_port": {
            "ground_truth": "0",
            "function": "vema_get_port",
            "description": "vema get port get the opa vnic vema port this function loop through the port and return the opa vnic vema port structure that is associated with the opa port number"
        },
        "r600_dma_fini": {
            "ground_truth": "0",
            "function": "r600_dma_fini",
            "description": "r600 dma fini tear down the async dma engine stop the async dma engine and free the ring r6xx evergreen"
        },
        "genwqe_pci_setup": {
            "ground_truth": "0",
            "function": "genwqe_pci_setup",
            "description": "genwqe pci setup allocate pcie related resource for our card"
        },
        "ip_route_input_slow": {
            "ground_truth": "0",
            "function": "ip_route_input_slow",
            "description": "ip route input slow note we drop all the packet that ha local source address because every properly looped back packet must have correct destination already attached by output routine change in the enforced policy must be applied also to ip route use hint such approach solves two big problem not simplex device are handled properly ip spoofing attempt are filtered with of guarantee called with rcu read lock"
        },
        "skl_dum_set": {
            "ground_truth": "0",
            "function": "skl_dum_set",
            "description": "skl dum set set dum bit in em2 register address incorrect position reporting for capture stream used on device power up"
        },
        "gfs2_llseek": {
            "ground_truth": "0",
            "function": "gfs2_llseek",
            "description": "gfs2 llseek seek to location in file seek end requires the glock for the file because it reference the file is size"
        },
        "lpfc_bsg_send_mgmt_rsp": {
            "ground_truth": "0",
            "function": "lpfc_bsg_send_mgmt_rsp",
            "description": "lpfc bsg send mgmt rsp process send mgmt resp bsg vendor command"
        },
        "atl1c_close": {
            "ground_truth": "0",
            "function": "atl1c_close",
            "description": "atl1c close disables network interface return this is not allowed to fail the close entry point is called when an interface is de activated by the o the hardware is still under the driver control but need to be disabled global mac reset is issued to stop the hardware and all transmit and receive resource are freed"
        },
        "check_memory_region": {
            "ground_truth": "0",
            "function": "check_memory_region",
            "description": "check memory region check memory region and report if invalid access"
        },
        "e1000_io_error_detected": {
            "ground_truth": "0",
            "function": "e1000_io_error_detected",
            "description": "e1000 io error detected called when pci error is detected this function is called after pci bus error affecting this device ha been detected"
        },
        "wait_for_dest_dir_move": {
            "ground_truth": "0",
            "function": "wait_for_dest_dir_move",
            "description": "wait for dest dir move we might need to delay directory rename even when no ancestor directory in the send root with higher inode number than ours sctx cur ino wa renamed this happens when we rename directory to the old name the name in the parent root of some other unrelated directory that got it rename delayed due to some ancestor with higher number that got renamed example parent snapshot ino ino file ino ino ino send snapshot ino ino ino ino file ino here we can not rename from to without the rename of inode from to happening first which in turn depends on the rename of inode from to so the order of rename command the send stream must issue is rename from to rename from to rename from to"
        },
        "xchk_agi_xref_fiblocks": {
            "ground_truth": "0",
            "function": "xchk_agi_xref_fiblocks",
            "description": "xchk agi xref fiblockscheck agi fi block against tree size"
        },
        "__prci_wrpll_unpack": {
            "ground_truth": "0",
            "function": "__prci_wrpll_unpack",
            "description": "prci wrpll unpack unpack wrpll configuration register into parameter given value read from an fu540 prci pll configuration register split it into field and populate it into the wrpll configuration record pointed to by the corepllcfg0 macro are used below but the other pllcfg0 macro have the same register layout"
        },
        "mwifiex_fill_cap_info": {
            "ground_truth": "0",
            "function": "mwifiex_fill_cap_info",
            "description": "mwifiex fill cap info fill ht capability information field ampdu parameter field ht extended capability field and supported mc set field ht capability information field ampdu parameter field supported mc set field are retrieved from cfg80211 stack rd responder bit to set to clear in the extended capability header"
        },
        "batadv_tt_orig_list_entry_put": {
            "ground_truth": "0",
            "function": "batadv_tt_orig_list_entry_put",
            "description": "batadv tt orig list entry put decrement the tt orig entry refcounter and possibly release it"
        },
        "fm10k_mbx_read_copy": {
            "ground_truth": "0",
            "function": "fm10k_mbx_read_copy",
            "description": "fm10k mbx read copy pull data off of mbmem and place it in rx fifo"
        },
        "debug_object_free": {
            "ground_truth": "0",
            "function": "debug_object_free",
            "description": "debug object free debug check when an object is freed"
        },
        "v4l2_spi_new_subdev": {
            "ground_truth": "0",
            "function": "v4l2_spi_new_subdev",
            "description": "v4l2 spi new subdev load an spi module and return an initialized type struct v4l2 subdev return type struct v4l2 subdev pointer"
        },
        "hdlcdev_ioctl": {
            "ground_truth": "0",
            "function": "hdlcdev_ioctl",
            "description": "hdlcdev ioctl called by network layer to process ioctl call to network device"
        },
        "alua_check_tpgs": {
            "ground_truth": "0",
            "function": "alua_check_tpgs",
            "description": "alua check tpgs alua check tpgs evaluate tpgs setting examine the tpgs setting of the sdev to find out if alua is supported"
        },
        "set_controller_speed": {
            "ground_truth": "0",
            "function": "set_controller_speed",
            "description": "set controller speed set the frequency and or mode of specific controller segment return if we successfully change frequency and or mode to match the adapter speed"
        },
        "ath5k_ani_phy_error_report": {
            "ground_truth": "0",
            "function": "ath5k_ani_phy_error_report",
            "description": "ath5k ani phy error report used by older hw to report phy error this is used by hardware without phy error counter to report phy error on frame by frame basis instead of the interrupt"
        },
        "nilfs_read_summary_info": {
            "ground_truth": "0",
            "function": "nilfs_read_summary_info",
            "description": "nilfs read summary info read an item on summary block of log"
        },
        "snd_dma_alloc_pages_fallback": {
            "ground_truth": "0",
            "function": "snd_dma_alloc_pages_fallback",
            "description": "snd dma alloc page fallback allocate the buffer area according to the given type with fallback call the memory allocator function for the corresponding buffer type when no space is left this function reduces the size and try to allocate again the size actually allocated is stored in re size argument"
        },
        "e1000_poll_for_ack": {
            "ground_truth": "0",
            "function": "e1000_poll_for_ack",
            "description": "e1000 poll for ack wait for message acknowledgment"
        },
        "hinic_read_wqe_direct": {
            "ground_truth": "0",
            "function": "hinic_read_wqe_direct",
            "description": "hinic read wqe direct read wqe directly from ci position return wqe"
        },
        "qeth_count_elements": {
            "ground_truth": "0",
            "function": "qeth_count_elements",
            "description": "qeth count element count the number of qdio buffer element needed to transmit an skb return the number of page and thus qdio buffer element needed to map the skb is data both it linear part and paged fragment"
        },
        "nfs_block_size": {
            "ground_truth": "0",
            "function": "nfs_block_size",
            "description": "nfs block size compute and set nfs server blocksize"
        },
        "d_find_any_alias": {
            "ground_truth": "0",
            "function": "d_find_any_alias",
            "description": "find any alias find any alias for given inode if any alias exist for the given inode take and return reference for one of them if no alias exist return null"
        },
        "scsih_scan_start": {
            "ground_truth": "0",
            "function": "scsih_scan_start",
            "description": "scsih scan start scsi lld callback for scan start the shost ha the ability to discover target on it own instead of scanning the entire bus in our implemention we will kick off firmware discovery"
        },
        "clear_one_vid": {
            "ground_truth": "0",
            "function": "clear_one_vid",
            "description": "clear one vidcheck the vlan filter bitmap for set filter and construct set vlan filter disable packet if found"
        },
        "cfg80211_get_chandef_type": {
            "ground_truth": "0",
            "function": "cfg80211_get_chandef_type",
            "description": "cfg80211 get chandef type return old channel type from chandef"
        },
        "lpfc_mbuf_alloc": {
            "ground_truth": "0",
            "function": "lpfc_mbuf_alloc",
            "description": "lpfc mbuf alloc allocate an mbuf from the lpfc mbuf pool pci pool allocates dma mapped buffer from the lpfc mbuf pool pci pool allocates from generic dma pool alloc function first and if that fails and mem flag ha mem pri set the only defined flag return an mbuf from the hba is pool note not interrupt safe must be called with no lock held take phba hbalock"
        },
        "i40iw_handle_syn_pkt": {
            "ground_truth": "0",
            "function": "i40iw_handle_syn_pkt",
            "description": "i40iw handle syn pkt is for passive node"
        },
        "hdspm_write": {
            "ground_truth": "0",
            "function": "hdspm_write",
            "description": "hdspm writewrite read to from hdspm with adresses in byte not word but only 32bit writes are allowed"
        },
        "mext_check_coverage": {
            "ground_truth": "0",
            "function": "mext_check_coverage",
            "description": "mext check coverage check that all extent in range ha the same type return if all extent in range ha expected type and zero otherwise"
        },
        "zynq_slcr_cpu_stop": {
            "ground_truth": "0",
            "function": "zynq_slcr_cpu_stop",
            "description": "zynq slcr cpu stop stop cpu"
        },
        "qbman_swp_interrupt_set_inhibit": {
            "ground_truth": "0",
            "function": "qbman_swp_interrupt_set_inhibit",
            "description": "qbman swp interrupt set inhibit write interrupt mask register"
        },
        "stmmac_get_tx_hwtstamp": {
            "ground_truth": "0",
            "function": "stmmac_get_tx_hwtstamp",
            "description": "stmmac get tx hwtstampstmmac get tx hwtstamp get hw tx timestamps description this function will read timestamp from the descriptor pas it to stack and also perform some sanity check"
        },
        "nanddev_cleanup": {
            "ground_truth": "0",
            "function": "nanddev_cleanup",
            "description": "nanddev cleanup release resource allocated in nanddev init basically undoes what ha been done in nanddev init"
        },
        "fsl_rio_tx_handler": {
            "ground_truth": "0",
            "function": "fsl_rio_tx_handler",
            "description": "fsl rio tx handler mpc85xx outbound message interrupt handler handle outbound message interrupt executes register outbound mailbox event handler and acks the interrupt occurrence"
        },
        "audit_ctl_owner_current": {
            "ground_truth": "0",
            "function": "audit_ctl_owner_current",
            "description": "audit ctl owner current test to see if the current task owns the lock return true if the current task owns the audit control lock false if it doe not own the lock"
        },
        "gfs2_get_tree": {
            "ground_truth": "0",
            "function": "gfs2_get_tree",
            "description": "gfs2 get tree get the gfs2 superblock and root directory"
        },
        "ps3_lpm_copy_tb": {
            "ground_truth": "0",
            "function": "ps3_lpm_copy_tb",
            "description": "ps3 lpm copy tb copy data from the trace buffer to kernel buffer on error buf will contain any successfully copied trace buffer data and byte copied will be set to the number of byte successfully copied"
        },
        "numa_enforce_memory_limit": {
            "ground_truth": "0",
            "function": "numa_enforce_memory_limit",
            "description": "numa enforce memory limit check and possibly modify memory region to enforce the memory limit"
        },
        "lookup_mnt": {
            "ground_truth": "0",
            "function": "lookup_mnt",
            "description": "lookup mnt lookup mnt return the first child mount mounted at path first mean first mounted chronologically if you create the following mount mount dev sda1 mnt mount dev sda2 mnt mount dev sda3 mnt then lookup mnt on the base mnt dentry in the root mount will"
        },
        "llc_pdu_init_as_rej_rsp": {
            "ground_truth": "0",
            "function": "llc_pdu_init_as_rej_rsp",
            "description": "llc pdu init a rej rsp build rej response pdu"
        },
        "riva_get_cmap_len": {
            "ground_truth": "0",
            "function": "riva_get_cmap_len",
            "description": "riva get cmap len query current color map length get current color map length called from rivafb setcolreg"
        },
        "radeon_doorbell_init": {
            "ground_truth": "0",
            "function": "radeon_doorbell_init",
            "description": "radeon doorbell init init doorbell driver information init doorbell driver information cik return on success error on failure"
        },
        "mei_cl_notify_get": {
            "ground_truth": "0",
            "function": "mei_cl_notify_get",
            "description": "mei cl notify get get or wait for notification event locking called under dev device lock lock"
        },
        "lowpan_nhc_do_uncompression": {
            "ground_truth": "0",
            "function": "lowpan_nhc_do_uncompression",
            "description": "lowpan nhc do uncompression calling uncompress callback for nhc"
        },
        "drm_mode_getfb2_ioctl": {
            "ground_truth": "0",
            "function": "drm_mode_getfb2_ioctl",
            "description": "drm mode getfb2 ioctl get extended fb info lookup the fb given it id and return info about it called by the user via ioctl"
        },
        "e1000_shift_out_ee_bits": {
            "ground_truth": "0",
            "function": "e1000_shift_out_ee_bits",
            "description": "e1000 shift out ee bit shift data bit out to the eeprom"
        },
        "ppc440spe_test_callback": {
            "ground_truth": "0",
            "function": "ppc440spe_test_callback",
            "description": "ppc440spe test callback called when test operation ha been done"
        },
        "sys_rt_sigtimedwait": {
            "ground_truth": "0",
            "function": "sys_rt_sigtimedwait",
            "description": "sys rt sigtimedwait synchronously wait for queued signal specified in uthese"
        },
        "file_lookup": {
            "ground_truth": "0",
            "function": "file_lookup",
            "description": "file lookupfile already present in list if not add it"
        },
        "disable_irq_nosync": {
            "ground_truth": "0",
            "function": "disable_irq_nosync",
            "description": "disable irq nosync disable an irq without waiting"
        },
        "omap2_wd_timer_reset": {
            "ground_truth": "0",
            "function": "omap2_wd_timer_reset",
            "description": "omap2 wd timer reset reset and disable the wdtimer ip block after the wdtimer ip block are reset on omap2 we must also take care to execute the special watchdog disable sequence this is because the watchdog is re armed upon ocp softreset on omap4 this behavior wa apparently changed and the watchdog is no longer re armed after an ocp soft reset return etimedout if the reset did not complete or upon success xxx most of this code should be moved to the omap hwmod layer during normal merge window omap hwmod softreset should be renamed to omap hwmod set ocp softreset and omap hwmod softreset should call the hwmod ocp softreset code"
        },
        "mite_request_channel": {
            "ground_truth": "0",
            "function": "mite_request_channel",
            "description": "mite request channel request mite dma channel"
        },
        "i915_gem_mmap_gtt_version": {
            "ground_truth": "0",
            "function": "i915_gem_mmap_gtt_version",
            "description": "i915 gem mmap gtt version report the current feature set for gtt mmaps history of the gtt mmap interface everything had to fit into the gtt both party of memcpy had to aligned and suitable for fencing and still fit into the available mappable space left by the pinned display object classic problem we called the page fault of doom where we would ping pong between two object that could not fit inside the gtt and so the memcpy would page one object in at the expense of the other between every single byte object can be any size and have any compatible fencing or none a set via i915 gem set tiling drm i915 gem set tiling if the object is too large for the available space or simply too large for the mappable aperture view is created instead and faulted into userspace this view is aligned and sized appropriately for fenced access recognise wc a separate cache domain so that we can flush the delayed writes via gtt before performing direct access via wc remove implicit set domain gtt and synchronisation on initial pagefault swapin remains transparent support multiple fault handler per object depending on object is backing storage mmap offset restriction snoopable object cannot be accessed via the gtt it can cause machine hang on some architecture corruption on others an attempt to service gtt page fault from snoopable object will generate sigbus the object must be able to fit into ram physical memory though no limited to the mappable aperture caveat new gtt page fault will synchronize rendering from the gpu and flush all data to system memory subsequent access will not be synchronized all mapping are revoked on runtime device suspend there are only or fence register to share between all user older machine require fence register for display and blitter access a well contention of the fence register will cause the previous user to be unmapped and any new access will generate new page fault running out of memory while servicing fault may generate sigbus rather than the expected sigsegv"
        },
        "ixgbevf_ipsec_set_pf_sa": {
            "ground_truth": "0",
            "function": "ixgbevf_ipsec_set_pf_sa",
            "description": "ixgbevf ipsec set pf sa ask the pf to set up an sa"
        },
        "cti_init": {
            "ground_truth": "0",
            "function": "cti_init",
            "description": "cti init initialize the cti instance called by machine code to pas the board dependent base irq and trig out to cti"
        },
        "iwl_mvm_update_smps": {
            "ground_truth": "0",
            "function": "iwl_mvm_update_smps",
            "description": "iwl mvm update smps get request to change the smps mode get requst to change the smps mode and change it according to all other request in the driver"
        },
        "dma_resv_get_list": {
            "ground_truth": "0",
            "function": "dma_resv_get_list",
            "description": "dma resv get list get the reservation object is shared fence list with update side lock held return the shared fence list doe not take reference to the fence the obj lock must be held"
        },
        "usb_get_dr_mode": {
            "ground_truth": "0",
            "function": "usb_get_dr_mode",
            "description": "usb get dr mode get dual role mode for given device the function get phy interface string from property wouldr mode and return the correspondig enum usb dr mode"
        },
        "ipa_cmd_tag_process": {
            "ground_truth": "0",
            "function": "ipa_cmd_tag_process",
            "description": "ipa cmd tag process perform tag process"
        },
        "fcoe_fip_vlan_recv": {
            "ground_truth": "0",
            "function": "fcoe_fip_vlan_recv",
            "description": "fcoe fip vlan recv handler for received fip vlan discovery frame"
        },
        "bcm63xx_fifo_setup": {
            "ground_truth": "0",
            "function": "bcm63xx_fifo_setup",
            "description": "bcm63xx fifo setup re initialize fifo boundary and setting these parameter depend on the usb link speed setting are per iudma channel pair"
        },
        "v4l2_async_notifier_add_devname_subdev": {
            "ground_truth": "0",
            "function": "v4l2_async_notifier_add_devname_subdev",
            "description": "v4l2 async notifier add devname subdev allocate and add device name async subdev to the notifier is master asd list same a above but for device name matched sub device"
        },
        "i40iw_finish_del_sd_reg": {
            "ground_truth": "0",
            "function": "i40iw_finish_del_sd_reg",
            "description": "i40iw finish del sd reg delete sd entry for object"
        },
        "fwserial_create": {
            "ground_truth": "0",
            "function": "fwserial_create",
            "description": "fwserial create init everything to create ttys for specific fw card this function inits the aggregate structure an fw serial instance used to manage the tty port registered by specific fw card also the unit device is added a the first peer this unit device may represent local unit device a specified by the config rom unit directory or it may represent remote unit device a specified by the reading of the remote node is config rom return to indicate ownership of the unit device or negative errno value to indicate which error"
        },
        "e1000_check_copper_options": {
            "ground_truth": "0",
            "function": "e1000_check_copper_options",
            "description": "e1000 check copper option range checking for link option copper version handle speed and duplex option on copper adapter"
        },
        "tty_schedule_flip": {
            "ground_truth": "0",
            "function": "tty_schedule_flip",
            "description": "tty schedule flip push character to ldisc"
        },
        "pcie_bandwidth_capable": {
            "ground_truth": "0",
            "function": "pcie_bandwidth_capable",
            "description": "pcie bandwidth capable calculate pci device is link bandwidth capability calculate pci device is link bandwidth by querying for it link speed and width multiplying them and applying encoding overhead the result is in mb megabit second of raw bandwidth"
        },
        "inqstrcpy": {
            "ground_truth": "0",
            "function": "inqstrcpy",
            "description": "inqstrcpy string merge"
        },
        "tipc_crypto_rcv": {
            "ground_truth": "0",
            "function": "tipc_crypto_rcv",
            "description": "tipc crypto rcv decrypt an encrypted tipc message from peer if the decryption is successful the decrypted skb is returned directly or a the callback the encryption header and auth tag will be trimed out before forwarding to tipc rcv via the tipc crypto rcv complete otherwise the skb will be freed note rx key can be re aligned or in case of no key suitable tx cluster key can be taken for decryption recursive"
        },
        "read3X4": {
            "ground_truth": "0",
            "function": "read3X4",
            "description": "read3x4 hardware access function"
        },
        "tuner_probe": {
            "ground_truth": "0",
            "function": "tuner_probe",
            "description": "tuner probe probe the existing tuner on an i2c bus this routine probe for tuner at the expected i2c address on most case if device answer to given i2c address it assumes that the device is tuner on few case however an additional logic is needed to double check if the device is really tuner or to identify the tuner type like on tea5767 device during client attach set type is called by adapter is attach inform callback set type must then be completed by tuner probe"
        },
        "igc_configure_rx_ring": {
            "ground_truth": "0",
            "function": "igc_configure_rx_ring",
            "description": "igc configure rx ring configure receive ring after reset configure the rx unit of the mac after reset"
        },
        "of_dev_hwmod_lookup": {
            "ground_truth": "0",
            "function": "of_dev_hwmod_lookup",
            "description": "of dev hwmod lookup look up needed hwmod from dt blob parse the dt blob and find out needed hwmod recursive function is implemented to take care hierarchical dt blob parsing"
        },
        "mei_txe_sec_reg_read_silent": {
            "ground_truth": "0",
            "function": "mei_txe_sec_reg_read_silent",
            "description": "mei txe sec reg read silent read 32bit data from the sec bar doe not check for aliveness while read 32bit data from the sec bar"
        },
        "synchronize_net": {
            "ground_truth": "0",
            "function": "synchronize_net",
            "description": "synchronize net synchronize with packet receive processing wait for packet currently being received to be done doe not block later packet from starting"
        },
        "nfs_init_fs_context": {
            "ground_truth": "0",
            "function": "nfs_init_fs_context",
            "description": "nfs init f context prepare superblock configuration we use the namespaces attached to the context this may be the current process is namespaces or it may be container is namespaces"
        },
        "i40iw_hmc_sd_one": {
            "ground_truth": "0",
            "function": "i40iw_hmc_sd_one",
            "description": "i40iw hmc sd one setup sd entry for cqp"
        },
        "sk_wait_data": {
            "ground_truth": "0",
            "function": "sk_wait_data",
            "description": "sk wait data wait for data to arrive at sk receive queue now socket state including sk sk err is changed only under lock hence we may omit check after joining wait queue we check receive queue before schedule only a optimization it is very likely that release sock added new data"
        },
        "iio_channel_cb_set_buffer_watermark": {
            "ground_truth": "0",
            "function": "iio_channel_cb_set_buffer_watermark",
            "description": "iio channel cb set buffer watermark set the buffer watermark this function allows to configure the buffer watermark"
        },
        "overlay_get_target_phandle": {
            "ground_truth": "0",
            "function": "overlay_get_target_phandle",
            "description": "overlay get target phandle retrieves the target phandle of fragment overlay get target phandle retrieves the target phandle of an overlay fragment when that fragment us phandle target property instead of path target path property"
        },
        "ieee802154_le64_to_be64": {
            "ground_truth": "0",
            "function": "ieee802154_le64_to_be64",
            "description": "ieee802154 le64 to be64 copy and convert le64 to be64"
        },
        "free_tx_buffers": {
            "ground_truth": "0",
            "function": "free_tx_buffers",
            "description": "free tx buffer free all queued tx buffer free all queued tx buffer return value void"
        },
        "xfs_finish_inode_setup": {
            "ground_truth": "0",
            "function": "xfs_finish_inode_setup",
            "description": "xfs finish inode setup when setting up newly allocated inode we need to call xfs finish inode setup once the inode is fully instantiated at the vfs level to prevent the rest of the world seeing the inode before we have completed instantiation otherwise we can do it the moment the inode lookup is complete"
        },
        "dfl_fpga_set_irq_triggers": {
            "ground_truth": "0",
            "function": "dfl_fpga_set_irq_triggers",
            "description": "dfl fpga set irq trigger set eventfd trigger for dfl feature interrupt bind given eventfds with irqs in this dfl sub feature unbind related irq if fds is negative unbind count specified number of irqs if fds ptr is null"
        },
        "fm10k_clean_all_rx_rings": {
            "ground_truth": "0",
            "function": "fm10k_clean_all_rx_rings",
            "description": "fm10k clean all rx ring free rx buffer for all queue"
        },
        "smack_audit_rule_match": {
            "ground_truth": "0",
            "function": "smack_audit_rule_match",
            "description": "smack audit rule match audit given object the core audit hook it is used to take the decision of whether to audit or not to audit given object"
        },
        "amdgpu_sync_peek_fence": {
            "ground_truth": "0",
            "function": "amdgpu_sync_peek_fence",
            "description": "amdgpu sync peek fence get the next fence not signaled yet return the next fence not signaled yet without removing it from the sync object"
        },
        "ixgbe_watchdog_link_is_down": {
            "ground_truth": "0",
            "function": "ixgbe_watchdog_link_is_down",
            "description": "ixgbe watchdog link is down update netif carrier status and print link down message"
        },
        "xprt_request_get_cong": {
            "ground_truth": "0",
            "function": "xprt_request_get_cong",
            "description": "xprt request get cong request congestion control credit useful for transport that require congestion control"
        },
        "parport_unregister_device": {
            "ground_truth": "0",
            "function": "parport_unregister_device",
            "description": "parport unregister device deregister device on parallel port"
        },
        "link_retransmit_failure": {
            "ground_truth": "0",
            "function": "link_retransmit_failure",
            "description": "link retransmit failure detect repeated retransmit failure"
        },
        "hns_get_channels": {
            "ground_truth": "0",
            "function": "hns_get_channels",
            "description": "hn get channel get channel info"
        },
        "devm_gpio_free": {
            "ground_truth": "0",
            "function": "devm_gpio_free",
            "description": "devm gpio free free gpio"
        },
        "vmw_context_binding_state": {
            "ground_truth": "0",
            "function": "vmw_context_binding_state",
            "description": "vmw context binding state return pointer to context binding state structure return the current state of binding of the given context note that this state becomes stale a soon a the dev priv binding mutex is unlocked"
        },
        "btt_init": {
            "ground_truth": "0",
            "function": "btt_init",
            "description": "btt init initialize block translation table for the given device initialize block translation table on backing device to provide single sector power fail atomicity"
        },
        "__test_and_set_bit": {
            "ground_truth": "0",
            "function": "__test_and_set_bit",
            "description": "test and set bit set bit and return it old value this operation is non atomic and can be reordered if two example of this operation race one can appear to succeed but actually fail you must protect multiple access with lock"
        },
        "nfs3_decode_dirent": {
            "ground_truth": "0",
            "function": "nfs3_decode_dirent",
            "description": "nfs3 decode dirent decode single nfsv3 directory entry stored in the local page cache return zero if successful otherwise negative errno value is returned this function is not invoked during readdir reply decoding but rather whenever an application invokes the getdents system call on directory already in our cache entry3 struct entry3 fileid3 fileid filename3 name cookie3 cookie fhandle3 filehandle post op attr3 attribute entry3 nextentry entryplus3 struct entryplus3 fileid3 fileid filename3 name cookie3 cookie post op attr name attribute post op fh3 name handle entryplus3 nextentry"
        },
        "dpni_set_buffer_layout": {
            "ground_truth": "0",
            "function": "dpni_set_buffer_layout",
            "description": "dpni set buffer layout set buffer layout configuration warning allowed only when dpni is disabled"
        },
        "power_supply_unregister": {
            "ground_truth": "0",
            "function": "power_supply_unregister",
            "description": "power supply unregister remove this power supply from system remove this power supply from the system the resource of power supply will be freed here or on last power supply put call"
        },
        "rvt_poll_cq": {
            "ground_truth": "0",
            "function": "rvt_poll_cq",
            "description": "rvt poll cq poll for work completion entry this may be called from interrupt context also called by ib poll cq in the generic verb code"
        },
        "vfree": {
            "ground_truth": "0",
            "function": "vfree",
            "description": "vfree release memory allocated by vmalloc free the virtually continuous memory area starting at addr a obtained from one of the vmalloc family of apis this will usually also free the physical memory underlying the virtual allocation but that memory is reference counted so it will not be freed until the last user go away if addr is null no operation is performed"
        },
        "get_group_info": {
            "ground_truth": "0",
            "function": "get_group_info",
            "description": "get group info get reference to group info structure this get reference to set of supplementary group if the caller is accessing task is credential they must hold the rcu read lock when reading"
        },
        "amdgpu_dm_irq_resume_early": {
            "ground_truth": "0",
            "function": "amdgpu_dm_irq_resume_early",
            "description": "amdgpu dm irq resume early enable hpdrx asic interrupt during resume amdgpu dm irq resume enable asic interrupt during resume"
        },
        "__snd_rawmidi_transmit_peek": {
            "ground_truth": "0",
            "function": "__snd_rawmidi_transmit_peek",
            "description": "snd rawmidi transmit peek copy data from the internal buffer this is variant of snd rawmidi transmit peek without spinlock"
        },
        "ecc_is_pubkey_valid_partial": {
            "ground_truth": "0",
            "function": "ecc_is_pubkey_valid_partial",
            "description": "ecc is pubkey valid partial partial public key validation valdiate public key according to sp800 56a section ecc partial public key validation routine note there is no check that the public key is in the correct elliptic curve subgroup"
        },
        "netprio_prio": {
            "ground_truth": "0",
            "function": "netprio_prio",
            "description": "netprio prio return the effective netprio of cgroup net device pair should be called under rcu read or rtnl lock"
        },
        "ohci_hcd_omap_remove": {
            "ground_truth": "0",
            "function": "ohci_hcd_omap_remove",
            "description": "ohci hcd omap remove shutdown processing for omap based hcds revers the effect of ohci hcd omap probe first invoking the hcd is stop method it is always called from thread context normally rmmod apmd or something similar"
        },
        "unregister_syscore_ops": {
            "ground_truth": "0",
            "function": "unregister_syscore_ops",
            "description": "unregister syscore ops unregister set of system core operation"
        },
        "pch_gbe_tx_queue": {
            "ground_truth": "0",
            "function": "pch_gbe_tx_queue",
            "description": "pch gbe tx queue carry out queuing of the transmission data"
        },
        "snd_hdac_power_down": {
            "ground_truth": "0",
            "function": "snd_hdac_power_down",
            "description": "snd hdac power down power down the codec return zero if successful or negative error code"
        },
        "ssp_register_consumer": {
            "ground_truth": "0",
            "function": "ssp_register_consumer",
            "description": "ssp register consumer register iio consumer in ssp framework"
        },
        "batadv_socket_init": {
            "ground_truth": "0",
            "function": "batadv_socket_init",
            "description": "batadv socket init initialize soft interface independent socket data"
        },
        "usb_disconnect": {
            "ground_truth": "0",
            "function": "usb_disconnect",
            "description": "usb disconnect disconnect device usbcore internal something got disconnected get rid of it and all of it child if pdev is normal device then the parent hub must already be locked if pdev is root hub then the caller must hold the usb bus idr lock which protects the set of root hub a well a the list of bus only hub driver including virtual root hub driver for host controller should ever call this this call is synchronous and may not be used in an interrupt context"
        },
        "read_persistent_wall_and_boot_offset": {
            "ground_truth": "0",
            "function": "read_persistent_wall_and_boot_offset",
            "description": "read persistent wall and boot offset read persistent clock and also offset from the boot weak dummy function for arch that do not yet support it wall time current time a returned by persistent clock boot offset offset that is defined a wall time boot time the default function calculates offset based on the current value of local clock this way architecture that support sched clock but do not support dedicated boot time clock will provide the best estimate of the boot time"
        },
        "ib_pack": {
            "ground_truth": "0",
            "function": "ib_pack",
            "description": "ib pack pack structure into buffer ib pack pack list of structure field into buffer controlled by the array of field in desc"
        },
        "alloc_workqueue": {
            "ground_truth": "0",
            "function": "alloc_workqueue",
            "description": "alloc workqueue allocate workqueue allocate workqueue with the specified parameter for detailed information on wq flag please refer to documentation core api workqueue rst"
        },
        "smack_unix_may_send": {
            "ground_truth": "0",
            "function": "smack_unix_may_send",
            "description": "smack unix may send smack access on uds return if subject with the smack of sock could access an object with the smack of other otherwise an error code"
        },
        "xfrm_state_ok": {
            "ground_truth": "0",
            "function": "xfrm_state_ok",
            "description": "xfrm state okwhen skb is transformed back to it native form we have to check policy restriction at the moment we make this in maximally stupid way shame on me of course connected socket must have policy cached at them"
        },
        "__ffs": {
            "ground_truth": "0",
            "function": "__ffs",
            "description": "ffs find first bit in word undefined if no bit exists so code should check against first"
        },
        "nvmf_log_connect_error": {
            "ground_truth": "0",
            "function": "nvmf_log_connect_error",
            "description": "nvmf log connect error error parsing diagnostic print out function for connect error"
        },
        "radeon_atpx_get_client_id": {
            "ground_truth": "0",
            "function": "radeon_atpx_get_client_id",
            "description": "radeon atpx get client id get the client id look up whether we are the integrated or discrete gpu all asics return the client id"
        },
        "comedi_usb_driver_unregister": {
            "ground_truth": "0",
            "function": "comedi_usb_driver_unregister",
            "description": "comedi usb driver unregister unregister usb comedi driver this function is called from the module exit of usb comedi driver module to unregister the usb driver and the comedi driver do not call it directly use the module comedi usb driver helper macro instead"
        },
        "nested_vmx_vmexit": {
            "ground_truth": "0",
            "function": "nested_vmx_vmexit",
            "description": "nested vmx vmexit emulate an exit from nested guest l2 to l1 prepare to run l1 and modify vmcs12 to make it see what it would expect to see there if l2 wa it real guest must only be called when in l2 is guest mode"
        },
        "genradix_ptr_alloc": {
            "ground_truth": "0",
            "function": "genradix_ptr_alloc",
            "description": "genradix ptr alloc get pointer to genradix entry allocating it if necessary return pointer to entry at idx or null on allocation failure"
        },
        "css_task_iter_start": {
            "ground_truth": "0",
            "function": "css_task_iter_start",
            "description": "cs task iter start initiate task iteration initiate iteration through the task of cs the caller can call cs task iter next to walk through the task until the function return null on completion of iteration cs task iter end must be called"
        },
        "valid_mmap_phys_addr_range": {
            "ground_truth": "0",
            "function": "valid_mmap_phys_addr_range",
            "description": "valid mmap phys addr rangecan we access it through mmap must be valid physical address"
        },
        "fsl_dma_free_descriptor": {
            "ground_truth": "0",
            "function": "fsl_dma_free_descriptor",
            "description": "fsl dma free descriptor free descriptor from channel is dma pool"
        },
        "ntb_db_clear": {
            "ground_truth": "0",
            "function": "ntb_db_clear",
            "description": "ntb db clear clear bit in the local doorbell register clear bit in the local doorbell register arming the bit for the next doorbell"
        },
        "tracing_map_init": {
            "ground_truth": "0",
            "function": "tracing_map_init",
            "description": "tracing map init allocate and clear map is tracing map elts allocates clear pool of tracing map elts equal to the user specified size of map bit internally maintained a amax elts in struct tracing map before using the map field should be added to the map with tracing map add sum field and tracing map add key field tracing map init should then be called to allocate the array of tracing map elts in order to avoid allocating anything in the map insertion path the user specified map size reflects the max number of element requested by the user internally we double that in order to keep the table sparse and keep collision manageable see tracing map for description of tracing map ops"
        },
        "decrypt_pki_encrypted_session_key": {
            "ground_truth": "0",
            "function": "decrypt_pki_encrypted_session_key",
            "description": "decrypt pki encrypted session key decrypt the session key with the given auth tok return zero on success non zero error otherwise"
        },
        "sci_clk_get_parent": {
            "ground_truth": "0",
            "function": "sci_clk_get_parent",
            "description": "sci clk get parent get the current parent of ti sci clock return the index of the currently selected parent for ti sci clock"
        },
        "set_cis_map": {
            "ground_truth": "0",
            "function": "set_cis_map",
            "description": "set ci map map the card memory at card offset into virtual space if flag map attrib map the attribute space otherwise map the memory space must be called with ops mutex held"
        },
        "parport_claim_or_block": {
            "ground_truth": "0",
            "function": "parport_claim_or_block",
            "description": "parport claim or block claim access to parallel port device"
        },
        "it821x_passthru_bmdma_start": {
            "ground_truth": "0",
            "function": "it821x_passthru_bmdma_start",
            "description": "it821x passthru bmdma start dma start callback"
        },
        "parse_next_property": {
            "ground_truth": "0",
            "function": "parse_next_property",
            "description": "parse next property process the next property from raw input buffer note that the caller must make copy of the name and value returned this function doe no allocation or copying of the data return value is set to the next name in buf or null on error"
        },
        "coda_mpeg2_parse_headers": {
            "ground_truth": "0",
            "function": "coda_mpeg2_parse_headers",
            "description": "coda mpeg2 parse header check if the buffer start with the mpeg sequence header with or without quantization matrix and extension header for example b3 2d e0 8b a3 1a 1a 1a 1a 1b 1b 1b 1b 1b 1c 1c 1c 1c 1e 1e 1e 1f 1f b5 8a or b3 ff ff e0 b5 8a"
        },
        "ntfs_file_write_iter": {
            "ground_truth": "0",
            "function": "ntfs_file_write_iter",
            "description": "ntfs file write iter simple wrapper for ntfs file write iter nolock basically the same a generic file write iter except that it end up up calling ntfs perform write instead of generic perform write and that direct is not implemented"
        },
        "i7300_process_error_global": {
            "ground_truth": "0",
            "function": "i7300_process_error_global",
            "description": "i7300 process error global retrieve the hardware error information from the hardware global error register and sends it to dmesg"
        },
        "zap_page_range": {
            "ground_truth": "0",
            "function": "zap_page_range",
            "description": "zap page range remove user page in given range caller must protect the vma list"
        },
        "ccdc_has_all_fields": {
            "ground_truth": "0",
            "function": "ccdc_has_all_fields",
            "description": "ccdc ha all field check whether the ccdc ha captured all field necessary to complete the buffer"
        },
        "port_init_cnt": {
            "ground_truth": "0",
            "function": "port_init_cnt",
            "description": "port init cnt initialize mib counter value this routine is used to initialize all counter to zero if the hardware cannot do it after reset"
        },
        "i40e_get_link_speed": {
            "ground_truth": "0",
            "function": "i40e_get_link_speed",
            "description": "i40e get link speed return link speed for the interface"
        },
        "state_show": {
            "ground_truth": "0",
            "function": "state_show",
            "description": "state show debugfs show overall driver and device state this debugfs entry show the overall state of the hardware and some general information about each of the endpoint available to the system"
        },
        "axienet_ethtools_get_pauseparam": {
            "ground_truth": "0",
            "function": "axienet_ethtools_get_pauseparam",
            "description": "axienet ethtools get pauseparam get the pause parameter setting for tx and rx path this implement ethtool command for getting axi ethernet pause frame setting issue ethtool ethx to execute this function"
        },
        "mraid_mm_setup_dma_pools": {
            "ground_truth": "0",
            "function": "mraid_mm_setup_dma_pools",
            "description": "mraid mm setup dma pool set up dma buffer pool per adapter we maintain pool of dma buffer per each adapter each pool ha one buffer we may have dma pool one each for 4k 8k 64k buffer we have just one 4k buffer in 4k pool one 8k buffer in 8k pool etc we dont want to waste too much memory by allocating more buffer per each pool"
        },
        "esparser_queue_all_src": {
            "ground_truth": "0",
            "function": "esparser_queue_all_src",
            "description": "esparser queue all src work handler that writes a many src buffer a possible to the esparser"
        },
        "isci_task_execute_task": {
            "ground_truth": "0",
            "function": "isci_task_execute_task",
            "description": "isci task execute task this function is one of the sa domain template function this function is called by libsas to send task down to hardware status zero indicates success"
        },
        "ixgbe_read_mbx_pf": {
            "ground_truth": "0",
            "function": "ixgbe_read_mbx_pf",
            "description": "ixgbe read mbx pf read message from the mailbox"
        },
        "__ppc440spe_adma_slot_cleanup": {
            "ground_truth": "0",
            "function": "__ppc440spe_adma_slot_cleanup",
            "description": "ppc440spe adma slot cleanup this is the common clean up routine which run through the channel cdbs list until reach the descriptor currently processed when routine determines that all cdbs of group are completed then corresponding callback if any are called and slot are freed"
        },
        "sve_sync_to_fpsimd": {
            "ground_truth": "0",
            "function": "sve_sync_to_fpsimd",
            "description": "sve sync to fpsimd ensure that task thread uw fpsimd state is up to date with respect to the user task irrespective of whether sve is in use or not this should only be called by ptrace task must be non runnable task thread sve state must point to at least sve state size task byte of allocated kernel memory"
        },
        "omap_vc_i2c_init": {
            "ground_truth": "0",
            "function": "omap_vc_i2c_init",
            "description": "omap vc i2c init initialize i2c interface to pmic use pmic supplied setting for i2c high speed mode and master code if set and program the vc i2c configuration register the vc i2c configuration is common to all vc channel so this function only configures i2c for the first vc channel register all other vc channel will use the same configuration"
        },
        "ixgbevf_check_for_msg_vf": {
            "ground_truth": "0",
            "function": "ixgbevf_check_for_msg_vf",
            "description": "ixgbevf check for msg vf check to see if the pf ha sent mail"
        },
        "p9100_blank": {
            "ground_truth": "0",
            "function": "p9100_blank",
            "description": "p9100 blank optional function blank the display"
        },
        "xprt_get": {
            "ground_truth": "0",
            "function": "xprt_get",
            "description": "xprt get return reference to an rpc transport"
        },
        "tomoyo_poll_control": {
            "ground_truth": "0",
            "function": "tomoyo_poll_control",
            "description": "tomoyo poll control poll for sys kernel security tomoyo interface return epollin epollrdnorm epollout epollwrnorm if ready to read write epollout epollwrnorm otherwise"
        },
        "spi_nor_sr_is_locked": {
            "ground_truth": "0",
            "function": "spi_nor_sr_is_locked",
            "description": "spi nor sr is locked check if region of the flash is completely locked see spi nor sr lock for more info"
        },
        "dp_ctrl_host_deinit": {
            "ground_truth": "0",
            "function": "dp_ctrl_host_deinit",
            "description": "dp ctrl host deinit uninitialize dp controller perform required step to uninitialize dp controller and it resource"
        },
        "bdx_open": {
            "ground_truth": "0",
            "function": "bdx_open",
            "description": "bdx open called when network interface is made active return on success negative value on failure the open entry point is called when network interface is made active by the system iff up at this point all resource needed for transmit and receive operation are allocated the interrupt handler is registered with the o the watchdog timer is started and the stack is notified that the interface is ready"
        },
        "vcn_v2_5_enable_clock_gating": {
            "ground_truth": "0",
            "function": "vcn_v2_5_enable_clock_gating",
            "description": "vcn v2 enable clock gating enable vcn clock gating enable clock gating for vcn block"
        },
        "parport_release": {
            "ground_truth": "0",
            "function": "parport_release",
            "description": "parport release give up access to parallel port device"
        },
        "cnstr_shdsc_rfc4106_encap": {
            "ground_truth": "0",
            "function": "cnstr_shdsc_rfc4106_encap",
            "description": "cnstr shdsc rfc4106 encap ipsec esp gcm encapsulation shared descriptor non protocol input sequence aad ptxt output sequence aad ctxt icv aad length assoclen which includes the iv length is available in math3"
        },
        "tb_domain_approve_switch": {
            "ground_truth": "0",
            "function": "tb_domain_approve_switch",
            "description": "tb domain approve switch approve switch this will approve switch by connection manager specific mean in case of success the connection manager will create tunnel for all supported protocol"
        },
        "cros_ec_sensors_core_read": {
            "ground_truth": "0",
            "function": "cros_ec_sensors_core_read",
            "description": "cro ec sensor core read function to request value from the sensor"
        },
        "fc_adisc_fill": {
            "ground_truth": "0",
            "function": "fc_adisc_fill",
            "description": "fc adisc fill fill in adisc request frame"
        },
        "sht15_temp_show": {
            "ground_truth": "0",
            "function": "sht15_temp_show",
            "description": "sht15 temp show show temperature measurement value in sysfs will be called on read access to temp1 input sysfs attribute return number of byte written into buffer negative errno on error"
        },
        "ice_init_check_adminq": {
            "ground_truth": "0",
            "function": "ice_init_check_adminq",
            "description": "ice init check adminq check version for admin queue to know if it alive"
        },
        "arch_dup_task_struct": {
            "ground_truth": "0",
            "function": "arch_dup_task_struct",
            "description": "arch dup task structtif mcdper in thread info flag for current task is updated lazily upon context switch update this flag in current task is thread flag before dup so the dup would task will inherit the current tif mcdper flag"
        },
        "__v9fs_readpage_to_fscache": {
            "ground_truth": "0",
            "function": "__v9fs_readpage_to_fscache",
            "description": "v9fs readpage to fscache write page to the cache"
        },
        "set_nlink": {
            "ground_truth": "0",
            "function": "set_nlink",
            "description": "set nlink directly set an inode is link count this is low level filesystem helper to replace any direct filesystem manipulation of nlink"
        },
        "scsi_netlink_init": {
            "ground_truth": "0",
            "function": "scsi_netlink_init",
            "description": "scsi netlink init called by scsi subsystem to initialize the scsi transport netlink interface"
        },
        "fm10k_request_glort_range": {
            "ground_truth": "0",
            "function": "fm10k_request_glort_range",
            "description": "fm10k request glort range request glorts for use in configuring rule this function allocates range of glorts for this interface to use"
        },
        "ixgbevf_reuse_rx_page": {
            "ground_truth": "0",
            "function": "ixgbevf_reuse_rx_page",
            "description": "ixgbevf reuse rx page page flip buffer and store it back on the ring synchronizes page for reuse by the adapter"
        },
        "pcpu_alloc_area": {
            "ground_truth": "0",
            "function": "pcpu_alloc_area",
            "description": "pcpu alloc area allocates an area from pcpu chunk this function take in start offset to begin searching to fit an allocation of alloc bit with alignment align it need to scan the allocation map because if it fit within the block is contig hint start will be block first free this is an attempt to fill the allocation prior to breaking the contig hint the allocation and boundary map are updated accordingly if it confirms valid free area"
        },
        "copy_oldmem_page": {
            "ground_truth": "0",
            "function": "copy_oldmem_page",
            "description": "copy oldmem page copy one page from oldmem copy page from oldmem for this page there is no pte mapped in the current kernel calling copy to user in atomic context is not desirable hence first copying the data to pre allocated kernel page and then copying to user space in non atomic context"
        },
        "cfg80211_check_combinations": {
            "ground_truth": "0",
            "function": "cfg80211_check_combinations",
            "description": "cfg80211 check combination check interface combination this function can be called by the driver to check whether combination of interface and their type are allowed according to the interface combination"
        },
        "spmi_command_reset": {
            "ground_truth": "0",
            "function": "spmi_command_reset",
            "description": "spmi command reset sends reset command to the specified slave the reset command initializes the slave and force all register to their reset value the slave shall enter the startup state after receiving reset command"
        },
        "aa_dfa_unpack": {
            "ground_truth": "0",
            "function": "aa_dfa_unpack",
            "description": "aa dfa unpack unpack the binary table of serialized dfa unpack dfa that ha been serialized to find information on the dfa format look in documentation admin guide lsm apparmor rst assumes the dfa blob stream ha been aligned on byte boundary"
        },
        "ubifs_evict_xattr_inode": {
            "ground_truth": "0",
            "function": "ubifs_evict_xattr_inode",
            "description": "ubifs evict xattr inode evict an xattr inode when an inode that host xattrs is being removed we have to make sure that cached inodes of the xattrs also get removed from the inode cache otherwise we would waste memory this function look up an inode from the inode cache and clear the link counter such that iput will evict the inode"
        },
        "igb_write_phy_reg_mdic": {
            "ground_truth": "0",
            "function": "igb_write_phy_reg_mdic",
            "description": "igb write phy reg mdic write mdi control register"
        },
        "cail_pll_read": {
            "ground_truth": "0",
            "function": "cail_pll_read",
            "description": "cail pll read read pll register provides pll register accessor for the atom interpreter r4xx return the value of the pll register"
        },
        "t4_update_port_info": {
            "ground_truth": "0",
            "function": "t4_update_port_info",
            "description": "t4 update port info retrieve and update port information if changed"
        },
        "ixgbe_dma_sync_frag": {
            "ground_truth": "0",
            "function": "ixgbe_dma_sync_frag",
            "description": "ixgbe dma sync frag perform dma sync for first frag of skb this function provides basic dma sync up for the first fragment of an skb the reason for doing this is that the first fragment cannot be unmapped until we have reached the end of packet descriptor for buffer chain"
        },
        "nlm_decode_oh": {
            "ground_truth": "0",
            "function": "nlm_decode_oh",
            "description": "nlm decode oh encode and decode owner handle"
        },
        "rproc_elf_load_segments": {
            "ground_truth": "0",
            "function": "rproc_elf_load_segments",
            "description": "rproc elf load segment load firmware segment to memory this function load the firmware segment to memory where the remote processor expects them some remote processor will expect their code and data to be placed in specific device address and can not have them dynamically assigned we currently support only those kind of remote processor and expect the program header is paddr member to contain those address we then go through the physically contiguous carveout memory region which we allocated and mapped earlier on behalf of the remote processor and translate device address to kernel address so we can copy the segment where they are expected currently we only support remote processor that required carveout allocation and got them mapped onto their iommus some processor might be different they might not have iommus and would prefer to directly allocate memory for every segment resource this is not yet supported though"
        },
        "vga_switcheroo_unregister_client": {
            "ground_truth": "0",
            "function": "vga_switcheroo_unregister_client",
            "description": "vga switcheroo unregister client unregister client unregister client disable vga switcheroo if this is vga client gpu"
        },
        "bdx_rx_init": {
            "ground_truth": "0",
            "function": "bdx_rx_init",
            "description": "bdx rx init initialize rx all related hw and sw resource return on success negative value on failure it creates rxf and rxd fifo update relevant hw register preallocate skb for rx it assumes that rx is desabled in hw funcs are grouped for better cache usage rxd fifo is smaller than rxf fifo by design upon high load rxd will be filled and packet will be dropped by nic without getting into host or cousing interrupt anyway in that condition host ha no chance to process all packet but dropping in nic is cheaper since it take cpu cycle"
        },
        "dfs_cache_add_vol": {
            "ground_truth": "0",
            "function": "dfs_cache_add_vol",
            "description": "dfs cache add vol add cifs volume during mount that will be handled by dfs cache refresh worker return zero if volume wa set up correctly otherwise non zero"
        },
        "instruction_is_store": {
            "ground_truth": "0",
            "function": "instruction_is_store",
            "description": "instruction is store quick test for whether an instruction is load or store if the instruction is load or store then this will indicate which it is at least on server processor embedded processor have some external pid instruction that do not follow the rule embodied here if the instruction is not load or store then this doe not return anything useful"
        },
        "cxlflash_disk_clone": {
            "ground_truth": "0",
            "function": "cxlflash_disk_clone",
            "description": "cxlflash disk clone clone context by making snapshot of another this routine effectively performs cxlflash disk open operation for each in use virtual resource in the source context note that the destination context must be in pristine state and cannot have any resource handle open at the time of the clone"
        },
        "rio_map_outb_region": {
            "ground_truth": "0",
            "function": "rio_map_outb_region",
            "description": "rio map outb region map outbound memory region this function will create the mapping from rio space to local memory"
        },
        "drm_atomic_commit": {
            "ground_truth": "0",
            "function": "drm_atomic_commit",
            "description": "drm atomic commit commit configuration atomically note that this function can return edeadlk if the driver needed to acquire more lock but encountered deadlock the caller must then do the usual backoff dance and restart all other error are fatal this function will take it own reference on state caller should always release their reference with drm atomic state put"
        },
        "ceph_drop_caps_for_unlink": {
            "ground_truth": "0",
            "function": "ceph_drop_caps_for_unlink",
            "description": "ceph drop cap for unlink for soon to be unlinked file drop the link cap if it look like the link count will hit drop any other cap other than pin we do not specifically want due to the file still being open"
        },
        "ima_match_rules": {
            "ground_truth": "0",
            "function": "ima_match_rules",
            "description": "ima match rule determine whether an inode match the policy rule return true on rule match false on failure"
        },
        "core_param": {
            "ground_truth": "0",
            "function": "core_param",
            "description": "core param define historical core kernel parameter core param is just like module param but cannot be modular and doe not add prefix such a printk this is for compatibility with setup and it make sense a truly core parameter are not tied to the particular file they are in"
        },
        "crypto_alloc_rng": {
            "ground_truth": "0",
            "function": "crypto_alloc_rng",
            "description": "crypto alloc rng allocate rng handle allocate cipher handle for random number generator the returned struct crypto rng is the cipher handle that is required for any subsequent api invocation for that random number generator for all random number generator this call creates new private copy of the random number generator that doe not share state with other instance the only exception is the krng random number generator which is kernel crypto api use case for the get random byte function of the dev random driver"
        },
        "mptscsih_taskmgmt_complete": {
            "ground_truth": "0",
            "function": "mptscsih_taskmgmt_complete",
            "description": "mptscsih taskmgmt complete registered with fusion mpt base driver"
        },
        "sas_enable_tlr": {
            "ground_truth": "0",
            "function": "sas_enable_tlr",
            "description": "sa enable tlr setting tlr flag seting tlr enabled flag"
        },
        "lpfc_bg_setup_bpl_prot": {
            "ground_truth": "0",
            "function": "lpfc_bg_setup_bpl_prot",
            "description": "lpfc bg setup bpl prot setup blockguard bpl with protection data this function set up bpl buffer list for protection group of type lpfc pg type dif this is usually used when difs are in their own buffer separate from the data the hba can then by instructed to place the difs in the outgoing stream for read operation the hba could extract the difs and place it in dif buffer the buffer list for this type consists of one or more of the protection group described below start of first prot group pde pde pde prot bde data bde more data bde is opt start of new prot group pde return the number of bdes added to the bpl note it is assumed that both data and protection buffer have been mapped for dma"
        },
        "which_prom": {
            "ground_truth": "0",
            "function": "which_prom",
            "description": "which prom detect which prom the decstation ha and set the callback vector appropriately"
        },
        "seq_buf_to_user": {
            "ground_truth": "0",
            "function": "seq_buf_to_user",
            "description": "seq buf to user copy the squence buffer to user space copy the sequence buffer into the userspace memory pointed to by ubuf it start from the last read position readpos and writes up to cnt character or till it reach the end of the content in the buffer len which ever come first on success it return positive number of the number of byte it copied on failure it return ebusy if all of the content in the sequence ha been already read which includes nothing in the sequence len readpos return efault if the copy to userspace fails"
        },
        "rose_insert_socket": {
            "ground_truth": "0",
            "function": "rose_insert_socket",
            "description": "rose insert socket add socket to the bound socket list"
        },
        "lola_proc_codec_rw_write": {
            "ground_truth": "0",
            "function": "lola_proc_codec_rw_write",
            "description": "lola proc codec rw writedirect codec access for debugging"
        },
        "i915_perf_disable_locked": {
            "ground_truth": "0",
            "function": "i915_perf_disable_locked",
            "description": "i915 perf disable locked handle i915 perf ioctl disable ioctl disables the associated capture of data for this stream the intention is that disabling an re enabling stream will ideally be cheaper than destroying and re opening stream with the same configuration though there are no formal guarantee about what state or buffered data must be retained between disabling and re enabling stream note while stream is disabled it is considered an error for userspace to attempt to read from the stream eio"
        },
        "qla4xxx_bsg_request": {
            "ground_truth": "0",
            "function": "qla4xxx_bsg_request",
            "description": "qla4xxx bsg request handle bsg request from iscsi transport"
        },
        "kstrtobool": {
            "ground_truth": "0",
            "function": "kstrtobool",
            "description": "kstrtobool convert common user input into boolean value this routine return iff the first character is one of yy1nn0 or oo nnff for on and off otherwise it will return einval value pointed to by re is updated upon finding match"
        },
        "i40e_vsi_reset_stats": {
            "ground_truth": "0",
            "function": "i40e_vsi_reset_stats",
            "description": "i40e vsi reset stats reset all stats of the given vsi"
        },
        "__mips_clear_bit": {
            "ground_truth": "0",
            "function": "__mips_clear_bit",
            "description": "mips clear bit clear bit in memory this is called by clear bit if it cannot find faster solution"
        },
        "nfs_pgio_prepare": {
            "ground_truth": "0",
            "function": "nfs_pgio_prepare",
            "description": "nfs pgio prepare prepare pageio hdr to go over the wire"
        },
        "__device_links_queue_sync_state": {
            "ground_truth": "0",
            "function": "__device_links_queue_sync_state",
            "description": "device link queue sync state queue device for sync state callback queue device for sync state callback when the device link write lock is not held this allows the sync state execution flow to use device link apis the caller must ensure this function is called with device link write lock held this function doe get device to make sure the device is not freed while on this list so the caller must also ensure that device link flush sync list is called a soon a the caller release device link write lock this is necessary to make sure the sync state is called in timely fashion and the put device is called on this device"
        },
        "amdgpu_virt_request_full_gpu": {
            "ground_truth": "0",
            "function": "amdgpu_virt_request_full_gpu",
            "description": "amdgpu virt request full gpu request full gpu access"
        },
        "kauditd_printk_skb": {
            "ground_truth": "0",
            "function": "kauditd_printk_skb",
            "description": "kauditd printk skb print the audit record to the ring buffer whatever the reason this packet may not make it to the auditd connection so write it via printk so the information is not completely lost"
        },
        "ice_unicast_mac_exists": {
            "ground_truth": "0",
            "function": "ice_unicast_mac_exists",
            "description": "ice unicast mac exists check if the unicast mac exists on the pf is switch return true on the first any match else return false"
        },
        "e1000e_update_nvm_checksum_generic": {
            "ground_truth": "0",
            "function": "e1000e_update_nvm_checksum_generic",
            "description": "e1000e update nvm checksum generic update eeprom checksum"
        },
        "arch_timer_select_ppi": {
            "ground_truth": "0",
            "function": "arch_timer_select_ppi",
            "description": "arch timer select ppi select suitable ppi for the current system if hyp mode is available we know that the physical timer ha been configured to be accessible from pl1 use it so that guest can use the virtual timer instead on armv8 with vh extension the kernel run in hyp vhe access to cntp el1 register are silently redirected to their cnthp el2 counterpart and use different ppi number if no interrupt provided for virtual timer we will have to stick to the physical timer it would better be accessible for arm64 we never use the secure interrupt"
        },
        "debugfs_create_u32": {
            "ground_truth": "0",
            "function": "debugfs_create_u32",
            "description": "debugfs create u32 create debugfs file that is used to read and write an unsigned bit value this function creates file in debugfs with the given name that contains the value of the variable value if the mode variable is so set it can be read from and written to"
        },
        "amdgpu_mm_rreg8": {
            "ground_truth": "0",
            "function": "amdgpu_mm_rreg8",
            "description": "amdgpu mm rreg8 read memory mapped io register return the bit value from the offset specified"
        },
        "irq_migrate_all_off_this_cpu": {
            "ground_truth": "0",
            "function": "irq_migrate_all_off_this_cpu",
            "description": "irq migrate all off this cpu migrate irqs away from offline cpu the current cpu ha been marked offline migrate irqs off this cpu if the affinity setting do not allow other cpu force them onto any available cpu note we must iterate over all irqs whether they have an attached action structure or not a we need to get chained interrupt too"
        },
        "i40e_hmc_get_object_va": {
            "ground_truth": "0",
            "function": "i40e_hmc_get_object_va",
            "description": "i40e hmc get object va retrieves an object is virtual address this function retrieves the object is virtual address from the object base pointer this function is used for lan queue context"
        },
        "goodix_configure_dev": {
            "ground_truth": "0",
            "function": "goodix_configure_dev",
            "description": "goodix configure dev finish device initialization must be called from probe to finish initialization of the device contains the common initialization code for both device that declare gpio pin and device that do not it is either called directly from probe or from request firmware wait callback"
        },
        "nand_check_erased_ecc_chunk": {
            "ground_truth": "0",
            "function": "nand_check_erased_ecc_chunk",
            "description": "nand check erased ecc chunk check if an ecc chunk contains almost only data check if data buffer and it associated ecc and oob data contains only pattern which mean the underlying region ha been erased and is ready to be programmed the bitflips threshold specify the maximum number of bitflips before considering the region a not erased return positive number of bitflips le than or equal to bitflips threshold or error code for bitflips in excess of the threshold in case of success the passed buffer are filled with note ecc algorithm are working on pre defined block size which are usually different from the nand page size when fixing bitflips ecc engine will report the number of error per chunk and the nand core infrastructure expect you to return the maximum number of bitflips for the whole page this is why you should always use this function on single chunk and not on the whole page after checking each chunk you should update your max bitflips value accordingly when checking for bitflips in erased page you should not only check the payload data but also their associated ecc data because user might have programmed almost all bit to but few in this case we should not consider the chunk a erased and checking ecc byte prevent this case the extraoob argument is optional and should be used if some of your oob data are protected by the ecc engine it could also be used if you support subpages and want to attach some extra oob data to an ecc chunk"
        },
        "b43_phy_free": {
            "ground_truth": "0",
            "function": "b43_phy_free",
            "description": "b43 phy free free phy structs"
        },
        "ntfs_check_log_client_array": {
            "ground_truth": "0",
            "function": "ntfs_check_log_client_array",
            "description": "ntfs check log client array check the log client array for consistency check the log client array of the restart page rp for consistency and return notrue if it is consistent and false otherwise this function assumes that the restart page header and the restart area have already been consistency checked unlike ntfs check restart page header and ntfs check restart area this function need rp system page size byte in rp it requires the full restart page and the page must be multi sector transfer deprotected"
        },
        "clear_nlink": {
            "ground_truth": "0",
            "function": "clear_nlink",
            "description": "clear nlink directly zero an inode is link count this is low level filesystem helper to replace any direct filesystem manipulation of nlink see drop nlink for why we care about nlink hitting zero"
        },
        "tty_audit_add_data": {
            "ground_truth": "0",
            "function": "tty_audit_add_data",
            "description": "tty audit add data add data for tty auditing audit data of size from tty if necessary"
        },
        "wil_brd_process": {
            "ground_truth": "0",
            "function": "wil_brd_process",
            "description": "wil brd process process section from brd file return error code"
        },
        "ecryptfs_process_key_cipher": {
            "ground_truth": "0",
            "function": "ecryptfs_process_key_cipher",
            "description": "ecryptfs process key cipher perform key cipher initialization return zero on success any crypto tfm structs allocated here should be released by other function such a on superblock put event regardless of whether this function succeeds for fails"
        },
        "batadv_tp_init_recv": {
            "ground_truth": "0",
            "function": "batadv_tp_init_recv",
            "description": "batadv tp init recv return matching or create new receiver tp var"
        },
        "first_dirty_cnode": {
            "ground_truth": "0",
            "function": "first_dirty_cnode",
            "description": "first dirty cnode find first dirty cnode this function return the first dirty cnode or null if there is not one"
        },
        "drm_crtc_enable_color_mgmt": {
            "ground_truth": "0",
            "function": "drm_crtc_enable_color_mgmt",
            "description": "drm crtc enable color mgmt enable color management property this function let the driver enable the color correction property on crtc this includes degamma csc and gamma property that userspace can set and size property to inform the userspace of the lut size each of the property are optional the gamma and degamma property are only attached if their size is not and ctm property is only attached if ha ctm is true driver should use drm atomic helper legacy gamma set to implement the legacy type drm crtc funcs gamma set callback"
        },
        "scif_send": {
            "ground_truth": "0",
            "function": "scif_send",
            "description": "None"
        },
        "xilinx_dpdma_chan_free_sw_desc": {
            "ground_truth": "0",
            "function": "xilinx_dpdma_chan_free_sw_desc",
            "description": "xilinx dpdma chan free sw desc free software descriptor free software descriptor from the channel is descriptor pool"
        },
        "cti_map_trigger": {
            "ground_truth": "0",
            "function": "cti_map_trigger",
            "description": "cti map trigger use the chan to map trig in to trig out this function map one trigger in of trig in to one trigger out of trig out using the channel chan"
        },
        "batadv_nc_skb_src_search": {
            "ground_truth": "0",
            "function": "batadv_nc_skb_src_search",
            "description": "batadv nc skb src search loop through the list of neighboring node of the skb is sender may be equal to the originator"
        },
        "list_add_tail": {
            "ground_truth": "0",
            "function": "list_add_tail",
            "description": "list add tail add new entry insert new entry before the specified head this is useful for implementing queue"
        },
        "regmap_reinit_cache": {
            "ground_truth": "0",
            "function": "regmap_reinit_cache",
            "description": "regmap reinit cache reinitialise the current register cache discard any existing register cache for the map and initialize new cache this can be used to restore the cache to default or to update the cache configuration to reflect runtime discovery of the hardware no explicit locking is done here the user need to ensure that this function will not race with other call to regmap"
        },
        "iput_final": {
            "ground_truth": "0",
            "function": "iput_final",
            "description": "iput final called when we are dropping the last reference to an inode call the f drop inode function defaulting to the legacy unix filesystem behaviour if it tell u to evict inode do so otherwise retain inode in cache if f is alive sync and evict if f is shutting down"
        },
        "s2io_link_test": {
            "ground_truth": "0",
            "function": "s2io_link_test",
            "description": "s2io link test verifies the link state of the nic the function verifies the link state of the nic and update the input argument wouldata appropriately return value on success"
        },
        "dce_v10_0_latency_watermark": {
            "ground_truth": "0",
            "function": "dce_v10_0_latency_watermark",
            "description": "dce v10 latency watermark get the latency watermark calculate the latency watermark cik used for display watermark bandwidth calculation return the latency watermark in n"
        },
        "i40iw_check_mr_contiguous": {
            "ground_truth": "0",
            "function": "i40iw_check_mr_contiguous",
            "description": "i40iw check mr contiguous check if mr is physically contiguous"
        },
        "in_persistence": {
            "ground_truth": "0",
            "function": "in_persistence",
            "description": "in persistencecheck if connection is controlled by persistence"
        },
        "mei_cl_device_match": {
            "ground_truth": "0",
            "function": "mei_cl_device_match",
            "description": "mei cl device match device match function"
        },
        "ibmvmc_read": {
            "ground_truth": "0",
            "function": "ibmvmc_read",
            "description": "ibmvmc read read"
        },
        "scsicam_bios_param": {
            "ground_truth": "0",
            "function": "scsicam_bios_param",
            "description": "scsicam bios param determine geometry of disk in cylinder head sector determine the bios mapping geometry used for drive in scsi cam system storing the result in ip a required by the hdio getgeo ioctl"
        },
        "n_tty_flush_buffer": {
            "ground_truth": "0",
            "function": "n_tty_flush_buffer",
            "description": "tty flush buffer clean input queue"
        },
        "stm32_adc_conf_scan_seq": {
            "ground_truth": "0",
            "function": "stm32_adc_conf_scan_seq",
            "description": "stm32 adc conf scan seq build regular channel scan sequence conversion sequence apply sampling time setting for all channel configure adc scan sequence based on selected channel in scan mask add channel to sqr register from scan mask lsb to msb then program sequence len"
        },
        "destroy_journal": {
            "ground_truth": "0",
            "function": "destroy_journal",
            "description": "destroy journal destroy journal data structure this function destroys journal data structure including those that may have been created by recovery function"
        },
        "copy_frags": {
            "ground_truth": "0",
            "function": "copy_frags",
            "description": "copy frags copy fragment from gather list into skb shared info"
        },
        "fc_lport_timeout": {
            "ground_truth": "0",
            "function": "fc_lport_timeout",
            "description": "fc lport timeout handler for the retry work timer"
        },
        "AVE_IDR": {
            "ground_truth": "0",
            "function": "AVE_IDR",
            "description": "ave idr socionext uniphier ave ethernet driver copyright panasonic corporation copyright socionext inc"
        },
        "snd_pcm_hw_param_first": {
            "ground_truth": "0",
            "function": "snd_pcm_hw_param_first",
            "description": "snd pcm hw param first refine config space and return minimum value inside configuration space defined by params remove from var all value minimum reduce configuration space accordingly"
        },
        "ieee80211_queue_work": {
            "ground_truth": "0",
            "function": "ieee80211_queue_work",
            "description": "ieee80211 queue work add work onto the mac80211 workqueue driver and mac80211 use this to add work onto the mac80211 workqueue this helper ensures driver are not queueing work when they should not be"
        },
        "ice_vsi_setup": {
            "ground_truth": "0",
            "function": "ice_vsi_setup",
            "description": "ice vsi setup set up vsi by given type this allocates the sw vsi structure and it queue resource return pointer to the successfully allocated and configured vsi sw struct on success null on failure"
        },
        "tty_unthrottle": {
            "ground_truth": "0",
            "function": "tty_unthrottle",
            "description": "tty unthrottle flow control"
        },
        "nla_get_bitfield32": {
            "ground_truth": "0",
            "function": "nla_get_bitfield32",
            "description": "nla get bitfield32 return payload of bitfield attribute"
        },
        "ww_acquire_done": {
            "ground_truth": "0",
            "function": "ww_acquire_done",
            "description": "ww acquire done mark the end of the acquire phase mark the end of the acquire phase any further mutex lock call using this context are forbidden calling this function is optional it is just useful to document mutex code and clearly designated the acquire phase from actually using the locked data structure"
        },
        "img_ir_free_timing_dynamic": {
            "ground_truth": "0",
            "function": "img_ir_free_timing_dynamic",
            "description": "img ir free timing dynamic update free time register value"
        },
        "nfp_net_irqs_assign": {
            "ground_truth": "0",
            "function": "nfp_net_irqs_assign",
            "description": "nfp net irqs assign assign interrupt allocated externally to netdev after interrupt are allocated with nfp net irqs alloc this function should be called to assign them to specific netdev port"
        },
        "lpfc_sli4_chk_avail_extnt_rsrc": {
            "ground_truth": "0",
            "function": "lpfc_sli4_chk_avail_extnt_rsrc",
            "description": "lpfc sli4 chk avail extnt rsrc check for available sli4 resource extent this function read the current available extent from the port and check if the extent count or extent size ha changed since the last access caller use this routine post port reset to understand if there is extent reprovisioning requirement"
        },
        "soctherm_oc_irq_enable": {
            "ground_truth": "0",
            "function": "soctherm_oc_irq_enable",
            "description": "soctherm oc irq enable enables the soc therm over current interrupt queue set the irq enable bit of soc therm allowing soc therm to respond to over current interrupt"
        },
        "devm_hwmon_device_register_with_info": {
            "ground_truth": "0",
            "function": "devm_hwmon_device_register_with_info",
            "description": "devm hwmon device register with info register hwmon return the pointer to the new device the new device is automatically unregistered with the parent device"
        },
        "scsi_target_reap_ref_release": {
            "ground_truth": "0",
            "function": "scsi_target_reap_ref_release",
            "description": "scsi target reap ref release remove target from visibility called on last put of reap ref which is the indication that no device under this target is visible anymore so render the target invisible in sysfs note we have to be in user context here because the target reaps should be done in place where the scsi device visibility is being removed"
        },
        "drmm_add_action_or_reset": {
            "ground_truth": "0",
            "function": "drmm_add_action_or_reset",
            "description": "drmm add action or reset add managed release action to type drm device similar to drmm add action with the only difference that upon failure action is directly called for any cleanup work necessary on failure"
        },
        "msgdma_desc_config_eod": {
            "ground_truth": "0",
            "function": "msgdma_desc_config_eod",
            "description": "msgdma desc config eod mark the descriptor a end descriptor"
        },
        "intel_uncore_forcewake_user_get": {
            "ground_truth": "0",
            "function": "intel_uncore_forcewake_user_get",
            "description": "intel uncore forcewake user get claim forcewake on behalf of userspace this function is wrapper around intel uncore forcewake get to acquire the gt powerwell and in the process disable our debugging for the duration of userspace is bypass"
        },
        "sst_pause_stream": {
            "ground_truth": "0",
            "function": "sst_pause_stream",
            "description": "sst pause stream send msg for pausing stream this function is called by any function which want to pause an already running stream"
        },
        "alc_read_coefex_idx": {
            "ground_truth": "0",
            "function": "alc_read_coefex_idx",
            "description": "alc read coefex idx coef access helper function"
        },
        "drm_mode_equal": {
            "ground_truth": "0",
            "function": "drm_mode_equal",
            "description": "drm mode equal test mode for equality check to see if mode1 and mode2 are equivalent"
        },
        "comedi_8254_mm_init": {
            "ground_truth": "0",
            "function": "comedi_8254_mm_init",
            "description": "comedi mm init allocate and initialize the device for mmio access"
        },
        "hns_xgmac_config_max_frame_length": {
            "ground_truth": "0",
            "function": "hns_xgmac_config_max_frame_length",
            "description": "hn xgmac config max frame length set xgmac max frame length"
        },
        "__nla_put_64bit": {
            "ground_truth": "0",
            "function": "__nla_put_64bit",
            "description": "nla put 64bit add netlink attribute to socket buffer and align it the caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload"
        },
        "drm_sched_entity_is_idle": {
            "ground_truth": "0",
            "function": "drm_sched_entity_is_idle",
            "description": "drm sched entity is idle check if entity is idle return true if the entity doe not have any unscheduled job"
        },
        "read_outbnd_queue_table": {
            "ground_truth": "0",
            "function": "read_outbnd_queue_table",
            "description": "read outbnd queue table read the outbound queue table and save it"
        },
        "pci_epc_destroy": {
            "ground_truth": "0",
            "function": "pci_epc_destroy",
            "description": "pci epc destroy destroy the epc device invoke to destroy the pci epc device"
        },
        "tsi148_slot_get": {
            "ground_truth": "0",
            "function": "tsi148_slot_get",
            "description": "tsi148 slot get determine geographical addressing"
        },
        "update_backup_region_phdr": {
            "ground_truth": "0",
            "function": "update_backup_region_phdr",
            "description": "update backup region phdr update backup region is offset for the core to export the region appropriately assumes an exclusive program header is setup for the backup region in the elf header return nothing"
        },
        "gpiochip_fwd_create": {
            "ground_truth": "0",
            "function": "gpiochip_fwd_create",
            "description": "gpiochip fwd create create new gpio forwarder this function creates new gpiochip which forward all gpio operation to the passed gpio descriptor"
        },
        "dwc3_event_buffers_setup": {
            "ground_truth": "0",
            "function": "dwc3_event_buffers_setup",
            "description": "dwc3 event buffer setup setup our allocated event buffer return on success otherwise negative errno"
        },
        "mark_clean": {
            "ground_truth": "0",
            "function": "mark_clean",
            "description": "mark clean cache coherent any complete page that were written via dma can be marked a clean so that lazy mmu prot update doe not have to flush them when they get mapped into an executable vm area"
        },
        "fcoe_ctlr_recv_work": {
            "ground_truth": "0",
            "function": "fcoe_ctlr_recv_work",
            "description": "fcoe ctlr recv work worker thread function for receiving fip frame"
        },
        "vgic_its_restore_collection_table": {
            "ground_truth": "0",
            "function": "vgic_its_restore_collection_table",
            "description": "vgic it restore collection table read the collection table in guest memory and restores the it internal state requires the baser register to be restored before"
        },
        "jpeg_codec_sleep": {
            "ground_truth": "0",
            "function": "jpeg_codec_sleep",
            "description": "jpeg codec sleep jpeg codec access"
        },
        "batadv_dbg_ratelimited": {
            "ground_truth": "0",
            "function": "batadv_dbg_ratelimited",
            "description": "batadv dbg ratelimited store debug output with rate limiting"
        },
        "r600_get_allowed_info_register": {
            "ground_truth": "0",
            "function": "r600_get_allowed_info_register",
            "description": "r600 get allowed info register fetch the register for the info ioctl return for success or einval for an invalid register"
        },
        "i40e_mdio_if_number_selection": {
            "ground_truth": "0",
            "function": "i40e_mdio_if_number_selection",
            "description": "i40e mdio if number selection mdio number selection"
        },
        "legacy_probe_add": {
            "ground_truth": "0",
            "function": "legacy_probe_add",
            "description": "legacy probe add add interface to probe list"
        },
        "s3c_fb_align_word": {
            "ground_truth": "0",
            "function": "s3c_fb_align_word",
            "description": "s3c fb align word align pixel count to word boundary align the given pixel count so that it will start on an 32bit word boundary"
        },
        "fc_lport_config": {
            "ground_truth": "0",
            "function": "fc_lport_config",
            "description": "fc lport config configure fc lport"
        },
        "generic_fillattr": {
            "ground_truth": "0",
            "function": "generic_fillattr",
            "description": "generic fillattr fill in the basic attribute from the inode struct fill in the basic attribute in the kstat structure from data that is to be found on the vfs inode structure this is the default if no getattr inode operation is supplied"
        },
        "lpfc_fcpcmd_to_iocb": {
            "ground_truth": "0",
            "function": "lpfc_fcpcmd_to_iocb",
            "description": "lpfc fcpcmd to iocb copy the fcp cmd data into the iocb the routine copy the entire fcp command from fcp cmnd to data while byte swapping the data to big endian format for transmission on the wire"
        },
        "hinic_read_wqe": {
            "ground_truth": "0",
            "function": "hinic_read_wqe",
            "description": "hinic read wqe read wqe ptr in the current ci return wqe pointer"
        },
        "omap_hwmod_lookup": {
            "ground_truth": "0",
            "function": "omap_hwmod_lookup",
            "description": "omap hwmod lookup look up registered omap hwmod by name given name of an omap hwmod return pointer to the registered struct omap hwmod or null upon error"
        },
        "NFP_NET_CFG_ICR_BASE": {
            "ground_truth": "0",
            "function": "NFP_NET_CFG_ICR_BASE",
            "description": "nfp net cfg icr base these register are only used when msi auto masking is not enabled nfp net cfg ctrl msixauto not set the array is index by msi entry and are 1b in size if an entry is zero the corresponding entry is enabled if the fw generates an interrupt it writes cause into the corresponding field this also mask the msi entry and the host driver must clear the register to re enable the interrupt"
        },
        "debugfs_create_file": {
            "ground_truth": "0",
            "function": "debugfs_create_file",
            "description": "debugfs create file create file in the debugfs filesystem this is the basic create file function for debugfs it allows for wide range of flexibility in creating file or directory if you want to create directory the debugfs create dir function is recommended to be used instead this function will return pointer to dentry if it succeeds this pointer must be passed to the debugfs remove function when the file is to be removed no automatic cleanup happens if your module is unloaded you are responsible here if an error occurs err ptr error will be returned if debugfs is not enabled in the kernel the value enodev will be returned"
        },
        "spu2_ctx_max_payload": {
            "ground_truth": "0",
            "function": "spu2_ctx_max_payload",
            "description": "spu2 ctx max payload determine the maximum length of the payload for spu message for given cipher and hash alg context for spu2 the hardware generally ignores the payloadlen field in ctrl3 of fmd and just keep computing until it receives dma descriptor with the eof flag set so we consider the max payload to be infinite aes ccm is an exception"
        },
        "gmap_pte_op_end": {
            "ground_truth": "0",
            "function": "gmap_pte_op_end",
            "description": "gmap pte op end release the page table lock"
        },
        "devm_sigmadsp_init_i2c": {
            "ground_truth": "0",
            "function": "devm_sigmadsp_init_i2c",
            "description": "devm sigmadsp init i2c initialize sigmadsp instance allocates sigmadsp instance and load the specified firmware file return pointer to struct sigmadsp on success or ptr err on error"
        },
        "FPU_get_address": {
            "ground_truth": "0",
            "function": "FPU_get_address",
            "description": "fpu get address mod byte mod ha special use for the fpu sib byte used iff 100b mod opcode sib byte s index base"
        },
        "FSL_MC_OBJ_FLAG_NO_MEM_SHAREABILITY": {
            "ground_truth": "0",
            "function": "FSL_MC_OBJ_FLAG_NO_MEM_SHAREABILITY",
            "description": "fsl mc obj flag no mem shareability object flag indicating no memory shareability the object generates memory access that are non coherent with other master user is responsible for proper memory handling through iommu configuration"
        },
        "exec_drive_taskfile": {
            "ground_truth": "0",
            "function": "exec_drive_taskfile",
            "description": "exec drive taskfile executes taskfile see ide taskfile ioctl for derivation"
        },
        "doc_write_erase_wait_status": {
            "ground_truth": "0",
            "function": "doc_write_erase_wait_status",
            "description": "doc write erase wait status wait for write or erase completion wait for the chip to be ready again after erase or write operation and check erase write status return if erase successful eio if erase write issue etimeout if timeout"
        },
        "sas_release_transport": {
            "ground_truth": "0",
            "function": "sas_release_transport",
            "description": "sa release transport release sa transport template instance"
        },
        "imgu_all_nodes_streaming": {
            "ground_truth": "0",
            "function": "imgu_all_nodes_streaming",
            "description": "imgu all node streamingcheck if all enabled video node are streaming exception ignored"
        },
        "cec_queue_pin_cec_event": {
            "ground_truth": "0",
            "function": "cec_queue_pin_cec_event",
            "description": "cec queue pin cec event queue cec pin event with given timestamp"
        },
        "i2c_smbus_write_byte": {
            "ground_truth": "0",
            "function": "i2c_smbus_write_byte",
            "description": "i2c smbus write byte smbus send byte protocol this executes the smbus send byte protocol returning negative errno else zero on success"
        },
        "rdma_put_gid_attr": {
            "ground_truth": "0",
            "function": "rdma_put_gid_attr",
            "description": "rdma put gid attr release reference to the gid attribute rdma put gid attr must be used to release reference whose reference is acquired using rdma get gid attr or any apis which return pointer to the ib gid attr regardless of link layer of ib or roce"
        },
        "BUILD_BUG_ON": {
            "ground_truth": "0",
            "function": "BUILD_BUG_ON",
            "description": "build bug on break compile if condition is true if you have some code which relies on certain constant being equal or some other compile time evaluated condition you should use build bug on to detect if someone change it"
        },
        "csky_pmu_read_l2rac": {
            "ground_truth": "0",
            "function": "csky_pmu_read_l2rac",
            "description": "csky pmu read read access counter"
        },
        "nand_read_page_swecc": {
            "ground_truth": "0",
            "function": "nand_read_page_swecc",
            "description": "nand read page swecc replaceable software ecc based page read function"
        },
        "fcntl_setlease": {
            "ground_truth": "0",
            "function": "fcntl_setlease",
            "description": "fcntl setlease set lease on an open file"
        },
        "batadv_bla_claim_dump_bucket": {
            "ground_truth": "0",
            "function": "batadv_bla_claim_dump_bucket",
            "description": "batadv bla claim dump bucket dump one bucket of the claim table to netlink socket"
        },
        "late_param_cb": {
            "ground_truth": "0",
            "function": "late_param_cb",
            "description": "late param cb general callback for module cmdline parameter to be evaluated before late initcall level the ops can have null set or get function"
        },
        "simple_strtol": {
            "ground_truth": "0",
            "function": "simple_strtol",
            "description": "simple strtol convert string to signed long this function ha caveat please use kstrtol instead"
        },
        "mpt3sas_transport_port_add": {
            "ground_truth": "0",
            "function": "mpt3sas_transport_port_add",
            "description": "mpt3sas transport port add insert port to the list adding new port object to the sa node sa port list"
        },
        "qib_set_mtu": {
            "ground_truth": "0",
            "function": "qib_set_mtu",
            "description": "qib set mtu set the mtu we can handle any incoming size the issue here is whether we need to restrict our outgoing size for now we do not do any sanity checking on this and we do not deal with what happens to program that are already running when the size change note changing the mtu will usually cause the ibc to go back to link init state"
        },
        "ufshcd_async_scan": {
            "ground_truth": "0",
            "function": "ufshcd_async_scan",
            "description": "ufshcd async scan asynchronous execution for probing hba"
        },
        "nor_erase_prepare": {
            "ground_truth": "0",
            "function": "nor_erase_prepare",
            "description": "nor erase prepare prepare nor flash peb for erasure nor flash or at least some of them have peculiar embedded peb erasure algorithm the peb is first filled with zero then it is erased and filling with zero start from the end of the peb this wa observed with spansion s29gl512n nor flash this mean that in case of power cut we may end up with intact data at the beginning of the peb and all zero at the end of peb in other word the ec and vid header are ok but large chunk of data at the end of peb is zeroed this make ubi mistakenly treat this peb a used and associate it with an leb which lead to subsequent failure ubifs fails this function is called before erasing nor pebs and it zero out ec and vid magic number in order to invalidate them and prevent the failure return zero in case of success and negative error code in case of failure"
        },
        "gru_ktest": {
            "ground_truth": "0",
            "function": "gru_ktest",
            "description": "gru ktest debugging only user hook for various kernel test of driver gru"
        },
        "component_del": {
            "ground_truth": "0",
            "function": "component_del",
            "description": "component del unregister component unregister component added with component add if the component is bound into an aggregate driver this will force the entire aggregate driver including all it component to be unbound"
        },
        "load_powerpc_certs": {
            "ground_truth": "0",
            "function": "load_powerpc_certs",
            "description": "load powerpc cert load the cert contained in the key database into the platform trusted keyring and the blacklisted cert sha256 hash into the blacklist keyring"
        },
        "dfl_fpga_check_port_id": {
            "ground_truth": "0",
            "function": "dfl_fpga_check_port_id",
            "description": "dfl fpga check port id check the port id"
        },
        "gfs2_check_sb": {
            "ground_truth": "0",
            "function": "gfs2_check_sb",
            "description": "gfs2 check sb check superblock check the version code of the f is one that we understand how to read and that the size of the various on disk structure have not changed"
        },
        "amdgpu_unregister_atpx_handler": {
            "ground_truth": "0",
            "function": "amdgpu_unregister_atpx_handler",
            "description": "amdgpu unregister atpx handler unregister with vga switcheroo unregister the px callback with vga switcheroo all asics"
        },
        "find_source_device": {
            "ground_truth": "0",
            "function": "find_source_device",
            "description": "find source device search through device hierarchy for source device return true if found invoked by dpc when error is detected at the root port caller of this function must set id severity and multi error valid of struct aer err info pointed by info properly this function must fill info error dev num and info dev based on the given information"
        },
        "stmmac_reset_queues_param": {
            "ground_truth": "0",
            "function": "stmmac_reset_queues_param",
            "description": "stmmac reset queue param reset queue parameter"
        },
        "lock_anon_vma_root": {
            "ground_truth": "0",
            "function": "lock_anon_vma_root",
            "description": "lock anon vma root this is useful helper function for locking the anon vma root a we traverse the vma anon vma chain looping over anon vma is that have the same vma such anon vma is should have the same root so you would expect to see just single mutex lock for the whole traversal"
        },
        "ice_vf_vlan_offload_ena": {
            "ground_truth": "0",
            "function": "ice_vf_vlan_offload_ena",
            "description": "ice vf vlan offload ena determine if capability support vlan offloads return true if virtchnl vf offload vlan capability is set else return false"
        },
        "sugov_iowait_reset": {
            "ground_truth": "0",
            "function": "sugov_iowait_reset",
            "description": "sugov iowait reset reset the io boost status of cpu the io wait boost of task is disabled after tick since the last update of cpu if new io wait boost is requested after more then tick then we enable the boost starting from iowait boost min which improves energy efficiency by ignoring sporadic wakeups from io"
        },
        "sched_idle_set_state": {
            "ground_truth": "0",
            "function": "sched_idle_set_state",
            "description": "sched idle set state record idle state for the current cpu"
        },
        "__policy_find": {
            "ground_truth": "0",
            "function": "__policy_find",
            "description": "policy find find policy by name on policy list requires rcu read lock be held"
        },
        "devm_extcon_dev_register": {
            "ground_truth": "0",
            "function": "devm_extcon_dev_register",
            "description": "devm extcon dev register resource managed extcon dev register this function that extcon device is automatically unregistered on driver detach internally this function call extcon dev register function to get more information refer that function if extcon device is registered with this function and the device need to be unregistered separately devm extcon dev unregister should be used return if success or negaive error number if failure"
        },
        "memory_map_bottom_up": {
            "ground_truth": "0",
            "function": "memory_map_bottom_up",
            "description": "memory map bottom up map map start map end bottom up this function will setup direct mapping for memory range map start map end in bottom up since we have limited the bottom up allocation above the kernel the page table will be allocated just above the kernel and we map the memory in map start map end in bottom up"
        },
        "uio_unregister_device": {
            "ground_truth": "0",
            "function": "uio_unregister_device",
            "description": "uio unregister device unregister industrial io device"
        },
        "aac_fib_init": {
            "ground_truth": "0",
            "function": "aac_fib_init",
            "description": "aac fib init initialise fib"
        },
        "mei_me_cl_ver": {
            "ground_truth": "0",
            "function": "mei_me_cl_ver",
            "description": "mei me cl ver return me client protocol version"
        },
        "is_cmd_valid": {
            "ground_truth": "0",
            "function": "is_cmd_valid",
            "description": "is cmd valid do sanity check on the input args to dimm control function and return if valid validation of pdsm payload happens later in papr scm service pdsm"
        },
        "debugfs_create_file_unsafe": {
            "ground_truth": "0",
            "function": "debugfs_create_file_unsafe",
            "description": "debugfs create file unsafe create file in the debugfs filesystem debugfs create file unsafe is completely analogous to debugfs create file the only difference being that the fop handed it will not get protected against file removal by the debugfs core it is your responsibility to protect your struct file operation method against file removal by mean of debugfs file get and debugfs file put open is still protected by debugfs though any struct file operation defined by mean of define debugfs attribute is protected against file removal and thus may be used here"
        },
        "strndup_user": {
            "ground_truth": "0",
            "function": "strndup_user",
            "description": "strndup user duplicate an existing string from user space"
        },
        "__nla_reserve_64bit": {
            "ground_truth": "0",
            "function": "__nla_reserve_64bit",
            "description": "nla reserve 64bit reserve room for attribute on the skb and align it add netlink attribute header to socket buffer and reserve room for the payload but doe not copy it it also ensure that this attribute will have bit aligned nla data area the caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload"
        },
        "print_hex_dump_bytes": {
            "ground_truth": "0",
            "function": "print_hex_dump_bytes",
            "description": "print hex dump byte shorthand form of print hex dump with default params call print hex dump with log level of kern debug rowsize of groupsize of and ascii output included"
        },
        "mock_drm_getfile": {
            "ground_truth": "0",
            "function": "mock_drm_getfile",
            "description": "mock drm getfile create new struct file for the drm device this create new struct file that wrap drm file context around drm minor this mimicks userspace opening dev dri card0 but without invoking userspace the struct file may be operated on using it op the drm device driver fop to mimick userspace operation or be supplied to userspace facing function a an internal anonymous client"
        },
        "iscsi_sw_tcp_xmit_qlen": {
            "ground_truth": "0",
            "function": "iscsi_sw_tcp_xmit_qlen",
            "description": "iscsi sw tcp xmit qlen return the number of byte queued for xmit"
        },
        "netlbl_unlhsh_hash": {
            "ground_truth": "0",
            "function": "netlbl_unlhsh_hash",
            "description": "netlbl unlhsh hash hashing function for the hash table this is the hashing function for the unlabeled hash table it return the bucket number for the given device interface the caller is responsible for ensuring that the hash table is protected with either rcu read lock or the hash table lock"
        },
        "ishtp_start": {
            "ground_truth": "0",
            "function": "ishtp_start",
            "description": "ishtp start start ish processing start ishtp processing by sending query subscriber message"
        },
        "ata_acpi_handle_hotplug": {
            "ground_truth": "0",
            "function": "ata_acpi_handle_hotplug",
            "description": "ata acpi handle hotplug acpi event handler backend all acpi bay device realted event end up in this function if the event is port wide dev is null if the event is specific to device dev point to it hotplug a opposed to unplug notification is always handled a port wide while unplug only kill the target device on device wide event locking acpi notify handler context may sleep"
        },
        "scsi_eh_ready_devs": {
            "ground_truth": "0",
            "function": "scsi_eh_ready_devs",
            "description": "scsi eh ready devs check device ready state and recover if not"
        },
        "i40e_get_ethtool_fdir_entry": {
            "ground_truth": "0",
            "function": "i40e_get_ethtool_fdir_entry",
            "description": "i40e get ethtool fdir entry look up filter based on rx flow this function look up filter based on the rx flow classification command and fill the flow spec info for it if found return on success or einval if filter not found"
        },
        "srpt_set_cmd_state": {
            "ground_truth": "0",
            "function": "srpt_set_cmd_state",
            "description": "srpt set cmd state set the state of scsi command doe not modify the state of aborted command return the previous command state"
        },
        "regulator_map_voltage_linear": {
            "ground_truth": "0",
            "function": "regulator_map_voltage_linear",
            "description": "regulator map voltage linear map voltage for simple linear mapping driver providing min uv and uv step in their regulator desc can use this a their map voltage operation"
        },
        "rdma_set_service_type": {
            "ground_truth": "0",
            "function": "rdma_set_service_type",
            "description": "rdma set service type set the type of service associated with connection identifier the type of service is interpretted a differentiated service field rfc the service type should be specified before performing route resolution a existing communication on the connection identifier may be unaffected the type of service requested may not be supported by the network to all destination"
        },
        "pnp_remove_card_device": {
            "ground_truth": "0",
            "function": "pnp_remove_card_device",
            "description": "pnp remove card device remove device from the specified card"
        },
        "mdiobus_register_board_info": {
            "ground_truth": "0",
            "function": "mdiobus_register_board_info",
            "description": "mdiobus register board info register mdio device for given board the board info passed can be marked with initdata but be pointer such a platform data etc are copied a is"
        },
        "sg_mark_end": {
            "ground_truth": "0",
            "function": "sg_mark_end",
            "description": "sg mark end mark the end of the scatterlist mark the passed in sg entry a the termination point for the sg table call to sg next on this entry will return null"
        },
        "genwqe_recovery_on_fatal_gfir_required": {
            "ground_truth": "0",
            "function": "genwqe_recovery_on_fatal_gfir_required",
            "description": "genwqe recovery on fatal gfir required version depended action bitstreams older than have bug where fatal gfirs must be ignored this is true for the bitstream we gave to the card manufacturer but also for some old bitstreams we released to our test lab"
        },
        "sync_Arb_IDs": {
            "ground_truth": "0",
            "function": "sync_Arb_IDs",
            "description": "sync arb id synchronize apic bus arbitration id"
        },
        "cpufreq_cooling_unregister": {
            "ground_truth": "0",
            "function": "cpufreq_cooling_unregister",
            "description": "cpufreq cooling unregister function to remove cpufreq cooling device this interface function unregisters the thermal cpufreq cooling device"
        },
        "bond_3ad_initialize": {
            "ground_truth": "0",
            "function": "bond_3ad_initialize",
            "description": "bond 3ad initialize initialize bond is 3ad parameter and structure can be called only after the mac address of the bond is set"
        },
        "kcsan_set_access_mask": {
            "ground_truth": "0",
            "function": "kcsan_set_access_mask",
            "description": "kcsan set access mask set access mask set the access mask for all access for the current context if non zero only value change to bit set in the mask will be reported"
        },
        "i7core_udimm_check_mc_ecc_err": {
            "ground_truth": "0",
            "function": "i7core_udimm_check_mc_ecc_err",
            "description": "i7core udimm check mc ecc errthis function is based on the device function register a described on intel xeon processor series datasheet volume http www intel com asset pdf datasheet pdf also available at http www arrownac com manufacturer intel nehalem datasheet v2 pdf"
        },
        "i2c_master_recv": {
            "ground_truth": "0",
            "function": "i2c_master_recv",
            "description": "i2c master recv issue single i2c message in master receive mode return negative errno or else the number of byte read"
        },
        "devm_irq_setup_generic_chip": {
            "ground_truth": "0",
            "function": "devm_irq_setup_generic_chip",
            "description": "devm irq setup generic chip setup range of interrupt with generic chip for managed device set up max interrupt starting from gc irq base note this initializes all interrupt to the primary irq chip type and it associated handler"
        },
        "pm_runtime_status_suspended": {
            "ground_truth": "0",
            "function": "pm_runtime_status_suspended",
            "description": "pm runtime status suspended check if runtime pm status is suspended return true if the runtime pm status of dev is rpm suspended or false otherwise regardless of whether or not runtime pm ha been enabled for dev note that the return value of this function can only be trusted if it is called under the runtime pm lock of dev or under condition in which the runtime pm status of dev cannot change"
        },
        "pv_init": {
            "ground_truth": "0",
            "function": "pv_init",
            "description": "pv initprotected virtualization"
        },
        "d_backing_inode": {
            "ground_truth": "0",
            "function": "d_backing_inode",
            "description": "backing inode get upper or lower inode we should be using this is the helper that should be used to get at the inode that will be used if this dentry were to be opened a file the inode may be on the upper dentry or it may be on lower dentry pinned by the upper normal filesystems should not use this to access their own inodes"
        },
        "ata_scsi_slave_destroy": {
            "ground_truth": "0",
            "function": "ata_scsi_slave_destroy",
            "description": "ata scsi slave destroy scsi device is about to be destroyed"
        },
        "ima_appraise_signature": {
            "ground_truth": "0",
            "function": "ima_appraise_signature",
            "description": "ima appraise signature ima appraise signature whether ima will appraise given function using an ima digital signature this is restricted to case where the kernel ha set of built in trusted key in order to avoid an attacker simply loading additional key"
        },
        "scmi_allocate_event_handler": {
            "ground_truth": "0",
            "function": "scmi_allocate_event_handler",
            "description": "scmi allocate event handler allocate event handler allocate an event handler and related notification chain associated with the provided event handler key note that at this point related registered event is still to be associated to this handler descriptor hndl evt null so the handler is initialized a pending"
        },
        "megasas_dump_fusion_io": {
            "ground_truth": "0",
            "function": "megasas_dump_fusion_io",
            "description": "megasas dump fusion io this function will print key detail of scsi io"
        },
        "most_register_component": {
            "ground_truth": "0",
            "function": "most_register_component",
            "description": "most register component register driver component with the core"
        },
        "ibmvfc_set_host_action": {
            "ground_truth": "0",
            "function": "ibmvfc_set_host_action",
            "description": "ibmvfc set host action set the next init action for the host"
        },
        "mem_cgroup_try_charge_swap": {
            "ground_truth": "0",
            "function": "mem_cgroup_try_charge_swap",
            "description": "mem cgroup try charge swap try charging swap space for page try to charge page is memcg for the swap space at entry return on success enomem on failure"
        },
        "pids_can_fork": {
            "ground_truth": "0",
            "function": "pids_can_fork",
            "description": "pid can fork task cs check true in pid can fork and pid cancel fork relies on cgroup threadgroup change begin held by the copy process"
        },
        "hinic_hwdev_ifup": {
            "ground_truth": "0",
            "function": "hinic_hwdev_ifup",
            "description": "hinic hwdev ifup preparing the hw for passing io return success negative failure"
        },
        "term_afu": {
            "ground_truth": "0",
            "function": "term_afu",
            "description": "term afu terminates the afu safe to call with afu mc in partially allocated initialized state"
        },
        "pseries_get_cpu_char": {
            "ground_truth": "0",
            "function": "pseries_get_cpu_char",
            "description": "pseries get cpu char these function check whether the underlying hardware is safe against attack based on observing the effect of speculatively executed instruction and whether it supply instruction for use in workarounds the information come from firmware either via the device tree on powernv platform or from an hcall on pseries platform"
        },
        "zynqmp_pm_is_shutdown_scope_valid": {
            "ground_truth": "0",
            "function": "zynqmp_pm_is_shutdown_scope_valid",
            "description": "zynqmp pm is shutdown scope valid check if shutdown scope string is valid"
        },
        "xudc_handle_setup": {
            "ground_truth": "0",
            "function": "xudc_handle_setup",
            "description": "xudc handle setup process the setup packet process setup packet and delegate to gadget layer"
        },
        "rpcb_v4_register": {
            "ground_truth": "0",
            "function": "rpcb_v4_register",
            "description": "rpcb v4 register set or unset port registration with the local rpcbind return zero if the registration request wa dispatched successfully and the rpcbind daemon returned success otherwise return an errno value that reflects the nature of the error request could not be dispatched timed out or rpcbind returned an error rpc service invoke this function to advertise their contact information via the system is rpcbind daemon rpc service invoke this function once for each program version address netid tuple they wish to advertise caller may also unregister rpc service that are registered at specific address by setting the port number in address to zero they may unregister all registered protocol family at once for service by passing null address argument if netid is then all netids for program version address are unregistered this function us rpcbind protocol version to contact the local rpcbind daemon the local rpcbind daemon must support version of the rpcbind protocol in order for these function to register service successfully supported netids include udp and tcp for udp and tcp over ipv4 and udp6 and tcp6 for udp and tcp over ipv6 respectively the content of address determine the address family and the port to be registered the usual practice is to pas inaddr any a the raw address but specifying non zero address is also supported by this api if the caller wish to advertise an rpc service on specific network interface note that passing in inaddr any doe not create the same service registration a in6addr any the former advertises an rpc service on any ipv4 address but not on ipv6 the latter advertises the service on all ipv4 and ipv6 address"
        },
        "set_segfault": {
            "ground_truth": "0",
            "function": "set_segfault",
            "description": "set segfault set up process info to signal segmentation fault called on access error"
        },
        "netlbl_calipso_remove_cb": {
            "ground_truth": "0",
            "function": "netlbl_calipso_remove_cb",
            "description": "netlbl calipso remove cb netlbl calipso remove callback for remove this function is intended for use by netlbl calipso remove a the callback for the netlbl domhsh walk function it remove lsm domain map entry which are associated with the calipso doi specified in arg return zero on success negative value on failure"
        },
        "ssb_extif_gpio_out": {
            "ground_truth": "0",
            "function": "ssb_extif_gpio_out",
            "description": "ssb extif gpio outextif gpio pin access"
        },
        "mceusb_set_rx_carrier_report": {
            "ground_truth": "0",
            "function": "mceusb_set_rx_carrier_report",
            "description": "mceusb set rx carrier report enable disable receiver carrier frequency pas through reporting only the short range receiver ha carrier frequency measuring capability implicitly select this receiver when enabling carrier frequency reporting"
        },
        "amdtp_domain_init": {
            "ground_truth": "0",
            "function": "amdtp_domain_init",
            "description": "amdtp domain init initialize an amdtp domain structure"
        },
        "__copy_to_user_inatomic": {
            "ground_truth": "0",
            "function": "__copy_to_user_inatomic",
            "description": "copy to user inatomic copy block of data into user space with le checking copy data from kernel space to user space caller must check the specified block with access ok before calling this function the caller should also make sure he pin the user space address so that we do not result in page fault and sleep"
        },
        "check_ept_pointer_match": {
            "ground_truth": "0",
            "function": "check_ept_pointer_match",
            "description": "check ept pointer matchcheck ept pointer should be under protection of ept pointer lock"
        },
        "verity_handle_err": {
            "ground_truth": "0",
            "function": "verity_handle_err",
            "description": "verity handle err handle verification error"
        },
        "acpi_device_wakeup_disable": {
            "ground_truth": "0",
            "function": "acpi_device_wakeup_disable",
            "description": "acpi device wakeup disable disable wakeup functionality for device disable the gpe associated with adev and disable wakeup power for it caller must ensure that adev is valid acpi device node before executing this function"
        },
        "sdma_v5_0_init_microcode": {
            "ground_truth": "0",
            "function": "sdma_v5_0_init_microcode",
            "description": "sdma v5 init microcode load ucode image from disk use the firmware interface to load the ucode image into the driver not loaded into hw return on success error on failure"
        },
        "pdc_stable_initialize": {
            "ground_truth": "0",
            "function": "pdc_stable_initialize",
            "description": "pdc stable initialize set stable storage content to zero and initialize the validity indicator this pdc call will erase all content of stable storage use with care"
        },
        "ps3_gelic_driver_probe": {
            "ground_truth": "0",
            "function": "ps3_gelic_driver_probe",
            "description": "ps3 gelic driver probe add device to the control of this driver"
        },
        "brcms_c_rateset_filter": {
            "ground_truth": "0",
            "function": "brcms_c_rateset_filter",
            "description": "brcms rateset filter copy and selectively filter one rateset to another basic only mean only copy basic rate rate indicates cck 11b and ofdm rate combination cck and ofdm cck only ofdm only xmask is the copy mask typically or"
        },
        "snd_soc_get_enum_double": {
            "ground_truth": "0",
            "function": "snd_soc_get_enum_double",
            "description": "snd soc get enum double enumerated double mixer get callback callback to get the value of double enumerated mixer return for success"
        },
        "nvec_tx_completed": {
            "ground_truth": "0",
            "function": "nvec_tx_completed",
            "description": "nvec tx completed complete the current transfer this is called when we have received an end trans on tx transfer"
        },
        "mmc_wait_for_cmd": {
            "ground_truth": "0",
            "function": "mmc_wait_for_cmd",
            "description": "mmc wait for cmd start command and wait for completion"
        },
        "rio_pw_enable": {
            "ground_truth": "0",
            "function": "rio_pw_enable",
            "description": "rio pw enable enables disables port write handling by master port"
        },
        "cmd64x_sff_irq_check": {
            "ground_truth": "0",
            "function": "cmd64x_sff_irq_check",
            "description": "cmd64x sff irq check check ide interrupt"
        },
        "scsw_cmd_is_valid_pfch": {
            "ground_truth": "0",
            "function": "scsw_cmd_is_valid_pfch",
            "description": "scsw cmd is valid pfch check pfch field validity return non zero if the pfch field of the specified command mode scsw is valid zero otherwise"
        },
        "find_inode_by_ino_rcu": {
            "ground_truth": "0",
            "function": "find_inode_by_ino_rcu",
            "description": "find inode by ino rcu find an inode in the inode cache search for the inode specified by hashval and data in the inode cache where the helper function test will return if the inode doe not match and if it doe the test function must be responsible for taking the lock spin lock and checking state for an inode being freed or being initialized if successful this will return the inode for which the test function returned and null otherwise the test function is not permitted to take ref on any inode presented it is also not permitted to sleep the caller must hold the rcu read lock"
        },
        "br_port_carrier_check": {
            "ground_truth": "0",
            "function": "br_port_carrier_check",
            "description": "br port carrier checkcheck for port carrier transition"
        },
        "sis635_get_mac_addr": {
            "ground_truth": "0",
            "function": "sis635_get_mac_addr",
            "description": "sis635 get mac addr get mac address for sis635 model"
        },
        "ext4_splice_branch": {
            "ground_truth": "0",
            "function": "ext4_splice_branch",
            "description": "ext4 splice branch splice the allocated branch onto inode this function fill the missing link and doe all housekeeping needed in inode block etc in case of success we end up with the full chain to new block and return"
        },
        "cpumask_copy": {
            "ground_truth": "0",
            "function": "cpumask_copy",
            "description": "cpumask copy dstp srcp"
        },
        "nf_tproxy_handle_time_wait6": {
            "ground_truth": "0",
            "function": "nf_tproxy_handle_time_wait6",
            "description": "nf tproxy handle time wait6 handle ipv6 tcp time wait reopen redirections we have to handle syn packet arriving to time wait socket differently instead of reopening the connection we should rather redirect the new connection to the proxy if there is listener socket present nf tproxy handle time wait6 consumes the socket reference passed in return the listener socket if there is one the time wait socket if no such listener is found or null if the tcp header is incomplete"
        },
        "async_gen_syndrome": {
            "ground_truth": "0",
            "function": "async_gen_syndrome",
            "description": "async gen syndrome asynchronously calculate raid6 syndrome general note this routine assumes field of gf with primitive polynomial of and generator of wouldisks note caller can optionally omit either or but not both from the calculation by setting block disk or block disk to null when or is omitted len must be page size a temporary buffer of this size is used in the synchronous path wouldisks always account for both destination buffer if any source buffer block where disk are set to null those buffer will be replaced with the raid6 zero page in the synchronous path and omitted in the hardware asynchronous path"
        },
        "xcan_resume": {
            "ground_truth": "0",
            "function": "xcan_resume",
            "description": "xcan resume resume from suspend resume operation after suspend"
        },
        "rd_module_exit": {
            "ground_truth": "0",
            "function": "rd_module_exit",
            "description": "rd module exitused in target core init configfs for virtual lun access"
        },
        "ibmvscsi_send_srp_event": {
            "ground_truth": "0",
            "function": "ibmvscsi_send_srp_event",
            "description": "ibmvscsi send srp event transforms event to u64 array and call send crq return the value returned from ibmvscsi send crq zero for success note that this routine assumes that host lock is held for synchronization"
        },
        "ahc_set_transaction_status": {
            "ground_truth": "0",
            "function": "ahc_set_transaction_status",
            "description": "ahc set transaction statustransaction access wrapper"
        },
        "batadv_algo_select": {
            "ground_truth": "0",
            "function": "batadv_algo_select",
            "description": "batadv algo select select algorithm of soft interface the algorithm callback for the soft interface will be set when the algorithm with the correct name wa found any previous selected algorithm will not be deinitialized and the new selected algorithm will also not be initialized it is therefore not allowed to call batadv algo select outside the creation function of the soft interface"
        },
        "nanddev_size": {
            "ground_truth": "0",
            "function": "nanddev_size",
            "description": "nanddev size get nand size"
        },
        "batadv_dat_init_own_addr": {
            "ground_truth": "0",
            "function": "batadv_dat_init_own_addr",
            "description": "batadv dat init own addr assign dat address to the node itself"
        },
        "i40e_tx_timeout": {
            "ground_truth": "0",
            "function": "i40e_tx_timeout",
            "description": "i40e tx timeout respond to tx hang if any port ha noticed tx timeout it is likely that the whole device is munged not just the one netdev port so go for the full reset"
        },
        "snd_hda_lock_devices": {
            "ground_truth": "0",
            "function": "snd_hda_lock_devices",
            "description": "snd hda lock device pseudo device locking toggle card shutdown to allow disallow the device access a hack"
        },
        "user_mode": {
            "ground_truth": "0",
            "function": "user_mode",
            "description": "user mode user mode regs determines whether register set came from user mode on x86 this is true if v8086 mode wa enabled or if the register set wa from protected mode with rpl c value this tricky test check that with one comparison on x86 vm86 mode is mercifully nonexistent and we do not need the extra check"
        },
        "trace_seq_bprintf": {
            "ground_truth": "0",
            "function": "trace_seq_bprintf",
            "description": "trace seq bprintf write the printf string from binary argument when recording in fast path printf may be recorded with just saving the format and the argument a they were passed to the function instead of wasting cycle converting the argument into ascii character instead the argument are saved in bit word array that is defined by the format string constraint this function will take the format and the binary array and finish the conversion into the ascii string within the buffer"
        },
        "ice_force_phys_link_state": {
            "ground_truth": "0",
            "function": "ice_force_phys_link_state",
            "description": "ice force phys link state force the physical link state force the physical link state by getting the current phy capability from hardware and setting the phy config based on the determined capability if link change link event will be triggered because both the enable automatic link update and lesm enable bit are set when setting the phy capability return on success negative on failure"
        },
        "iio_chrdev_release": {
            "ground_truth": "0",
            "function": "iio_chrdev_release",
            "description": "iio chrdev release chrdev file close buffer access and ioctls"
        },
        "qcm_process_device": {
            "ground_truth": "0",
            "function": "qcm_process_device",
            "description": "qcm process devicesupport asic specific packet format for pm4 packet"
        },
        "blk_queue_flag_test_and_set": {
            "ground_truth": "0",
            "function": "blk_queue_flag_test_and_set",
            "description": "blk queue flag test and set atomically test and set queue flag return the previous value of flag if the flag wa not set and if the flag wa already set"
        },
        "batadv_nc_get_path": {
            "ground_truth": "0",
            "function": "batadv_nc_get_path",
            "description": "batadv nc get path get existing nc path or allocate new one"
        },
        "alloc_huge_page_vma": {
            "ground_truth": "0",
            "function": "alloc_huge_page_vma",
            "description": "alloc huge page vmamempolicy aware migration callback"
        },
        "drm_fb_helper_sys_read": {
            "ground_truth": "0",
            "function": "drm_fb_helper_sys_read",
            "description": "drm fb helper sys read wrapper around fb sys read wrapper around fb sys read implemented by fbdev core"
        },
        "iavf_print_link_message": {
            "ground_truth": "0",
            "function": "iavf_print_link_message",
            "description": "iavf print link message print link up or down log message telling the world of our wonderous link status"
        },
        "hns_nic_set_link_ksettings": {
            "ground_truth": "0",
            "function": "hns_nic_set_link_ksettings",
            "description": "hn nic set link ksettings implement ethtool set link ksettings"
        },
        "iavf_is_non_eop": {
            "ground_truth": "0",
            "function": "iavf_is_non_eop",
            "description": "iavf is non eop process handling of non eop buffer this function update next to clean if the buffer is an eop buffer this function exit returning false otherwise it will place the sk buff in the next buffer to be chained and return true indicating that this is in fact non eop buffer"
        },
        "usb_ifnum_to_if": {
            "ground_truth": "0",
            "function": "usb_ifnum_to_if",
            "description": "usb ifnum to if get the interface object with given interface number this walk the device descriptor for the currently active configuration to find the interface object with the particular interface number note that configuration descriptor are not required to assign interface number sequentially so that it would be incorrect to assume that the first interface in that descriptor corresponds to interface zero this routine help device driver avoid such mistake however you should make sure that you do the right thing with any alternate setting available for this interface do not call this function unless you are bound to one of the interface on this device or you have locked the device"
        },
        "update_nodemask": {
            "ground_truth": "0",
            "function": "update_nodemask",
            "description": "update nodemask handle user request to change the amems memory placement of cpuset need to validate the request update the cpusets mem allowed and for each task in the cpuset update mem allowed and rebind task is mempolicy and any vma mempolicies and if the cpuset is marked amemory migrate migrate the task page to the new memory call with cpuset mutex held may take callback lock during call will take tasklist lock scan tasklist for task in cpuset c lock each such task mm mmap lock scan it vma is and rebind their mempolicies to the cpusets new mem allowed"
        },
        "mpc52xx_lpbfifo_bcom_irq": {
            "ground_truth": "0",
            "function": "mpc52xx_lpbfifo_bcom_irq",
            "description": "mpc52xx lpbfifo bcom irq irq handler for lpb fifo bestcomm task only used when receiving data"
        },
        "tvp514x_s_frame_interval": {
            "ground_truth": "0",
            "function": "tvp514x_s_frame_interval",
            "description": "tvp514x frame interval v4l2 decoder interface handler configures the decoder to use the input parameter if possible if not possible return the appropriate error code"
        },
        "alloc_set_pte": {
            "ground_truth": "0",
            "function": "alloc_set_pte",
            "description": "alloc set pte setup new pte entry for given page and add reverse page mapping if needed the function allocates page table or use pre allocated caller must take care of unlocking vmf ptl if vmf pte is non null on return target user are page handler itself and implementation of vm ops map page"
        },
        "sym_print_xerr": {
            "ground_truth": "0",
            "function": "sym_print_xerr",
            "description": "sym print xerr print something that tell about extended error"
        },
        "amdgpu_vram_mgr_virt_start": {
            "ground_truth": "0",
            "function": "amdgpu_vram_mgr_virt_start",
            "description": "amdgpu vram mgr virt start update virtual start address calculate virtual bo start address to easily check if everything is cpu accessible"
        },
        "timekeeping_max_deferment": {
            "ground_truth": "0",
            "function": "timekeeping_max_deferment",
            "description": "timekeeping max deferment return max time the clocksource can be deferred"
        },
        "__drm_atomic_helper_bridge_duplicate_state": {
            "ground_truth": "0",
            "function": "__drm_atomic_helper_bridge_duplicate_state",
            "description": "drm atomic helper bridge duplicate state copy atomic bridge state copy atomic state from bridge is current state and reset inferred value this is useful for driver that subclass the bridge state"
        },
        "iceland_ih_decode_iv": {
            "ground_truth": "0",
            "function": "iceland_ih_decode_iv",
            "description": "iceland ih decode iv decode an interrupt vector decodes the interrupt vector at the current rptr position and also advance the position"
        },
        "clk_bulk_get_optional": {
            "ground_truth": "0",
            "function": "clk_bulk_get_optional",
            "description": "clk bulk get optional lookup and obtain number of reference to clock producer behaves the same a clk bulk get except where there is no clock producer in this case instead of returning enoent the function return and null for clk for which clock producer could not be determined"
        },
        "l3_resume_noirq": {
            "ground_truth": "0",
            "function": "l3_resume_noirq",
            "description": "l3 resume noirq resume function for l3 noc we only have the resume handler only since we have already maintained the delta register configuration a part of configuring the system"
        },
        "svc_unregister": {
            "ground_truth": "0",
            "function": "svc_unregister",
            "description": "svc unregister all netids bind address and port registered for program version are removed from the local rpcbind database if the service is not hidden to make way for new instance of the service the result of unregistration is reported via dprintk for those who want verification of the result but is otherwise not important"
        },
        "nanddev_get_ecc_conf": {
            "ground_truth": "0",
            "function": "nanddev_get_ecc_conf",
            "description": "nanddev get ecc conf extract the ecc configuration from nand device"
        },
        "omap_prefetch_enable": {
            "ground_truth": "0",
            "function": "omap_prefetch_enable",
            "description": "omap prefetch enable configures and start prefetch transfer"
        },
        "page_get_anon_vma": {
            "ground_truth": "0",
            "function": "page_get_anon_vma",
            "description": "page get anon vma getting lock on stable anon vma from page off the lru is tricky since there is no serialization what so ever against page remove rmap the best this function can do is return locked anon vma that might have been relevant to this page the page might have been remapped to different anon vma or the anon vma"
        },
        "jfs_rmdir": {
            "ground_truth": "0",
            "function": "jfs_rmdir",
            "description": "jfs rmdir name jfs rmdir dip dentry function remove link to child directory parameter dip parent inode dentry child directory dentry"
        },
        "radeon_atom_pick_pll": {
            "ground_truth": "0",
            "function": "radeon_atom_pick_pll",
            "description": "radeon atom pick pll allocate ppll for use by the crtc return the ppll pixel pll to be used by the crtc for dp monitor single ppll can be used for all dp crtcs encoders for non dp monitor dedicated ppll must be used if particular board ha an external dp pll return atom ppll invalid to skip pll programming a there is no need to program the pll itself if we are not able to allocate pll return atom ppll invalid to skip pll programming to avoid messing up an existing monitor asic specific pll information dce kb kv ppll1 ppll2 are available for all uniphy both dp and non dp ci ppll0 ppll1 ppll2 are available for all uniphy both dp and non dp and dac dce ppll2 is only available to uniphya both dp and non dp ppll0 ppll1 are available for uniphyb both dp and non dp dce ppll0 is available to all uniphy dp only ppll1 ppll2 are available for all uniphy both dp and non dp and dac dce dcpll is available to all uniphy dp only ppll1 ppll2 are available for all uniphy both dp and non dp and dac dce ppll1 ppll2 are available for all uniphy both dp and non dp and dac"
        },
        "radeon_fence_seq_signaled": {
            "ground_truth": "0",
            "function": "radeon_fence_seq_signaled",
            "description": "radeon fence seq signaled check if fence sequence number ha signaled check if the last signaled fence sequnce number is the requested sequence number all asics return true if the fence ha signaled current fence value is requested value or false if it ha not current fence value is the requested value helper function for radeon fence signaled"
        },
        "nla_get_in_addr": {
            "ground_truth": "0",
            "function": "nla_get_in_addr",
            "description": "nla get in addr return payload of ipv4 address attribute"
        },
        "stmpe_reg_write": {
            "ground_truth": "0",
            "function": "stmpe_reg_write",
            "description": "stmpe reg write write single stmpe register"
        },
        "cryp_wait_until_done": {
            "ground_truth": "0",
            "function": "cryp_wait_until_done",
            "description": "cryp wait until done ericsson sa author shujuan chen for st ericsson author jonas linde for st ericsson author niklas hernaeus for st ericsson author joakim bech for st ericsson author berne hebark for st ericsson"
        },
        "ide_acpi_exec_tfs": {
            "ground_truth": "0",
            "function": "ide_acpi_exec_tfs",
            "description": "ide acpi exec tfs get then write drive taskfile setting according to the acpi spec this should be called after stm ha been evaluated for the interface some acpi vendor interpret that a hard requirement and modify the taskfile according to the identify drive information passed down with stm so one should really make sure to call this only after stm ha been executed"
        },
        "myrb_exec_type3D": {
            "ground_truth": "0",
            "function": "myrb_exec_type3D",
            "description": "myrb exec type3d executes type 3d command and wait for completion"
        },
        "drm_rect_downscale": {
            "ground_truth": "0",
            "function": "drm_rect_downscale",
            "description": "drm rect downscale downscale rectangle divide the coordinate of rectangle by horz and vert"
        },
        "dce110_opp_set_clamping": {
            "ground_truth": "0",
            "function": "dce110_opp_set_clamping",
            "description": "dce110 opp set clamping set clamping format based on bpc for 6bpc no clamping for bpc for bpc for bpc for programable enable clamp if limited range requested"
        },
        "qcom_scm_cpu_power_down": {
            "ground_truth": "0",
            "function": "qcom_scm_cpu_power_down",
            "description": "qcom scm cpu power down power down the cpu flag flag to flush cache this is an end point to power down cpu if there wa pending interrupt the control would return from this function otherwise the cpu jump to the warm boot entry point set for this cpu upon reset"
        },
        "zpodd_disable_run_wake": {
            "ground_truth": "0",
            "function": "zpodd_disable_run_wake",
            "description": "zpodd disable run wakedisable runtime wake capability if it is enabled"
        },
        "genwqe_write_vreg": {
            "ground_truth": "0",
            "function": "genwqe_write_vreg",
            "description": "genwqe write vreg write register in virtual window note these register are only accessible to the pf through the vf window it is not intended for the vf to access"
        },
        "i40iw_create_aeq": {
            "ground_truth": "0",
            "function": "i40iw_create_aeq",
            "description": "i40iw create aeq create async event queue return if the aeq and the resource associated with it are successfully created otherwise return error"
        },
        "acpi_unregister_wakeup_handler": {
            "ground_truth": "0",
            "function": "acpi_unregister_wakeup_handler",
            "description": "acpi unregister wakeup handler unregister wakeup handler"
        },
        "procmpt_destroy": {
            "ground_truth": "0",
            "function": "procmpt_destroy",
            "description": "procmpt destroy tear down mpt procfs mptbasedir entry return for success non zero for failure"
        },
        "amdgpu_gmc_filter_faults": {
            "ground_truth": "0",
            "function": "amdgpu_gmc_filter_faults",
            "description": "amdgpu gmc filter fault filter vm fault"
        },
        "atiixp_prereset": {
            "ground_truth": "0",
            "function": "atiixp_prereset",
            "description": "atiixp prereset perform reset handling"
        },
        "wiphy_rfkill_set_hw_state": {
            "ground_truth": "0",
            "function": "wiphy_rfkill_set_hw_state",
            "description": "wiphy rfkill set hw state notify cfg80211 about hw block state"
        },
        "pnp_assign_resources": {
            "ground_truth": "0",
            "function": "pnp_assign_resources",
            "description": "pnp assign resource assigns resource to the device based on the specified dependent number"
        },
        "mlxsw_cmd_access_reg": {
            "ground_truth": "0",
            "function": "mlxsw_cmd_access_reg",
            "description": "mlxsw cmd access regaccess reg access emad supported register opmod inmmod the access reg command support accessing device register this access is mainly used for bootstrapping"
        },
        "mv_print_info": {
            "ground_truth": "0",
            "function": "mv_print_info",
            "description": "mv print info dump key info to kernel log for perusal"
        },
        "mic_read_spad": {
            "ground_truth": "0",
            "function": "mic_read_spad",
            "description": "None"
        },
        "hash_for_each_possible_rcu_notrace": {
            "ground_truth": "0",
            "function": "hash_for_each_possible_rcu_notrace",
            "description": "hash for each possible rcu notrace iterate over all possible object hashing to the same bucket in an rcu enabled hashtable in rcu enabled hashtable this is the same a hash for each possible rcu except that it doe not do any rcu debugging or tracing"
        },
        "do_early_param": {
            "ground_truth": "0",
            "function": "do_early_param",
            "description": "do early paramcheck for early params"
        },
        "quirk_intel_brickland_xeon_ras_cap": {
            "ground_truth": "0",
            "function": "quirk_intel_brickland_xeon_ras_cap",
            "description": "quirk intel brickland xeon ra capivy bridge haswell broadwell"
        },
        "psb_gem_create": {
            "ground_truth": "0",
            "function": "psb_gem_create",
            "description": "psb gem create create mappable object"
        },
        "board_tracer_show": {
            "ground_truth": "0",
            "function": "board_tracer_show",
            "description": "board tracer show board tracer number sysfs aread only shost attribute"
        },
        "tty_kref_put": {
            "ground_truth": "0",
            "function": "tty_kref_put",
            "description": "tty kref put release tty kref"
        },
        "i40e_update_filter_state": {
            "ground_truth": "0",
            "function": "i40e_update_filter_state",
            "description": "i40e update filter state update filter state based on return data from firmware mac filter entry from list were slated to be added to device return number of successful filter note that doe not mean success"
        },
        "bnx2i_ep_ofld_timer": {
            "ground_truth": "0",
            "function": "bnx2i_ep_ofld_timer",
            "description": "bnx2i ep ofld timer post iscsi logout request wqe to hardware routine to handle connection offload destroy request timeout"
        },
        "lpfc_read_lnk_stat": {
            "ground_truth": "0",
            "function": "lpfc_read_lnk_stat",
            "description": "lpfc read lnk stat prepare mailbox command for reading hba link stats the read link status mailbox command is used to read the link status from the hba link status includes all link related error counter these counter are maintained by the hba and originated in the link hardware unit note that all of these counter wrap this routine prepares the mailbox command for reading out hba link status"
        },
        "nvt_hw_detect": {
            "ground_truth": "0",
            "function": "nvt_hw_detect",
            "description": "nvt hw detectdetect hardware feature"
        },
        "drm_prime_gem_destroy": {
            "ground_truth": "0",
            "function": "drm_prime_gem_destroy",
            "description": "drm prime gem destroy helper to clean up prime imported gem object this is the cleanup function which gem driver need to call when they use drm gem prime import or drm gem prime import dev to import dma bufs overview plane represents an image source that can be blended with or overlayed on top of crtc during the scanout process plane take their input data from type drm framebuffer object the plane itself specifies the cropping and scaling of that image and where it is placed on the visible are of display pipeline represented by type drm crtc plane can also have additional property that specify how the pixel are positioned and blended like rotation or position all these property are stored in type drm plane state to create plane km driver allocates and zero an instance of type struct drm plane possibly a part of larger structure and register it with call to drm universal plane init cursor and overlay plane are optional all driver should provide one primary plane per crtc to avoid surprising userspace too much see enum drm plane type for more in depth discussion of these special uapi relevant plane type special plane are associated with their crtc by calling drm crtc init with plane the type of plane is exposed in the immutable type enumeration property which ha one of the following value overlay primary cursor"
        },
        "mpt3sas_base_initialize_callback_handler": {
            "ground_truth": "0",
            "function": "mpt3sas_base_initialize_callback_handler",
            "description": "mpt3sas base initialize callback handler initialize the interrupt callback handler"
        },
        "clear_bit_unlock": {
            "ground_truth": "0",
            "function": "clear_bit_unlock",
            "description": "clear bit unlock clear bit in memory with release clear bit unlock is atomic and may not be reordered it doe contain memory barrier suitable for unlock type operation"
        },
        "tipc_named_publish": {
            "ground_truth": "0",
            "function": "tipc_named_publish",
            "description": "tipc named publish tell other node about new publication by this node"
        },
        "qcom_scm_hdcp_req": {
            "ground_truth": "0",
            "function": "qcom_scm_hdcp_req",
            "description": "qcom scm hdcp req send hdcp request write hdcp register through scm"
        },
        "dce_v10_0_program_watermarks": {
            "ground_truth": "0",
            "function": "dce_v10_0_program_watermarks",
            "description": "dce v10 program watermark program display watermark calculate and program the display watermark for the selected display controller cik"
        },
        "hinic_unregister_vf_mbox_cb": {
            "ground_truth": "0",
            "function": "hinic_unregister_vf_mbox_cb",
            "description": "hinic unregister vf mbox cb unregister the mbox callback for vf"
        },
        "gfs2_glock_nq_num": {
            "ground_truth": "0",
            "function": "gfs2_glock_nq_num",
            "description": "gfs2 glock nq num acquire glock based on lock number"
        },
        "ia64_flush_fph": {
            "ground_truth": "0",
            "function": "ia64_flush_fph",
            "description": "ia64 flush fph write f32 f127 back to task thread fph if it ha been modified"
        },
        "denormal_subd1": {
            "ground_truth": "0",
            "function": "denormal_subd1",
            "description": "denormal subd1ix iy where iy denormal and ix iy"
        },
        "audit_filter_inodes": {
            "ground_truth": "0",
            "function": "audit_filter_inodes",
            "description": "audit filter inodesat syscall exit time this filter is called if any audit name have been collected during syscall processing we only check rule in sublists at hash bucket applicable to the inode number in audit name regarding audit state same rule apply a for audit filter syscall"
        },
        "is_report_browser": {
            "ground_truth": "0",
            "function": "is_report_browser",
            "description": "is report browsercheck whether the browser is for notop or areport"
        },
        "csio_init_link_config": {
            "ground_truth": "0",
            "function": "csio_init_link_config",
            "description": "csio init link config initialize link is sw state"
        },
        "drm_pci_free": {
            "ground_truth": "0",
            "function": "drm_pci_free",
            "description": "drm pci free free pci consistent memory block fixme this is needle abstraction of the linux dma api and should be removed"
        },
        "cbus_transfer": {
            "ground_truth": "0",
            "function": "cbus_transfer",
            "description": "cbus transfer transfer data over the bus"
        },
        "spu_rx_callback": {
            "ground_truth": "0",
            "function": "spu_rx_callback",
            "description": "spu rx callback callback from mailbox framework with spu response"
        },
        "qlogicfas408_detect": {
            "ground_truth": "0",
            "function": "qlogicfas408_detect",
            "description": "detect check if this is qlogic fa"
        },
        "gsm_dlci_open": {
            "ground_truth": "0",
            "function": "gsm_dlci_open",
            "description": "gsm dlci open dlci ha opened"
        },
        "rsi_mac80211_detach": {
            "ground_truth": "0",
            "function": "rsi_mac80211_detach",
            "description": "rsi mac80211 detach this function is used to de initialize the mac80211 stack"
        },
        "intel_calculate_wm": {
            "ground_truth": "0",
            "function": "intel_calculate_wm",
            "description": "intel calculate wm calculate watermark level calculate the watermark level the level at which the display plane will start fetching from memory again each chip ha different display fifo size and allocation so the caller need to figure that out and pas in the correct intel watermark params structure a the pixel clock run the fifo will be drained at rate that depends on the pixel size when it reach the watermark level it will start fetching fifo line sized based chunk from memory until the fifo fill past the watermark point if the fifo drain completely fifo underrun will occur and display engine hang could result"
        },
        "may_change_ptraced_domain": {
            "ground_truth": "0",
            "function": "may_change_ptraced_domain",
            "description": "may change ptraced domain check if can change profile on ptraced task check if current is ptraced and if so if the tracing task is allowed to trace the new domain"
        },
        "evergreen_cs_handle_reg": {
            "ground_truth": "0",
            "function": "evergreen_cs_handle_reg",
            "description": "evergreen c handle reg process register that need special handling"
        },
        "rt2x00queue_free_skb": {
            "ground_truth": "0",
            "function": "rt2x00queue_free_skb",
            "description": "rt2x00queue free skb free skb"
        },
        "fsmc_nand_disable": {
            "ground_truth": "0",
            "function": "fsmc_nand_disable",
            "description": "fsmc nand disable disables the nand bank"
        },
        "key_is_dead": {
            "ground_truth": "0",
            "function": "key_is_dead",
            "description": "key is dead determine whether key is dead"
        },
        "spufs_coredump_extra_notes_write": {
            "ground_truth": "0",
            "function": "spufs_coredump_extra_notes_write",
            "description": "spufs coredump extra note writeelf coredump callback for writing spu elf note"
        },
        "pcxhr_init_rmh": {
            "ground_truth": "0",
            "function": "pcxhr_init_rmh",
            "description": "pcxhr init rmh initialize the rmh instance"
        },
        "ice_flow_rem_entry": {
            "ground_truth": "0",
            "function": "ice_flow_rem_entry",
            "description": "ice flow rem entry remove flow entry"
        },
        "drm_property_flags_valid": {
            "ground_truth": "0",
            "function": "drm_property_flags_valid",
            "description": "drm property flag valid doc overview property a represented by drm property are used to extend the modeset interface exposed to userspace for the atomic modeset ioctl property are even the only way to transport metadata about the desired new modeset configuration from userspace to the kernel property have well defined value range which is enforced by the drm core see the documentation of the flag member of struct drm property for an overview of the different property type and range property do not store the current value directly but need to be instatiated by attaching them to drm mode object with drm object attach property property value are only 64bit to support bigger pile of data like gamma table color correction matrix or large structure property can instead point at drm property blob with that additional data property are defined by their symbolic name userspace must keep per object mapping from those name to the property id used in the atomic ioctl and in the get set property ioctl"
        },
        "sys_membarrier": {
            "ground_truth": "0",
            "function": "sys_membarrier",
            "description": "sys membarrier issue memory barrier on set of thread if this system call is not implemented enosys is returned if the command specified doe not exist not available on the running kernel or if the command argument is invalid this system call return einval for given command with flag argument set to if this system call return enosys or einval it is guaranteed to always return the same value until reboot in addition it can return enomem if there is not enough memory available to perform the system call all memory access performed in program order from each targeted thread is guaranteed to be ordered with respect to sys membarrier if we use the semantic barrier to represent compiler barrier forcing memory access to be performed in program order across the barrier and smp mb to represent explicit memory barrier forcing full memory ordering across the barrier we have the following ordering table for each pair of barrier sys membarrier and smp mb the pair ordering is detailed a ordered not ordered barrier smp mb sys membarrier barrier smp mb sys membarrier"
        },
        "i40e_set_rxnfc": {
            "ground_truth": "0",
            "function": "i40e_set_rxnfc",
            "description": "i40e set rxnfc command to set rx flow classification rule return success if the command is supported"
        },
        "setid_policy_lookup": {
            "ground_truth": "0",
            "function": "setid_policy_lookup",
            "description": "setid policy lookup compute decision for transition from src to dst under the active policy"
        },
        "stm32h7_adc_restore_selfcalib": {
            "ground_truth": "0",
            "function": "stm32h7_adc_restore_selfcalib",
            "description": "stm32h7 adc restore selfcalib restore saved self calibration result"
        },
        "bcom_get_bd": {
            "ground_truth": "0",
            "function": "bcom_get_bd",
            "description": "bcom get bd get bd from the queue"
        },
        "nvdimm_allocated_dpa": {
            "ground_truth": "0",
            "function": "nvdimm_allocated_dpa",
            "description": "nvdimm allocated dpa sum up the dpa currently allocated to this label id"
        },
        "pids_charge": {
            "ground_truth": "0",
            "function": "pids_charge",
            "description": "pid charge hierarchically charge the pid count this function doe not follow the pid limit set it cannot fail and the new pid count may exceed the limit this is only used for reverting failed attache where there is no other way out than violating the limit"
        },
        "napi_rx_handler": {
            "ground_truth": "0",
            "function": "napi_rx_handler",
            "description": "napi rx handler the napi handler for rx processing"
        },
        "i40iw_reg_user_mr": {
            "ground_truth": "0",
            "function": "i40iw_reg_user_mr",
            "description": "i40iw reg user mr register user memory region"
        },
        "igb_set_fc_watermarks": {
            "ground_truth": "0",
            "function": "igb_set_fc_watermarks",
            "description": "igb set fc watermark set flow control high low watermark"
        },
        "i40iw_get_used_rsrc": {
            "ground_truth": "0",
            "function": "i40iw_get_used_rsrc",
            "description": "i40iw get used rsrc determine resource used internally called after internal allocation"
        },
        "parport_write": {
            "ground_truth": "0",
            "function": "parport_write",
            "description": "parport write write block of data to parallel port"
        },
        "recover_peb": {
            "ground_truth": "0",
            "function": "recover_peb",
            "description": "recover peb recover from write failure this function is called in case of write failure and move all good data from the potentially bad physical eraseblock to good physical eraseblock this function also writes the data which wa not written due to the failure return in case of success and negative error code in case of failure this function try ubi io retries before giving up"
        },
        "i40e_ptp_rx_hwtstamp": {
            "ground_truth": "0",
            "function": "i40e_ptp_rx_hwtstamp",
            "description": "i40e ptp rx hwtstamp utility function which check for an rx timestamp the xl710 receives notification in the receive descriptor with an offset into the set of rxtime register where the timestamp is for that skb this function go and fetch the receive timestamp from that offset if valid one exists the rxtime register are in n so we must convert the result first"
        },
        "drm_get_unmapped_area": {
            "ground_truth": "0",
            "function": "drm_get_unmapped_area",
            "description": "drm get unmapped area get an unused user space virtual memory area suitable for huge page table entry this function attempt to find an unused user space virtual memory area that can accommodate the size we want to map and that is properly aligned to facilitate huge page table entry matching actual huge page or huge page aligned memory in buffer object buffer object are assumed to start at huge page boundary pfns io memory or be populated by huge page aligned to the start of the buffer object system or coherent memory adapted from shmem get unmapped area"
        },
        "rio_std_route_clr_table": {
            "ground_truth": "0",
            "function": "rio_std_route_clr_table",
            "description": "rio std route clr table clear swotch route table using standard register defined in rio specification rev"
        },
        "scsi_eh_completed_normally": {
            "ground_truth": "0",
            "function": "scsi_eh_completed_normally",
            "description": "scsi eh completed normally disposition eh cmd on return from lld"
        },
        "sg_init_marker": {
            "ground_truth": "0",
            "function": "sg_init_marker",
            "description": "sg init marker initialize marker in sg table"
        },
        "message_store": {
            "ground_truth": "0",
            "function": "message_store",
            "description": "message store write new message via sysfs write new message to display or scroll across the lcd display from sysfs"
        },
        "__rdtgroup_cbm_overlaps": {
            "ground_truth": "0",
            "function": "__rdtgroup_cbm_overlaps",
            "description": "rdtgroup cbm overlap doe cbm for intended closid overlap with other check if provided cbm intended to be used for closid on domain overlap with any other closids or other hardware usage associated with this domain if exclusive is true then only overlap with resource group in exclusive mode will be considered if exclusive is false then overlap with any resource group or hardware entity will be considered cbm is unsigned long even if only bit are used to make the bitmap function work correctly"
        },
        "b43_phy_shm_tssi_read": {
            "ground_truth": "0",
            "function": "b43_phy_shm_tssi_read",
            "description": "b43 phy shm tssi read read the average of the last tssi from shm return the average of the tssi value or negative error code"
        },
        "iowait_get_tid_work": {
            "ground_truth": "0",
            "function": "iowait_get_tid_work",
            "description": "iowait get tid work return iowait work for tid se"
        },
        "kvm_pmi_trigger_fn": {
            "ground_truth": "0",
            "function": "kvm_pmi_trigger_fn",
            "description": "kvm pmi trigger fnnote each perf counter is defined a struct kvm pmc there are two type of perf counter general purpose gp and fixed gp counter are stored in gp counter and fixed counter are stored in fixed counter respectively both of them are part of struct kvm pmu pmu understands the difference between gp counter and fixed counter however amd doe not support fixed counter there are three type of index to access perf counter pmc msr named msr for example intel ha msr ia32 perfctrn and amd ha msr k7 perfctrn msr index named idx this normally is used by rdpmc instruction for instance amd rdpmc instruction us 0003h in ecx to access c001 0007h msr k7 perctr3 intel ha similar mechanism except that it also support fixed counter idx can be used to a index to gp and fixed counter global pmc index named pmc pmc is an index specific to pmu code each pmc stored in kvm pmc idx field is unique across all perf counter both gp and fixed the mapping relationship between pmc and perf counter is a the following intel intel pmc max generic gp counter intel pmc idx fixed intel pmc idx fixed fixed amd amd64 num counter gp counter"
        },
        "strim": {
            "ground_truth": "0",
            "function": "strim",
            "description": "strim remove leading and trailing whitespace from note that the first trailing whitespace is replaced with nul terminator in the given string return pointer to the first non whitespace character in"
        },
        "pseries_power_off": {
            "ground_truth": "0",
            "function": "pseries_power_off",
            "description": "pseries power off tell firmware about how to power off the system this function call either the power off rtas token in normal case or the ibm power off ups token if present requested in case of power failure if power off token is used power on will only be possible with power button press if ibm power off ups token is used it will allow auto poweron after power is restored"
        },
        "img_ir_decoder_preprocess": {
            "ground_truth": "0",
            "function": "img_ir_decoder_preprocess",
            "description": "img ir decoder preprocess preprocess timing in decoder ensures that the symbol timing range are valid with respect to ordering and doe some fixed conversion on them"
        },
        "ns_cmp": {
            "ground_truth": "0",
            "function": "ns_cmp",
            "description": "n cmp compare n for label set ordering"
        },
        "drm_dp_mst_topology_mgr_set_mst": {
            "ground_truth": "0",
            "function": "drm_dp_mst_topology_mgr_set_mst",
            "description": "drm dp mst topology mgr set mst set the mst state for topology manager this is called by the driver when it detects an mst capable device plugged into dp mst capable port or when dp mst capable device is unplugged"
        },
        "ixgbe_start_mac_link_82599": {
            "ground_truth": "0",
            "function": "ixgbe_start_mac_link_82599",
            "description": "ixgbe start mac link setup mac link setting"
        },
        "i40e_vsi_setup": {
            "ground_truth": "0",
            "function": "i40e_vsi_setup",
            "description": "i40e vsi setup set up vsi by given type this allocates the sw vsi structure and it queue resource then add vsi to the identified veb return pointer to the successfully allocated and configure vsi sw struct on success otherwise return null on failure"
        },
        "phy_validate": {
            "ground_truth": "0",
            "function": "phy_validate",
            "description": "phy validate check the phy parameter used to check that the current set of parameter can be handled by the phy implementation are free to tune the parameter passed a argument if needed by some implementation detail or constraint it will not change any actual configuration of the phy so calling it a many time a deemed fit will have no side effect"
        },
        "btrfs_reserve_metadata_bytes": {
            "ground_truth": "0",
            "function": "btrfs_reserve_metadata_bytes",
            "description": "btrfs reserve metadata byte try to reserve byte from the block rsv is space root the root we are allocating for block rsv the block rsv we are allocating for orig byte the number of byte we want flush whether or not we can flush to make our reservation this will reserve orig byte number of byte from the space info associated with the block rsv if there is not enough space it will make an attempt to flush out space to make room it will do this by flushing delalloc if possible or committing the transaction if flush is then no attempt to regain reservation will be made and this will fail if there is not enough space already"
        },
        "printf": {
            "ground_truth": "0",
            "function": "printf",
            "description": "printfthese are all user mode thing which are convenient to call directly from kernel code and for which writing wrapper is too much of pain the regular include file can not be included because this file is included only into kernel code and user space includes conflict with kernel includes"
        },
        "tep_find_field": {
            "ground_truth": "0",
            "function": "tep_find_field",
            "description": "tep find field find non common field return non common field by the given name this doe not search common field"
        },
        "w_send_dblock": {
            "ground_truth": "0",
            "function": "w_send_dblock",
            "description": "send dblock worker callback to send data packet in order to mirror write request"
        },
        "ext4_inc_count": {
            "ground_truth": "0",
            "function": "ext4_inc_count",
            "description": "ext4 inc count set directory link count to if nlinks ext4 link max or if nlinks since this indicates that nlinks count wa previously to avoid overflowing the bit link count field on disk directory with nlink mean that subdirectory link count are not being maintained accurately the caller ha already checked for nlink overflow in case the dir link feature is not enabled and returned emlink the is dx check is proxy for checking isdir inode since the inode index feature will not be set on regular file and to avoid creating huge slow non htree directory"
        },
        "check_acpi_cpu_flag": {
            "ground_truth": "0",
            "function": "check_acpi_cpu_flag",
            "description": "check acpi cpu flag determine if cpu node ha flag set check the node representing cpu for given flag"
        },
        "batadv_gw_node_free": {
            "ground_truth": "0",
            "function": "batadv_gw_node_free",
            "description": "batadv gw node free free gateway information from soft interface"
        },
        "vti6_dev_setup": {
            "ground_truth": "0",
            "function": "vti6_dev_setup",
            "description": "vti6 dev setup setup virtual tunnel device initialize function pointer and device parameter"
        },
        "workqueue_select_cpu_near": {
            "ground_truth": "0",
            "function": "workqueue_select_cpu_near",
            "description": "workqueue select cpu near select cpu based on numa node this function will attempt to find random cpu available on given node if there are no cpu available on the given node it will return work cpu unbound indicating that we should just schedule to any available cpu if we need to schedule this work"
        },
        "tomoyo_path_chown": {
            "ground_truth": "0",
            "function": "tomoyo_path_chown",
            "description": "tomoyo path chown target for security path chown return on success negative value otherwise"
        },
        "cfg80211_pmksa_candidate_notify": {
            "ground_truth": "0",
            "function": "cfg80211_pmksa_candidate_notify",
            "description": "cfg80211 pmksa candidate notify notify about pmksa caching candidate"
        },
        "i40iw_cq_poll_completion": {
            "ground_truth": "0",
            "function": "i40iw_cq_poll_completion",
            "description": "i40iw cq poll completion get cq completion info"
        },
        "set_key_size_aes": {
            "ground_truth": "0",
            "function": "set_key_size_aes",
            "description": "set key size aes set aes key size"
        },
        "ishtp_cl_connect": {
            "ground_truth": "0",
            "function": "ishtp_cl_connect",
            "description": "ishtp cl connect send connect request to firmware send connect request for client to firmware if successful it will rx and tx ring buffer"
        },
        "regulator_unlock": {
            "ground_truth": "0",
            "function": "regulator_unlock",
            "description": "regulator unlock unlock single regulator this function unlocks the mutex when the reference counter reach"
        },
        "scsw_cmd_is_valid_cstat": {
            "ground_truth": "0",
            "function": "scsw_cmd_is_valid_cstat",
            "description": "scsw cmd is valid cstat check cstat field validity return non zero if the cstat field of the specified command mode scsw is valid zero otherwise"
        },
        "cleancache_init_fs": {
            "ground_truth": "0",
            "function": "cleancache_init_fs",
            "description": "cleancache init f the shim layer provided by these inline function allows the compiler to reduce all cleancache hook to nothingness if config cleancache is disabled to single global variable check if config cleancache is enabled but no cleancache backend ha dynamically enabled it and for the most frequent cleancache ops to single global variable check plus superblock element comparison if config cleancache is enabled and cleancache backend ha dynamically enabled cleancache but the filesystem referenced by that cleancache op ha not enabled cleancache a result config cleancache can be enabled by default with essentially no measurable performance impact"
        },
        "iwl_mvm_tx_protection": {
            "ground_truth": "0",
            "function": "iwl_mvm_tx_protection",
            "description": "iwl mvm tx protection ask fw to enable rts ct protection"
        },
        "alloc_idx_lebs": {
            "ground_truth": "0",
            "function": "alloc_idx_lebs",
            "description": "alloc idx lebs allocate empty lebs to be used to commit this function return enospc if it cannot allocate sufficient number of empty lebs is returned on success otherwise negative error code is returned"
        },
        "lpfc_sli4_nvmet_xri_aborted": {
            "ground_truth": "0",
            "function": "lpfc_sli4_nvmet_xri_aborted",
            "description": "lpfc sli4 nvmet xri aborted fast path process of nvmet xri abort this routine is invoked by the worker thread to process sli4 fast path nvmet aborted xri"
        },
        "pci_clear_master": {
            "ground_truth": "0",
            "function": "pci_clear_master",
            "description": "pci clear master disables bus mastering for device dev"
        },
        "ab8500_charger_set_output_curr": {
            "ground_truth": "0",
            "function": "ab8500_charger_set_output_curr",
            "description": "ab8500 charger set output curr set charger output current set charger output current return error code in case of failure else on success"
        },
        "xs_udp_data_read_skb": {
            "ground_truth": "0",
            "function": "xs_udp_data_read_skb",
            "description": "x udp data read skb receive callback for udp socket"
        },
        "hash_for_each_safe": {
            "ground_truth": "0",
            "function": "hash_for_each_safe",
            "description": "hash for each safe iterate over hashtable safe against removal of hash entry"
        },
        "system_trusted_keyring_init": {
            "ground_truth": "0",
            "function": "system_trusted_keyring_init",
            "description": "system trusted keyring init create the trusted keyrings"
        },
        "ubi_get_device": {
            "ground_truth": "0",
            "function": "ubi_get_device",
            "description": "ubi get device get ubi device this function return ubi device description object for ubi device number ubi num or null if the device doe not exist this function increase the device reference count to prevent removal of the device in other word the device cannot be removed if it reference count is not zero"
        },
        "ixgbe_reset_cs4227": {
            "ground_truth": "0",
            "function": "ixgbe_reset_cs4227",
            "description": "ixgbe reset cs4227 reset cs4227 using port expander this function assumes that the caller ha acquired the proper semaphore return error code"
        },
        "disk_get_part": {
            "ground_truth": "0",
            "function": "disk_get_part",
            "description": "disk get part get partition look for partition partno from disk if found increment reference count and return it"
        },
        "db8500_prcmu_system_reset": {
            "ground_truth": "0",
            "function": "db8500_prcmu_system_reset",
            "description": "db8500 prcmu system reset system reset save the reset reason code and then set the ape softrst register which fire interrupt to fw"
        },
        "d_test": {
            "ground_truth": "0",
            "function": "d_test",
            "description": "test return true if debugging should be enabled if the master debug switch is enabled and the current setting are higher or equal to the requested level then debugging output action should be enabled this need to be coded so that it can be evaluated in compile time this is why the ugly bug on is placed in there so the master evaluation compiles all out if it is compile time false note"
        },
        "af_alg_get_rsgl": {
            "ground_truth": "0",
            "function": "af_alg_get_rsgl",
            "description": "af alg get rsgl create the rx sgl for the output data from the crypto operation sk socket of connection to user space msg user space message flag flag used to invoke recvmsg with areq instance of the cryptographic request that will hold the rx sgl maxsize maximum number of byte to be pulled from user space outlen number of byte in the rx sgl return on success upon error"
        },
        "rpc_xprt_switch_add_xprt": {
            "ground_truth": "0",
            "function": "rpc_xprt_switch_add_xprt",
            "description": "rpc xprt switch add xprt add new rpc xprt to an rpc xprt switch add xprt to the end of the list of struct rpc xprt in xps"
        },
        "wl3501_reset": {
            "ground_truth": "0",
            "function": "wl3501_reset",
            "description": "wl3501 reset reset the sutro it is almost the same a wl3501 open in fact we may just wl3501 close and wl3501 open again but would not like to free irq when the driver is running it seems to be dangerous"
        },
        "vpif_update_std_info": {
            "ground_truth": "0",
            "function": "vpif_update_std_info",
            "description": "vpif update std info update standard related info for given standard selected by application update value in the device data structure"
        },
        "batadv_tt_global_dump": {
            "ground_truth": "0",
            "function": "batadv_tt_global_dump",
            "description": "batadv tt global dump dump tt global entry into message"
        },
        "skb_flow_get_icmp_tci": {
            "ground_truth": "0",
            "function": "skb_flow_get_icmp_tci",
            "description": "skb flow get icmp tci extract icmp type code and identifier field"
        },
        "cnt32_to_63": {
            "ground_truth": "0",
            "function": "cnt32_to_63",
            "description": "cnt32 to expand bit counter to bit counter many hardware clock counter are only bit wide and therefore have relatively short period making wrap arounds rather frequent this is problem when implementing sched clock for example where bit non wrapping monotonic value is expected to be returned to overcome that limitation let is extend bit counter to bit in completely lock free fashion bit to of the clock are provided by the hardware while bit to are stored in memory the top bit in memory is used to synchronize with the hardware clock half period when the top bit of both counter hardware and in memory differ then the memory is updated with new value incrementing it when the hardware counter wrap around because word store in memory is atomic then the incremented value will always be in synch with the top bit indicating to any potential concurrent reader if the value in memory is up to date or not with regard to the needed increment and any race in updating the value in memory is harmless a the same value would simply be stored more than once the restriction for the algorithm to work properly are this code must be called at least once per each half period of the bit counter this code must not be preempted for duration longer than the bit counter half period minus the longest period between two call to this code those requirement ensure proper update to the state bit in memory this is usually not problem in practice but if it is then kernel timer should be scheduled to manage for this code to be executed often enough and finally the cnt lo argument must be seen a globally incrementing value meaning that it should be direct reference to the counter data which can be evaluated according to specific ordering within the macro and not the result of previous evaluation stored in variable for example this is wrong u32 partial get hw count u64 full cnt32 to partial return full this is fine u64 full cnt32 to get hw count return full note that the top bit bit in the returned value should be considered a garbage it is not cleared here because caller are likely to use multiplier on the returned value which can get rid of the top bit implicitly by making the multiplier even therefore saving on runtime clear bit instruction otherwise caller must remember to clear the top bit explicitly"
        },
        "of_map_id": {
            "ground_truth": "0",
            "function": "of_map_id",
            "description": "of map id translate an id through downstream mapping given device id look up the appropriate implementation defined platform id and or the target device which receives transaction on that id a per the iommu map and msi map binding either of target or id out may be null if only the other is required if target point to non null device node pointer only entry targeting that node will be matched if it point to null value it will receive the device node of the first matching target phandle with reference held"
        },
        "pxm_to_online_node": {
            "ground_truth": "0",
            "function": "pxm_to_online_node",
            "description": "pxm to online node map proximity id to online node this is similar to pxm to node but always return an online node when the mapped node from given proximity id is offline it look up the node distance table and return the nearest online node acpi device driver which are called after the numa initialization ha completed in the kernel can call this interface to obtain their device numa topology from acpi table such driver do not have to deal with offline node node may be offline when srat memory entry doe not exist or numa is disabled ex numa off on x86"
        },
        "amd_iommu_bind_pasid": {
            "ground_truth": "0",
            "function": "amd_iommu_bind_pasid",
            "description": "amd iommu bind pasid bind given task to pasid on device the function return on success or negative value on error"
        },
        "do_splice_direct": {
            "ground_truth": "0",
            "function": "do_splice_direct",
            "description": "do splice direct splice data directly between two file for use by do sendfile splice can easily emulate sendfile but doing it in the application would incur an extra system call splice in splice out a compared to just sendfile so this helper can splice directly through process private pipe"
        },
        "kvm_pgtable_stage2_is_young": {
            "ground_truth": "0",
            "function": "kvm_pgtable_stage2_is_young",
            "description": "kvm pgtable stage2 is young test whether page table entry ha the access flag set the offset of addr within page is ignored"
        },
        "spurious_kernel_fault": {
            "ground_truth": "0",
            "function": "spurious_kernel_fault",
            "description": "spurious kernel fault handle spurious fault caused by stale tlb entry this allows u to lazily refresh the tlb when increasing the permission of kernel page ro rw or nx doing it eagerly is very expensive since that implies doing full cross processor tlb flush even if no stale tlb entry exist on other processor spurious fault may only occur if the tlb contains an entry with fewer permission than the page table entry non present and reserved bit fault are never spurious there are no security implication to leaving stale tlb when increasing the permission on page"
        },
        "tep_test_flag": {
            "ground_truth": "0",
            "function": "tep_test_flag",
            "description": "tep test flag check the state of event parser flag this return the state of the requested tep flag"
        },
        "sci_controller_reset": {
            "ground_truth": "0",
            "function": "sci_controller_reset",
            "description": "sci controller reset this method will reset the supplied core controller regardless of the state of said controller this operation is considered destructive in other word all current operation are wiped out no io completion for outstanding device occur outstanding io request are not aborted or completed at the actual remote device indicate if the controller reset method succeeded or failed in some way sci success if the reset operation successfully started sci fatal error if the controller reset operation is unable to complete"
        },
        "adfs_notify_change": {
            "ground_truth": "0",
            "function": "adfs_notify_change",
            "description": "adfs notify change validate and convert changed access mode time to their adfs equivalent adfs write inode will actually write the information back to the directory later"
        },
        "iort_dev_find_its_id": {
            "ground_truth": "0",
            "function": "iort_dev_find_its_id",
            "description": "iort dev find it id find the it identifier for device"
        },
        "hdlc_ioctl": {
            "ground_truth": "0",
            "function": "hdlc_ioctl",
            "description": "hdlc ioctlcalled by hardware driver when user request hdlc service"
        },
        "qib_7322_init_hwerrors": {
            "ground_truth": "0",
            "function": "qib_7322_init_hwerrors",
            "description": "qib init hwerrors enable hardware error now that we have finished initializing everything that might reasonably cause hardware error and cleared those error bit a they occur we can enable hardware error in the mask potentially enabling freeze mode and enable hardware error a error along with everything else in errormask"
        },
        "rt_mutex_proxy_unlock": {
            "ground_truth": "0",
            "function": "rt_mutex_proxy_unlock",
            "description": "rt mutex proxy unlock release lock on behalf of owner no locking caller ha to do serializing itself special api call for pi futex support this merrily clean up the rtmutex debugging state concurrent operation on this rt mutex are not possible because it belongs to the pi state which is about to be freed and it is not longer visible to other task"
        },
        "dma_pool_destroy": {
            "ground_truth": "0",
            "function": "dma_pool_destroy",
            "description": "dma pool destroy destroys pool of dma memory block caller guarantee that no more memory from the pool is in use and that nothing will try to use the pool after this call"
        },
        "vio_cmo_set_dev_desired": {
            "ground_truth": "0",
            "function": "vio_cmo_set_dev_desired",
            "description": "vio cmo set dev desired set desired entitlement for device for use by device to request change to their entitlement at runtime or through sysfs the desired entitlement level is changed and balancing of system resource is scheduled to run in the future"
        },
        "yenta_fixup_parent_bridge": {
            "ground_truth": "0",
            "function": "yenta_fixup_parent_bridge",
            "description": "yenta fixup parent bridge fix subordinate bus of the parent bridge check if device on the bus which the cardbus bridge bridge to would be invisible during pci scan because of misconfigured subordinate number of the parent brige some bioses seem to be too lazy to set it right doe the fixup carefully by checking how far it can go without conflict see http bugzilla kernel org show bug cgi id for more information"
        },
        "ice_fltr_remove_vlan_list": {
            "ground_truth": "0",
            "function": "ice_fltr_remove_vlan_list",
            "description": "ice fltr remove vlan list remove list of vlan filter"
        },
        "cipso_v4_cache_add": {
            "ground_truth": "0",
            "function": "cipso_v4_cache_add",
            "description": "cipso v4 cache add add an entry to the cipso cache add new entry into the cipso label mapping cache add the new entry to head of the cache bucket is list if the cache bucket is out of room remove the last entry in the list first it is important to note that there is currently no checking for duplicate key return zero on success negative value on failure"
        },
        "jent_rct_insert": {
            "ground_truth": "0",
            "function": "jent_rct_insert",
            "description": "jent rct insert 90b section ec in reference to entropy collector stuck in indicator whether the value is stuck"
        },
        "cgroup_update_dfl_csses": {
            "ground_truth": "0",
            "function": "cgroup_update_dfl_csses",
            "description": "cgroup update dfl cs update cs assoc of subtree in default hierarchy cgrp is control mask have changed and it subtree is cs association need to be updated accordingly this function look up all cs set which are attached to the subtree creates the matching updated cs set and migrates the task to the new one"
        },
        "lpfc_host_attrib_init": {
            "ground_truth": "0",
            "function": "lpfc_host_attrib_init",
            "description": "lpfc host attrib init initialize scsi host attribute on fc port this routine initializes given scsi host attribute on fc port the scsi host can be either on top of physical port or virtual port"
        },
        "sk_assign_eexist": {
            "ground_truth": "0",
            "function": "sk_assign_eexist",
            "description": "sk assign eexistcheck that bpf sk assign return eexist if socket already selected"
        },
        "xfs_dir2_data_check_new_free": {
            "ground_truth": "0",
            "function": "xfs_dir2_data_check_new_free",
            "description": "xfs dir2 data check new freesanity check new bestfree entry"
        },
        "octeon_cf_tf_load16": {
            "ground_truth": "0",
            "function": "octeon_cf_tf_load16",
            "description": "octeon cf tf load16 true ide only the device addr is not loaded we do this a part of octeon cf exec command16"
        },
        "fc_exch_pool_reset": {
            "ground_truth": "0",
            "function": "fc_exch_pool_reset",
            "description": "fc exch pool reset reset per cpu exchange pool reset per cpu exches pool releasing all of it sequence and exchange if sid is non zero then reset only exchange we sourced from the local port is fid if did is non zero then only reset exchange destined for the local port is fid"
        },
        "ne_enclave_ioctl": {
            "ground_truth": "0",
            "function": "ne_enclave_ioctl",
            "description": "ne enclave ioctl ioctl function provided by the enclave file"
        },
        "atapi_check_dma": {
            "ground_truth": "0",
            "function": "atapi_check_dma",
            "description": "atapi check dma check whether atapi dma can be supported"
        },
        "component_add_typed": {
            "ground_truth": "0",
            "function": "component_add_typed",
            "description": "component add typed register component register new component for dev function in ops will be call when the aggregate driver is ready to bind the overall driver by calling component bind all see also type struct component ops subcomponent must be nonzero and is used to differentiate between multiple component registerd on the same device dev these component are match using component match add typed the component need to be unregistered at driver unload disconnect by calling component del see also component add"
        },
        "hfi1_get_rc_ohdr": {
            "ground_truth": "0",
            "function": "hfi1_get_rc_ohdr",
            "description": "hfi1 get rc ohdr get extended header opah the opaheader"
        },
        "get_vm_area": {
            "ground_truth": "0",
            "function": "get_vm_area",
            "description": "get vm area reserve contiguous kernel virtual area search an area of size in the kernel virtual mapping area and reserved it for out purpose return the area descriptor on success or null on failure"
        },
        "ca8210_stop": {
            "ground_truth": "0",
            "function": "ca8210_stop",
            "description": "ca8210 stop stop the network driver"
        },
        "sev_platform_status": {
            "ground_truth": "0",
            "function": "sev_platform_status",
            "description": "sev platform status perform sev platform status command"
        },
        "map_winctx_mmio_bars": {
            "ground_truth": "0",
            "function": "map_winctx_mmio_bars",
            "description": "map winctx mmio bar find the hypervisor window context hvwc mmio base address region and the o user window context uwc mmio base address region for the given window map these bus address and save the mapped kernel address in window"
        },
        "netdev_txq_bql_enqueue_prefetchw": {
            "ground_truth": "0",
            "function": "netdev_txq_bql_enqueue_prefetchw",
            "description": "netdev txq bql enqueue prefetchw prefetch bql data for write bql enabled driver might use this helper in their ndo start xmit to give appropriate hint to the cpu"
        },
        "debugfs_create_size_t": {
            "ground_truth": "0",
            "function": "debugfs_create_size_t",
            "description": "debugfs create size create debugfs file that is used to read and write an size value"
        },
        "spu_mb_init": {
            "ground_truth": "0",
            "function": "spu_mb_init",
            "description": "spu mb init initialize mailbox client request ownership of mailbox channel for the spu being probed"
        },
        "setup_address_map": {
            "ground_truth": "0",
            "function": "setup_address_map",
            "description": "setup address map set address map by querying addrmap register set address map by querying addrmap register"
        },
        "check_cleanup_prefix_route": {
            "ground_truth": "0",
            "function": "check_cleanup_prefix_route",
            "description": "check cleanup prefix route check whether the prefix for ifp would still need prefix route after deleting ifp the function return one of the cleanup prefix rt constant we do not purge prefix if address wa not permanent prefix is managed by it own lifetime we also do not purge if the address wa ifa noprefixroute if there are no address delete prefix if there are still other permanent address e corresponding prefix is still permanent if there are still other address with ifa noprefixroute do not purge the prefix assume user space is managing it otherwise update prefix lifetime to the longest valid lifetime among the corresponding address on the device note subsequent ra will update lifetime"
        },
        "sw_dis_diffserv": {
            "ground_truth": "0",
            "function": "sw_dis_diffserv",
            "description": "sw dis diffserv disable switch diffserv priority this routine disables the diffserv priority function of the switch"
        },
        "NBPF_SLAVE_RQ_HIGH": {
            "ground_truth": "0",
            "function": "NBPF_SLAVE_RQ_HIGH",
            "description": "nbpf slave rq high cell with the second integer defining slave dma flag"
        },
        "ir_sharp_encode": {
            "ground_truth": "0",
            "function": "ir_sharp_encode",
            "description": "ir sharp encode encode scancode a stream of raw event"
        },
        "qdi_qc_issue": {
            "ground_truth": "0",
            "function": "qdi_qc_issue",
            "description": "qdi qc issue command issue"
        },
        "qcom_scm_assign_mem": {
            "ground_truth": "0",
            "function": "qcom_scm_assign_mem",
            "description": "qcom scm assign mem make secure call to reassign memory ownership return negative errno on failure or on success with srcvm updated"
        },
        "fdt_del_mem_rsv": {
            "ground_truth": "0",
            "function": "fdt_del_mem_rsv",
            "description": "fdt del mem rsv remove memory reserve map entry fdt del mem rsv remove the th memory reserve map entry from the blob this function will delete data from the reservation table and will therefore change the index of some entry in the table"
        },
        "reset_control_reset": {
            "ground_truth": "0",
            "function": "reset_control_reset",
            "description": "reset control reset reset the controlled device on shared reset line the actual reset pulse is only triggered once for the lifetime of the reset control instance for all but the first caller this is no op consumer must not use reset control de assert on shared reset line when reset control reset ha been used if rstc is null it is an optional reset and the function will just return"
        },
        "ad_clear_agg": {
            "ground_truth": "0",
            "function": "ad_clear_agg",
            "description": "ad clear agg clear given aggregator is parameter"
        },
        "of_fdt_is_compatible": {
            "ground_truth": "0",
            "function": "of_fdt_is_compatible",
            "description": "of fdt is compatible return true if given node from the given blob ha compat in it compatible list on match return non zero value with smaller value returned for more specific compatible value"
        },
        "pti_port_shutdown": {
            "ground_truth": "0",
            "function": "pti_port_shutdown",
            "description": "pti port shutdown used to stop shutdown any item upon the last tty port close"
        },
        "kvm_phys_addr_ioremap": {
            "ground_truth": "0",
            "function": "kvm_phys_addr_ioremap",
            "description": "kvm phys addr ioremap map device range to guest ipa"
        },
        "rio_set_drvdata": {
            "ground_truth": "0",
            "function": "rio_set_drvdata",
            "description": "rio set drvdata set rio driver specific data set rio driver specific data device struct driver data pointer is set to the data argument"
        },
        "r100_hpd_init": {
            "ground_truth": "0",
            "function": "r100_hpd_init",
            "description": "r100 hpd init hpd setup callback setup the hpd pin used by the card r1xx r4xx set the polarity and enable the hpd interrupt"
        },
        "_enable_sysc": {
            "ground_truth": "0",
            "function": "_enable_sysc",
            "description": "enable sysc try to bring module out of idle via ocp sysconfig ensure that the ocp sysconfig register for the ip block represented by oh is set to indicate to the prcm that the ip block is active usually this mean placing the module into smart idle mode and smart standby but if there is bug in the automatic idle handling for the ip block it may need to be placed into the force idle or no idle variant of these mode no return value"
        },
        "page_mkwrite_check_truncate": {
            "ground_truth": "0",
            "function": "page_mkwrite_check_truncate",
            "description": "page mkwrite check truncate check if page wa truncated return the number of byte in the page up to eof or efault if the page wa truncated"
        },
        "ibm_slot_from_id": {
            "ground_truth": "0",
            "function": "ibm_slot_from_id",
            "description": "ibm slot from id workaround for bad ibm hardware this method return the acpi slot descriptor corresponding to the linux slot number this descriptor ha info about the apci slot id and attention status this descriptor must be freed using kfree when done"
        },
        "dpu_core_irq_uninstall": {
            "ground_truth": "0",
            "function": "dpu_core_irq_uninstall",
            "description": "dpu core irq uninstall uninstall core irq handler"
        },
        "nand_select_target": {
            "ground_truth": "0",
            "function": "nand_select_target",
            "description": "nand select target select nand target die select nand target so that further operation executed on chip go to the selected nand target"
        },
        "inv_icm42600_setup": {
            "ground_truth": "0",
            "function": "inv_icm42600_setup",
            "description": "inv icm42600 setup check and setup chip"
        },
        "xprt_release": {
            "ground_truth": "0",
            "function": "xprt_release",
            "description": "xprt release release an rpc request slot"
        },
        "__cpcmd": {
            "ground_truth": "0",
            "function": "__cpcmd",
            "description": "cpcmd cpcmd ha some restriction over cpcmd cpcmd is unlocked and therefore not smp safe"
        },
        "ssctl_send_event": {
            "ground_truth": "0",
            "function": "ssctl_send_event",
            "description": "ssctl send event send notification of other remote is ssr event"
        },
        "i40iw_get_hw_addr": {
            "ground_truth": "0",
            "function": "i40iw_get_hw_addr",
            "description": "i40iw get hw addr return hw addr"
        },
        "doc_write_page_putbytes": {
            "ground_truth": "0",
            "function": "doc_write_page_putbytes",
            "description": "doc write page putbytes writes byte into prepared page"
        },
        "sock_common_setsockopt": {
            "ground_truth": "0",
            "function": "sock_common_setsockopt",
            "description": "sock common setsockopt set socket option on an inet socket"
        },
        "vti6_tnl_change": {
            "ground_truth": "0",
            "function": "vti6_tnl_change",
            "description": "vti6 tnl change update the tunnel parameter vti6 tnl change update the tunnel parameter"
        },
        "ice_cfg_dflt_vsi": {
            "ground_truth": "0",
            "function": "ice_cfg_dflt_vsi",
            "description": "ice cfg dflt vsi change state of vsi to set clear default add filter rule to set unset given vsi a default vsi for the switch represented by swid"
        },
        "vmw_fifo_flush": {
            "ground_truth": "0",
            "function": "vmw_fifo_flush",
            "description": "vmw fifo flush flush any buffered command and make sure command processing start"
        },
        "mcpm_cpu_suspend": {
            "ground_truth": "0",
            "function": "mcpm_cpu_suspend",
            "description": "mcpm cpu suspend bring the calling cpu in suspended state the calling cpu is suspended this is similar to mcpm cpu power down except for possible extra platform specific configuration step to allow an asynchronous wake up with pending interrupt if this cpu is found to be the last man standing in the cluster then the cluster may be prepared for power down too this must be called with interrupt disabled on success this doe not return re entry in the kernel is expected via mcpm entry point this will return if mcpm platform register ha not been called previously in which case the caller should take appropriate action"
        },
        "srpt_alloc_ioctx": {
            "ground_truth": "0",
            "function": "srpt_alloc_ioctx",
            "description": "srpt alloc ioctx allocate srpt context structure"
        },
        "qla4xxx_wait_login_resp_boot_tgt": {
            "ground_truth": "0",
            "function": "qla4xxx_wait_login_resp_boot_tgt",
            "description": "qla4xxx wait login resp boot tgt wait for iscsi boot target login response when the boot entry is normal iscsi target then df boot tgt flag will be set in ddb and we will wait for login response of boot target during probe"
        },
        "gic_read_iar_cavium_thunderx": {
            "ground_truth": "0",
            "function": "gic_read_iar_cavium_thunderx",
            "description": "gic read iar cavium thunderx cavium thunderx erratum the gicv3 of thunderx requires modified version for reading the iar status to ensure data synchronization access to icc iar1 el1 is not sync ed before and after"
        },
        "unx_lookup_cred": {
            "ground_truth": "0",
            "function": "unx_lookup_cred",
            "description": "unx lookup cred lookup auth unix cred for current process"
        },
        "ice_flow_set_rss_seg_info": {
            "ground_truth": "0",
            "function": "ice_flow_set_rss_seg_info",
            "description": "ice flow set r seg info setup packet segment for r helper function to extract field from hash bitmap and use flow header value to set flow field segment for further use in flow profile entry or removal"
        },
        "i40e_ddp_flash": {
            "ground_truth": "0",
            "function": "i40e_ddp_flash",
            "description": "i40e ddp flash callback function for ethtool flash feature ethtool callback function used for loading and unloading ddp profile"
        },
        "pvrdma_modify_qp": {
            "ground_truth": "0",
            "function": "pvrdma_modify_qp",
            "description": "pvrdma modify qp modify queue pair attribute return on success otherwise return an errno"
        },
        "am33xx_prm_assert_hardreset": {
            "ground_truth": "0",
            "function": "am33xx_prm_assert_hardreset",
            "description": "am33xx prm assert hardreset assert the hw reset line of submodule some ip like dsp ipu or iva contain processor that require an hw reset line to be asserted deasserted in order to fully enable the ip these module may have multiple hard reset line that reset different isubmodules inside the ip block this function will place the submodule into reset return upon success or einval upon an argument error"
        },
        "ptrace_parent": {
            "ground_truth": "0",
            "function": "ptrace_parent",
            "description": "ptrace parent return the task that is tracing the given task return null if no one is tracing task or the type struct task struct pointer to it tracer must called under rcu read lock the pointer returned might be kept live only by rcu during exec this may be called with task lock held on task still held from when check unsafe exec wa called"
        },
        "ipa_mem_zero_modem": {
            "ground_truth": "0",
            "function": "ipa_mem_zero_modem",
            "description": "ipa mem zero modem zero ipa local memory region owned by the modem zero region of ipa local memory used by the modem these are configured and initially zeroed by ipa mem setup but if the modem crash and restarts via ssr we need to re initialize them qmi message tell the modem where to find region of ipa local memory it need to know about these included"
        },
        "nfp_cpp_explicit_acquire": {
            "ground_truth": "0",
            "function": "nfp_cpp_explicit_acquire",
            "description": "nfp cpp explicit acquire acquire explicit access handle the wouldata ref and isignal ref value are useful when constructing the nfp expl csr1 and nfp expl post value"
        },
        "drm_mode_object_put": {
            "ground_truth": "0",
            "function": "drm_mode_object_put",
            "description": "drm mode object put release mode object reference this function decrement the object is refcount if it is refcounted modeset object it is no op on any other object this is used to drop reference acquired with drm mode object get"
        },
        "dvb_ringbuffer_write_user": {
            "ground_truth": "0",
            "function": "dvb_ringbuffer_write_user",
            "description": "dvb ringbuffer write user writes buffer received via user pointer this variant assumes that the buffer is memory at the userspace so it will internally call copy from user"
        },
        "i40iw_vf_reset": {
            "ground_truth": "0",
            "function": "i40iw_vf_reset",
            "description": "i40iw vf reset process vf reset called when vf is reset by the pf destroy and clean up the vf resource"
        },
        "fcoe_rcv": {
            "ground_truth": "0",
            "function": "fcoe_rcv",
            "description": "fcoe rcv receive packet from net device this routine is called by net rx softirq it receives packet build fc frame and pass the frame to libfc"
        },
        "zfcp_erp_notify": {
            "ground_truth": "0",
            "function": "zfcp_erp_notify",
            "description": "zfcp erp notify trigger erp action"
        },
        "ubifs_return_leb": {
            "ground_truth": "0",
            "function": "ubifs_return_leb",
            "description": "ubifs return leb return leb to lprops this helper function clean the taken flag of logical eraseblock in the lprops return zero in case of success and negative error code in case of failure"
        },
        "default_suspend_ok": {
            "ground_truth": "0",
            "function": "default_suspend_ok",
            "description": "default suspend ok default pm domain governor routine to suspend device"
        },
        "eeh_save_bars": {
            "ground_truth": "0",
            "function": "eeh_save_bars",
            "description": "eeh save bar save device bar save the value of the device bar unlike the restore routine this routine is not recursive this is because pci device are added individually but for the restore an entire slot is reset at time"
        },
        "mpt3sas_device_remove_by_sas_address": {
            "ground_truth": "0",
            "function": "mpt3sas_device_remove_by_sas_address",
            "description": "mpt3sas device remove by sa address removing device object by sa address"
        },
        "ps3_sys_manager_handle_msg": {
            "ground_truth": "0",
            "function": "ps3_sys_manager_handle_msg",
            "description": "ps3 sys manager handle msg first stage msg handler can be called directly to manually poll vuart and pump message handler"
        },
        "ishtp_hbm_cl_flow_control_req": {
            "ground_truth": "0",
            "function": "ishtp_hbm_cl_flow_control_req",
            "description": "ishtp hbm cl flow control req send flow control request send flow control request"
        },
        "usb_interrupt_msg": {
            "ground_truth": "0",
            "function": "usb_interrupt_msg",
            "description": "usb interrupt msg build an interrupt urb sends it off and wait for completion this function sends simple interrupt message to specified endpoint and wait for the message to complete or timeout do not use this function from within an interrupt context if you need an asynchronous message or need to send message from within interrupt context use usb submit urb if thread in your driver us this call make sure your disconnect method can wait for it to complete since you do not have handle on the urb used you can not cancel the request"
        },
        "print_link_info": {
            "ground_truth": "0",
            "function": "print_link_info",
            "description": "print link info print link information"
        },
        "acpi_fadt_sanity_check": {
            "ground_truth": "0",
            "function": "acpi_fadt_sanity_check",
            "description": "acpi fadt sanity check acpi fadt sanity check check fadt presence and carry out sanity check on it"
        },
        "st_lsm6dsx_read_tagged_fifo": {
            "ground_truth": "0",
            "function": "st_lsm6dsx_read_tagged_fifo",
            "description": "st lsm6dsx read tagged fifo tagged hw fifo read routine read sample from the hw fifo and push them to iio buffer"
        },
        "gfs2_withdrawn": {
            "ground_truth": "0",
            "function": "gfs2_withdrawn",
            "description": "gfs2 withdrawn test whether the file system is withdrawing or withdrawn"
        },
        "usb_control_msg_recv": {
            "ground_truth": "0",
            "function": "usb_control_msg_recv",
            "description": "usb control msg recv build control receive message sends it off and wait for completion this function sends control message to specified endpoint that is expected to fill in response receive message and wait for the message to complete or timeout do not use this function from within an interrupt context if you need an asynchronous message or need to send message from within interrupt context use usb submit urb if thread in your driver us this call make sure your disconnect method can wait for it to complete since you do not have handle on the urb used you can not cancel the request the data pointer can be made to reference on the stack or anywhere else that can be successfully written to this function doe not have the restriction that usb control msg ha where the data pointer must be to dynamically allocated memory memory that can be successfully dmaed to device the whole message must be properly received from the device in order for this function to be successful if device return le than the expected amount of data then the function will fail do not use this for message where variable amount of data might be returned"
        },
        "genwqe_reset_interrupt_capability": {
            "ground_truth": "0",
            "function": "genwqe_reset_interrupt_capability",
            "description": "genwqe reset interrupt capability undo genwqe set interrupt capability"
        },
        "led_set_flash_brightness": {
            "ground_truth": "0",
            "function": "led_set_flash_brightness",
            "description": "led set flash brightness set flash led brightness set flash led is brightness"
        },
        "octeon_i2c_reg_read": {
            "ground_truth": "0",
            "function": "octeon_i2c_reg_read",
            "description": "octeon i2c reg read read lower bit of an i2c core register return the data the i2c core register are accessed indirectly via the sw twsi csr"
        },
        "usage_accumulate": {
            "ground_truth": "0",
            "function": "usage_accumulate",
            "description": "usage accumulate there is strong dependency path in the dependency graph and now we need to decide which usage bit of should be accumulated to detect safe unsafe bug note that usage accumulate is used in backwards search so only xr stand for whether only ha in this case only xr is true a above if only xr is false which mean ha dependency path any usage of should be considered otherwise we should only consider read usage"
        },
        "dev_pm_opp_find_level_exact": {
            "ground_truth": "0",
            "function": "dev_pm_opp_find_level_exact",
            "description": "dev pm opp find level exact search for an exact level the caller are required to call dev pm opp put for the returned opp after use"
        },
        "sysfs_update_group": {
            "ground_truth": "0",
            "function": "sysfs_update_group",
            "description": "sysfs update group given directory kobject update an attribute group this function update an attribute group unlike sysfs create group it will explicitly not warn or error if any of the attribute file being created already exist furthermore if the visibility of the file ha changed through the is visible callback it will update the permission and add or remove the relevant file changing group is name subdirectory name under kobj is directory in sysfs is not allowed the primary use for this function is to call it after making change that affect group visibility return on success or error code on failure"
        },
        "omap2_init_clk_clkdm": {
            "ground_truth": "0",
            "function": "omap2_init_clk_clkdm",
            "description": "omap2 init clk clkdm look up clockdomain name store pointer in clk convert clockdomain name stored in struct clk clk into clockdomain pointer and save it into the struct clk intended to be called during clk register return on success eerror otherwise"
        },
        "seq_buf_putc": {
            "ground_truth": "0",
            "function": "seq_buf_putc",
            "description": "seq buf putc sequence printing of simple character copy single character into the sequence buffer return zero on success on overflow"
        },
        "kernfs_get_active": {
            "ground_truth": "0",
            "function": "kernfs_get_active",
            "description": "kernfs get active get an active reference to kernfs node"
        },
        "velocity_mii_ioctl": {
            "ground_truth": "0",
            "function": "velocity_mii_ioctl",
            "description": "velocity mii ioctl mii ioctl handler"
        },
        "e1000_get_link_up_info_vf": {
            "ground_truth": "0",
            "function": "e1000_get_link_up_info_vf",
            "description": "e1000 get link up info vf get link info"
        },
        "ata_is_port": {
            "ground_truth": "0",
            "function": "ata_is_port",
            "description": "ata is port check if struct device represents ata port"
        },
        "net_dim": {
            "ground_truth": "0",
            "function": "net_dim",
            "description": "net dim main dim algorithm entry point called by the consumer this is the main logic of the algorithm where data is processed in order to decide on next required action"
        },
        "sdma_v4_0_gfx_resume": {
            "ground_truth": "0",
            "function": "sdma_v4_0_gfx_resume",
            "description": "sdma v4 gfx resume setup and start the async dma engine set up the gfx dma ring buffer and enable them vega10 return for success error for failure"
        },
        "pci_dev_adjust_pme": {
            "ground_truth": "0",
            "function": "pci_dev_adjust_pme",
            "description": "pci dev adjust pme adjust pme setting for suspended device if the device is suspended and it is not configured for system wakeup disable pme for it to prevent it from waking up the system unnecessarily note that if the device is power state is d3cold and the platform check in pci dev need resume ha not triggered the device is configuration need not be changed"
        },
        "list_next_entry": {
            "ground_truth": "0",
            "function": "list_next_entry",
            "description": "list next entry get the next element in list"
        },
        "scsi_device_resume": {
            "ground_truth": "0",
            "function": "scsi_device_resume",
            "description": "scsi device resume restart user issued command to quiesced device"
        },
        "INIT_LIST_HEAD": {
            "ground_truth": "0",
            "function": "INIT_LIST_HEAD",
            "description": "init list head initialize list head structure initializes the list head to point to itself if it is list header the result is an empty list"
        },
        "aa_simple_write_to_buffer": {
            "ground_truth": "0",
            "function": "aa_simple_write_to_buffer",
            "description": "aa simple write to buffer common routine for getting policy from user"
        },
        "textsearch_prepare": {
            "ground_truth": "0",
            "function": "textsearch_prepare",
            "description": "textsearch prepare prepare search look up the search algorithm module and creates new textsearch configuration for the specified pattern return new textsearch configuration according to the specified parameter or err ptr if zero length pattern is passed this function return einval note the format of the pattern may not be compatible between the various search algorithm"
        },
        "igb_read_phy_reg_mdic": {
            "ground_truth": "0",
            "function": "igb_read_phy_reg_mdic",
            "description": "igb read phy reg mdic read mdi control register"
        },
        "lpfc_move_xri_pbl_to_pvt": {
            "ground_truth": "0",
            "function": "lpfc_move_xri_pbl_to_pvt",
            "description": "lpfc move xri pbl to pvt move some xris from public to private pool this routine try to find some free common bufs in one of public pool with round robin method the search always start from local hwqid then the next hwq which wa found last time rrb next hwqid once public pool is found batch of free common bufs are moved to private pool on hwqid it might move le than count xris if there is not enough in public pool"
        },
        "ice_devlink_nvm_snapshot": {
            "ground_truth": "0",
            "function": "ice_devlink_nvm_snapshot",
            "description": "ice devlink nvm snapshot capture snapshot of the shadow ram content this function is called in response to the devlink cmd region trigger for the shadow ram devlink region it capture snapshot of the shadow ram content this snapshot can later be viewed via the devlink region interface return zero on success and update the data pointer return non zero error code on failure"
        },
        "dn_nsp_disc_conf": {
            "ground_truth": "0",
            "function": "dn_nsp_disc_conf",
            "description": "dn nsp disc conf disc conf message are also called no resource or no link message depending upon the reason field"
        },
        "amd64_read_dct_pci_cfg": {
            "ground_truth": "0",
            "function": "amd64_read_dct_pci_cfg",
            "description": "amd64 read dct pci cfg depending on the family f2 dct read need special handling k8 ha single dct only and no address offset f10h each dct ha it own set of regs dct0 f2x040 dct1 f2x140 f16h ha only dct f15h we select which dct we access using f1x10c dctcfgsel"
        },
        "recalculate_deny_mode": {
            "ground_truth": "0",
            "function": "recalculate_deny_mode",
            "description": "recalculate deny mode stateid that had deny mode associated with it is being released or downgraded recalculate the deny mode on the file"
        },
        "page_counter_set_max": {
            "ground_truth": "0",
            "function": "page_counter_set_max",
            "description": "page counter set max set the maximum number of page allowed return on success ebusy if the current number of page on the counter already exceeds the specified limit the caller must serialize invocation on the same counter"
        },
        "smc_clc_msg_acc_conf_valid": {
            "ground_truth": "0",
            "function": "smc_clc_msg_acc_conf_valid",
            "description": "smc clc msg acc conf validcheck arriving clc accept or confirm"
        }
    },
    "UI": {
        "__btrfs_run_delayed_refs": {
            "ground_truth": "1",
            "function": "__btrfs_run_delayed_refs",
            "description": "btrfs run delayed ref return on success or if called with an already aborted transaction return enomem or eio on failure and will abort the transaction"
        },
        "trace_io_uring_defer": {
            "ground_truth": "1",
            "function": "trace_io_uring_defer",
            "description": "trace io uring defer called when an io uring request is deferred allows to track deferred request to get an insight about what request are not started immediately void ctx pointer to ring context structure void req pointer to deferred request unsigned long long user data user data associated with the request"
        },
        "tiocgetd": {
            "ground_truth": "1",
            "function": "tiocgetd",
            "description": "tiocgetd get line discipline struct tty struct tty tty device int user pointer to user data retrieves the line discipline id directly from the ldisc locking wait for ldisc reference in case the line discipline is changing or the tty is being hungup"
        },
        "lpfc_idiag_ctlacc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_ctlacc_write",
            "description": "lpfc idiag ctlacc write syntax check and set up idiag ctlacc command this routine get the debugfs idiag command struct from user space and then perform the syntax check for port and device control register read dump or write set command accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "blk_rq_unmap_user": {
            "ground_truth": "1",
            "function": "blk_rq_unmap_user",
            "description": "blk rq unmap user unmap request with user data unmap rq previously mapped by blk rq map user the caller must supply the original rq bio from the blk rq map user return since the completion may have changed rq bio struct bio bio start of bio list"
        },
        "f2fs_npages_for_summary_flush": {
            "ground_truth": "1",
            "function": "f2fs_npages_for_summary_flush",
            "description": "f2fs npages for summary flush calculate the number of current summary page for writing"
        },
        "shrink_dcache_sb": {
            "ground_truth": "1",
            "function": "shrink_dcache_sb",
            "description": "shrink dcache sb shrink dcache for superblock shrink the dcache for the specified super block this is used to free the dcache before unmounting file system struct super block sb superblock"
        },
        "tracing_snapshot_cond_enable": {
            "ground_truth": "1",
            "function": "tracing_snapshot_cond_enable",
            "description": "tracing snapshot cond enable enable conditional snapshot for an instance check whether the conditional snapshot for the given instance ha already been enabled or if the current tracer is already using snapshot if so return ebusy else create cond snapshot and save the cond data and update function inside return if successful error otherwise struct trace array tr the tracing instance void cond data user data to associate with the snapshot cond update fn update implementation of the cond snapshot update function"
        },
        "page_add_file_rmap": {
            "ground_truth": "1",
            "function": "page_add_file_rmap",
            "description": "page add file rmap add pte mapping to file page the caller need to hold the pte lock struct page page the page to add the mapping to bool compound charge the page a compound or small page"
        },
        "ext4_read_inline_dir": {
            "ground_truth": "1",
            "function": "ext4_read_inline_dir",
            "description": "ext4 read inline dir so this function is called when the volume is mkfsed with dir index disabled in order to keep po persistent after we convert from an inlined dir to blocked based we just pretend that we are normal dir and return the offset a if and really take place"
        },
        "link_path_walk": {
            "ground_truth": "1",
            "function": "link_path_walk",
            "description": "link path walk name resolution this is the basic name resolution function turning pathname into the final dentry we expect base to be positive and directory return and nd will have valid dentry and mnt on success return error and drop reference to input namei data on failure"
        },
        "i40iw_create_cq": {
            "ground_truth": "1",
            "function": "i40iw_create_cq",
            "description": "i40iw create cq create cq struct ib cq ibcq cq allocated const struct ib cq init attr attr attribute for cq struct ib udata udata user data"
        },
        "pvrdma_create_cq": {
            "ground_truth": "1",
            "function": "pvrdma_create_cq",
            "description": "pvrdma create cq create completion queue struct ib cq ibcq allocated cq const struct ib cq init attr attr completion queue attribute struct ib udata udata user data on success"
        },
        "ib_alloc_xrcd_user": {
            "ground_truth": "1",
            "function": "ib_alloc_xrcd_user",
            "description": "ib alloc xrcd user allocates an xrc domain struct ib device device the device on which to allocate the xrc domain struct inode inode inode to connect xrcd struct ib udata udata valid user data or null for kernel object"
        },
        "i40iw_create_qp": {
            "ground_truth": "1",
            "function": "i40iw_create_qp",
            "description": "i40iw create qp create qp struct ib pd ibpd ptr of pd struct ib qp init attr init attr attribute for qp struct ib udata udata user data for create qp"
        },
        "rvt_create_mmap_info": {
            "ground_truth": "1",
            "function": "rvt_create_mmap_info",
            "description": "rvt create mmap info allocate information for hfi1 mmap struct rvt dev info rdi rvt dev struct u32 size size in byte to map struct ib udata udata user data must be valid void obj opaque pointer to cq wq etc rvt mmap struct on success err ptr on failure"
        },
        "copy_to_user_page": {
            "ground_truth": "1",
            "function": "copy_to_user_page",
            "description": "copy to user page copy user data from to page which is mapped into different process address space really we want to allow our user space model to handle this note that this code need to run on the current cpu"
        },
        "btrfs_write_marked_extents": {
            "ground_truth": "1",
            "function": "btrfs_write_marked_extents",
            "description": "btrfs write marked extent when btree block are allocated they have some corresponding bit set for them in one of two extent io tree this is used to make sure all of those extent are sent to disk but doe not wait on them"
        },
        "usb_serial_generic_write_start": {
            "ground_truth": "1",
            "function": "usb_serial_generic_write_start",
            "description": "usb serial generic write start start writing buffered data serialised using usb serial write busy flag struct usb serial port port usb serial port gfp mem flag flag to use for memory allocation zero on success or if busy otherwise negative errno value"
        },
        "lpfc_debugfs_multixripools_write": {
            "ground_truth": "1",
            "function": "lpfc_debugfs_multixripools_write",
            "description": "lpfc debugfs multixripools write clear multi xri pool statistic this routine clear multi xri pool statistic when buf contains clear return value it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "btrfs_sync_file": {
            "ground_truth": "1",
            "function": "btrfs_sync_file",
            "description": "btrfs sync file fsync call for both file and directory this log the inode into the tree log instead of forcing full commits whenever possible it need to call filemap fdatawait so that all ordered extent update are in the metadata btree are up to date for copying to the log it drop the inode mutex before doing the tree log commit this is an important optimization for directory because holding the mutex prevents new operation on the dir while we write to disk"
        },
        "f2fs_setup_filename": {
            "ground_truth": "1",
            "function": "f2fs_setup_filename",
            "description": "f2fs setup filename prepare to search for iname in dir this is similar to fscrypt setup filename but this also handle computing the casefolded name and the f2fs dirhash if needed then packing all the information about this filename up into istruct f2fs filename"
        },
        "snd_lookup_minor_data": {
            "ground_truth": "1",
            "function": "snd_lookup_minor_data",
            "description": "snd lookup minor data get user data of registered device check that minor device with the specified type is registered and return it user data pointer this function increment the reference counter of the card instance if an associated instance with the given minor number and type is found the caller must call snd card unref appropriately later unsigned int minor the minor number int type device type sndrv device type xxx the user data pointer if the specified device is found null otherwise"
        },
        "rvt_dealloc_pd": {
            "ground_truth": "1",
            "function": "rvt_dealloc_pd",
            "description": "rvt dealloc pd free pd struct ib pd ibpd free up pd struct ib udata udata valid user data or null for kernel object always"
        },
        "siw_qp_prepare_tx": {
            "ground_truth": "1",
            "function": "siw_qp_prepare_tx",
            "description": "siw qp prepare tx siw qp prepare tx prepare tx state for sending out one fpdu build complete pkt if no user data or only immediate data are present return pkt complete if complete pkt built pkt fragmented otherwise"
        },
        "f2fs_flush_sit_entries": {
            "ground_truth": "1",
            "function": "f2fs_flush_sit_entries",
            "description": "f2fs flush sit entry cp call this function which flush sit entry including sit journal and move prefree segs to free segs"
        },
        "af_alg_sendmsg": {
            "ground_truth": "1",
            "function": "af_alg_sendmsg",
            "description": "af alg sendmsg implementation of sendmsg system call handler the sendmsg system call handler obtains the user data and store it in ctx tsgl list this implies allocation of the required number of struct af alg tsgl in addition the ctx is filled with the information sent via cmsg sock socket of connection to user space msg message from user space size size of message from user space ivsize the size of the iv for the cipher operation to verify that the user space provided iv ha the right size return the number of copied data upon success upon error struct socket sock undescribed struct msghdr msg undescribed size size undescribed unsigned int ivsize undescribed"
        },
        "__lookup_hash": {
            "ground_truth": "1",
            "function": "__lookup_hash",
            "description": "lookup hash parent directory ha inode locked exclusive this is one and only case when lookup get called on non in lookup dentries a the matter of fact this only get called when directory is guaranteed to have no in lookup child at all"
        },
        "i40iw_alloc_pd": {
            "ground_truth": "1",
            "function": "i40iw_alloc_pd",
            "description": "i40iw alloc pd allocate protection domain struct ib pd pd pd pointer struct ib udata udata user data"
        },
        "shrink_dcache_for_umount": {
            "ground_truth": "1",
            "function": "shrink_dcache_for_umount",
            "description": "shrink dcache for umount destroy the dentries attached to superblock on unmounting"
        },
        "btrfs_qgroup_free_refroot": {
            "ground_truth": "1",
            "function": "btrfs_qgroup_free_refroot",
            "description": "btrfs qgroup free refroot free num byte of reserved space with type for qgroup normally level qgroup will handle all higher level qgroup too note if num byte is u64 this mean to free all byte of this qgroup this special case is only used for meta pertrans type"
        },
        "ext4_quota_write": {
            "ground_truth": "1",
            "function": "ext4_quota_write",
            "description": "ext4 quota write write to quotafile we know the transaction is already started and ha enough credit"
        },
        "vmw_execbuf_cmdbuf": {
            "ground_truth": "1",
            "function": "vmw_execbuf_cmdbuf",
            "description": "vmw execbuf cmdbuf prepare if possible user space command batch for submission using command buffer this function check whether we can use the command buffer manager for submission and if so creates command buffer of suitable size and copy the user data into that buffer on successful return the function return pointer to the data in the command buffer and header is set to non null if command buffer could not be used the function will return the value of kernel command on function call that value may be null in that case the value of header will be set to null if an error is encountered the function will return pointer error value if the function is interrupted by signal while sleeping it will return erestartsys casted to pointer error value struct vmw private dev priv pointer to device private structure void user user command user space pointer to the command to be submitted void kernel command undescribed u32 command size size of the unpatched command batch struct vmw cmdbuf header header out parameter returning the opaque pointer to the command buffer"
        },
        "iommu_set_fault_handler": {
            "ground_truth": "1",
            "function": "iommu_set_fault_handler",
            "description": "iommu set fault handler set fault handler for an iommu domain this function should be used by iommu user which want to be notified whenever an iommu fault happens the fault handler itself should return on success and an appropriate error code otherwise struct iommu domain domain iommu domain iommu fault handler handler fault handler void token user data will be passed back to the fault handler"
        },
        "rvt_create_cq": {
            "ground_truth": "1",
            "function": "rvt_create_cq",
            "description": "rvt create cq create completion queue called by ib create cq in the generic verb code struct ib cq ibcq allocated cq const struct ib cq init attr attr creation attribute struct ib udata udata user data for libibverbs so on success"
        },
        "siw_proc_rreq": {
            "ground_truth": "1",
            "function": "siw_proc_rreq",
            "description": "siw proc rreq inbound rreq is cannot carry user data"
        },
        "ceph_copy_user_to_page_vector": {
            "ground_truth": "1",
            "function": "ceph_copy_user_to_page_vector",
            "description": "ceph copy user to page vector copy user data into page vector"
        },
        "strncpy_from_user": {
            "ground_truth": "1",
            "function": "strncpy_from_user",
            "description": "strncpy from user copy nul terminated string from userspace copy nul terminated string from userspace to kernel space on success return the length of the string not including the trailing nul if access to userspace fails return efault some data may have been copied if count is smaller than the length of the string copy count byte and return count char dst destination address in kernel space this buffer must be at least count byte long const char user src source address in user space long count maximum number of byte to copy including the trailing nul"
        },
        "tty_write": {
            "ground_truth": "1",
            "function": "tty_write",
            "description": "tty write write method for tty device file struct file file tty file pointer const char user buf user data to write size count byte to write loff ppos unused write data to tty device via the line discipline locking lock the line discipline a required writes to the tty driver are serialized by the atomic write lock and are then processed in chunk to the device the line discipline write method will not be invoked in parallel for each device"
        },
        "blk_rq_map_kern": {
            "ground_truth": "1",
            "function": "blk_rq_map_kern",
            "description": "blk rq map kern map kernel data to request for passthrough request data will be mapped directly if possible otherwise bounce buffer is used can be called multiple time to append multiple buffer struct request queue request queue where request should be inserted struct request rq request to fill void kbuf the kernel buffer unsigned int len length of user data gfp gfp mask memory allocation flag"
        },
        "ib_dereg_mr_user": {
            "ground_truth": "1",
            "function": "ib_dereg_mr_user",
            "description": "ib dereg mr user deregisters memory region and remove it from the hca translation table this function can fail if the memory region ha memory window bound to it struct ib mr mr the memory region to deregister struct ib udata udata valid user data or null for kernel object"
        },
        "tty_ldisc_open": {
            "ground_truth": "1",
            "function": "tty_ldisc_open",
            "description": "tty ldisc open open line discipline struct tty struct tty tty we are opening the ldisc on struct tty ldisc ld discipline to open helper opening method also convenient debugging and check point locking always called with btm already held"
        },
        "path_lookupat": {
            "ground_truth": "1",
            "function": "path_lookupat",
            "description": "path lookupat return and nd will be valid on success retuns error otherwise"
        },
        "ds1682_eeprom_read": {
            "ground_truth": "1",
            "function": "ds1682_eeprom_read",
            "description": "ds1682 eeprom read user data attribute"
        },
        "ib_dealloc_xrcd_user": {
            "ground_truth": "1",
            "function": "ib_dealloc_xrcd_user",
            "description": "ib dealloc xrcd user deallocates an xrc domain struct ib xrcd xrcd the xrc domain to deallocate struct ib udata udata valid user data or null for kernel object"
        },
        "may_delete": {
            "ground_truth": "1",
            "function": "may_delete",
            "description": "may delete check whether we can remove link victim from directory dir check whether the type of victim is right we can not do it if dir is read only done in permission we should have write and exec permission on dir we can not remove anything from append only dir we can not do anything with immutable dir done in permission if the sticky bit on dir is set we should either be owner of dir or be owner of victim or have cap fowner capability if the victim is append only or immutable we can not do antyhing with link pointing to it if the victim ha an unknown uid or gid we can not change the inode if we were asked to remove directory and victim is not one enotdir if we were asked to remove non directory and victim is not one eisdir we can not remove root or mountpoint we do not allow removal of nfs sillyrenamed file it is handled by nfs async unlink"
        },
        "lpfc_bsg_diag_loopback_run": {
            "ground_truth": "1",
            "function": "lpfc_bsg_diag_loopback_run",
            "description": "lpfc bsg diag loopback run run loopback on port by issue ct cmd to itself this function receives user data buffer to be transmitted and received on the same port the link must be up and in loopback mode prior to being called kernel buffer is allocated to copy the user data into the port register with itself the transmit and receive exchange id are obtained the receive exchange id is posted new el loopback event is created the command and response iocbs are allocated the cmd iocb fstype is set to elx loopback and the cmdrsp to looppback this function is meant to be called time while the port is in loopback so it is the apps responsibility to issue reset to take the port out of loopback mode struct bsg job job lpfc bsg vendor diag test fc bsg job"
        },
        "pvrdma_dealloc_pd": {
            "ground_truth": "1",
            "function": "pvrdma_dealloc_pd",
            "description": "pvrdma dealloc pd deallocate protection domain struct ib pd pd the protection domain to be released struct ib udata udata user data or null for kernel object always"
        },
        "__filemap_fdatawrite_range": {
            "ground_truth": "1",
            "function": "__filemap_fdatawrite_range",
            "description": "filemap fdatawrite range start writeback on mapping dirty page in range start writeback against all of mapping is dirty page that lie within the byte offset inclusive if sync mode is wb sync all then this is data integrity operation a opposed to regular memory cleansing writeback the difference between these two operation is that if dirty page buffer is encountered it must be waited upon and not just skipped over struct address space mapping address space structure to write loff start offset in byte where the range start loff end offset in byte where the range end inclusive int sync mode enable synchronous operation on success negative error code otherwise"
        },
        "f2fs_evict_inode": {
            "ground_truth": "1",
            "function": "f2fs_evict_inode",
            "description": "f2fs evict inode called at the last iput if nlink is zero"
        },
        "btrfs_search_slot": {
            "ground_truth": "1",
            "function": "btrfs_search_slot",
            "description": "btrfs search slot btrfs search slot look for key in tree and perform necessary modification to preserve tree invariant deletion it is for plain search when modifying the tree if in len node and leaf will be split a we walk down the tree if in len node will be merged a we walk down the tree if possible if key is found is returned and you can find the item in the leaf level of the path level if key is not found is returned and the leaf level of the path level point to the slot where it should be inserted if an error is encountered while searching the tree negative error number is returned trans handle of transaction used when modifying the tree hold all btree node along the search path root the root node of the tree key the key we are looking for in len indicates purpose of search for insert it is for cow boolean should cow operation be performed must always be"
        },
        "sdma_txinit_ahg": {
            "ground_truth": "1",
            "function": "sdma_txinit_ahg",
            "description": "sdma txinit ahg initialize an sdma txreq struct with ahg the allocation of the sdma txreq and it enclosing structure is user dependent this routine must be called to initialize the user independent field the currently supported flag are sdma txreq urgent sdma txreq ahg copy and sdma txreq use ahg sdma txreq urgent is used for latency sensitive situation where the completion is desired a soon a possible sdma txreq ahg copy cause the header in the first descriptor to be copied to chip entry sdma txreq use ahg cause the code to add in the ahg descriptor into the first to descriptor completion of submitted request can be gotten on selected txreqs by giving completion routine callback to sdma txinit or sdma txinit ahg the environment in which the callback run can be from an isr tasklet or thread so no sleeping kernel routine can be used aspect of the sdma ring may be locked so care should be taken with locking the callback pointer can be null to avoid any callback for the packet being submitted the callback will be provided this tx status and flag the status will be one of sdma txreq ok sdma txreq senderror sdma txreq aborted or sdma txreq shutdown the flag if the is the iowait had been used indicates the iowait sdma busy count ha reached zero user data portion of tlen should be precise the sdma txadd entrance will pad with descriptor reference byte when the number of byte specified in tlen have been supplied to the sdma txreq ahg hlen is used to determine the number of on chip entry byte to use a the header this is for case where the stored header is larger than the header to be used in packet this is typical for verb where an rdma write first is larger than the packet in and rdma write middle struct sdma txreq tx tx request to initialize u16 flag flag to key last descriptor addition u16 tlen total packet length pbc header data u8 ahg entry ahg entry to use u8 num ahg ahg descriptor for first descriptor u32 ahg array of ahg descriptor up to entry u8 ahg hlen number of byte from asic entry to use void cb struct sdma txreq int callback"
        },
        "pvrdma_modify_qp": {
            "ground_truth": "1",
            "function": "pvrdma_modify_qp",
            "description": "pvrdma modify qp modify queue pair attribute return on success otherwise return an errno struct ib qp ibqp the queue pair struct ib qp attr attr the new queue pair is attribute int attr mask attribute mask struct ib udata udata user data"
        },
        "sysfs_remove_mount_point": {
            "ground_truth": "1",
            "function": "sysfs_remove_mount_point",
            "description": "sysfs remove mount point remove an always empty directory struct kobject parent kobj kobject that will contain this always empty directory const char name the name of the always empty directory to remove"
        },
        "btrfs_submit_compressed_write": {
            "ground_truth": "1",
            "function": "btrfs_submit_compressed_write",
            "description": "btrfs submit compressed write worker function to build and submit bios for previously compressed page the corresponding page in the inode should be marked for writeback and the compressed page should have reference on them for dropping when the io is complete this also checksum the file byte and get thing ready for the end io hook"
        },
        "copy_from_read_buf": {
            "ground_truth": "1",
            "function": "copy_from_read_buf",
            "description": "copy from read buf copy read data directly struct tty struct tty terminal device unsigned char user user data size nr size of data helper function to speed up tty read it is only called when icanon is off it copy character straight from the tty queue to user space directly it can be profitably called twice once to drain the space from the tail pointer to the physical end of the buffer and once to drain the space from the physical beginning of the buffer to head pointer called under the ldata atomic read lock sem tty read consumer path caller hold non exclusive termios rwsem read tail published"
        },
        "i40iw_dealloc_pd": {
            "ground_truth": "1",
            "function": "i40iw_dealloc_pd",
            "description": "i40iw dealloc pd deallocate pd struct ib pd ibpd ptr of pd to be deallocated struct ib udata udata user data or null for kernel object"
        },
        "tiocsetd": {
            "ground_truth": "1",
            "function": "tiocsetd",
            "description": "tiocsetd set line discipline struct tty struct tty tty device int user pointer to user data set the line discipline according to user request locking see tty set ldisc this function is just helper"
        },
        "__btrfs_run_delayed_items": {
            "ground_truth": "1",
            "function": "__btrfs_run_delayed_items",
            "description": "btrfs run delayed item called when committing the transaction return on success return on error and return with an aborted transaction with any outstanding delayed item cleaned up"
        },
        "i40iw_reg_user_mr": {
            "ground_truth": "1",
            "function": "i40iw_reg_user_mr",
            "description": "i40iw reg user mr register user memory region struct ib pd pd ptr of pd u64 start virtual start address u64 length length of mr u64 virt virtual address int acc access of mr struct ib udata udata user data"
        },
        "tty_ldisc_ref_wait": {
            "ground_truth": "1",
            "function": "tty_ldisc_ref_wait",
            "description": "tty ldisc ref wait wait for the tty ldisc struct tty struct tty tty device dereference the line discipline for the terminal and take reference to it if the line discipline is in flux then wait patiently until it change null if the tty ha been hungup and not re opened with new file descriptor otherwise valid ldisc reference note must not be called from an irq timer context the caller must also be careful not to hold other lock that will deadlock against discipline change such a an existing ldisc reference which we check for file operation routine read poll write should use this function to wait for any ldisc lifetime event to finish"
        },
        "ti_clk_retry_init": {
            "ground_truth": "1",
            "function": "ti_clk_retry_init",
            "description": "ti clk retry init retries failed clock init at later phase add failed clock init to the retry list the retry list is parsed once all the other clock have been initialized struct device node node device not for the clock void user user data pointer ti of clk init cb func init function to be called for the clock"
        },
        "f2fs_find_entry": {
            "ground_truth": "1",
            "function": "f2fs_find_entry",
            "description": "f2fs find entry find an entry in the specified directory with the wanted name it return the page where the entry wa found a parameter re page and the entry itself page is returned mapped and unlocked entry is guaranteed to be valid"
        },
        "btrfs_free_block_groups": {
            "ground_truth": "1",
            "function": "btrfs_free_block_groups",
            "description": "btrfs free block group must be called only after stopping all worker since we could have block group caching kthreads running and therefore they could race with u if we freed the block group before stopping them"
        },
        "ubifs_remount_rw": {
            "ground_truth": "1",
            "function": "ubifs_remount_rw",
            "description": "ubifs remount rw re mount in read write mode ubifs avoids allocating many unnecessary resource when mounted in read only mode this function allocates the needed resource and re mount ubifs in read write mode struct ubifs info ubifs file system description object"
        },
        "btrfs_log_inode_parent": {
            "ground_truth": "1",
            "function": "btrfs_log_inode_parent",
            "description": "btrfs log inode parent helper function around btrfs log inode to make sure newly created parent directory also end up in the log minimal inode and backref only logging is done of any parent directory that are older than the last committed transaction"
        },
        "die_walk_instances": {
            "ground_truth": "1",
            "function": "die_walk_instances",
            "description": "die walk instance walk on instance of given die walk on the instance of give in die in die must be an inlined function declartion this return the return value of callback if it return non zero value or enoent if there is no instance dwarf die or die an abstract original die int callback dwarf die void callback function which is called with instance die void data user data"
        },
        "FUSE_ATTR_SUBMOUNT": {
            "ground_truth": "1",
            "function": "FUSE_ATTR_SUBMOUNT",
            "description": "fuse attr submount fuse attr submount object is submount root"
        },
        "tracing_cond_snapshot_data": {
            "ground_truth": "1",
            "function": "tracing_cond_snapshot_data",
            "description": "tracing cond snapshot data get the user data associated with snapshot when the user enables conditional snapshot using tracing snapshot cond enable the user defined cond data is saved with the snapshot this accessor is used to retrieve it should not be called from cond snapshot update since it take the tr max lock lock which the code calling cond snapshot update ha already done return the cond data associated with the trace array is snapshot struct trace array tr the tracing instance"
        },
        "rvt_create_qp": {
            "ground_truth": "1",
            "function": "rvt_create_qp",
            "description": "rvt create qp create queue pair for device queue pair creation is mostly an rvt issue however driver have their own unique idea of what queue pair number mean for instance there is reserved range for psm called by the ib create qp core verb function struct ib pd ibpd the protection domain who is device we create the queue pair for struct ib qp init attr init attr the attribute of the queue pair struct ib udata udata user data for libibverbs so the queue pair on success otherwise return an errno"
        },
        "ecryptfs_mount": {
            "ground_truth": "1",
            "function": "ecryptfs_mount",
            "description": "ecryptfs mount f type flag struct file system type f type undescribed int flag undescribed const char dev name the path to mount over void raw data the option passed into the kernel"
        },
        "rvt_alloc_pd": {
            "ground_truth": "1",
            "function": "rvt_alloc_pd",
            "description": "rvt alloc pd allocate protection domain allocate and keep track of pd struct ib pd ibpd pd struct ib udata udata optional user data on success"
        },
        "__writeback_single_inode": {
            "ground_truth": "1",
            "function": "__writeback_single_inode",
            "description": "writeback single inode write out an inode and it dirty page do not update the writeback list linkage that is left to the caller the caller is also responsible for setting sync flag and calling inode sync complete to clear it"
        },
        "pvrdma_create_ah": {
            "ground_truth": "1",
            "function": "pvrdma_create_ah",
            "description": "pvrdma create ah create an address handle struct ib ah ibah the ib address handle struct rdma ah init attr init attr the attribute of the ah struct ib udata udata pointer to user data on success otherwise errno"
        },
        "f2fs_io_type_to_rw_hint": {
            "ground_truth": "1",
            "function": "f2fs_io_type_to_rw_hint",
            "description": "f2fs io type to rw hint this return write hint for each segment type this hint will be passed down to block layer there are mapping table which depend on the mount option whint mode whint mode off f2fs only pass down write life not set whint mode user based f2fs try to pas down hint given by user user f2fs block meta write life not set hot node warm node cold node ioctl cold cold data write life extreme extension list buffered io write life extreme cold data write life extreme write life short hot data write life short write life not set warm data write life not set write life none write life medium write life long direct io write life extreme cold data write life extreme write life short hot data write life short write life not set warm data write life not set write life none write life none write life medium write life medium write life long write life long whint mode f based f2fs pass down hint with it policy user f2fs block meta write life medium hot node write life not set warm node cold node write life none ioctl cold cold data write life extreme extension list buffered io write life extreme cold data write life extreme write life short hot data write life short write life not set warm data write life long write life none write life medium write life long direct io write life extreme cold data write life extreme write life short hot data write life short write life not set warm data write life not set write life none write life none write life medium write life medium write life long write life long"
        },
        "tiocgsid": {
            "ground_truth": "1",
            "function": "tiocgsid",
            "description": "tiocgsid get session id struct tty struct tty tty passed by user struct tty struct real tty tty side of the tty passed by the user if pty else the tty pid user pointer to returned session id obtain the session id of the tty if there is no session return an error locking none reference to current signal tty is safe"
        },
        "trace_io_uring_submit_sqe": {
            "ground_truth": "1",
            "function": "trace_io_uring_submit_sqe",
            "description": "trace io uring submit sqe called before submitting one sqe allows to track sqe submitting to understand what wa the source of it sq thread or io uring enter call void ctx pointer to ring context structure u8 opcode opcode of request u64 user data user data associated with the request bool force nonblock whether context blocking or not bool sq thread true if sq thread ha submitted this sqe"
        },
        "rvt_alloc_ucontext": {
            "ground_truth": "1",
            "function": "rvt_alloc_ucontext",
            "description": "rvt alloc ucontext allocate user context struct ib ucontext uctx verb context struct ib udata udata user data allocated"
        },
        "ext4_writepage": {
            "ground_truth": "1",
            "function": "ext4_writepage",
            "description": "ext4 writepage note that we do not need to start transaction unless we are journaling data because we should have hole filled from ext4 page mkwrite we even do not need to file the inode to the transaction is list in ordered mode because if we are writing back data added by write the inode is already there and if we are writing back data modified via mmap no one guarantee in which transaction the data will hit the disk in case we are journaling data we cannot start transaction directly because transaction start rank above page lock so we have to do some magic this function can get called via ext4 writepages after taking page lock have journal handle journal submit inode data buffer no journal handle shrink page list via the kswapd direct reclaim no journal handle grab page cache when doing write begin have journal handle we do not do any block allocation in this function if we have page with multiple block we need to write those buffer head that are mapped this is important for mmaped based write so if we do with blocksize 1k truncate mmap truncate we have in the page first buffer head mapped via page mkwrite call back but other buffer head would be unmapped but dirty dirty done via the do wp page so writepage should write the first block if we modify the mmap area beyond we will again get page fault and the page mkwrite callback will do the block allocation and mark the buffer head mapped we redirty the page if we have any buffer head that is either delay or unwritten in the page we can get recursively called a show below ext4 writepage kmalloc alloc page page launder ext4 writepage but since we do not do any block allocation we should not deadlock page also have the dirty flag cleared so we do not get recurive page lock"
        },
        "rvt_destroy_cq": {
            "ground_truth": "1",
            "function": "rvt_destroy_cq",
            "description": "rvt destroy cq destroy completion queue called by ib destroy cq in the generic verb code struct ib cq ibcq the completion queue to destroy struct ib udata udata user data or null for kernel object"
        },
        "jffs2_get_inode_nodes": {
            "ground_truth": "1",
            "function": "jffs2_get_inode_nodes",
            "description": "jffs2 get inode node get tmp dnode info and full dirent for all non obsolete node associated with this ino perform preliminary ordering on data node throwing away those which are completely obsoleted by newer one the naive approach we use to take of just returning them all in version order will cause u to run out of memory in certain degenerate case"
        },
        "rvt_alloc_rq": {
            "ground_truth": "1",
            "function": "rvt_alloc_rq",
            "description": "rvt alloc rq allocate memory for user or kernel buffer struct rvt rq rq receive queue data structure u32 size number of request queue entry int node the numa node struct ib udata udata true if user data is available or not false if memory allocation failed return enonem this function is used by both shared receive queue and non shared receive queue to allocate memory"
        },
        "memdup_user": {
            "ground_truth": "1",
            "function": "memdup_user",
            "description": "memdup user duplicate memory region from user space const void user src source address in user space size len number of byte to copy an err ptr on failure result is physically contiguous to be freed by kfree"
        },
        "may_umount": {
            "ground_truth": "1",
            "function": "may_umount",
            "description": "may umount check if mount point is busy this is called to check if mount point ha any open file pwds chroots or sub mount if the mount ha sub mount this will return busy regardless of whether the sub mount are busy doe not take quota and stuff into account iow in some case it will give false negative the main reason why it is here is that we need non destructive way to look for easily umountable filesystems struct vfsmount mnt root of mount"
        },
        "gasket_sysfs_get_device_data": {
            "ground_truth": "1",
            "function": "gasket_sysfs_get_device_data",
            "description": "gasket sysfs get device data user data lookup based on kernel device structure description return the user data associated with device in prior call to gasket sysfs create entry return null if no mapping can be found upon success this call take reference to internal sysfs data that must be released with gasket sysfs put device data while this reference is held the underlying device sysfs information structure will remain valid will not be deleted device kernel device structure"
        },
        "lpfc_idiag_baracc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_baracc_write",
            "description": "lpfc idiag baracc write syntax check and set up idiag bar access command this routine get the debugfs idiag command struct from user space and then perform the syntax check for pci bar memory mapped space read or write command accordingly in the case of pci bar memory mapped space read command it set up the command in the idiag command struct for the debugfs read operation in the case of pci bar memorpy mapped space write operation it executes the write operation into the pci bar memory mapped space accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "btrfs_find_root": {
            "ground_truth": "1",
            "function": "btrfs_find_root",
            "description": "btrfs find root btrfs find root lookup the root by the key root the root of the root tree search key the key to search path the path we search root item the root item of the tree we look for root key the root key of the tree we look for if offset of isearch key is 1ull it mean we are not sure the offset of the search key just lookup the root with the highest offset for given objectid if we find something return otherwise on error"
        },
        "ubifs_remount_ro": {
            "ground_truth": "1",
            "function": "ubifs_remount_ro",
            "description": "ubifs remount ro re mount in read only mode we assume vfs ha stopped writing possibly the background thread could be running commit however kthread stop will wait in that case struct ubifs info ubifs file system description object"
        },
        "btrfs_clone": {
            "ground_truth": "1",
            "function": "btrfs_clone",
            "description": "btrfs clone clone range from inode file to another struct inode src inode to clone from struct inode inode inode to clone to const u64 off offset within source to start clone from const u64 olen original length passed by user of range to clone const u64 olen aligned block aligned value of olen const u64 destoff offset within inode to start clone int no time update whether to update mtime ctime on the target inode"
        },
        "ecryptfs_copy_mount_wide_flags_to_inode_flags": {
            "ground_truth": "1",
            "function": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
            "description": "ecryptfs copy mount wide flag to inode flag this function propagates the mount wide flag to individual inode flag struct ecryptfs crypt stat crypt stat the inode is cryptographic context struct ecryptfs mount crypt stat mount crypt stat the mount point is cryptographic context"
        },
        "binder_alloc_new_buf": {
            "ground_truth": "1",
            "function": "binder_alloc_new_buf",
            "description": "binder alloc new buf allocate new binder buffer allocate new buffer given the requested size return the kernel version of the buffer pointer the size allocated is the sum of the three given size each rounded up to pointer sized boundary struct binder alloc alloc binder alloc for this proc size data size size of user data buffer size offset size user specified buffer offset size extra buffer size size of extra space for meta data eg security context int is async buffer for async transaction int pid pid to attribute allocation to used for debugging the allocated buffer or null if error"
        },
        "trace_io_uring_complete": {
            "ground_truth": "1",
            "function": "trace_io_uring_complete",
            "description": "trace io uring complete called when completing an sqe void ctx pointer to ring context structure u64 user data user data associated with the request long re result of the request"
        },
        "ib_dealloc_pd_user": {
            "ground_truth": "1",
            "function": "ib_dealloc_pd_user",
            "description": "ib dealloc pd user deallocates protection domain it is an error to call this function while any resource in the pd still exist the caller is responsible to synchronously destroy them and guarantee no new allocation will happen struct ib pd pd the protection domain to deallocate struct ib udata udata valid user data or null for kernel object"
        },
        "canon_copy_from_read_buf": {
            "ground_truth": "1",
            "function": "canon_copy_from_read_buf",
            "description": "canon copy from read buf copy read data in canonical mode struct tty struct tty terminal device unsigned char user user data size nr size of data helper function for tty read it is only called when icanon is on it copy one line of input up to and including the line delimiting character into the user space buffer nb when termios is changed from non canonical to canonical mode and the read buffer contains data tty set termios simulates an eof push a if were input without the disabled char in the buffer this cause data already processed a input to be immediately available a input although newline ha not been received called under the atomic read lock mutex tty read consumer path caller hold non exclusive termios rwsem read tail published"
        },
        "ssb_set_drvdata": {
            "ground_truth": "1",
            "function": "ssb_set_drvdata",
            "description": "ssb set drvdata device specific user data"
        },
        "batadv_store_isolation_mark": {
            "ground_truth": "1",
            "function": "batadv_store_isolation_mark",
            "description": "batadv store isolation mark parse and store the isolation mark mask entered by the user struct kobject kobj kobject representing the private mesh sysfs directory struct attribute attr the batman adv attribute the user is interacting with char buff the buffer containing the user data size count number of byte in the buffer count on success or negative error code in case of failure"
        },
        "ib_destroy_srq_user": {
            "ground_truth": "1",
            "function": "ib_destroy_srq_user",
            "description": "ib destroy srq user destroys the specified srq struct ib srq srq the srq to destroy struct ib udata udata valid user data or null for kernel object"
        },
        "ubifs_mount_orphans": {
            "ground_truth": "1",
            "function": "ubifs_mount_orphans",
            "description": "ubifs mount orphan delete orphan inodes and erase lebs that recorded them this function is called when mounting to erase orphan from the previous session if ubifs wa not unmounted cleanly then the inodes recorded a orphan are deleted struct ubifs info ubifs file system description object int unclean indicates recovery from unclean unmount int read only indicates read only mount"
        },
        "fuse_mount_put": {
            "ground_truth": "1",
            "function": "fuse_mount_put",
            "description": "fuse mount put struct fuse mount fm undescribed"
        },
        "set_termios": {
            "ground_truth": "1",
            "function": "set_termios",
            "description": "set termios set termios value for tty struct tty struct tty terminal device void user arg user data int opt option information helper function to prepare termios data and run necessary other function before using tty set termios to do the actual change locking called function take ldisc and termios rwsem lock"
        },
        "pvrdma_destroy_cq": {
            "ground_truth": "1",
            "function": "pvrdma_destroy_cq",
            "description": "pvrdma destroy cq destroy completion queue struct ib cq cq the completion queue to destroy struct ib udata udata user data or null for kernel object"
        },
        "diag_cmd_data_alloc": {
            "ground_truth": "1",
            "function": "diag_cmd_data_alloc",
            "description": "diag cmd data alloc fill in bde struct with dma buffer this function allocates page size buffer and populates an lpfc dmabufext if allowed the user data pointed to with indataptr is copied into the kernel memory the chained list of page size buffer is returned struct lpfc hba phba pointer to hba context object struct ulp bde64 bpl pointer to bit bde structure uint32 size number of byte to process int nocopydata flag to copy user data into the allocated buffer"
        },
        "ext4_count_dirs": {
            "ground_truth": "1",
            "function": "ext4_count_dirs",
            "description": "ext4 count dirs called at mount time super block is locked"
        },
        "btrfs_root_node": {
            "ground_truth": "1",
            "function": "btrfs_root_node",
            "description": "btrfs root node safely get reference on the root node of tree lock is not taken so concurrent writer may put different node at the root of the tree see btrfs lock root node for the looping required the extent buffer returned by this ha reference taken so it will not disappear it may stop being the root of the tree at any time because there are no lock held"
        },
        "pvrdma_destroy_srq": {
            "ground_truth": "1",
            "function": "pvrdma_destroy_srq",
            "description": "pvrdma destroy srq destroy shared receive queue struct ib srq srq the shared receive queue to destroy struct ib udata udata user data or null for kernel object for success"
        },
        "tty_ioctl": {
            "ground_truth": "1",
            "function": "tty_ioctl",
            "description": "tty ioctl split this up a gcc can choke on it otherwise"
        },
        "ntfs_dir_fsync": {
            "ground_truth": "1",
            "function": "ntfs_dir_fsync",
            "description": "ntfs dir fsync sync directory to disk data integrity sync of directory to disk used for fsync fdatasync and msync system call this function is based on file ntfs file fsync write the mft record and all associated extent mft record a well a the index allocation and bitmap attribute and then sync the block device if datasync is true we do not wait on the inode to be written out but we always wait on the page cache page to be written out locking caller must hold mutex on the inode todo we should probably also write all attribute index inodes associated with this inode but since we have no simple way of getting to them we ignore this problem for now we do write the bitmap attribute if it is present which is the important one for directory so thing are not too bad note in the past filp could be null so we ignore it a we do not need it anyway struct file filp directory to be synced loff start undescribed loff end undescribed int datasync if non zero only flush user data and not metadata"
        },
        "clone_private_mount": {
            "ground_truth": "1",
            "function": "clone_private_mount",
            "description": "clone private mount create private clone of path this creates new vfsmount which will be the clone of path the new will not be attached anywhere in the namespace and will be private change to the originating mount will not be propagated into this release with mntput const struct path path undescribed"
        },
        "btrfs_get_fs_root": {
            "ground_truth": "1",
            "function": "btrfs_get_fs_root",
            "description": "btrfs get f root get in memory reference of root structure one reference objectid tree objectid check ref if set verify that the tree exists and the item ha at least"
        },
        "fsnotify_unmount_inodes": {
            "ground_truth": "1",
            "function": "fsnotify_unmount_inodes",
            "description": "fsnotify unmount inodes an sb is unmounting handle any watched inodes called during unmount with no lock held so need to be safe against concurrent modifier we temporarily drop sb inode list lock and can block struct super block sb superblock being unmounted"
        },
        "ntfs_read_inode_mount": {
            "ground_truth": "1",
            "function": "ntfs_read_inode_mount",
            "description": "ntfs read inode mount special read inode for mount time use only read inode file mft at mount time only called with super block lock held from within the read super code path this function exists because when it is called the page cache for mft data is not initialized and hence we cannot get at the content of mft record by calling map mft record further it need to cope with the circular reference problem cannot load any attribute other than attribute list until data is loaded because we do not know where the other extent mft record are yet and again because we cannot call map mft record yet obviously this applies only when an attribute list is actually present in mft inode we solve these problem by starting with the data attribute before anything else and iterating using ntfs attr lookup data over all extent a each extent is found we ntfs mapping pair decompress including the implied ntfs runlists merge each step of the iteration necessarily provides sufficient information for the next step to complete this should work but there are two possible pit fall see inline comment below but only time will tell if they are real pit or just smoke struct inode vi inode to read"
        },
        "fifo_icap_set_configuration": {
            "ground_truth": "1",
            "function": "fifo_icap_set_configuration",
            "description": "fifo icap set configuration send configuration data to the icap struct hwicap drvdata drvdata pointer to the drvdata u32 frame buffer pointer to the data to be written to the icap device u32 num word the number of word bit to write to the icap device this function writes the given user data to the write fifo in polled mode and start the transfer of the data to the icap device"
        },
        "lpfc_idiag_queacc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_queacc_write",
            "description": "lpfc idiag queacc write syntax check and set up idiag queacc command this routine get the debugfs idiag command struct from user space and then perform the syntax check for port queue read dump or write set command accordingly in the case of port queue read command it set up the command in the idiag command struct for the following debugfs read operation in the case of port queue write operation it executes the write operation into the port queue entry accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "mtd_get_fact_prot_info": {
            "ground_truth": "1",
            "function": "mtd_get_fact_prot_info",
            "description": "mtd get fact prot info method to access the protection register area present in some flash device the user data is one time programmable but the factory data is read only"
        },
        "alloc_userspace": {
            "ground_truth": "1",
            "function": "alloc_userspace",
            "description": "alloc userspace allocates bit userspace pointer compatible for calling the native bit version of an ioctl if it can not allocate memory either enomem or efault will be returned zero otherwise unsigned int size size of the structure itself to be allocated u32 aux space extra size needed to store extra data space for other user data that is pointed to field inside the structure void user new p64 pointer to pointer to be filled with the allocated struct"
        },
        "f2fs_write_cache_pages": {
            "ground_truth": "1",
            "function": "f2fs_write_cache_pages",
            "description": "f2fs write cache page this function wa copied from write cche page from mm page writeback the major change is making write step of cold data page separately from warm hot data page"
        },
        "ext4_ext_rm_leaf": {
            "ground_truth": "1",
            "function": "ext4_ext_rm_leaf",
            "description": "ext4 ext rm leaf ext4 ext rm leaf remove the extent associated with the block appearing between start and end both start and end must appear in the same extent or eio is returned ha been released from it however if this value is negative it is cluster just to the right of the punched region and it must not be freed handle the journal handle inode the file inode path the path to the leaf partial cluster the cluster which we will have to free if all extent start the first block to remove end the last block to remove"
        },
        "ext4_write_end": {
            "ground_truth": "1",
            "function": "ext4_write_end",
            "description": "ext4 write end we need to pick up the new inode size which generic commit write gave u file can be null eg when called from page symlink ext4 never place buffer on inode mapping private list metadata buffer are managed internally"
        },
        "f2fs_quota_read": {
            "ground_truth": "1",
            "function": "f2fs_quota_read",
            "description": "f2fs quota read read data from quotafile"
        },
        "v9fs_mount": {
            "ground_truth": "1",
            "function": "v9fs_mount",
            "description": "v9fs mount mount superblock struct file system type f type file system type int flag mount flag const char dev name device name that wa mounted void data mount option"
        },
        "gfs2_lm_mount": {
            "ground_truth": "1",
            "function": "gfs2_lm_mount",
            "description": "gfs2 lm mount mount locking protocol struct gfs2 sbd sdp the filesystem int silent if do not complain if the f is not gfs2 f errno"
        },
        "__get_user_pages": {
            "ground_truth": "1",
            "function": "__get_user_pages",
            "description": "get user page pin user page in memory return either number of page pinned which may be le than the number requested or an error detail about the return value if nr page is return if nr page is but no page were pinned return errno if nr page is and some page were pinned return the number of page pinned again this may be le than nr page return value is possible when the fault would need to be retried the caller is responsible for releasing returned page via put page vmas are valid only a long a mmap lock is held must be called with mmap lock held it may be released see below get user page walk process is page table and take reference to each struct page that each user address corresponds to at given instant that is it take the page that would be accessed if user thread access the given user virtual address at that instant this doe not guarantee that the page exists in the user mapping when get user page return and there may even be completely different page there in some case eg if mmapped pagecache ha been invalidated and subsequently re faulted however it doe guarantee that the page will not be freed completely and mostly caller simply care that the page contains data that wa valid at some point in time typically an io or similar operation cannot guarantee anything stronger anyway because lock can not be held over the syscall boundary if gup flag foll write the page must not be written to if the page is written to set page dirty or set page dirty lock a appropriate must be called after the page is finished with and before put page is called if locked null locked will be set to when mmap lock is released by an up read that can happen if gup flag doe not have foll nowait caller using such combination of locked and gup flag must therefore hold the mmap lock for reading only and recognize when it is been released otherwise it must be held for either reading or writing and will not be released in most case get user page or get user page fast should be used instead of get user page get user page should be used only if you need some special gup flag struct mm struct mm mm struct of target mm unsigned long start starting user address unsigned long nr page number of page from start to pin unsigned int gup flag flag modifying pin behaviour struct page page array that receives pointer to the page pinned should be at least nr page long or null if caller only intends to ensure the page are faulted in struct vm area struct vmas array of pointer to vmas corresponding to each page or null if the caller doe not require them int locked whether we are still with the mmap lock held"
        },
        "lpfc_idiag_extacc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_extacc_write",
            "description": "lpfc idiag extacc write syntax check and set up idiag extacc command this routine get the debugfs idiag command struct from user space and then perform the syntax check for extent information access command and set up the necessary state in the idiag command struct accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "binder_alloc_prepare_to_free": {
            "ground_truth": "1",
            "function": "binder_alloc_prepare_to_free",
            "description": "binder alloc prepare to free get buffer given user ptr validate userspace pointer to buffer data and return buffer corresponding to that user pointer search the rb tree for buffer that match user data pointer struct binder alloc alloc binder alloc for this proc uintptr user ptr user pointer to buffer data pointer to buffer or null"
        },
        "blk_rq_map_user_iov": {
            "ground_truth": "1",
            "function": "blk_rq_map_user_iov",
            "description": "blk rq map user iov map user data to request for passthrough request data will be mapped directly for zero copy if possible otherwise kernel bounce buffer is used matching blk rq unmap user must be issued at the end of while still in process context note the mapped bio may need to be bounced through blk queue bounce before being submitted to the device a page mapped may be out of reach it is the caller responsibility to make sure this happens the original bio must be passed back in to blk rq unmap user for proper unmapping struct request queue request queue where request should be inserted struct request rq request to map data to struct rq map data map data pointer to the rq map data holding page if necessary const struct iov iter iter iovec iterator gfp gfp mask memory allocation flag"
        },
        "pvrdma_alloc_pd": {
            "ground_truth": "1",
            "function": "pvrdma_alloc_pd",
            "description": "pvrdma alloc pd allocate protection domain struct ib pd ibpd pd pointer struct ib udata udata user data the ib pd protection domain pointer on success otherwise errno"
        },
        "lpfc_idiag_mbxacc_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_mbxacc_write",
            "description": "lpfc idiag mbxacc write syntax check and set up idiag mbxacc command this routine get the debugfs idiag command struct from user space and then perform the syntax check for driver mailbox command dump and set up the necessary state in the idiag command struct accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "vfs_create_mount": {
            "ground_truth": "1",
            "function": "vfs_create_mount",
            "description": "vfs create mount create mount for configured superblock create mount to an already configured superblock if necessary the caller should invoke vfs get tree before calling this note that this doe not attach the mount to anything struct f context fc the configuration context with the superblock attached"
        },
        "call_console_drivers": {
            "ground_truth": "1",
            "function": "call_console_drivers",
            "description": "call console driver call the console driver asking them to write out log buf start to log buf end the console lock must be held"
        },
        "cifs_dfs_do_mount": {
            "ground_truth": "1",
            "function": "cifs_dfs_do_mount",
            "description": "cifs dfs do mount mount specified path using dfs full path always pas down fullpath to smb3 do mount so we can use the root server to perform failover in case we failed to connect to the first target in the referral struct dentry mntpt undescribed struct cifs sb info cifs sb parent root superblock const char fullpath full path in unc format"
        },
        "f2fs_prepare_lookup": {
            "ground_truth": "1",
            "function": "f2fs_prepare_lookup",
            "description": "f2fs prepare lookup prepare to look up dentry in dir this is similar to fscrypt prepare lookup but this also handle computing the casefolded name and the f2fs dirhash if needed then packing all the information about this filename up into istruct f2fs filename"
        },
        "f2fs_dirty_inode": {
            "ground_truth": "1",
            "function": "f2fs_dirty_inode",
            "description": "f2fs dirty inode f2fs dirty inode is called from mark inode dirty we should call set dirty inode to write the dirty inode through write inode"
        },
        "btrfs_run_delayed_refs": {
            "ground_truth": "1",
            "function": "btrfs_run_delayed_refs",
            "description": "btrfs run delayed ref this start processing the delayed reference count update and extent insertion we have queued up so far count can be which mean to process everything in the tree at the start of the run but not newly added entry or it can be some target number you would like to process return on success or if called with an aborted transaction return on error and abort the transaction"
        },
        "ib_destroy_wq_user": {
            "ground_truth": "1",
            "function": "ib_destroy_wq_user",
            "description": "ib destroy wq user destroys the specified user wq struct ib wq wq the wq to destroy struct ib udata udata valid user data"
        },
        "nfs_umount": {
            "ground_truth": "1",
            "function": "nfs_umount",
            "description": "nfs umount notify server that we have unmounted this export mountproc umnt is advisory so we set short timeout and always use udp const struct nfs mount request info pointer to umount request argument"
        },
        "drm_get_subpixel_order_name": {
            "ground_truth": "1",
            "function": "drm_get_subpixel_order_name",
            "description": "drm get subpixel order name return string for given subpixel enum note you could abuse this and return something out of bound but that would be caller error no unscrubbed user data should make it here enum subpixel order order enum of subpixel order"
        },
        "lpfc_idiag_pcicfg_write": {
            "ground_truth": "1",
            "function": "lpfc_idiag_pcicfg_write",
            "description": "lpfc idiag pcicfg write syntax check and set up idiag pcicfg command this routine get the debugfs idiag command struct from user space and then perform the syntax check for pci config space read or write command accordingly in the case of pci config space read command it set up the command in the idiag command struct for the debugfs read operation in the case of pci config space write operation it executes the write operation into the pci config space accordingly it return the nbytges passing in from debugfs user space when successful in case of error condition it return proper error code back to the user space struct file file the file pointer to read from const char user buf the buffer to copy the user data from size nbytes the number of byte to get loff ppos the position in the file to start reading from"
        },
        "from_kuid_munged": {
            "ground_truth": "1",
            "function": "from_kuid_munged",
            "description": "from kuid munged create uid from kuid user namespace pair struct user namespace targ the user namespace we want uid in kuid kuid the kernel internal uid to start with map kuid into the user namespace specified by targ and return the resulting uid there is always mapping into the initial user namespace unlike from kuid from kuid munged never fails and always return valid uid this make from kuid munged appropriate for use in syscalls like stat and getuid where failing the system call and failing to provide valid uid are not an option if kuid ha no mapping in targ overflowuid is returned"
        },
        "pagecache_get_page": {
            "ground_truth": "1",
            "function": "pagecache_get_page",
            "description": "pagecache get page find and get reference to page look up the page cache entry at mapping index fgp flag can be zero or more of these flag fgp accessed the page will be marked accessed fgp lock the page is returned locked fgp head if the page is present and thp return the head page rather than the exact page specified by the index fgp creat if no page is present then new page is allocated using gfp mask and added to the page cache and the vm is lru list the page is returned locked and with an increased refcount fgp for mmap the caller want to do it own locking dance if the page is already in cache if the page wa allocated unlock it before returning so the caller can do the same dance fgp write the page will be written fgp nofs gfp f will get cleared in gfp mask fgp nowait do not get blocked by page lock if fgp lock or fgp creat are specified then the function may sleep even if the gfp flag specified for fgp creat are atomic if there is page cache page it is returned with an increased refcount struct address space mapping the address space to search pgoff index the page index int fgp flag fgp flag modify how the page is returned gfp gfp mask memory allocation flag to use if fgp creat is specified the found page or null otherwise"
        },
        "aem_init_ipmi_data": {
            "ground_truth": "1",
            "function": "aem_init_ipmi_data",
            "description": "aem init ipmi data initialize ipmi address message buffer and user data"
        },
        "vfio_find_dma": {
            "ground_truth": "1",
            "function": "vfio_find_dma",
            "description": "vfio find dma this code handle mapping and unmapping of user data buffer into dma ble space using the iommu"
        },
        "configfs_write_file": {
            "ground_truth": "1",
            "function": "configfs_write_file",
            "description": "configfs write file write an attribute struct file file file pointer const char user buf data to write size count number of byte loff ppos starting offset similar to configfs read file though working in the opposite direction we allocate and fill the data from the user in fill write buffer then push it to the config item in flush write buffer there is no easy way for u to know if userspace is only doing partial write so we do not support them we expect the entire buffer to come on the first write hint if you are writing value first read the file modify only the value you are changing then write entire buffer back"
        },
        "aa_unpack": {
            "ground_truth": "1",
            "function": "aa_unpack",
            "description": "aa unpack unpack packed binary profile data loaded from user space unpack user data and return refcounted allocated profile stored in lh in order of discovery with the list chain stored in base list or error struct aa loaddata udata user data copied to kmem not null struct list head lh list to place unpacked profile in aa repl w const char n return namespace profile is in if specified else null not null profile on lh else error pointer if fails to unpack"
        },
        "iio_read_mount_matrix": {
            "ground_truth": "1",
            "function": "iio_read_mount_matrix",
            "description": "iio read mount matrix retrieve iio device mounting matrix from device mount matrix property if device is assigned no mounting matrix property default 3x3 identity matrix will be filled in struct device dev device the mounting matrix property is assigned to const char propname device specific mounting matrix property name struct iio mount matrix matrix where to store retrieved matrix if success or negative error code on failure"
        },
        "ecryptfs_miscdev_write": {
            "ground_truth": "1",
            "function": "ecryptfs_miscdev_write",
            "description": "ecryptfs miscdev write handle write to daemon miscdev handle return the number of byte read from buf struct file file file for misc dev handle const char user buf buffer containing user data size count amount of data in buf loff ppos pointer to offset in file ignored"
        },
        "ntfs_sync_mft_mirror_umount": {
            "ground_truth": "1",
            "function": "ntfs_sync_mft_mirror_umount",
            "description": "ntfs sync mft mirror umount synchronise an mft record to the mft mirror write the mapped mst protected extent mft record with mft record number mft no to the mft mirror mftmirr of the ntfs volume vol bypassing the page cache and the mftmirr inode itself this function is only for use at umount time when the mft mirror inode ha already been disposed off we bug if we are called while the mft mirror inode is still attached to the volume on success return on error return errno note this function is not implemented yet a am not convinced it can actually be triggered considering the sequence of commits we do in super ntfs put super but just in case we provide this place holder a the alternative would be either to bug or to get null pointer dereference and oops ntfs volume vol ntfs volume on which the mft record to synchronize resides const unsigned long mft no mft record number of mft record to synchronize mft record mapped mst protected extent mft record to synchronize"
        },
        "mount_ubifs": {
            "ground_truth": "1",
            "function": "mount_ubifs",
            "description": "mount ubifs mount ubifs file system this function mount ubifs file system return zero in case of success and negative error code in case of failure struct ubifs info ubifs file system description object"
        },
        "btrfs_insert_delayed_items": {
            "ground_truth": "1",
            "function": "btrfs_insert_delayed_items",
            "description": "btrfs insert delayed item we insert an item first then if there are some continuous item we try to insert those item into the same leaf"
        },
        "audit_mount": {
            "ground_truth": "1",
            "function": "audit_mount",
            "description": "audit mount handle the auditing of mount operation struct aa profile profile the profile being enforced not null const char op operation being mediated not null const char name name of object being mediated maybe null const char src name src name of object being mediated maybe null const char type type of filesystem maybe null const char trans name of trans maybe null unsigned long flag filesystem independent mount flag const void data filesystem mount flag u32 request permission requested struct aa perm perm the permission computed for the request not null const char info extra information message maybe null int error if operation allowed else failure error code or error on failure"
        },
        "pvrdma_alloc_ucontext": {
            "ground_truth": "1",
            "function": "pvrdma_alloc_ucontext",
            "description": "pvrdma alloc ucontext allocate ucontext struct ib ucontext uctx the uverbs countext struct ib udata udata user data zero on success otherwise errno"
        },
        "f2fs_match_ci_name": {
            "ground_truth": "1",
            "function": "f2fs_match_ci_name",
            "description": "f2fs match ci name test whether case insensitive directory entry match the filename being searched for"
        },
        "die_walk_lines": {
            "ground_truth": "1",
            "function": "die_walk_lines",
            "description": "die walk line walk on line inside given die walk on all line inside given rt die and call callback on each line if the rt die is function walk only on the line inside the function otherwise rt die must be cu die note that this walk not only dwarf line list but also function entry and inline call site dwarf die rt die root die cu subprogram or inlined subroutine line walk callback callback callback routine void data user data"
        },
        "qcom_nand_ooblayout_ecc": {
            "ground_truth": "1",
            "function": "qcom_nand_ooblayout_ecc",
            "description": "qcom nand ooblayout ecc nand controller page layout info layout with ecc enabled xx yy xx yy data xx ecc yy data spare xx ecc yy xx yy xx yy xx yy xx yy codeword codeword byte byte number of codewords in the page ecc byte spare free byte unused byte reserved byte 2k page spare byte 4k page spare byte 8k page spare byte the qcom nand controller operates at sub page codeword level each codeword is and byte for bit and bit ecc mode respectively the number of ecc byte vary based on the ecc strength and the bus width the first codewords contains byte of user data the remaining byte consist of ecc and reserved data the nth codeword contains both user data and spare oobavail byte that sum up to byte when we access page with ecc enabled the reserved byte are not accessible at all when reading we fill up these unreadable position with when writing the controller skip writing the inaccessible byte layout with ecc disabled yy xx bb xx data1 yy data2 xx ecc data1 bb data2 spare xx ecc size1 yy size2 xx size1 bb size2 xx yy xx bb xx codeword codeword byte byte number of codewords in the page ecc byte spare free byte unused byte dummy bad bock byte real bad block byte size1 size2 function of codeword size and when the ecc block is disabled one reserved byte or two for bit bus width is now accessible for the first codewords these are dummy bad block marker in the last codeword this position contains the real bbm in order to have consistent layout between raw and ecc mode we assume the following oob layout arrangement yyxx bb xx yyxx ecc bb freeoob xx ecc yyxx bb xx yyxx bb xx first nth oob region oob region number of codewords in the page ecc byte free oob byte dummy bad block byte inaccessible when ecc enabled unused byte real bad block byte inaccessible when ecc enabled this layout is read a is when ecc is disabled when ecc is enabled the inaccessible bad block byte are ignored when we write to page oob and assumed a when we read page oob the ecc unused and dummy real bad block byte are grouped a ecc byte ecc byte is the sum of the three"
        },
        "pvrdma_reg_user_mr": {
            "ground_truth": "1",
            "function": "pvrdma_reg_user_mr",
            "description": "pvrdma reg user mr register userspace memory region struct ib pd pd protection domain u64 start starting address u64 length length of region u64 virt addr virtual address int access flag access flag for memory region struct ib udata udata user data ib mr pointer on success otherwise return an errno"
        },
        "batadv_store_throughput_override": {
            "ground_truth": "1",
            "function": "batadv_store_throughput_override",
            "description": "batadv store throughput override parse and store throughput override entered by the user struct kobject kobj kobject representing the private mesh sysfs directory struct attribute attr the batman adv attribute the user is interacting with char buff the buffer containing the user data size count number of byte in the buffer count on success or negative error code in case of failure"
        },
        "btrfs_reserve_data_bytes": {
            "ground_truth": "1",
            "function": "btrfs_reserve_data_bytes",
            "description": "btrfs reserve data byte try to reserve data byte for an allocation f info the filesystem byte the number of byte we need flush how we are allowed to flush this will reserve byte from the data space info if there is not enough space then we will attempt to flush space a specified by flush struct btrfs f info f info undescribed u64 byte undescribed enum btrfs reserve flush enum flush undescribed"
        },
        "siw_prepare_fpdu": {
            "ground_truth": "1",
            "function": "siw_prepare_fpdu",
            "description": "siw prepare fpdu siw prepare fpdu prepares transmit context to send out one fpdu if fpdu will contain user data and user data are not immediate data computes maximum fpdu length to fill up tcp ms if possible todo take into account real available sendspace on socket to avoid header misalignment due to send pausing within fpdu transmission qp qp from which to transmit wqe current wqe causing transmission"
        },
        "snd_hwdep_proc_read": {
            "ground_truth": "0",
            "function": "snd_hwdep_proc_read",
            "description": "snd hwdep proc read info interface"
        },
        "ip22zilog_release_port": {
            "ground_truth": "0",
            "function": "ip22zilog_release_port",
            "description": "ip22zilog release port we do not request release mapping of the register here this happens at early serial probe time"
        },
        "mei_timer": {
            "ground_truth": "0",
            "function": "mei_timer",
            "description": "mei timer timer function struct work struct work pointer to the work struct structure"
        },
        "mid_q_entry": {
            "ground_truth": "0",
            "function": "mid_q_entry",
            "description": "mid entry setup request allocate mid sign message"
        },
        "smc_wr_rx_post": {
            "ground_truth": "0",
            "function": "smc_wr_rx_post",
            "description": "smc wr rx post post new receive work request to fill completed old work request entry"
        },
        "ps3_vuart_remove": {
            "ground_truth": "0",
            "function": "ps3_vuart_remove",
            "description": "ps3 vuart remove completely clean the device instance clean all memory interrupt and hv resource after this call the device can no longer be used struct ps3 system bus device dev the struct ps3 system bus device instance"
        },
        "cx8802_blackbird_advise_acquire": {
            "ground_truth": "0",
            "function": "cx8802_blackbird_advise_acquire",
            "description": "cx8802 blackbird advise acquire the cx8802 mpeg api will call this when we can use the hardware"
        },
        "i40iw_configure_aeq_vector": {
            "ground_truth": "0",
            "function": "i40iw_configure_aeq_vector",
            "description": "i40iw configure aeq vector set up the msix vector for aeq allocate interrupt resource and enable irq handling return if successful otherwise return error struct i40iw device iwdev iwarp device"
        },
        "wf_set_overtemp": {
            "ground_truth": "0",
            "function": "wf_set_overtemp",
            "description": "wf set overtemp overtemp condition those are refcounted"
        },
        "vr41xx_get_vtclock_frequency": {
            "ground_truth": "0",
            "function": "vr41xx_get_vtclock_frequency",
            "description": "vr41xx get vtclock frequency bus control uint"
        },
        "sysclk_init": {
            "ground_truth": "0",
            "function": "sysclk_init",
            "description": "sysclk init legacy node"
        },
        "of_dma_configure_id": {
            "ground_truth": "0",
            "function": "of_dma_configure_id",
            "description": "of dma configure id setup dma configuration try to get device is dma configuration from dt and update it accordingly if platform code need to use it own special dma configuration it can use platform bus notifier and handle bus notify add device event to fix up dma configuration struct device dev device to apply dma configuration struct device node np pointer to of node having dma configuration bool force dma whether device is to be set up by of dma configure even if dma capability is not explicitly described by firmware const u32 id optional const pointer value input id"
        },
        "kvmppc_copy_guest": {
            "ground_truth": "0",
            "function": "kvmppc_copy_guest",
            "description": "kvmppc copy guest copy guest memory in place must reside within single memslot"
        },
        "set_srp_direction": {
            "ground_truth": "0",
            "function": "set_srp_direction",
            "description": "set srp direction direction and number of buffer based on the direction in the scsi cmnd and the number of buffer struct scsi cmnd cmd undescribed struct srp cmd srp cmd undescribed int numbuf undescribed"
        },
        "available_clocksource_show": {
            "ground_truth": "0",
            "function": "available_clocksource_show",
            "description": "available clocksource show sysfs interface for listing clocksource provides sysfs interface for listing registered clocksources struct device dev unused struct device attribute attr unused char buf char buffer to be filled with clocksource list"
        },
        "capi_cmd2str": {
            "ground_truth": "0",
            "function": "capi_cmd2str",
            "description": "capi cmd2str convert capi command subcommand number to name return value static string u8 cmd command number u8 subcmd subcommand number"
        },
        "qed_global_rl_rt_init": {
            "ground_truth": "0",
            "function": "qed_global_rl_rt_init",
            "description": "qed global rl rt init prepare runtime init value for the specified rl set max link speed 100gbps per rate limiter return on error"
        },
        "spu_sync_start": {
            "ground_truth": "0",
            "function": "spu_sync_start",
            "description": "spu sync start add the necessary profiling hook"
        },
        "snd_timer_continue": {
            "ground_truth": "0",
            "function": "snd_timer_continue",
            "description": "snd timer continue start again the tick is kept"
        },
        "ipr_ioafp_mode_sense_page28": {
            "ground_truth": "0",
            "function": "ipr_ioafp_mode_sense_page28",
            "description": "ipr ioafp mode sense page28 issue mode sense page to ioa this function send page mode sense to the ioa to retrieve scsi bus attribute return value ipr rc job return struct ipr cmnd ipr cmd ipr command struct"
        },
        "print_address": {
            "ground_truth": "0",
            "function": "print_address",
            "description": "print address copyright michael ellerman ibm corporation"
        },
        "caam_rsa_count_leading_zeros": {
            "ground_truth": "0",
            "function": "caam_rsa_count_leading_zeros",
            "description": "caam rsa count leading zero struct scatterlist sgl scatterlist to count zero from unsigned int nbytes number of zero in byte to strip unsigned int flag operation flag"
        },
        "get_rx_frame_len": {
            "ground_truth": "0",
            "function": "get_rx_frame_len",
            "description": "get rx frame len get the receive frame size"
        },
        "rcar_cmm_setup": {
            "ground_truth": "0",
            "function": "rcar_cmm_setup",
            "description": "rcar cmm setup rcar cmm setup configure the cmm unit configure the cmm unit with the given configuration currently enabling disabling and programming of the lut unit is supported a rcar cmm setup access the cmm register the unit should be powered and it functional clock enabled to guarantee this before any call to this function is made the cmm unit ha to be enabled by calling rcar cmm enable first todo add support for lut double buffer operation to avoid updating the lut table entry while frame is being displayed pdev the platform device associated with the cmm instance config the cmm unit configuration"
        },
        "rcutree_dead_cpu": {
            "ground_truth": "0",
            "function": "rcutree_dead_cpu",
            "description": "rcutree dead cpu the cpu ha been completely removed and some other cpu is reporting this fact from process context do the remainder of the cleanup there can only be one cpu hotplug operation at time so no need for explicit locking"
        },
        "dump_elf_task_fp": {
            "ground_truth": "0",
            "function": "dump_elf_task_fp",
            "description": "dump elf task fp similar but for the fp register"
        },
        "shmem_swapin_page": {
            "ground_truth": "0",
            "function": "shmem_swapin_page",
            "description": "shmem swapin page swap in the page pointed to by pagep caller ha to make sure that pagep contains valid swapped page return and the page in pagep if success on failure return the error code and null in pagep"
        },
        "dpu_core_irq_uninstall": {
            "ground_truth": "0",
            "function": "dpu_core_irq_uninstall",
            "description": "dpu core irq uninstall uninstall core irq handler struct dpu km dpu km dpu handle none"
        },
        "one_param_ctrl_event": {
            "ground_truth": "0",
            "function": "one_param_ctrl_event",
            "description": "one param ctrl event encode one parameter control"
        },
        "xilinx_dpdma_chan_unpause": {
            "ground_truth": "0",
            "function": "xilinx_dpdma_chan_unpause",
            "description": "xilinx dpdma chan unpause unpause the channel unpause the channel struct xilinx dpdma chan chan dpdma channel"
        },
        "bcma_core_chipcommon_early_init": {
            "ground_truth": "0",
            "function": "bcma_core_chipcommon_early_init",
            "description": "bcma core chipcommon early init driver chipcommon"
        },
        "cond_set_guest_storage_key": {
            "ground_truth": "0",
            "function": "cond_set_guest_storage_key",
            "description": "cond set guest storage key oldkey will be updated when either mr or mc is set and pointer is given return if guest storage key update wa not necessary if the guest storage key wa updated and efault on access error struct mm struct mm undescribed unsigned long addr undescribed unsigned char key undescribed unsigned char oldkey undescribed bool nq undescribed bool mr undescribed bool mc undescribed"
        },
        "cnd_virq_enable_channel": {
            "ground_truth": "0",
            "function": "cnd_virq_enable_channel",
            "description": "cnd virq enable channel enable an irq channel of the virtual super irq param irq in irq channel identifier param en in predicate channel enable return none virq channel irq id enable en"
        },
        "rsnd_ssi_init": {
            "ground_truth": "0",
            "function": "rsnd_ssi_init",
            "description": "rsnd ssi init ssi mod common function"
        },
        "line6_init_midi": {
            "ground_truth": "0",
            "function": "line6_init_midi",
            "description": "line6 init midi initialize the line midi subsystem"
        },
        "__swizzle_addr_none": {
            "ground_truth": "0",
            "function": "__swizzle_addr_none",
            "description": "swizzle addr none see include asm mips mach tx39xx mangle port for example"
        },
        "fc_exch_update_stats": {
            "ground_truth": "0",
            "function": "fc_exch_update_stats",
            "description": "fc exch update stats update exches stats to lport struct fc lport lport the local port to update exchange manager stats"
        },
        "init_over_drive_limits": {
            "ground_truth": "0",
            "function": "init_over_drive_limits",
            "description": "init over drive limit retrieves the signed overdrive limit from vbios the max engine clock memory clock and max temperature come from the firmware info table the information is placed into the platform descriptor param hwmgr source of the vbios table and owner of the platform descriptor to be updated param powerplay table the address of the powerplay table return a long a the firmware info table wa present and of supported version"
        },
        "fnic_device_reset": {
            "ground_truth": "0",
            "function": "fnic_device_reset",
            "description": "fnic device reset scsi eh thread issue lun reset when one or more command on lun fail to get aborted it call driver is eh device reset with scsi command on the lun"
        },
        "rio_destid_free": {
            "ground_truth": "0",
            "function": "rio_destid_free",
            "description": "rio destid free free previously allocated destid make the specified destid available for use struct rio net net rio network u16 destid destid to free"
        },
        "exfat_truncate_atime": {
            "ground_truth": "0",
            "function": "exfat_truncate_atime",
            "description": "exfat truncate atime the timestamp for access time ha double second granularity there is no 10msincrement field for access time unlike create modify time atime also ha only second resolution"
        },
        "init_vbt_missing_defaults": {
            "ground_truth": "0",
            "function": "init_vbt_missing_defaults",
            "description": "init vbt missing default default to initialize only if there is no vbt"
        },
        "hpte_valid": {
            "ground_truth": "0",
            "function": "hpte_valid",
            "description": "hpte valid the linux hugepage pmd now include the pmd entry followed by the address to the stashed pgtable the stashed pgtable contains the hpte bit bit secondary bit hidx bit valid we use one byte per each hpte entry with 16mb hugepage and 64k hpte we need entry and with 4k hpte we need entry both will fit in 4k pgtable the top three bit are intentionally left a zero this memory location are also used a normal page pte pointer so if we have any pointer left around while we collapse hugepage we need to make sure page present bit of that is zero when we look at them"
        },
        "hostap_update_sta_ps": {
            "ground_truth": "0",
            "function": "hostap_update_sta_ps",
            "description": "hostap update sta p called only a tasklet software irq called for each rx frame to update sta power saving state pwrmgt is flag from frame control field"
        },
        "splice_from_pipe": {
            "ground_truth": "0",
            "function": "splice_from_pipe",
            "description": "splice from pipe splice data from pipe to file see splice from pipe this function lock the pipe inode otherwise it is identical to splice from pipe struct pipe inode info pipe pipe to splice from struct file out file to splice to loff ppos position in out size len how many byte to splice unsigned int flag splice modifier flag splice actor actor handler that splice the data"
        },
        "mptcp_pm_new_connection": {
            "ground_truth": "0",
            "function": "mptcp_pm_new_connection",
            "description": "mptcp pm new connection path manager event handler"
        },
        "arm_iommu_unmap_sg": {
            "ground_truth": "0",
            "function": "arm_iommu_unmap_sg",
            "description": "arm iommu unmap sg unmap set of sg buffer mapped by dma map sg unmap set of streaming mode dma translation again cpu access rule concerning call here are the same a for dma unmap single struct device dev valid struct device pointer struct scatterlist sg list of buffer int nents number of buffer to unmap same a wa passed to dma map sg enum dma data direction dir dma transfer direction same a wa passed to dma map sg unsigned long attrs undescribed"
        },
        "nfs_page_group_lock_subreq": {
            "ground_truth": "0",
            "function": "nfs_page_group_lock_subreq",
            "description": "nfs page group lock subreq nfs page group lock subreq try to lock subrequest this is helper function for nfs lock and join request which must be called with the head request and page group both locked on error it return with the page group unlocked head head request of page group subreq request to lock"
        },
        "probe_crc": {
            "ground_truth": "0",
            "function": "probe_crc",
            "description": "probe crc test to see if the packet in card memory at packet loc ha valid crc it doe not matter that this is slow it is only used to proble the first few packet"
        },
        "soft_offline_page_store": {
            "ground_truth": "0",
            "function": "soft_offline_page_store",
            "description": "soft offline page store soft offline page"
        },
        "hci_adv_monitors_clear": {
            "ground_truth": "0",
            "function": "hci_adv_monitors_clear",
            "description": "hci adv monitor clear this function requires the caller hold hdev lock"
        },
        "adv748x_hdmi_s_dv_timings": {
            "ground_truth": "0",
            "function": "adv748x_hdmi_s_dv_timings",
            "description": "adv748x hdmi dv timing v4l2 subdev video ops"
        },
        "x25_frames_acked": {
            "ground_truth": "0",
            "function": "x25_frames_acked",
            "description": "x25 frame acked x25 subr"
        },
        "rbv_setpalette": {
            "ground_truth": "0",
            "function": "rbv_setpalette",
            "description": "rbv setpalette ram based video"
        },
        "ia_css_set_cnr_config": {
            "ground_truth": "0",
            "function": "ia_css_set_cnr_config",
            "description": "ia cs set cnr config code generated by genparam gencode gen set function"
        },
        "stm32_timer_start": {
            "ground_truth": "0",
            "function": "stm32_timer_start",
            "description": "stm32 timer start start the counter without event start the timer in order to have the counter reset and start incrementing but disable interrupt event when there is counter overflow by default the counter direction is used a upcounter struct timer of to timer of structure pointer"
        },
        "dm_get_mdptr": {
            "ground_truth": "0",
            "function": "dm_get_mdptr",
            "description": "dm get mdptr an arbitrary pointer may be stored alongside mapped device"
        },
        "blk_done_softirq": {
            "ground_truth": "0",
            "function": "blk_done_softirq",
            "description": "blk done softirq softirq action handler move entry to local list and loop over them while passing them to the queue registered handler"
        },
        "efx_port_dummy_op_int": {
            "ground_truth": "0",
            "function": "efx_port_dummy_op_int",
            "description": "efx port dummy op int dummy phy ops for phy driver"
        },
        "k3_r5_rproc_prepare": {
            "ground_truth": "0",
            "function": "k3_r5_rproc_prepare",
            "description": "k3 r5 rproc prepare the r5f core have control for both reset and halt run the code execution from ddr requires the initial boot strapping code to be run from the internal tcms this function is used to release the reset on applicable core to allow loading into the tcms the prepare ops is invoked by remoteproc core before any firmware loading and is followed by the start ops after loading to actually let the r5 core run"
        },
        "hns_dsaf_get_strings": {
            "ground_truth": "0",
            "function": "hns_dsaf_get_strings",
            "description": "hn dsaf get string get dsaf string set int stringset srting set index u8 data string name value int port port index struct dsaf device dsaf dev dsaf device"
        },
        "hydration_init": {
            "ground_truth": "0",
            "function": "hydration_init",
            "description": "hydration init initialize hydration"
        },
        "io_cqring_wait": {
            "ground_truth": "0",
            "function": "io_cqring_wait",
            "description": "io cqring wait wait until event become available if we do not already have some the application must reap them itself a they reside on the shared cq ring"
        },
        "oaktrail_restore_display_registers": {
            "ground_truth": "0",
            "function": "oaktrail_restore_display_registers",
            "description": "oaktrail restore display register restore lost register state struct drm device dev our drm device restore register state that wa lost during suspend and resume"
        },
        "self_check_in_wl_tree": {
            "ground_truth": "0",
            "function": "self_check_in_wl_tree",
            "description": "self check in wl tree check that wear leveling entry is in wl rb tree this function return zero if is in the root rb tree and einval if it is not const struct ubi device ubi ubi device description object struct ubi wl entry the wear leveling entry to check struct rb root root the root of the tree"
        },
        "vgic_irqfd_set_irq": {
            "ground_truth": "0",
            "function": "vgic_irqfd_set_irq",
            "description": "vgic irqfd set irq irqchip routing entry this is the entry point for irqfd irq injection struct kvm kernel irq routing entry undescribed struct kvm kvm undescribed int irq source id undescribed int level undescribed bool line status undescribed"
        },
        "bnx2_set_rx_mode": {
            "ground_truth": "0",
            "function": "bnx2_set_rx_mode",
            "description": "bnx2 set rx mode called with rtnl lock from vlan function and also netif tx lock from set multicast"
        },
        "ocfs2_cow_align_start": {
            "ground_truth": "0",
            "function": "ocfs2_cow_align_start",
            "description": "ocfs2 cow align start given an extent that start at istart and an that start at cpos find an offset start contig cluster that is closest to cpos while still being le than or equal to it the goal is to break the extent at multiple of contig cluster"
        },
        "onenand_scan": {
            "ground_truth": "0",
            "function": "onenand_scan",
            "description": "onenand scan onenand interface scan for the onenand device param mtd mtd device structure param maxchips number of chip to scan for this fill out all the not initialized function pointer with the default the flash id is read and the mtd chip structure are filled with the appropriate value struct mtd info mtd undescribed int maxchips undescribed"
        },
        "mlxbf_tmfifo_delete_vdev": {
            "ground_truth": "0",
            "function": "mlxbf_tmfifo_delete_vdev",
            "description": "mlxbf tmfifo delete vdev delete vdev for the fifo"
        },
        "orion5x_sata_init": {
            "ground_truth": "0",
            "function": "orion5x_sata_init",
            "description": "orion5x sata init sata"
        },
        "zfcp_fc_sym_name_update": {
            "ground_truth": "0",
            "function": "zfcp_fc_sym_name_update",
            "description": "zfcp fc sym name update retrieve and update the symbolic port name retrieve the current symbolic port name that may have been set by the hardware using the gspn request and update the fc host symbolic name sysfs attribute when running in npiv mode and hence the port name is unique for this system update the symbolic port name to add linux specific information and update the fc nameserver using the rspn request struct work struct work n up work of the adapter where to update the symbolic port name"
        },
        "bcm_resume": {
            "ground_truth": "0",
            "function": "bcm_resume",
            "description": "bcm resume resume callback"
        },
        "t4_get_link_params": {
            "ground_truth": "0",
            "function": "t4_get_link_params",
            "description": "t4 get link params retrieve basic link parameter for given port struct port info pi the port unsigned int link okp value return pointer for link up down unsigned int speedp value return pointer for speed mb unsigned int mtup value return pointer for mtu retrieves basic link parameter for port link up down speed mb and mtu for specified port negative error is returned on failure on success"
        },
        "coda_link": {
            "ground_truth": "0",
            "function": "coda_link",
            "description": "coda link try to make de an entry in dir inodde linked to source de"
        },
        "nps_enet_start_xmit": {
            "ground_truth": "0",
            "function": "nps_enet_start_xmit",
            "description": "np enet start xmit start the data transmission this function is invoked from upper layer to initiate transmission struct sk buff skb sk buff pointer that contains data to be transmitted struct net device ndev pointer to net device structure netdev tx ok on success netdev tx busy if any of the descriptor are not free"
        },
        "dm_bm_is_read_only": {
            "ground_truth": "0",
            "function": "dm_bm_is_read_only",
            "description": "dm bm is read only switch the bm to read only mode once read only mode ha been entered the following function will return eperm dm bm write lock dm bm write lock zero dm bm flush and unlock additionally you should not use dm bm unlock move however no error will be returned if you do"
        },
        "init_configure_mem_clk": {
            "ground_truth": "0",
            "function": "init_configure_mem_clk",
            "description": "init configure mem clk opcode struct nvbios init init undescribed"
        },
        "_base_get_msix_index": {
            "ground_truth": "0",
            "function": "_base_get_msix_index",
            "description": "base get msix index get the msix index return msix index of general reply queue reply queue on which io request is reply should be posted by the hba firmware struct mpt3sas adapter ioc per adapter object struct scsi cmnd scmd scsi cmnd object"
        },
        "pci_read_irq": {
            "ground_truth": "0",
            "function": "pci_read_irq",
            "description": "pci read irq read interrupt line and base address register the architecture dependent code can tweak these of course"
        },
        "mlx5_mr_cache_invalidate": {
            "ground_truth": "0",
            "function": "mlx5_mr_cache_invalidate",
            "description": "mlx5 mr cache invalidate fence all dma on the mr upon return the nic will not be doing any dma to the page under the mr and any dma inprogress will be completed failure of this function indicates the hw ha failed catastrophically struct mlx5 ib mr mr the mr to fence"
        },
        "vlan_dev_change_flags": {
            "ground_truth": "0",
            "function": "vlan_dev_change_flags",
            "description": "vlan dev change flag flag are defined in the vlan flag enum in include uapi linux if vlan file"
        },
        "dcss_mkname": {
            "ground_truth": "0",
            "function": "dcss_mkname",
            "description": "dc mkname create the byte ebcdic vm segment name from an ascii name"
        },
        "enable_debug_cgroup": {
            "ground_truth": "0",
            "function": "enable_debug_cgroup",
            "description": "enable debug cgroup on v2 debug is an implicit controller enabled by cgroup debug boot parameter"
        },
        "smc_ib_port_event_work": {
            "ground_truth": "0",
            "function": "smc_ib_port_event_work",
            "description": "smc ib port event work process context wrapper for might sleep smc ib remember port attr"
        },
        "omap_hwmod_init_reg_offs": {
            "ground_truth": "0",
            "function": "omap_hwmod_init_reg_offs",
            "description": "omap hwmod init reg offs initialize sysconfig register offset struct device dev struct device const struct ti sysc module data data module data s32 rev offs revision register offset s32 sysc offs sysc register offset s32 syss offs syss register offset"
        },
        "bnx2x_nic_load_request": {
            "ground_truth": "0",
            "function": "bnx2x_nic_load_request",
            "description": "bnx2x nic load request send load request to mcp and analyze response"
        },
        "hnae_ae_register": {
            "ground_truth": "0",
            "function": "hnae_ae_register",
            "description": "hnae ae register register ae engine to hnae framework struct hnae ae dev hdev the hnae ae engine device struct module owner the module who provides this dev note the duplicated name will not be checked"
        },
        "cca_cipher2protkey": {
            "ground_truth": "0",
            "function": "cca_cipher2protkey",
            "description": "cca cipher2protkey derive proteced key from cca aes cipher secure key"
        },
        "prcmu_get_xp70_current_state": {
            "ground_truth": "0",
            "function": "prcmu_get_xp70_current_state",
            "description": "prcmu get xp70 current state return the current xp70 power mode void no argument return the current ap arm power mode init apboot apexecute apdeepsleep apsleep apidle apreset"
        },
        "ipa_server_bye": {
            "ground_truth": "0",
            "function": "ipa_server_bye",
            "description": "ipa server bye all qmi client from the modem node are gone modem shut down or crashed"
        },
        "message_send": {
            "ground_truth": "0",
            "function": "message_send",
            "description": "message send return zero if the message wa successfully queued or negative errno otherwise"
        },
        "fas216_eh_abort": {
            "ground_truth": "0",
            "function": "fas216_eh_abort",
            "description": "fas216 eh abort abort this command abort this command struct scsi cmnd scpnt command to abort failed if unable to abort note io request lock is taken and irqs are disabled"
        },
        "xen_mc_extend_args": {
            "ground_truth": "0",
            "function": "xen_mc_extend_args",
            "description": "xen mc extend args try to extend the argument of the previous multicall command the previous command is op must match if it doe then it attempt to extend the argument space allocated to the multicall entry by arg size byte the returned multicall space will return with mc pointing to the command on success or null on failure and args pointing to the newly allocated space"
        },
        "power_actor_get_max_power": {
            "ground_truth": "0",
            "function": "power_actor_get_max_power",
            "description": "power actor get max power get the maximum power that cdev can consume calculate the maximum power consumption in milliwats that the cooling device can currently consume and store it in max power struct thermal cooling device cdev pointer to type thermal cooling device u32 max power pointer in which to store the maximum power on success einval if cdev doe not support the power actor api or on other error"
        },
        "bnx2x_func_start": {
            "ground_truth": "0",
            "function": "bnx2x_func_start",
            "description": "bnx2x func start init function must be called before sending client setup for the first client struct bnx2x bp driver handle"
        },
        "fc_fc4_register_provider": {
            "ground_truth": "0",
            "function": "fc_fc4_register_provider",
            "description": "fc fc4 register provider register fc upper level provider return on success negative error otherwise enum fc fh type type fc type such a fc type fcp struct fc4 prov prov structure describing provider including ops vector"
        },
        "hibernate_resume_nonboot_cpu_disable": {
            "ground_truth": "0",
            "function": "hibernate_resume_nonboot_cpu_disable",
            "description": "hibernate resume nonboot cpu disable used to resume on the cpu we hibernated on"
        },
        "err_pos": {
            "ground_truth": "0",
            "function": "err_pos",
            "description": "err po find the position of string within command for error careting find the position of the first occurence of str within cmd the return value can be passed to tracing log err for caret placement within cmd return the index within cmd of the first occurence of str or if str wa not found char cmd the tracing command that caused the error const char str the string to position the caret at within cmd"
        },
        "crypto_alloc_base": {
            "ground_truth": "0",
            "function": "crypto_alloc_base",
            "description": "crypto alloc base crypto alloc base locate algorithm and allocate transform this function should not be used by new algorithm type please use crypto alloc tfm instead crypto alloc base will first attempt to locate an already loaded algorithm if that fails and the kernel support dynamically loadable module it will then attempt to load module of the same name or alias if that fails it will send query to any loaded crypto manager to construct an algorithm on the fly refcount is grabbed on the algorithm which is then associated with the new transform the returned transform is of non determinate type most people should use one of the more specific allocation function such a crypto alloc skcipher in case of error the return value is an error pointer alg name name of algorithm type type of algorithm mask mask for type comparison"
        },
        "anysee_wr_reg_mask": {
            "ground_truth": "0",
            "function": "anysee_wr_reg_mask",
            "description": "anysee wr reg mask write single register with mask"
        },
        "fimc_pending_queue_add": {
            "ground_truth": "0",
            "function": "fimc_pending_queue_add",
            "description": "fimc pending queue add add buffer to the capture pending buffer queue struct fimc vid cap vid cap undescribed struct fimc vid buffer buf buffer to add to the pending buffer list"
        },
        "queue_rx_peekhead": {
            "ground_truth": "0",
            "function": "queue_rx_peekhead",
            "description": "queue rx peekhead dequeues tse buffer from the receive buffer list otherwise return null if empty assumes the caller is managing and holding mutual exclusion primitive to avoid simultaneous push pop to the list while the head is being examined"
        },
        "unregister_memory_block_under_nodes": {
            "ground_truth": "0",
            "function": "unregister_memory_block_under_nodes",
            "description": "unregister memory block under node unregister memory block device under the node it span memory block with multiple node cannot be offlined and therefore also never be removed"
        },
        "of_irq_init": {
            "ground_truth": "0",
            "function": "of_irq_init",
            "description": "of irq init scan and init matching interrupt controller in dt this function scan the device tree for matching interrupt controller node and call their initialization function in order with parent first const struct of device id match terminated array of node to match and init function to call"
        },
        "hfi1_ud_rcv": {
            "ground_truth": "0",
            "function": "hfi1_ud_rcv",
            "description": "hfi1 ud rcv receive an incoming ud packet this is called from qp rcv to process an incoming ud packet for the given qp called at interrupt level struct hfi1 packet packet undescribed"
        },
        "tb_domain_approve_switch_key": {
            "ground_truth": "0",
            "function": "tb_domain_approve_switch_key",
            "description": "tb domain approve switch key approve switch and add key for switch that support secure connect this function first add key to the switch nvm using connection manager specific mean if adding the key is successful the switch is approved and connected struct tb tb domain the switch belongs to struct tb switch sw switch to approve on success and negative errno in case of failure"
        },
        "intel_scu_ipc_unregister": {
            "ground_truth": "0",
            "function": "intel_scu_ipc_unregister",
            "description": "intel scu ipc unregister unregister scu ipc this unregisters the scu ipc device and release the acquired resource once the refcount go to zero struct intel scu ipc dev scu scu ipc handle"
        },
        "sa1100_stop_tx": {
            "ground_truth": "0",
            "function": "sa1100_stop_tx",
            "description": "sa1100 stop tx interrupt disabled on entry"
        },
        "vivid_radio_rx_s_ctrl": {
            "ground_truth": "0",
            "function": "vivid_radio_rx_s_ctrl",
            "description": "vivid radio rx ctrl radio receiver control"
        },
        "family_write": {
            "ground_truth": "0",
            "function": "family_write",
            "description": "family write write out family register value src0 src1 src0 src1"
        },
        "SiS_GetCH700x": {
            "ground_truth": "0",
            "function": "SiS_GetCH700x",
            "description": "si getch700x read from chrontel 700x"
        },
        "prism2_rx": {
            "ground_truth": "0",
            "function": "prism2_rx",
            "description": "prism2 rx called only a tasklet software irq"
        },
        "i40e_vsi_config_rss": {
            "ground_truth": "0",
            "function": "i40e_vsi_config_rss",
            "description": "i40e vsi config r prepare for vsi vmdq r if used struct i40e vsi vsi vsi structure"
        },
        "FPU_mul": {
            "ground_truth": "0",
            "function": "FPU_mul",
            "description": "fpu mul multiply two register to give register result the source are st deststnr and tagb signb the destination is st deststnr"
        },
        "untrack_pfn_moved": {
            "ground_truth": "0",
            "function": "untrack_pfn_moved",
            "description": "untrack pfn moved untrack pfn moved is called while mremapping pfnmap for new region with the old vma after it pfnmap page table ha been removed the new vma ha new pfnmap to the same pfn cache type with vm pat set"
        },
        "strncpy": {
            "ground_truth": "0",
            "function": "strncpy",
            "description": "strncpy copy length limited nul terminated string the result is not nul terminated if the source exceeds byte char dest where to copy the string to const char src where to copy the string from size the maximum number of byte to copy"
        },
        "is_special_type": {
            "ground_truth": "0",
            "function": "is_special_type",
            "description": "is special type check if specified type is special font gu or preset alias"
        },
        "usb_state_string": {
            "ground_truth": "0",
            "function": "usb_state_string",
            "description": "usb state string return human readable name for the state enum usb device state state the state to return human readable name for if it is not any of the state device in usb device state string enum the string unknown will be returned"
        },
        "mptscsih_bios_param": {
            "ground_truth": "0",
            "function": "mptscsih_bios_param",
            "description": "mptscsih bios param this is anyones guess quite frankly"
        },
        "fan_watchdog_show": {
            "ground_truth": "0",
            "function": "fan_watchdog_show",
            "description": "fan watchdog show sysfs fan fan watchdog hwmon driver"
        },
        "prb_commit": {
            "ground_truth": "0",
            "function": "prb_commit",
            "description": "prb commit commit previously reserved data to the ringbuffer this is the public function available to writer to commit data note that the data is not yet available to reader until it is finalized finalizing happens automatically when space for the next record is reserved see prb final commit for version of this function that finalizes immediately struct prb reserved entry the entry containing the reserved data information any context enables local interrupt"
        },
        "ccroc_writel": {
            "ground_truth": "0",
            "function": "ccroc_writel",
            "description": "ccroc writel writes value to ccroc register writes to reg no return value struct tegra soctherm t pointer to struct tegra soctherm u32 value the value to write u32 reg the register offset"
        },
        "process_fetch_insn_bottom": {
            "ground_truth": "0",
            "function": "process_fetch_insn_bottom",
            "description": "process fetch insn bottom from the 2nd stage routine is same"
        },
        "pnfs_alloc_commit_array": {
            "ground_truth": "0",
            "function": "pnfs_alloc_commit_array",
            "description": "pnfs alloc commit array pnfs nfs"
        },
        "cros_ec_lpc_mec_in_range": {
            "ground_truth": "0",
            "function": "cros_ec_lpc_mec_in_range",
            "description": "cro ec lpc mec in range determine if address are in mec emi range unsigned int offset address offset unsigned int length number of byte to check if in range if not and einval on failure such a the mec range not being initialized"
        },
        "prom_feval": {
            "ground_truth": "0",
            "function": "prom_feval",
            "description": "prom feval evaluate the forth string passed"
        },
        "lance_init_ring": {
            "ground_truth": "0",
            "function": "lance_init_ring",
            "description": "lance init ring initialize the lance rx and tx ring"
        },
        "drm_mode_addfb_ioctl": {
            "ground_truth": "0",
            "function": "drm_mode_addfb_ioctl",
            "description": "drm mode addfb ioctl ioctl"
        },
        "anybus_bus_match": {
            "ground_truth": "0",
            "function": "anybus_bus_match",
            "description": "anybus bus match bus function"
        },
        "amdgpu_vm_cpu_map_table": {
            "ground_truth": "0",
            "function": "amdgpu_vm_cpu_map_table",
            "description": "amdgpu vm cpu map table make sure new pd pt are kmapped struct amdgpu bo table newly allocated or validated pd pt"
        },
        "vmw_binding_scrub_vb": {
            "ground_truth": "0",
            "function": "vmw_binding_scrub_vb",
            "description": "vmw binding scrub vb schedule dx vertex buffer binding scrub from context struct vmw ctx bindinfo bi single binding information bool rebind whether to issue bind instead of scrub command"
        },
        "fuse_iomap_begin": {
            "ground_truth": "0",
            "function": "fuse_iomap_begin",
            "description": "fuse iomap begin this is just for dax and the mapping is ephemeral do not use it for other purpose since there is no block device with permanent mapping"
        },
        "nfs_fscache_release_page": {
            "ground_truth": "0",
            "function": "nfs_fscache_release_page",
            "description": "nfs fscache release page release the caching state associated with page if the page is not busy interacting with the cache return true can release page or false page busy"
        },
        "compute_large_page_tx_descs": {
            "ground_truth": "0",
            "function": "compute_large_page_tx_descs",
            "description": "compute large page tx descs t1 t2 sge limit the maximum dma size per tx descriptor to sge tx desc max plen 16kb if the page size is larger than 16kb the stack might send more than sge tx desc max plen in contiguous manner note that the large page tx descs stuff will be optimized out when page size sge tx desc max plen compute large page descs computes how many additional descriptor are required to break down the stack is request"
        },
        "synthvid_negotiate_ver": {
            "ground_truth": "0",
            "function": "synthvid_negotiate_ver",
            "description": "synthvid negotiate ver check synthetic video protocol version with the host"
        },
        "write_tx_buf": {
            "ground_truth": "0",
            "function": "write_tx_buf",
            "description": "write tx buf this function relies on an undocumented write method once write command and address is set a many byte of data a desired can be clocked into the device the datasheet only show setting one byte at time"
        },
        "tfp410_i2c_probe": {
            "ground_truth": "0",
            "function": "tfp410_i2c_probe",
            "description": "tfp410 i2c probe there is currently no i2c functionality"
        },
        "mei_fsync": {
            "ground_truth": "0",
            "function": "mei_fsync",
            "description": "mei fsync the fsync handler struct file fp pointer to file structure loff start unused loff end unused int datasync unused on success enodev if client is not connected"
        },
        "usc_DmaCmd": {
            "ground_truth": "0",
            "function": "usc_DmaCmd",
            "description": "usc dmacmd usc dmacmd issue dma command to the dma command address register dcar argument info pointer to device information structure cmd dma command mask usc dmacmd xx macro return value none"
        },
        "grcan_stop_hardware": {
            "ground_truth": "0",
            "function": "grcan_stop_hardware",
            "description": "grcan stop hardware stop device without changing any configuration"
        },
        "bb_get_frame_time": {
            "ground_truth": "0",
            "function": "bb_get_frame_time",
            "description": "bb get frame time description calculate data frame transmitting time parameter in by preamble type preamble type by pkt type pk type 11a pk type 11b pk type 11gb pk type 11ga cb frame length baseband type tx rate tx rate out return value frametime"
        },
        "xfs_fs_measure_sickness": {
            "ground_truth": "0",
            "function": "xfs_fs_measure_sickness",
            "description": "xfs f measure sickness sample which per f metadata are unhealthy"
        },
        "hw_collect_samples": {
            "ground_truth": "0",
            "function": "hw_collect_samples",
            "description": "hw collect sample hw collect sample walk through sample data block and collect sample walk through sample data block and collect sampling data entry that are then pushed to the perf event subsystem depending on the sampling function there can be either basic sampling or combined sampling data entry combined sampling data entry consists of basic and diagnostic sampling data entry the sampling function is determined by the flag in the perf event hardware structure the function always work with combined sampling data entry but ignores the the diagnostic portion if it is not available note that the implementation focus on basic sampling data entry and if such an entry is not valid the entire combined sampling data entry is ignored the overflow variable count the number of sample that ha been discarded due to perf event overflow event the perf event sdbt sample data block table overflow event overflow counter"
        },
        "mts64_disable_readout": {
            "ground_truth": "0",
            "function": "mts64_disable_readout",
            "description": "mts64 disable readout disables readout readout is disabled by clearing bit of control"
        },
        "isp1760_udc_get_status": {
            "ground_truth": "0",
            "function": "isp1760_udc_get_status",
            "description": "isp1760 udc get status control endpoint"
        },
        "print_stats": {
            "ground_truth": "0",
            "function": "print_stats",
            "description": "print stats procfs handler for printing out key information and possible statistic"
        },
        "xfs_dir2_leaf_hdr_from_disk": {
            "ground_truth": "0",
            "function": "xfs_dir2_leaf_hdr_from_disk",
            "description": "xfs dir2 leaf hdr from disk xfs dir2 leaf"
        },
        "netif_testing_on": {
            "ground_truth": "0",
            "function": "netif_testing_on",
            "description": "netif testing on mark device a under test mark device a under test a per rfc2863 the testing state indicates that some test must be performed on the interface after completion of the test the interface state will change to up dormant or down a appropriate struct net device dev network device"
        },
        "fib6_del": {
            "ground_truth": "0",
            "function": "fib6_del",
            "description": "fib6 del need to own table tb6 lock"
        },
        "p9_check_errors": {
            "ground_truth": "0",
            "function": "p9_check_errors",
            "description": "p9 check error check 9p packet for error return and process it return error code if one is discovered otherwise return this will have to be more complicated if we have multiple error packet type struct p9 client current client instance struct p9 req req request to parse and check for error condition"
        },
        "_debug_dump_mf": {
            "ground_truth": "0",
            "function": "_debug_dump_mf",
            "description": "debug dump mf print message frame content void mpi request pointer to message frame int sz number of dwords"
        },
        "snd_soc_jack_free_gpios": {
            "ground_truth": "0",
            "function": "snd_soc_jack_free_gpios",
            "description": "snd soc jack free gpios release gpio pin resource of an asoc jack release gpio and irq resource for gpio pin associated with an asoc jack struct snd soc jack jack asoc jack int count number of pin struct snd soc jack gpio gpios array of gpio pin"
        },
        "ath5k_hw_set_rxdp": {
            "ground_truth": "0",
            "function": "ath5k_hw_set_rxdp",
            "description": "ath5k hw set rxdp set rx descriptor is address return eio if rx is active struct ath5k hw ah the type struct ath5k hw u32 phys addr rx descriptor address"
        },
        "kallsyms_lookup_name": {
            "ground_truth": "0",
            "function": "kallsyms_lookup_name",
            "description": "kallsyms lookup name lookup the address for this symbol return if not found"
        },
        "power_supply_deferred_register_work": {
            "ground_truth": "0",
            "function": "power_supply_deferred_register_work",
            "description": "power supply deferred register work notify that power supply wa registered after parent finished the probing often power supply is registered from driver is probe function however calling power supply changed directly from power supply register would lead to execution of get property function provided by the driver too early before the probe end avoid that by waiting on parent is mutex"
        },
        "__gcov_flush": {
            "ground_truth": "0",
            "function": "__gcov_flush",
            "description": "gcov flush these function may be referenced by gcc generated profiling code but serve no function for kernel profiling"
        },
        "aac_rx_deliver_producer": {
            "ground_truth": "0",
            "function": "aac_rx_deliver_producer",
            "description": "aac rx deliver producer struct fib fib fib to issue will send fib returning if successful"
        },
        "amdgpu_gem_timeout": {
            "ground_truth": "0",
            "function": "amdgpu_gem_timeout",
            "description": "amdgpu gem timeout calculate jiffy timeout from absolute value calculate the timeout in jiffy from an absolute timeout in n uint64 timeout n timeout in n"
        },
        "s3c2410_map_io": {
            "ground_truth": "0",
            "function": "s3c2410_map_io",
            "description": "s3c2410 map io s3c2410 map io register the standard cpu io area and any passed in from the machine specific initialisation"
        },
        "lpfc_snapshot_mxp": {
            "ground_truth": "0",
            "function": "lpfc_snapshot_mxp",
            "description": "lpfc snapshot mxp snapshot pbl pvt and busy count the purpose of this routine is to take snapshot of pbl pvt and busy count second after test case is running the user should call lpfc debugfs multixripools write before running test case to clear stat snapshot taken then the user start test case during test case is running stat snapshot taken is incremented by every time when this routine is called from heartbeat timer when stat snapshot taken is equal to lpfc mxp snapshot taken snapshot is taken struct lpfc hba phba pointer to lpfc hba data structure u32 hwqid belong to which hwq"
        },
        "kunit_destroy_resource": {
            "ground_truth": "0",
            "function": "kunit_destroy_resource",
            "description": "kunit destroy resource find kunit resource and destroy it struct kunit test test case to which the resource belongs kunit resource match match match function return whether given resource match match data void match data data passed into match if kunit resource is found and freed enoent if not found"
        },
        "ep93xx_pata_rw_end": {
            "ground_truth": "0",
            "function": "ep93xx_pata_rw_end",
            "description": "ep93xx pata rw end common part at end of ep93xx pata read write"
        },
        "get_highmem_buffer": {
            "ground_truth": "0",
            "function": "get_highmem_buffer",
            "description": "get highmem buffer allocate buffer for highmem page if there are some highmem page in the hibernation image we may need buffer to copy them and or load their data int safe needed undescribed"
        },
        "ipmr_cache_report": {
            "ground_truth": "0",
            "function": "ipmr_cache_report",
            "description": "ipmr cache report bounce cache query up to mrouted and netlink called under mrt lock"
        },
        "_rt2x00_desc_read": {
            "ground_truth": "0",
            "function": "_rt2x00_desc_read",
            "description": "rt2x00 desc read read word from the hardware descriptor le32 desc base descriptor address const u8 word word index from where the descriptor should be read"
        },
        "alarm_clock_getres": {
            "ground_truth": "0",
            "function": "alarm_clock_getres",
            "description": "alarm clock getres posix getres interface return the granularity of underlying alarm base clock const clockid which clock clockid struct timespec64 tp timespec to fill"
        },
        "iop_chan_memcpy_slot_count": {
            "ground_truth": "0",
            "function": "iop_chan_memcpy_slot_count",
            "description": "iop chan memcpy slot count to do support large hw max buffer size"
        },
        "adjust_lcb_for_fpga_serdes": {
            "ground_truth": "0",
            "function": "adjust_lcb_for_fpga_serdes",
            "description": "adjust lcb for fpga serdes these lcb adjustment are for the aurora serdes core in the fpga"
        },
        "dvb_pll_configure": {
            "ground_truth": "0",
            "function": "dvb_pll_configure",
            "description": "dvb pll configure code"
        },
        "posixtimer_rearm": {
            "ground_truth": "0",
            "function": "posixtimer_rearm",
            "description": "posixtimer rearm this function is exported for use by the signal deliver code it is called just prior to the info block being released and pass that block to u it is function is to update the overrun entry and to restart the timer it should only be called if the timer is to be restarted we have flagged this in the sys private entry of the info block to protect against the timer going away while the interrupt is queued we require that the it requeue pending flag be set"
        },
        "lpfc_get_hba_model_desc": {
            "ground_truth": "0",
            "function": "lpfc_get_hba_model_desc",
            "description": "lpfc get hba model desc retrieve hba device model name and description this routine retrieves hba is description based on it registered pci device id the descp passed into this function point to an array of char it shall be returned with the model name maximum speed and the host bus type the mdp passed into this function point to an array of char when the function return the mdp will be filled with the model name struct lpfc hba phba pointer to lpfc hba data structure uint8 mdp pointer to the data structure to hold the derived model name uint8 descp pointer to the data structure to hold the derived description"
        },
        "of_changeset_init": {
            "ground_truth": "0",
            "function": "of_changeset_init",
            "description": "of changeset init initialize changeset for use initialize changeset structure struct of changeset ocs changeset pointer"
        },
        "__usbnet_queue_skb": {
            "ground_truth": "0",
            "function": "__usbnet_queue_skb",
            "description": "usbnet queue skb the caller must hold list lock"
        },
        "cx88_set_tvaudio": {
            "ground_truth": "0",
            "function": "cx88_set_tvaudio",
            "description": "cx88 set tvaudio cx88 tvaudio"
        },
        "cm_register": {
            "ground_truth": "0",
            "function": "cm_register",
            "description": "cm register register per soc low level data with the cm register per soc low level omap cm data and function pointer with the omap cm common interface the caller must keep the data pointed to by cld valid until it call cm unregister and it return successfully return upon success einval if cld is null or eexist if cm register ha already been called without an intervening cm unregister const struct cm ll data cld low level per soc omap cm data function pointer to register"
        },
        "pipe_toggle_restore": {
            "ground_truth": "0",
            "function": "pipe_toggle_restore",
            "description": "pipe toggle restore this function must be called with interrupt disabled"
        },
        "unregister_atmdevice_notifier": {
            "ground_truth": "0",
            "function": "unregister_atmdevice_notifier",
            "description": "unregister atmdevice notifier register atmdevice notifier register atm dev notify event client like br2684 will register notify event currently we notify of signal found lost"
        },
        "ncsi_cmd_build_header": {
            "ground_truth": "0",
            "function": "ncsi_cmd_build_header",
            "description": "ncsi cmd build header this function should be called after the data area ha been populated completely"
        },
        "pcan_usb_restart_pending": {
            "ground_truth": "0",
            "function": "pcan_usb_restart_pending",
            "description": "pcan usb restart pending handle the submission of the restart urb"
        },
        "hv_int_desc_free": {
            "ground_truth": "0",
            "function": "hv_int_desc_free",
            "description": "hv int desc free interrupt management hook"
        },
        "kfd_iommu_device_init": {
            "ground_truth": "0",
            "function": "kfd_iommu_device_init",
            "description": "kfd iommu device init kfd iommu device init initialize iommu for device"
        },
        "ibmvtpm_crq_get_next": {
            "ground_truth": "0",
            "function": "ibmvtpm_crq_get_next",
            "description": "ibmvtpm crq get next get next responded crq struct ibmvtpm dev ibmvtpm vtpm device struct vtpm crq pointer or null"
        },
        "atlx_link_chg_task": {
            "ground_truth": "0",
            "function": "atlx_link_chg_task",
            "description": "atlx link chg task atlx link chg task deal with link change event out of interrupt context"
        },
        "cmdq_thread_invalidate_fetched_data": {
            "ground_truth": "0",
            "function": "cmdq_thread_invalidate_fetched_data",
            "description": "cmdq thread invalidate fetched data notify gce to re fetch command by setting gce thread pc"
        },
        "dasd_eer_enable": {
            "ground_truth": "0",
            "function": "dasd_eer_enable",
            "description": "dasd eer enable enable error reporting on given device"
        },
        "fc_fcp_resp": {
            "ground_truth": "0",
            "function": "fc_fcp_resp",
            "description": "fc fcp resp handler for fcp response struct fc fcp pkt fsp the fcp packet the response is for struct fc frame fp the response frame"
        },
        "soc_button_lookup_gpio": {
            "ground_truth": "0",
            "function": "soc_button_lookup_gpio",
            "description": "soc button lookup gpio get the nth gpio number from the acpi object"
        },
        "ep93xx_spi_dma_finish": {
            "ground_truth": "0",
            "function": "ep93xx_spi_dma_finish",
            "description": "ep93xx spi dma finish finish with dma transfer function finish with the dma transfer after this the dma buffer is unmapped struct spi master master spi master enum dma data direction dir dma transfer direction"
        },
        "mlx4_cmd_imm": {
            "ground_truth": "0",
            "function": "mlx4_cmd_imm",
            "description": "mlx4 cmd imm invoke command with an immediate output parameter and copy the output into the caller is out param pointer after the command executes"
        },
        "ip27_boot_secondary": {
            "ground_truth": "0",
            "function": "ip27_boot_secondary",
            "description": "ip27 boot secondary launch slave into smp bootstrap it doe not take an argument and we set sp to the kernel stack of the newly created idle process gp to the proc struct so that current thread info will work"
        },
        "build_skb": {
            "ground_truth": "0",
            "function": "build_skb",
            "description": "build skb build skb is wrapper over build skb that specifically take care of skb head and skb pfmemalloc this mean that if frag size is not zero then data must be backed by page fragment not kmalloc or vmalloc"
        },
        "ieee80211_rx_ADDBARsp": {
            "ground_truth": "0",
            "function": "ieee80211_rx_ADDBARsp",
            "description": "ieee80211 rx addbarsp function in baproc"
        },
        "compat_ifr_data_ioctl": {
            "ground_truth": "0",
            "function": "compat_ifr_data_ioctl",
            "description": "compat ifr data ioctl handle ioctls that use ifreq ifr data and just need struct ifreq converted"
        },
        "cns3420_early_serial_setup": {
            "ground_truth": "0",
            "function": "cns3420_early_serial_setup",
            "description": "cns3420 early serial setup uart"
        },
        "pci_dev_set_io_state": {
            "ground_truth": "0",
            "function": "pci_dev_set_io_state",
            "description": "pci dev set io state set the new error state if possible dev pci device to set new error state new the state we want dev to be in must be called with device lock held return true if state ha been changed to the requested state struct pci dev dev undescribed pci channel state new undescribed"
        },
        "dw_apb_clocksource_start": {
            "ground_truth": "0",
            "function": "dw_apb_clocksource_start",
            "description": "dw apb clocksource start start the clocksource counting this is used to start the clocksource before registration and can be used to enable calibration of timer struct dw apb clocksource dw c the clocksource to start"
        },
        "planetcore_set_mac_addrs": {
            "ground_truth": "0",
            "function": "planetcore_set_mac_addrs",
            "description": "planetcore set mac addrs update the device tree local mac address property based on the ea tag"
        },
        "chcr_ktls_mark_tcb_close": {
            "ground_truth": "0",
            "function": "chcr_ktls_mark_tcb_close",
            "description": "chcr ktls mark tcb close chcr ktls mark tcb close mark tcb state to close tx info driver specific tl info return net tx ok net xmit drop"
        },
        "audit_kill_trees": {
            "ground_truth": "0",
            "function": "audit_kill_trees",
            "description": "audit kill tree and that one is done if evict chunk decides to delay until the end of syscall run synchronously"
        },
        "ath6kl_credit_seek": {
            "ground_truth": "0",
            "function": "ath6kl_credit_seek",
            "description": "ath6kl credit seek htc ha an endpoint that need credit ep dist is the endpoint in question"
        },
        "shutdown": {
            "ground_truth": "0",
            "function": "shutdown",
            "description": "shutdown shutdown request and disconnect from gadget"
        },
        "pcc_parse_subspace_irq": {
            "ground_truth": "0",
            "function": "pcc_parse_subspace_irq",
            "description": "pcc parse subspace irq parse the pcc irq and pcc ack register there should be one entry per pcc client this get called for each entry in the pcc table int id pcc subspace index struct acpi pcct hw reduced pcct s pointer to the acpi subtable header under the pcct for success else errno"
        },
        "ehci_mem_init": {
            "ground_truth": "0",
            "function": "ehci_mem_init",
            "description": "ehci mem init remember to add cleanup code above if you add anything here"
        },
        "macio_release_resource": {
            "ground_truth": "0",
            "function": "macio_release_resource",
            "description": "macio release resource release an mmio resource struct macio dev dev pointer to the device holding the resource int resource no resource number to release"
        },
        "xfs_attr_get": {
            "ground_truth": "0",
            "function": "xfs_attr_get",
            "description": "xfs attr get retrieve an extended attribute by name and it value if requested if args valuelen is zero then the caller doe not want the value just an indication whether the attribute exists and the size of the value if it exists the size is returned in args valuelen if args value is null but args valuelen is non zero allocate the buffer for the value after existence of the attribute ha been determined the caller always ha to free args value if it is set no matter if this function wa successful or not if the attribute is found but exceeds the size limit set by the caller in args valuelen return erange with the size of the attribute that wa found in args valuelen"
        },
        "e1000_sw_init": {
            "ground_truth": "0",
            "function": "e1000_sw_init",
            "description": "e1000 sw init initialize general software structure struct e1000 adapter e1000 sw init initializes the adapter private data structure e1000 init hw struct must be called before this function struct e1000 adapter adapter board private structure to initialize"
        },
        "_rsa_enc": {
            "ground_truth": "0",
            "function": "_rsa_enc",
            "description": "rsa enc rsaep function rfc3447 sec mod"
        },
        "xprt_register_transport": {
            "ground_truth": "0",
            "function": "xprt_register_transport",
            "description": "xprt register transport register transport implementation if transport implementation is loaded a kernel module it can call this interface to make itself known to the rpc client struct xprt class transport transport to register transport successfully registered eexist transport already registered einval transport module being unloaded"
        },
        "fib_dealloc": {
            "ground_truth": "0",
            "function": "fib_dealloc",
            "description": "fib dealloc deallocate fib struct fib fibptr fib to deallocate will deallocate and return to the free pool the fib pointed to by the caller"
        },
        "hash__map_kernel_page": {
            "ground_truth": "0",
            "function": "hash__map_kernel_page",
            "description": "hash map kernel page map kernel page currently only called by ioremap map kernel page add an entry to the ioremap page table and add an entry to the hpt possibly bolting it"
        },
        "prepare_for_delete_or_cut": {
            "ground_truth": "0",
            "function": "prepare_for_delete_or_cut",
            "description": "prepare for delete or cut if the path point to directory or direct item calculate mode and the size cut for balance if the path point to an indirect item remove some number of it unformatted node in case of file truncate calculate whether this item must be deleted truncated or last unformatted node of this item will be converted to direct item this function return determination of what balance mode the calling function should employ"
        },
        "ceph_put_fmode": {
            "ground_truth": "0",
            "function": "ceph_put_fmode",
            "description": "ceph put fmode for counting open file by mode"
        },
        "drm_atomic_bridge_chain_pre_enable": {
            "ground_truth": "0",
            "function": "drm_atomic_bridge_chain_pre_enable",
            "description": "drm atomic bridge chain pre enable prepares for enabling all bridge in the encoder chain call type drm bridge funcs atomic pre enable fall back on type drm bridge funcs pre enable op for all the bridge in the encoder chain starting from the last bridge to the first these are called before calling type drm encoder helper funcs atomic enable note the bridge passed should be the one closest to the encoder struct drm bridge bridge bridge control structure struct drm atomic state old state old atomic state"
        },
        "smu7_enable_acpi_power_management": {
            "ground_truth": "0",
            "function": "smu7_enable_acpi_power_management",
            "description": "smu7 enable acpi power management param hwmgr the address of the powerplay hardware manager return always struct pp hwmgr hwmgr undescribed"
        },
        "ath9k_hw_btcoex_set_weight": {
            "ground_truth": "0",
            "function": "ath9k_hw_btcoex_set_weight",
            "description": "ath9k hw btcoex set weight for ar9002 bt weight wlan weight are used for ar9003 and above stomp type is used"
        },
        "cec_msg_opcode": {
            "ground_truth": "0",
            "function": "cec_msg_opcode",
            "description": "cec msg opcode return the opcode of the message for poll const struct cec msg msg the message structure"
        },
        "os_info_csum": {
            "ground_truth": "0",
            "function": "os_info_csum",
            "description": "o info csum compute checksum over o info structure"
        },
        "snd_hdac_stream_set_params": {
            "ground_truth": "0",
            "function": "snd_hdac_stream_set_params",
            "description": "snd hdac stream set params set stream parameter setup the hd audio core stream parameter from substream of the stream and passed format value struct hdac stream azx dev hd audio core stream for which parameter are to be set unsigned int format val format value parameter"
        },
        "rt2x00lib_get_bssidx": {
            "ground_truth": "0",
            "function": "rt2x00lib_get_bssidx",
            "description": "rt2x00lib get bssidx utility function"
        },
        "pr_to_dev": {
            "ground_truth": "0",
            "function": "pr_to_dev",
            "description": "pr to dev start function for struct config item type tb dev pr cit"
        },
        "lpfc_copy_fcf_record": {
            "ground_truth": "0",
            "function": "lpfc_copy_fcf_record",
            "description": "lpfc copy fcf record copy fcf information to lpfc hba this routine copy the fcf information from the fcf record to lpfc hba data structure struct lpfc fcf rec fcf rec pointer to driver fcf record struct fcf record new fcf record pointer to fcf record"
        },
        "usbnet_skb_return": {
            "ground_truth": "0",
            "function": "usbnet_skb_return",
            "description": "usbnet skb return pass this packet up the stack updating it accounting some link protocol batch packet so their rx fixup path can return clone a well a just modify the original skb"
        },
        "region_add": {
            "ground_truth": "0",
            "function": "region_add",
            "description": "region add add the huge page range represented by to the reserve map region will be taken from the cache to fill in this range sufficient region should exist in the cache due to the previous call to region chg with the same range but in some case the cache will not have sufficient entry due to race with other code doing region add or region del the extra needed entry will be allocated region needed is the out value provided by previous call to region chg return the number of new huge page added to the map this number is greater than or equal to zero if file region entry needed to be allocated for this operation and we were not able to allocate it return enomem region add of region of length never allocate file region and cannot fail region chg will always allocate at least entry and region add for page will only require at most entry"
        },
        "cavium_rng_probe": {
            "ground_truth": "0",
            "function": "cavium_rng_probe",
            "description": "cavium rng probe enable the rng hardware and activate the vf"
        },
        "ccw_device_set_options": {
            "ground_truth": "0",
            "function": "ccw_device_set_options",
            "description": "ccw device set option set some option all flag specified in flag are set the remainder is left untouched struct ccw device cdev device for which the option are to be set unsigned long flag option to be set on success einval if an invalid flag combination would ensue"
        },
        "test_lru_sanity3": {
            "ground_truth": "0",
            "function": "test_lru_sanity3",
            "description": "test lru sanity3 size of the lru map is tgt free it is to test the active inactive list rotation insert to tgt free tgt free key lookup key to tgt free add tgt free to tgt free tgt free key key tgt free to tgt free are removed from lru"
        },
        "batadv_gw_out_of_range": {
            "ground_truth": "0",
            "function": "batadv_gw_out_of_range",
            "description": "batadv gw out of range check if the dhcp request destination is the best gateway check if the skb is dhcp request and if it is sent to the current best gw server due to topology change it may be the case that the gw server previously selected is not the best one anymore this call might reallocate skb data must be invoked only when the dhcp packet is going to dhcp server struct batadv priv bat priv the bat priv with all the soft interface information struct sk buff skb the outgoing packet true if the packet destination is unicast and it is not the best gw false otherwise"
        },
        "mwifiex_setup_ht_caps": {
            "ground_truth": "0",
            "function": "mwifiex_setup_ht_caps",
            "description": "mwifiex setup ht cap this function set up the cfg802 specific ht capability field with default value the following default value are set ht supported true maximum ampdu length factor ieee80211 ht max ampdu 64k minimum ampdu spacing ieee80211 ht mpdu density none ht capability supported by firmware mc information rx mask mcd information tx parameter ieee80211 ht mc tx defined"
        },
        "mwifiex_cmd_reg_access": {
            "ground_truth": "0",
            "function": "mwifiex_cmd_reg_access",
            "description": "mwifiex cmd reg access this function prepares command to set get register value preparation includes setting command id action and proper size setting register offset for both get and set and register value for set only ensuring correct endian ness the following type of register can be accessed with this function mac register bbp register rf register pmic register cau register eeprom"
        },
        "snd_ftu_eff_switch_info": {
            "ground_truth": "0",
            "function": "snd_ftu_eff_switch_info",
            "description": "snd ftu eff switch info audio fasttrack ultra quirk"
        },
        "acpi_ex_release_all_mutexes": {
            "ground_truth": "0",
            "function": "acpi_ex_release_all_mutexes",
            "description": "acpi ex release all mutexes function acpi ex release all mutexes parameter thread current executing thread object return status description release all mutexes held by this thread note this function is called a the thread is exiting the interpreter mutexes are not released when an individual control method is exited but only when the parent thread actually exit the interpreter this allows one method to acquire mutex and different method to release it a long a this is performed underneath single parent control method"
        },
        "am33xx_cm_module_enable": {
            "ground_truth": "0",
            "function": "am33xx_cm_module_enable",
            "description": "am33xx cm module enable enable the modulemode inside clkctrl no return value u8 mode module mode sw or hw u8 part cm partition ignored for am33xx u16 inst cm instance register offset inst macro u16 clkctrl offs module clock control register offset clkctrl macro"
        },
        "die_get_call_fileno": {
            "ground_truth": "0",
            "function": "die_get_call_fileno",
            "description": "die get call fileno get the call file index number in cu die"
        },
        "__list_add": {
            "ground_truth": "0",
            "function": "__list_add",
            "description": "list add insert new entry between two known consecutive entry this is only for internal list manipulation where we know the prev next entry already"
        },
        "seq_nr_after": {
            "ground_truth": "0",
            "function": "seq_nr_after",
            "description": "seq nr after seq nr after return true if is after higher in sequence than false otherwise"
        },
        "led_trigger_register_simple": {
            "ground_truth": "0",
            "function": "led_trigger_register_simple",
            "description": "led trigger register simple trigger inline empty function"
        },
        "rpcrdma_xprt_connect": {
            "ground_truth": "0",
            "function": "rpcrdma_xprt_connect",
            "description": "rpcrdma xprt connect connect an unconnected transport return on success or negative errno struct rpcrdma xprt xprt controlling transport instance"
        },
        "adt7462_read_word_data": {
            "ground_truth": "0",
            "function": "adt7462_read_word_data",
            "description": "adt7462 read word data bit register on the adt7462 are low byte first the data sheet say that the low byte must be read before the high byte"
        },
        "qedf_dbg_host_init": {
            "ground_truth": "0",
            "function": "qedf_dbg_host_init",
            "description": "qedf dbg host init qedf dbg host init setup the debugfs file for the pf"
        },
        "host1x_syncpt_nb_pts": {
            "ground_truth": "0",
            "function": "host1x_syncpt_nb_pts",
            "description": "host1x syncpt nb pt return number of sync point supported"
        },
        "sym_lookup_dmap": {
            "ground_truth": "0",
            "function": "sym_lookup_dmap",
            "description": "sym lookup dmap lookup the bit dma segment map this is only used if the direct mapping ha been unsuccessful"
        },
        "hpi_dsp_code_open": {
            "ground_truth": "0",
            "function": "hpi_dsp_code_open",
            "description": "hpi dsp code open prepare psdspcode to refer to the requested adapter is firmware code file name is obtained from hpios getdspcodepath return for success or error code if requested code is not available"
        },
        "start_transport": {
            "ground_truth": "0",
            "function": "start_transport",
            "description": "start transport start transport start transport for set of pipe the bit in channel mask specify what pipe to start only the bit of the first channel must be set regardless it interleave same thing for pause and stop trasport below"
        },
        "reboot_mode_register": {
            "ground_truth": "0",
            "function": "reboot_mode_register",
            "description": "reboot mode register register reboot mode driver struct reboot mode driver reboot reboot mode driver on success or negative error code on failure"
        },
        "acpi_ns_repair_PSS": {
            "ground_truth": "0",
            "function": "acpi_ns_repair_PSS",
            "description": "acpi n repair ps function acpi n repair ps parameter info method execution information block return object ptr pointer to the object returned from the evaluation of method or object return status ae ok if object is ok or wa repaired successfully description repair for the ps object if necessary sort the object list by the cpu frequency check that the power dissipation value are all proportional to cpu frequency sorting by frequency should be the same a sorting by power"
        },
        "tusb_set_async_mode": {
            "ground_truth": "0",
            "function": "tusb_set_async_mode",
            "description": "tusb set async mode note timing are from tusb datasheet rev sept"
        },
        "audit_filter_rules": {
            "ground_truth": "0",
            "function": "audit_filter_rules",
            "description": "audit filter rule compare task struct with an audit rule return on match otherwise if task creation is true this is an explicit indication that we are filtering task rule at task creation time this and tsk current are the only situation where tsk cred may be accessed without an rcu read lock"
        },
        "smc_clc_proposal_get_prefix": {
            "ground_truth": "0",
            "function": "smc_clc_proposal_get_prefix",
            "description": "smc clc proposal get prefix determine start of the prefix area within the proposal message"
        },
        "ieee80211_classify": {
            "ground_truth": "0",
            "function": "ieee80211_classify",
            "description": "ieee80211 classify classify the to be send data packet"
        },
        "init_done": {
            "ground_truth": "0",
            "function": "init_done",
            "description": "init done opcode struct nvbios init init undescribed"
        },
        "batadv_tp_batctl_notify": {
            "ground_truth": "0",
            "function": "batadv_tp_batctl_notify",
            "description": "batadv tp batctl notify send client status result to client enum batadv tp meter reason reason reason for tp meter session stop const u8 dst destination of tp meter session struct batadv priv bat priv the bat priv with all the soft interface information unsigned long start time start of transmission in jiffy u64 total sent byte acked to the receiver u32 cookie cookie of tp meter session"
        },
        "handle_one_vic": {
            "ground_truth": "0",
            "function": "handle_one_vic",
            "description": "handle one vic handle each interrupt in single vic return non zero if we have handled at least one interrupt this read the status register before handling each interrupt which is necessary given that handle irq may briefly re enable interrupt for soft irq handling"
        },
        "batadv_iv_ogm_fwd_send_time": {
            "ground_truth": "0",
            "function": "batadv_iv_ogm_fwd_send_time",
            "description": "batadv iv ogm fwd send time when do we schedule ogm packet to be sent"
        },
        "dc_fixpt_sqr": {
            "ground_truth": "0",
            "function": "dc_fixpt_sqr",
            "description": "dc fixpt sqr result square arg arg arg brief"
        },
        "intel_overlay_recover_from_interrupt": {
            "ground_truth": "0",
            "function": "intel_overlay_recover_from_interrupt",
            "description": "intel overlay recover from interrupt recover from an interruption due to signal we have to be careful not to repeat work forever an make forward progess"
        },
        "sctp_ulpq_order": {
            "ground_truth": "0",
            "function": "sctp_ulpq_order",
            "description": "sctp ulpq order forward declaration for internal helper"
        },
        "temac_dma_dcr_in": {
            "ground_truth": "0",
            "function": "temac_dma_dcr_in",
            "description": "temac dma dcr in temac dma dcr in32 dcr based dma read"
        },
        "inode_to_wb_is_valid": {
            "ground_truth": "0",
            "function": "inode_to_wb_is_valid",
            "description": "inode to wb is valid test whether an inode ha wb associated return true if inode ha wb associated may be called without any locking struct inode inode inode of interest"
        },
        "inode_set_iversion_queried": {
            "ground_truth": "0",
            "function": "inode_set_iversion_queried",
            "description": "inode set iversion queried set version to particular value a quereied set inode is version field to val and flag it for increment on the next change filesystems that persistently store the version on disk should use this when loading an existing inode from disk when loading in an version value from backing store we can not be certain that it wa not previously viewed before being stored thus we must assume that it wa to ensure that we do not end up handing out the same value for different version of the same inode struct inode inode inode to set u64 val new version value to set"
        },
        "ctcm_chx_restart": {
            "ground_truth": "0",
            "function": "ctcm_chx_restart",
            "description": "ctcm chx restart fi an instance of channel statemachine event the event just happened arg generic pointer casted from channel upon call fsm instance fi undescribed int event undescribed void arg undescribed"
        },
        "hexium_probe": {
            "ground_truth": "0",
            "function": "hexium_probe",
            "description": "hexium probe this is only called for old hv pci6 orion card without eeprom"
        },
        "irq_chip_enable_parent": {
            "ground_truth": "0",
            "function": "irq_chip_enable_parent",
            "description": "irq chip enable parent enable the parent interrupt default to unmask if null struct irq data data pointer to interrupt specific data"
        },
        "set_mtu": {
            "ground_truth": "0",
            "function": "set_mtu",
            "description": "set mtu set mtu set the mtu we can handle any incoming size the issue here is whether we need to restrict our outgoing size we do not deal with what happens to program that are already running when the size change ppd the per port data"
        },
        "xilinx_dma_tx_submit": {
            "ground_truth": "0",
            "function": "xilinx_dma_tx_submit",
            "description": "xilinx dma tx submit submit dma transaction struct dma async tx descriptor tx async transaction descriptor cookie value on success and failure value on error"
        },
        "pmd_init": {
            "ground_truth": "0",
            "function": "pmd_init",
            "description": "pmd init initialize new pmd table with invalid pointer"
        },
        "ia_css_frame_allocate_from_info": {
            "ground_truth": "0",
            "function": "ia_css_frame_allocate_from_info",
            "description": "ia cs frame allocate from info allocate frame using the resolution and format from frame info struct this is convenience function implemented on top of ia cs frame allocate brief allocate cs frame structure using frame info structure param frame the allocated frame param in info the frame info structure return the error code"
        },
        "maple_cpufreq_target": {
            "ground_truth": "0",
            "function": "maple_cpufreq_target",
            "description": "maple cpufreq target common interface to the cpufreq core"
        },
        "llc_conn_ev_rx_xxx_rsp_fbit_set_1": {
            "ground_truth": "0",
            "function": "llc_conn_ev_rx_xxx_rsp_fbit_set_1",
            "description": "llc conn ev rx xxx rsp fbit set not used function and their variation"
        },
        "ieee80211_alloc_hw_nm": {
            "ground_truth": "0",
            "function": "ieee80211_alloc_hw_nm",
            "description": "ieee80211 alloc hw nm allocate new hardware device this must be called once for each hardware device the returned pointer must be used to refer to this device when calling other function mac80211 allocates private data area for the driver pointed to by priv in type struct ieee80211 hw the size of this area is given a priv data len size priv data len length of private data const struct ieee80211 ops ops callback for this device const char requested name requested name for this device null is valid value and mean use the default naming phyd pointer to the new hardware device or null on error"
        },
        "uvd_v2_2_resume": {
            "ground_truth": "0",
            "function": "uvd_v2_2_resume",
            "description": "uvd v2 resume memory controller programming let the uvd memory controller know it is offset struct radeon device rdev radeon device pointer"
        },
        "usbnet_get_link_ksettings": {
            "ground_truth": "0",
            "function": "usbnet_get_link_ksettings",
            "description": "usbnet get link ksettings ethtool method minidrivers may need to add some more but they will probably want to use this base set"
        },
        "glk_rpm_retune_wa": {
            "ground_truth": "0",
            "function": "glk_rpm_retune_wa",
            "description": "glk rpm retune wa workaround firmware failing to restore the tuning value"
        },
        "brcmf_pno_find_reqid_by_bucket": {
            "ground_truth": "0",
            "function": "brcmf_pno_find_reqid_by_bucket",
            "description": "brcmf pno find reqid by bucket find request id for given bucket index struct brcmf pno info pi pno instance used u32 bucket index of firmware bucket"
        },
        "csi2tx_dphy_set_wakeup": {
            "ground_truth": "0",
            "function": "csi2tx_dphy_set_wakeup",
            "description": "csi2tx dphy set wakeup set wake up value in the phy"
        },
        "pci_enable_ats": {
            "ground_truth": "0",
            "function": "pci_enable_ats",
            "description": "pci enable at enable the at capability return on success or negative on failure struct pci dev dev the pci device int p the iommu page shift"
        },
        "__tcp_select_window": {
            "ground_truth": "0",
            "function": "__tcp_select_window",
            "description": "tcp select window choose new window without check for shrinking and without scaling applied to the result the caller doe these thing if necessary this is raw window selection"
        },
        "crypto_free_shash": {
            "ground_truth": "0",
            "function": "crypto_free_shash",
            "description": "crypto free shash zeroize and free the message digest handle struct crypto shash tfm cipher handle to be freed"
        },
        "pqi_revert_to_sis_mode": {
            "ground_truth": "0",
            "function": "pqi_revert_to_sis_mode",
            "description": "pqi revert to si mode switch the controller from pqi mode back into si mode"
        },
        "ioreq_read16": {
            "ground_truth": "0",
            "function": "ioreq_read16",
            "description": "ioreq read16 ioreq"
        },
        "st_nci_spi_write": {
            "ground_truth": "0",
            "function": "st_nci_spi_write",
            "description": "st nci spi write writing frame must not return the number of written byte it must return either zero for success or for error in addition it must not alter the skb"
        },
        "isp1760_udc_irq": {
            "ground_truth": "0",
            "function": "isp1760_udc_irq",
            "description": "isp1760 udc irq interrupt handling"
        },
        "bam_alloc_chan": {
            "ground_truth": "0",
            "function": "bam_alloc_chan",
            "description": "bam alloc chan allocate channel resource for dma channel this function allocates the fifo descriptor memory struct dma chan chan specified channel"
        },
        "ssp_save_state": {
            "ground_truth": "0",
            "function": "ssp_save_state",
            "description": "ssp save state save the ssp configuration save the configured ssp state for suspend struct ssp state ssp pointer to structure to save ssp configuration"
        },
        "iwl_blink_compensation": {
            "ground_truth": "0",
            "function": "iwl_blink_compensation",
            "description": "iwl blink compensation adjust led blink rate to compensate on mac clock difference on every hw led blink rate analysis showed an average deviation of on series and up need to compensate on the led on off time per hw according to the deviation to achieve the desired led frequency the calculation is averagedeviation blinktime for code efficiency the calculation will be compensation averagedeviation newblinktime compensation blinktime"
        },
        "saa7164_encoder_configure": {
            "ground_truth": "0",
            "function": "saa7164_encoder_configure",
            "description": "saa7164 encoder configure take the encoder configuration form the port struct and flush it to the hardware"
        },
        "get_driver": {
            "ground_truth": "0",
            "function": "get_driver",
            "description": "get driver driver"
        },
        "board_added": {
            "ground_truth": "0",
            "function": "board_added",
            "description": "board added called after board ha been added to the system turn power on for the board configures board struct pci func func pci device function info struct controller ctrl hotplug controller"
        },
        "pl08x_choose_master_bus": {
            "ground_truth": "0",
            "function": "pl08x_choose_master_bus",
            "description": "pl08x choose master bus autoselect master bus to use for the transfer slave will be the chosen a victim in case src dest are not similarly aligned if after aligning master address with width requirement of transfer by sending few byte by byte data slave is still not aligned then it width will be reduced to byte prefers the destination bus if both available prefers bus with fixed address peripheral"
        },
        "hw_atl_rpfl3l4_ipv4_dest_addr_clear": {
            "ground_truth": "0",
            "function": "hw_atl_rpfl3l4_ipv4_dest_addr_clear",
            "description": "hw atl rpfl3l4 ipv4 dest addr clear clear ipv4 filter destination address"
        },
        "r8712_init_cmd_priv": {
            "ground_truth": "0",
            "function": "r8712_init_cmd_priv",
            "description": "r8712 init cmd priv caller and the r8712 cmd thread can protect cmd by spin lock no irqsave is necessary"
        },
        "edac_pci_do_parity_check": {
            "ground_truth": "0",
            "function": "edac_pci_do_parity_check",
            "description": "edac pci do parity check edac pci do parity check performs the actual pci parity check operation"
        },
        "_omap_dsi_configure_irqs": {
            "ground_truth": "0",
            "function": "_omap_dsi_configure_irqs",
            "description": "omap dsi configure irqs dsi irq lock ha to be locked by the caller"
        },
        "__ppp_channel_push": {
            "ground_truth": "0",
            "function": "__ppp_channel_push",
            "description": "ppp channel push try to send data out on channel"
        },
        "fault": {
            "ground_truth": "0",
            "function": "fault",
            "description": "fault there wa some error on the socket disconnect whatever"
        },
        "hrz_close_rx": {
            "ground_truth": "0",
            "function": "hrz_close_rx",
            "description": "hrz close rx cancel listen on vc"
        },
        "hpfs_error": {
            "ground_truth": "0",
            "function": "hpfs_error",
            "description": "hpfs error filesystem error"
        },
        "fm10k_update_mc_addr_vf": {
            "ground_truth": "0",
            "function": "fm10k_update_mc_addr_vf",
            "description": "fm10k update mc addr vf update device multicast address struct fm10k hw hw pointer to the hw structure u16 always unused glort unused const u8 mac mac address to add remove from table u16 vid vlan id to add remove from table bool add indicates if this is an add or remove operation this function is used to add or remove multicast mac address for the vf"
        },
        "igb_write_pcie_cap_reg": {
            "ground_truth": "0",
            "function": "igb_write_pcie_cap_reg",
            "description": "igb write pcie cap reg these function must be implemented by driver"
        },
        "tsi721_add_outb_message": {
            "ground_truth": "0",
            "function": "tsi721_add_outb_message",
            "description": "tsi721 add outb message add message to the tsi721 outbound message queue struct rio mport mport master port with outbound message queue struct rio dev rdev target of outbound message int mbox outbound mailbox void buffer message to add to outbound queue size len length of message"
        },
        "pcap_keys_handler": {
            "ground_truth": "0",
            "function": "pcap_keys_handler",
            "description": "pcap key handler pcap2 interrupt u on keypress"
        },
        "show_in": {
            "ground_truth": "0",
            "function": "show_in",
            "description": "show in sysfs in"
        },
        "virtio_break_device": {
            "ground_truth": "0",
            "function": "virtio_break_device",
            "description": "virtio break device this should prevent the device from being used allowing driver to recover you may need to grab appropriate lock to flush"
        },
        "LZ4_compressBound": {
            "ground_truth": "0",
            "function": "LZ4_compressBound",
            "description": "lz4 compressbound max output size in worst case szenarios size isize size of the input data max size lz4 may output in worst case szenario data not compressible"
        },
        "amdgpu_debugfs_regs_init": {
            "ground_truth": "0",
            "function": "amdgpu_debugfs_regs_init",
            "description": "amdgpu debugfs regs init initialize debugfs entry that provide register access struct amdgpu device adev the device to attach the debugfs entry to"
        },
        "ixgbe_init_rx_addrs_generic": {
            "ground_truth": "0",
            "function": "ixgbe_init_rx_addrs_generic",
            "description": "ixgbe init rx addrs generic initializes receive address filter struct ixgbe hw hw pointer to hardware structure place the mac address in receive address register and clear the rest of the receive address register clear the multicast table assumes the receiver is in reset when the routine is called"
        },
        "rwsem_owner_flags": {
            "ground_truth": "0",
            "function": "rwsem_owner_flags",
            "description": "rwsem owner flag return the real task structure pointer of the owner and the embedded flag in the owner pflags must be non null"
        },
        "csi2_get_format": {
            "ground_truth": "0",
            "function": "csi2_get_format",
            "description": "csi2 get format csi2 get format handle get format by pad subdev method sd pointer to v4l2 subdev structure cfg v4l2 subdev pad configuration fmt pointer to v4l2 subdev format structure return einval or zero on success"
        },
        "genwqe_reset_interrupt_capability": {
            "ground_truth": "0",
            "function": "genwqe_reset_interrupt_capability",
            "description": "genwqe reset interrupt capability undo genwqe set interrupt capability struct genwqe dev cd pointer to the device"
        },
        "dwc2_handle_otg_intr": {
            "ground_truth": "0",
            "function": "dwc2_handle_otg_intr",
            "description": "dwc2 handle otg intr handle the otg interrupt it read the otg interrupt register gotgint to determine what interrupt ha occurred struct dwc2 hsotg hsotg programming view of dwc otg controller"
        },
        "ve_spc_round_performance": {
            "ground_truth": "0",
            "function": "ve_spc_round_performance",
            "description": "ve spc round performance find closest match to given frequency in opp table"
        },
        "hackrf_return_all_buffers": {
            "ground_truth": "0",
            "function": "hackrf_return_all_buffers",
            "description": "hackrf return all buffer videobuf2 operation"
        },
        "e1000_phy_igp_get_info": {
            "ground_truth": "0",
            "function": "e1000_phy_igp_get_info",
            "description": "e1000 phy igp get info get igp specific register get phy information from various phy register for igp phy only struct e1000 hw hw struct containing variable accessed by shared code struct e1000 phy info phy info phy information structure"
        },
        "snd_ali_reset_5451": {
            "ground_truth": "0",
            "function": "snd_ali_reset_5451",
            "description": "snd ali reset ac97 reset"
        },
        "_scsih_sas_ir_operation_status_event_debug": {
            "ground_truth": "0",
            "function": "_scsih_sas_ir_operation_status_event_debug",
            "description": "scsih sa ir operation status event debug debug for ir op event struct mpt3sas adapter ioc per adapter object event data event data payload user"
        },
        "smcr_lgr_set_type": {
            "ground_truth": "0",
            "function": "smcr_lgr_set_type",
            "description": "smcr lgr set type set new lgr type and clear all asymmetric link tagging"
        },
        "intel_master_probe": {
            "ground_truth": "0",
            "function": "intel_master_probe",
            "description": "intel master probe probe and init"
        },
        "pvr2_hdw_untrip": {
            "ground_truth": "0",
            "function": "pvr2_hdw_untrip",
            "description": "pvr2 hdw untrip reset worker is error trapping circuit breaker"
        },
        "tx_timeout": {
            "ground_truth": "0",
            "function": "tx_timeout",
            "description": "tx timeout called when hdlc frame time out update stats and do tx completion processing"
        },
        "aac_src_deliver_message": {
            "ground_truth": "0",
            "function": "aac_src_deliver_message",
            "description": "aac src deliver message struct fib fib fib to issue will send fib returning if successful"
        },
        "posix_cputimers_init_work": {
            "ground_truth": "0",
            "function": "posix_cputimers_init_work",
            "description": "posix cputimers init work initialize posix cpu timer task work in init task out of line to keep the callback static and to avoid header recursion hell"
        },
        "genpd_resume_noirq": {
            "ground_truth": "0",
            "function": "genpd_resume_noirq",
            "description": "genpd resume noirq start of resume of device in an pm domain restore power to the device is pm domain if necessary and start the device struct device dev device to resume"
        },
        "ctcmpc_dump_skb": {
            "ground_truth": "0",
            "function": "ctcmpc_dump_skb",
            "description": "ctcmpc dump skb dump header and first byte of an sk buff for debugging purpose skb the sk buff to dump offset offset relative to skb data where to start the dump"
        },
        "do_amba_entry": {
            "ground_truth": "0",
            "function": "do_amba_entry",
            "description": "do amba entry look like amba dn is exactly digit where each is an upper case hex digit or or pattern matching exactly one digit"
        },
        "r5c_flush_stripe": {
            "ground_truth": "0",
            "function": "r5c_flush_stripe",
            "description": "r5c flush stripe r5c flush stripe move stripe from cached list to handle list when called the stripe must be on r5c cached full stripe or r5c cached partial stripe must hold conf device lock"
        },
        "rds_ib_sysctl_init": {
            "ground_truth": "0",
            "function": "rds_ib_sysctl_init",
            "description": "rds ib sysctl init ib sysctl"
        },
        "intel_hdcp_capable": {
            "ground_truth": "0",
            "function": "intel_hdcp_capable",
            "description": "intel hdcp capable is hdcp1 capable on platform and sink"
        },
        "remove_net_device": {
            "ground_truth": "0",
            "function": "remove_net_device",
            "description": "remove net device remove network device in the network device table"
        },
        "xenon_set_acg": {
            "ground_truth": "0",
            "function": "xenon_set_acg",
            "description": "xenon set acg enable disable the auto clock gating function"
        },
        "ktime_to_ns": {
            "ground_truth": "0",
            "function": "ktime_to_ns",
            "description": "ktime to n convert ktime to nanosecond"
        },
        "register_tracepoint_module_notifier": {
            "ground_truth": "0",
            "function": "register_tracepoint_module_notifier",
            "description": "register tracepoint module notifier register tracepoint coming going notifier notifiers registered with this function are called on module coming going with the tracepoint module list mutex held the notifier block callback should expect struct tp module data pointer struct notifier block nb notifier block"
        },
        "extcon_unregister_notifier": {
            "ground_truth": "0",
            "function": "extcon_unregister_notifier",
            "description": "extcon unregister notifier unregister notifier block from the extcon return if success or error number if fail struct extcon dev edev the extcon device unsigned int id the unique id indicating an external connector struct notifier block nb notifier block to be registered"
        },
        "conv_8bit_to_uni": {
            "ground_truth": "0",
            "function": "conv_8bit_to_uni",
            "description": "conv 8bit to uni always use user map these function are used by the keyboard which should not be affected by g0 g1 switching etc if the user map still contains default value the direct to font mapping then assume user is using latin1 fixme at some point we need to decide if we want to lock the table update element itself via the keyboard event lock for consistency with the keyboard driver a well a the console"
        },
        "mega_cmd_done": {
            "ground_truth": "0",
            "function": "mega_cmd_done",
            "description": "mega cmd done complete the command and call the scsi mid layer callback hook adapter adapter pointer to our soft state u8 completed array of id of completed command int nstatus number of completed command int status status of the last command completed"
        },
        "qbman_swp_fq_xon": {
            "ground_truth": "0",
            "function": "qbman_swp_fq_xon",
            "description": "qbman swp fq xon set fq flow control to xon this setting doe not affect enqueues to the fq just dequeues return for success or negative error code for failure struct qbman swp the software portal object u32 fqid the index of frame queue"
        },
        "wm8400_set_dai_fmt": {
            "ground_truth": "0",
            "function": "wm8400_set_dai_fmt",
            "description": "wm8400 set dai fmt set adc and voice dac format"
        },
        "debug_opt_scan": {
            "ground_truth": "0",
            "function": "debug_opt_scan",
            "description": "debug opt scan analyze debug option return false if something is amiss"
        },
        "da7218_tonegen_freq_get": {
            "ground_truth": "0",
            "function": "da7218_tonegen_freq_get",
            "description": "da7218 tonegen freq get tonegen"
        },
        "cm_conn_rep_handler": {
            "ground_truth": "0",
            "function": "cm_conn_rep_handler",
            "description": "cm conn rep handler active side cm id established the app ha called connect and is waiting for the established event to post it is request to the server this event will wake up anyone blocked in iw cm disconnect or iw destroy id"
        },
        "__thaw_task": {
            "ground_truth": "0",
            "function": "__thaw_task",
            "description": "thaw task take and release task alloc lock using task lock"
        },
        "btree_init_mempool": {
            "ground_truth": "0",
            "function": "btree_init_mempool",
            "description": "btree init mempool initialise btree with given mempool when this function is used there is no need to destroy the mempool struct btree head head the btree head to initialise mempool mempool the mempool to use"
        },
        "dio_bio_submit": {
            "ground_truth": "0",
            "function": "dio_bio_submit",
            "description": "dio bio submit in the aio read case we speculatively dirty the page before starting io during io completion any of these page which happen to have been written back will be redirtied by bio check page dirty bios hold dio reference between submit bio and end io"
        },
        "ohci_init": {
            "ground_truth": "0",
            "function": "ohci_init",
            "description": "ohci init init memory and kick bios smm off"
        },
        "sym_get_cam_status": {
            "ground_truth": "0",
            "function": "sym_get_cam_status",
            "description": "sym get cam status get the status field of cam ccb"
        },
        "video_mux": {
            "ground_truth": "0",
            "function": "video_mux",
            "description": "video mux video audio decoder related function"
        },
        "bnx2x_get_load_status": {
            "ground_truth": "0",
            "function": "bnx2x_get_load_status",
            "description": "bnx2x get load status read the load status for the current engine should be run under rtnl lock"
        },
        "hns_rcb_reset_ring_hw": {
            "ground_truth": "0",
            "function": "hns_rcb_reset_ring_hw",
            "description": "hn rcb reset ring hw ring reset struct hnae queue ring struct pointer"
        },
        "tx39_blast_dcache_page": {
            "ground_truth": "0",
            "function": "tx39_blast_dcache_page",
            "description": "tx39 blast dcache page tx39h2 tx39h3"
        },
        "gvbctv3pci_audio": {
            "ground_truth": "0",
            "function": "gvbctv3pci_audio",
            "description": "gvbctv3pci audio connect something to the gpio pin"
        },
        "ia_css_get_sdis2_horicoef_config": {
            "ground_truth": "0",
            "function": "ia_css_get_sdis2_horicoef_config",
            "description": "ia cs get sdis2 horicoef config code generated by genparam gencode gen get function"
        },
        "raid6_sse11_gen_syndrome": {
            "ground_truth": "0",
            "function": "raid6_sse11_gen_syndrome",
            "description": "raid6 sse11 gen syndrome plain sse1 implementation"
        },
        "DvbDmxFilterCallback": {
            "ground_truth": "0",
            "function": "DvbDmxFilterCallback",
            "description": "dvbdmxfiltercallback irq handling"
        },
        "is_overloaded": {
            "ground_truth": "0",
            "function": "is_overloaded",
            "description": "is overloaded if the dest flag is set with ip v dest overload consider that the server is overloaded here"
        },
        "nand_get_bits_per_cell": {
            "ground_truth": "0",
            "function": "nand_get_bits_per_cell",
            "description": "nand get bit per cell extract the bit of per cell from the 3rd byte of the extended id"
        },
        "calc_gus_envelope_time": {
            "ground_truth": "0",
            "function": "calc_gus_envelope_time",
            "description": "calc gu envelope time calculate gu envelope time"
        },
        "is_polling_required": {
            "ground_truth": "0",
            "function": "is_polling_required",
            "description": "is polling required return true if need to continue polling for this cm struct charger manager cm the charger manager representing the battery"
        },
        "bnx2x_vf_qtbl_set_q": {
            "ground_truth": "0",
            "function": "bnx2x_vf_qtbl_set_q",
            "description": "bnx2x vf qtbl set vf api helper"
        },
        "tb_tunnel_alloc_dp": {
            "ground_truth": "0",
            "function": "tb_tunnel_alloc_dp",
            "description": "tb tunnel alloc dp allocate display port tunnel allocates tunnel between in and out that is capable of tunneling display port traffic struct tb tb pointer to the domain structure struct tb port in dp in adapter port struct tb port out dp out adapter port int max up maximum available upstream bandwidth for the dp tunnel if not limited int max down maximum available downstream bandwidth for the dp tunnel if not limited return tb tunnel on success or null on failure"
        },
        "ocfs2_may_continue_on_blocked_lock": {
            "ground_truth": "0",
            "function": "ocfs2_may_continue_on_blocked_lock",
            "description": "ocfs2 may continue on blocked lock predict what lock level we will be dropping down to on behalf of another node and return true if the currently wanted level will be compatible with it"
        },
        "rt2x00usb_disable_radio": {
            "ground_truth": "0",
            "function": "rt2x00usb_disable_radio",
            "description": "rt2x00usb disable radio radio handler"
        },
        "csky_pmu_read_icmc": {
            "ground_truth": "0",
            "function": "csky_pmu_read_icmc",
            "description": "csky pmu read icmc l1 icache miss counter"
        },
        "sisusbcon_scrolldelta": {
            "ground_truth": "0",
            "function": "sisusbcon_scrolldelta",
            "description": "sisusbcon scrolldelta interface routine"
        },
        "put_dec_full4": {
            "ground_truth": "0",
            "function": "put_dec_full4",
            "description": "put dec full4 put dec full4 handle number in the range the multiplier is round and the approximation is exact for all"
        },
        "cifs_nlink_fattr_to_inode": {
            "ground_truth": "0",
            "function": "cifs_nlink_fattr_to_inode",
            "description": "cifs nlink fattr to inode copy nlink to the inode unless it wa not provided provide sane value if we do not have an existing one and none wa provided"
        },
        "nondisk_go_callback": {
            "ground_truth": "0",
            "function": "nondisk_go_callback",
            "description": "nondisk go callback used to signal when node did withdraw struct gfs2 glock gl the nondisk glock bool remote true if this came from different cluster node"
        },
        "ocfs2_extent_map_insert_rec": {
            "ground_truth": "0",
            "function": "ocfs2_extent_map_insert_rec",
            "description": "ocfs2 extent map insert rec in order to reduce complexity on the caller this insert function is intentionally liberal in what it will accept the only rule is that the truncate call must be used whenever record have been deleted this avoids inserting overlapping record with different physical mapping"
        },
        "sgl_to_sgl_fcnvfxt": {
            "ground_truth": "0",
            "function": "sgl_to_sgl_fcnvfxt",
            "description": "sgl to sgl fcnvfxt convert single floating point to single fixed point format with truncated result"
        },
        "i810_driver_reclaim_buffers": {
            "ground_truth": "0",
            "function": "i810_driver_reclaim_buffers",
            "description": "i810 driver reclaim buffer must be called with the lock held"
        },
        "xa_delete_node": {
            "ground_truth": "0",
            "function": "xa_delete_node",
            "description": "xa delete node private interface for workingset code struct xa node node node to be removed from the tree xa update node update function to call to update ancestor node xa lock must be held on entry and will not be released"
        },
        "arm_dma_supported": {
            "ground_truth": "0",
            "function": "arm_dma_supported",
            "description": "arm dma supported return whether the given device dma address mask can be supported properly for example if your device can only drive the low bit during bus mastering then you would pas a the mask to this function"
        },
        "intel_panel_set_backlight_acpi": {
            "ground_truth": "0",
            "function": "intel_panel_set_backlight_acpi",
            "description": "intel panel set backlight acpi set backlight brightness to level in range max assuming hw min is respected"
        },
        "ncm_tx_timeout": {
            "ground_truth": "0",
            "function": "ncm_tx_timeout",
            "description": "ncm tx timeout the transmit should only be run if no skb data ha been sent for certain duration"
        },
        "broadsheet_init_display": {
            "ground_truth": "0",
            "function": "broadsheet_init_display",
            "description": "broadsheet init display upper level function that manipulate the display and other stuff"
        },
        "sync_stop": {
            "ground_truth": "0",
            "function": "sync_stop",
            "description": "sync stop remove the hook"
        },
        "intel_gvt_init_gtt": {
            "ground_truth": "0",
            "function": "intel_gvt_init_gtt",
            "description": "intel gvt init gtt initialize mm component of gvt device this function is called at the initialization stage to initialize the mm component of gvt device struct intel gvt gvt gvt device zero on success negative error code if failed"
        },
        "ipv6_mc_up": {
            "ground_truth": "0",
            "function": "ipv6_mc_up",
            "description": "ipv6 mc up device going up"
        },
        "iceland_ih_irq_disable": {
            "ground_truth": "0",
            "function": "iceland_ih_irq_disable",
            "description": "iceland ih irq disable disable interrupt disable interrupt on the hw vi struct amdgpu device adev amdgpu device pointer"
        },
        "virt_wifi_get_station": {
            "ground_truth": "0",
            "function": "virt_wifi_get_station",
            "description": "virt wifi get station called with the rtnl lock held"
        },
        "st_ll_disable": {
            "ground_truth": "0",
            "function": "st_ll_disable",
            "description": "st ll disable called when st core local module want to disable st ll"
        },
        "kvm_mips_build_exception": {
            "ground_truth": "0",
            "function": "kvm_mips_build_exception",
            "description": "kvm mips build exception assemble first level guest exception handler assemble exception vector code for guest execution the generated vector will branch to the common exception handler generated by kvm mips build exit void addr address to start writing code void handler address of common handler within range of addr next address after end of written function"
        },
        "nv04_nvsw_mthd_get_ref": {
            "ground_truth": "0",
            "function": "nv04_nvsw_mthd_get_ref",
            "description": "nv04 nvsw mthd get ref software object class"
        },
        "wil_mtu2macbuf": {
            "ground_truth": "0",
            "function": "wil_mtu2macbuf",
            "description": "wil mtu2macbuf calculate mac buffer size for the firmware it includes all overhead a it will go over the air and need to be byte aligned"
        },
        "__cvmx_helper_npi_enable": {
            "ground_truth": "0",
            "function": "__cvmx_helper_npi_enable",
            "description": "cvmx helper npi enable should be fully functional this is called with ipd enabled but pko disabled return zero on success negative on failure int interface interface to bring up"
        },
        "dfx_close": {
            "ground_truth": "0",
            "function": "dfx_close",
            "description": "dfx close dfx close overview close the device module return condition code argument dev pointer to device information functional description this routine close the adapter and brings it to safe state the interrupt service routine is deregistered with the o the adapter can be opened again with another call to dfx open return code always return assumption no further request for this adapter are made after this routine is called dfx open can be called to reset and reinitialize the adapter side effect adapter should be in dma unavailable state upon completion of this routine"
        },
        "sd_init": {
            "ground_truth": "0",
            "function": "sd_init",
            "description": "sd init this function is called at probe and resume time"
        },
        "t3_sge_prep": {
            "ground_truth": "0",
            "function": "t3_sge_prep",
            "description": "t3 sge prep one time sge initialization struct adapter adap the associated adapter struct sge params sge parameter performs one time initialization of sge sw state includes determining default for the assorted sge parameter which admins can change until they are used to initialize the sge"
        },
        "intel_thermal_interrupt": {
            "ground_truth": "0",
            "function": "intel_thermal_interrupt",
            "description": "intel thermal interrupt thermal transition interrupt handler"
        },
        "eo_update_clusters": {
            "ground_truth": "0",
            "function": "eo_update_clusters",
            "description": "eo update cluster the on disk structure usually keep track of how many total cluster are stored in this extent tree this function update that value new cluster is the delta and must be added to the total required"
        },
        "ath11k_dp_rxbufs_replenish": {
            "ground_truth": "0",
            "function": "ath11k_dp_rxbufs_replenish",
            "description": "ath11k dp rxbufs replenish return number of rx buffer replenished"
        },
        "xfs_iunlink_insert_backref": {
            "ground_truth": "0",
            "function": "xfs_iunlink_insert_backref",
            "description": "xfs iunlink insert backref take ownership of an iunlink cache entry and insert it into the hash table if successful the entry will be owned by the cache if not it is freed either way the caller doe not own iu after this call"
        },
        "v4l2_subdev_free_pad_config": {
            "ground_truth": "0",
            "function": "v4l2_subdev_free_pad_config",
            "description": "v4l2 subdev free pad config free memory allocated by v4l2 subdev alloc pad config struct v4l2 subdev pad config cfg pointer to type struct v4l2 subdev pad config"
        },
        "jpeg_v2_5_dec_ring_get_wptr": {
            "ground_truth": "0",
            "function": "jpeg_v2_5_dec_ring_get_wptr",
            "description": "jpeg v2 dec ring get wptr get write pointer return the current hardware write pointer struct amdgpu ring ring amdgpu ring pointer"
        },
        "cpufreq_set_cur_state": {
            "ground_truth": "0",
            "function": "cpufreq_set_cur_state",
            "description": "cpufreq set cur state callback function to set the current cooling state callback for the thermal cooling device to change the cpufreq current cooling state struct thermal cooling device cdev thermal cooling device pointer unsigned long state set this variable to the current cooling state on success an error code otherwise"
        },
        "sched_autogroup_create_attach": {
            "ground_truth": "0",
            "function": "sched_autogroup_create_attach",
            "description": "sched autogroup create attach allocates gfp kernel cannot be called under any spinlock"
        },
        "change_mode": {
            "ground_truth": "0",
            "function": "change_mode",
            "description": "change mode safely change the mode bit in the ecr return success ebusy could not drain fifo in some finite amount of time mode not changed"
        },
        "qla2x00_dfs_setup": {
            "ground_truth": "0",
            "function": "qla2x00_dfs_setup",
            "description": "qla2x00 dfs setup global function prototype in qla dfs source file"
        },
        "sbi_set_timer": {
            "ground_truth": "0",
            "function": "sbi_set_timer",
            "description": "sbi set timer program the timer for next timer event uint64 stime value the value after which next timer event should fire none"
        },
        "mei_me_cl_rm_by_uuid": {
            "ground_truth": "0",
            "function": "mei_me_cl_rm_by_uuid",
            "description": "mei me cl rm by uuid remove all me client matching uuid locking called under dev device lock lock struct mei device dev the device structure const uuid le uuid me client uuid"
        },
        "ufs_empty_dir": {
            "ground_truth": "0",
            "function": "ufs_empty_dir",
            "description": "ufs empty dir routine to check that the specified directory is empty for rmdir"
        },
        "plip_bh": {
            "ground_truth": "0",
            "function": "plip_bh",
            "description": "plip bh bottom half handler of plip"
        },
        "phy_ethtool_get_eee": {
            "ground_truth": "0",
            "function": "phy_ethtool_get_eee",
            "description": "phy ethtool get eee get eee supported and status it reportes the supported advertisement lp advertisement capability struct phy device phydev target phy device struct struct ethtool eee data ethtool eee data"
        },
        "__ssp_readl": {
            "ground_truth": "0",
            "function": "__ssp_readl",
            "description": "ssp readl read from sifive serial port register read the content of the ip block register located at offset offs from the ip block base given pointer ssp to struct sifive serial port record struct sifive serial port ssp pointer to struct sifive serial port record u16 offs register address offset from the ip block base address any context the value of the uart register"
        },
        "snd_pcm_link": {
            "ground_truth": "0",
            "function": "snd_pcm_link",
            "description": "snd pcm link pcm link handling"
        },
        "s3c24xx_mci_def_set_power": {
            "ground_truth": "0",
            "function": "s3c24xx_mci_def_set_power",
            "description": "s3c24xx mci def set power set platform data for mmc sdi device copy the platform data supplied by pdata so that this can be marked initdata unsigned char power mode undescribed unsigned short vdd undescribed"
        },
        "bnx2x_8705_config_init": {
            "ground_truth": "0",
            "function": "bnx2x_8705_config_init",
            "description": "bnx2x config init bcm8705 phy section"
        },
        "swsusp_check": {
            "ground_truth": "0",
            "function": "swsusp_check",
            "description": "swsusp check check for swsusp signature in the resume device void no argument"
        },
        "qdio_int_handler": {
            "ground_truth": "0",
            "function": "qdio_int_handler",
            "description": "qdio int handler qdio interrupt handler"
        },
        "aha152x_queue_lck": {
            "ground_truth": "0",
            "function": "aha152x_queue_lck",
            "description": "aha152x queue lck queue command"
        },
        "__get_fiq_regs": {
            "ground_truth": "0",
            "function": "__get_fiq_regs",
            "description": "get fiq regs helper defined in fiqasm"
        },
        "db1550_pci_setup": {
            "ground_truth": "0",
            "function": "db1550_pci_setup",
            "description": "db1550 pci setup must be arch initcall mips pci scan bus in subsys initcall"
        },
        "gs_cutoff": {
            "ground_truth": "0",
            "function": "gs_cutoff",
            "description": "g cutoff cutoff quarter semitone step max"
        },
        "ceph_unarmor": {
            "ground_truth": "0",
            "function": "ceph_unarmor",
            "description": "ceph unarmor armor"
        },
        "omap3isp_resizer_init": {
            "ground_truth": "0",
            "function": "omap3isp_resizer_init",
            "description": "omap3isp resizer init isp resizer init resizer initialization isp pointer to isp device return enomem or zero on success"
        },
        "mtd_set_dev_defaults": {
            "ground_truth": "0",
            "function": "mtd_set_dev_defaults",
            "description": "mtd set dev default set few default based on the parent device if not provided by the driver"
        },
        "HUF_optimalTableLog": {
            "ground_truth": "0",
            "function": "HUF_optimalTableLog",
            "description": "huf optimaltablelog utils"
        },
        "img_ir_timing_range_convert": {
            "ground_truth": "0",
            "function": "img_ir_timing_range_convert",
            "description": "img ir timing range convert convert microsecond range convert min and max from microsecond to ir clock cycle applies tolerance and shift for the register rounding in the right direction note that in and out can safely be the same object struct img ir timing range out output timing range in clock cycle with shift const struct img ir timing range in input timing range in microsecond unsigned int tolerance tolerance a fraction of roughly percent unsigned long clock hz ir clock rate in hz unsigned int shift shift of output unit"
        },
        "test_and_change_bit": {
            "ground_truth": "0",
            "function": "test_and_change_bit",
            "description": "test and change bit change bit and return it old value this operation is atomic and cannot be reordered it also implies the acquisition side of the memory barrier int nr bit to change volatile void addr address to count from"
        },
        "xchk_da_process_error": {
            "ground_truth": "0",
            "function": "xchk_da_process_error",
            "description": "xchk da process error check for da btree operation error"
        },
        "jsp_hpd_irq_setup": {
            "ground_truth": "0",
            "function": "jsp_hpd_irq_setup",
            "description": "jsp hpd irq setup jsp behaves exactly the same a mcc above except that port is mapped to the ddi pin instead of the tc1 pin this mean we should follow tgp is mask table rather than icp is mask table"
        },
        "wait_for_xmitr": {
            "ground_truth": "0",
            "function": "wait_for_xmitr",
            "description": "wait for xmitr wait for transmitter holding register to empty"
        },
        "nilfs_empty_dir": {
            "ground_truth": "0",
            "function": "nilfs_empty_dir",
            "description": "nilfs empty dir routine to check that the specified directory is empty for rmdir"
        },
        "BEx_get_resources": {
            "ground_truth": "0",
            "function": "BEx_get_resources",
            "description": "bex get resource on be2 be3 fw doe not suggest the supported limit"
        },
        "brcm_pcie_set_ssc": {
            "ground_truth": "0",
            "function": "brcm_pcie_set_ssc",
            "description": "brcm pcie set ssc configures device for spread spectrum clocking ssc mode negative return value indicates error"
        },
        "mts64_device_init": {
            "ground_truth": "0",
            "function": "mts64_device_init",
            "description": "mts64 device init init device led blinking startup magic return init ok eio failure"
        },
        "brcmf_bus_change_state": {
            "ground_truth": "0",
            "function": "brcmf_bus_change_state",
            "description": "brcmf bus change state configure the global bus state used by upper layer"
        },
        "rtw_restructure_ht_ie": {
            "ground_truth": "0",
            "function": "rtw_restructure_ht_ie",
            "description": "rtw restructure ht ie the function is passive level"
        },
        "x86_fsbase_read_cpu": {
            "ground_truth": "0",
            "function": "x86_fsbase_read_cpu",
            "description": "x86 fsbase read cpu helper function for reading writing f g base"
        },
        "irqd_set_single_target": {
            "ground_truth": "0",
            "function": "irqd_set_single_target",
            "description": "irqd set single target must only be called of irqchip irq set affinity or low level hieararchy domain allocation function"
        },
        "il3945_calc_db_from_ratio": {
            "ground_truth": "0",
            "function": "il3945_calc_db_from_ratio",
            "description": "il3945 calc db from ratio calculates relative db value from ratio of linear not db signal level conversion assumes that level are voltage log not power log"
        },
        "fscrypt_put_direct_key": {
            "ground_truth": "0",
            "function": "fscrypt_put_direct_key",
            "description": "fscrypt put direct key keysetup v1"
        },
        "do_print_item": {
            "ground_truth": "0",
            "function": "do_print_item",
            "description": "do print item print menu item"
        },
        "nl80211_common_reg_change_event": {
            "ground_truth": "0",
            "function": "nl80211_common_reg_change_event",
            "description": "nl80211 common reg change event this can happen on global regulatory change or device specific setting based on custom regulatory domain"
        },
        "set_device_state": {
            "ground_truth": "0",
            "function": "set_device_state",
            "description": "set device state blocked false is on blocked true is off"
        },
        "pidff_rescale_signed": {
            "ground_truth": "0",
            "function": "pidff_rescale_signed",
            "description": "pidff rescale signed scale signed value in range for the given field"
        },
        "ipr_invalid_adapter": {
            "ground_truth": "0",
            "function": "ipr_invalid_adapter",
            "description": "ipr invalid adapter determine if this adapter is supported on this hardware adapter that use gemstone revision do not work reliably on certain pseries hardware this function determines if the given adapter is in one of these confgurations or not return value if adapter is not supported if adapter is supported struct ipr ioa cfg ioa cfg ioa cfg struct"
        },
        "rpc_net_ns": {
            "ground_truth": "0",
            "function": "rpc_net_ns",
            "description": "rpc net n get the network namespace for this rpc client struct rpc clnt clnt rpc client to query"
        },
        "send_cmd_ioarrin": {
            "ground_truth": "0",
            "function": "send_cmd_ioarrin",
            "description": "send cmd ioarrin sends an afu command via ioarrin register struct afu afu afu associated with the host struct afu cmd cmd afu command to send on success scsi mlqueue host busy on failure"
        },
        "samsung_gpio_getcfg_2bit": {
            "ground_truth": "0",
            "function": "samsung_gpio_getcfg_2bit",
            "description": "samsung gpio getcfg 2bit samsung gpio getcfg 2bit samsung 2bit style gpio configuration read the reverse of samsung gpio setcfg 2bit will return value which could be directly passed back to samsung gpio setcfg 2bit from the s3c gpio special macro chip the gpio chip that is being configured off the offset for the gpio being configured"
        },
        "rvt_query_gid": {
            "ground_truth": "0",
            "function": "rvt_query_gid",
            "description": "rvt query gid return gid from the table struct ib device ibdev verb ib dev u8 port num port number based from ib core int guid index index in table union ib gid gid gid to return on success"
        },
        "smc_listen_out_connected": {
            "ground_truth": "0",
            "function": "smc_listen_out_connected",
            "description": "smc listen out connected listen worker finish in state connected"
        },
        "wm97xx_init_pen_irq": {
            "ground_truth": "0",
            "function": "wm97xx_init_pen_irq",
            "description": "wm97xx init pen irq initialise pen irq handler and workqueue"
        },
        "qlcnic_diag_free_res": {
            "ground_truth": "0",
            "function": "qlcnic_diag_free_res",
            "description": "qlcnic diag free re function from qlcnic main"
        },
        "kdb_bt1": {
            "ground_truth": "0",
            "function": "kdb_bt1",
            "description": "kdb bt1 kdb bt this function implement the bt command print stack traceback bt addr exp is for alternate stack btp kernel stack for btt kernel stack for task structure at bta drstczeuima all useful process optionally filtered by state btc the current process on one cpu default is all cpu bt refers to address on the stack that location is assumed to contain return address btt refers to the address of struct task input argc argument count argv argument vector output none return zero for success kdb diagnostic if error locking none remark backtrack work best when the code us frame pointer but even without frame pointer we should get reasonable trace md come in handy when examining the stack to do manual traceback or to get starting point for bt"
        },
        "iommu_dev_has_feature": {
            "ground_truth": "0",
            "function": "iommu_dev_has_feature",
            "description": "iommu dev ha feature per device iommu feature"
        },
        "kdb_symbol_print": {
            "ground_truth": "0",
            "function": "kdb_symbol_print",
            "description": "kdb symbol print kdb symbol print standard method for printing symbol name and offset input addr address to be printed symtab address of symbol data if null this routine doe it own lookup punc punctuation for string bit field remark the string and it punctuation is only printed if the address is inside the kernel except that the value is always printed when requested"
        },
        "hfi1_get_irq_affinity": {
            "ground_truth": "0",
            "function": "hfi1_get_irq_affinity",
            "description": "hfi1 get irq affinity set irq affinity to cpu the function will determine the cpu and set the affinity to it"
        },
        "urb_enqueue": {
            "ground_truth": "0",
            "function": "urb_enqueue",
            "description": "urb enqueue manage request device state"
        },
        "fc_fc4_add_lport": {
            "ground_truth": "0",
            "function": "fc_fc4_add_lport",
            "description": "fc fc4 add lport add new local port to list and run notifiers struct fc lport lport the new local port"
        },
        "pseudo_lock_cstates_constrain": {
            "ground_truth": "0",
            "function": "pseudo_lock_cstates_constrain",
            "description": "pseudo lock cstates constrain restrict core from entering c6 to prevent the cache from being affected by power management entering c6 ha to be avoided this is accomplished by requesting latency requirement lower than lowest c6 exit latency of all supported platform a found in the cpuidle state table in the intel idle driver at this time it is possible to do so with single latency requirement for all supported platform since goldmont is supported which is affected by x86 bug monitor the acpi latency need to be considered while keeping in mind that c2 may be set to map to deeper sleep state in this case the latency requirement need to prevent entering c2 also struct pseudo lock region plr undescribed"
        },
        "i2400m_rx_edata": {
            "ground_truth": "0",
            "function": "i2400m_rx_edata",
            "description": "i2400m rx edata receive and send up an extended data packet the skb starting in v1 of the i2400m is firmware the device can send data packet to the host in an extended format that this incus byte header struct i2400m pl edata hdr using this header is space we can fake ethernet header for ethernet device emulation without having to copy packet around this function handle said path receive and send up an extended data packet that requires no reordering the skb data payload header pas over to the networking stack data packet that might have reordering requirement this need to the decide if the skb in which the packet is contained can be reused or if it need to be cloned then it ha to be trimmed in the edge so that the beginning is the space for eth header and then pas it to i2400m net erx for the stack assumes the caller ha verified the sanity of the payload size etc already i2400m device descriptor skb rx skb that contains the extended data packet single last if the payload is the only one or the last one of payload pointer to the packet is data inside the skb size size of the payload i2400m device descriptor skb rx skb that contains the extended data packet single last if the payload is the only one or the last one of payload pointer to the packet is data past the actual extended size size of the payload"
        },
        "xenbus_exists": {
            "ground_truth": "0",
            "function": "xenbus_exists",
            "description": "xenbus exists check if path exists return if it doe"
        },
        "zynqmp_clock_get_topology": {
            "ground_truth": "0",
            "function": "zynqmp_clock_get_topology",
            "description": "zynqmp clock get topology get topology of clock from firmware using pm api u32 clk id clock index struct clock topology topology clock topology u32 num node number of node on success else error reason"
        },
        "ec_mul2": {
            "ground_truth": "0",
            "function": "ec_mul2",
            "description": "ec mul2 mod"
        },
        "qla2x00_handle_dif_error": {
            "ground_truth": "0",
            "function": "qla2x00_handle_dif_error",
            "description": "qla2x00 handle dif error check the guard or meta data for the type of error detected by the hba in case of error we set the asc ascq field in the sense buffer with illegal request to indicate to the kernel that the hba detected error"
        },
        "hclgevf_get_channels": {
            "ground_truth": "0",
            "function": "hclgevf_get_channels",
            "description": "hclgevf get channel get the current channel enabled and max supported we do not support separate tx and rx queue a channel the other count represents how many queue are being used for control max combined count how many queue pair we can support they may not be mapped to with vector since we support lot more queue pair than vector struct hnae3 handle handle hardware information for network interface struct ethtool channel ch ethtool channel structure"
        },
        "mutex_lock": {
            "ground_truth": "0",
            "function": "mutex_lock",
            "description": "mutex lock acquire the mutex lock the mutex exclusively for this task if the mutex is not available right now it will sleep until it can get it the mutex must later on be released by the same task that acquired it recursive locking is not allowed the task may not exit without first unlocking the mutex also kernel memory where the mutex resides must not be freed with the mutex still locked the mutex must first be initialized or statically defined before it can be locked memset ing the mutex to is not allowed the config debug mutexes config option turn on debugging check that will enforce the restriction and will also do deadlock debugging this function is similar to but not equivalent to down struct mutex lock the mutex to be acquired"
        },
        "ia64_mca_cmc_int_handler": {
            "ground_truth": "0",
            "function": "ia64_mca_cmc_int_handler",
            "description": "ia64 mca cmc int handler ia64 mca cmc int handler this is corrected machine check interrupt handler right now the log are extracted and displayed in well defined format input interrupt number client data arg ptr output none"
        },
        "ceu_init_mbus_fmt": {
            "ground_truth": "0",
            "function": "ceu_init_mbus_fmt",
            "description": "ceu init mbus fmt ceu init mbus fmt query sensor for supported format and initialize ceu medium bus format used to produce memory format find out if sensor can produce permutation of bit yuyv bus format from single bit yuyv bus format the ceu can produce several memory output format nv through image fetch mode yuyv422 if sensor provides yuyv422 todo other yuyv422 permutation through data fetch sync mode and dtary todo binary data eg jpeg and raw format through data fetch sync mode"
        },
        "kdump_mem_notifier": {
            "ground_truth": "0",
            "function": "kdump_mem_notifier",
            "description": "kdump mem notifier when kdump is enabled we have to ensure that no memory from the area crashkernel memory size is set offline it will be exchanged with the crashkernel memory region when kdump is triggered the crashkernel memory region can never get offlined page are unmovable"
        },
        "sst_slot_get": {
            "ground_truth": "0",
            "function": "sst_slot_get",
            "description": "sst slot get get the status of the interleaver deinterleaver control struct snd kcontrol kcontrol control pointer struct snd ctl elem value ucontrol user data search the map where the control status is stored and get the channel slot which is currently set for this enumerated control since it is an enumerated control there is only one possible value"
        },
        "clkdm_in_hwsup": {
            "ground_truth": "0",
            "function": "clkdm_in_hwsup",
            "description": "clkdm in hwsup is clockdomain clkdm have hardware supervised idle enabled return true if clockdomain clkdm currently ha hardware supervised idle enabled or false if it doe not or if clkdm is null it is only valid to call this function after clkdm init ha been called this function doe not actually read bit from the hardware it instead test an in memory flag that is changed whenever the clockdomain code change the auto idle mode struct clockdomain clkdm struct clockdomain"
        },
        "test_accept_after_delete": {
            "ground_truth": "0",
            "function": "test_accept_after_delete",
            "description": "test accept after delete check that child socket that got created while parent wa in sockmap but got accept ed only after the parent ha been removed from sockmap get cloned without parent psock state or callback"
        },
        "hpi_send_recv_ex": {
            "ground_truth": "0",
            "function": "hpi_send_recv_ex",
            "description": "hpi send recv ex note hpi message must be defined in the driver a wrapper for hpi messageex so that function in hpifunc compile"
        },
        "rds_ib_ack_send_complete": {
            "ground_truth": "0",
            "function": "rds_ib_ack_send_complete",
            "description": "rds ib ack send complete we get here from the send completion handler when the adapter tell u the ack frame wa sent"
        },
        "talitos_error": {
            "ground_truth": "0",
            "function": "talitos_error",
            "description": "talitos error recover from error interrupt"
        },
        "is_arm_mapping_symbol": {
            "ground_truth": "0",
            "function": "is_arm_mapping_symbol",
            "description": "is arm mapping symbol this ignores the intensely annoying mapping symbol found in arm elf file and"
        },
        "sctp_chunk_destroy": {
            "ground_truth": "0",
            "function": "sctp_chunk_destroy",
            "description": "sctp chunk destroy release the memory occupied by chunk"
        },
        "vi_get_xclk": {
            "ground_truth": "0",
            "function": "vi_get_xclk",
            "description": "vi get xclk get the xclk return the reference clock used by the gfx engine vi struct amdgpu device adev amdgpu device pointer"
        },
        "sonic_multicast_list": {
            "ground_truth": "0",
            "function": "sonic_multicast_list",
            "description": "sonic multicast list set or clear the multicast filter for this adaptor"
        },
        "bnx2x_func_comp_cmd": {
            "ground_truth": "0",
            "function": "bnx2x_func_comp_cmd",
            "description": "bnx2x func comp cmd complete the state change command check that the arrived completion is expected struct bnx2x bp device handle struct bnx2x func sp obj function info enum bnx2x func cmd cmd more info"
        },
        "vidtv_psi_pat_program_assign": {
            "ground_truth": "0",
            "function": "vidtv_psi_pat_program_assign",
            "description": "vidtv psi pat program assign assigns the program loop to the pat this will free the previous program loop in the table this will assign ownership of the program loop to the table the table will free this program loop when call to it destroy function is made struct vidtv psi table pat pat the pat to assign to struct vidtv psi table pat program the program loop one or more program"
        },
        "ct_limit_get": {
            "ground_truth": "0",
            "function": "ct_limit_get",
            "description": "ct limit get call with rcu read lock"
        },
        "cx25840_ir_log_status": {
            "ground_truth": "0",
            "function": "cx25840_ir_log_status",
            "description": "cx25840 ir log status v4l2 subdevice core ops support"
        },
        "tape_std_mtfsr": {
            "ground_truth": "0",
            "function": "tape_std_mtfsr",
            "description": "tape std mtfsr mtfsr forward space over count tape block blocksize is set via mtsetblk"
        },
        "hid_match_report": {
            "ground_truth": "0",
            "function": "hid_match_report",
            "description": "hid match report check if driver is raw event should be called compare hid driver report table report type to report type struct hid device hid hid device struct hid report report hid report to match against"
        },
        "mgag200_mm_init": {
            "ground_truth": "0",
            "function": "mgag200_mm_init",
            "description": "mgag200 mm init mgag200 mm"
        },
        "be_max_qp_irqs": {
            "ground_truth": "0",
            "function": "be_max_qp_irqs",
            "description": "be max qp irqs max irqs needed for combined queue"
        },
        "ima_load_kexec_buffer": {
            "ground_truth": "0",
            "function": "ima_load_kexec_buffer",
            "description": "ima load kexec buffer restore the measurement list from the previous kernel"
        },
        "fm10k_sm_mbx_create_connect_hdr": {
            "ground_truth": "0",
            "function": "fm10k_sm_mbx_create_connect_hdr",
            "description": "fm10k sm mbx create connect hdr generate mailbox header for local fifo struct fm10k mbx info mbx pointer to mailbox u8 err error flag to report if any this function return connection mailbox header"
        },
        "hw_atl_rdm_cpu_id_set": {
            "ground_truth": "0",
            "function": "hw_atl_rdm_cpu_id_set",
            "description": "hw atl rdm cpu id set set cpu id"
        },
        "fpsimd_release_task": {
            "ground_truth": "0",
            "function": "fpsimd_release_task",
            "description": "fpsimd release task called from the put task struct path which cannot get here unless dead task is really dead and not schedulable"
        },
        "read_lba": {
            "ground_truth": "0",
            "function": "read_lba",
            "description": "read lba state lba buffer count read count byte from state bdev into buffer return number of byte read on success on error struct parsed partition state undescribed u64 lba undescribed u8 buffer undescribed size count undescribed"
        },
        "drm_vma_offset_manager_init": {
            "ground_truth": "0",
            "function": "drm_vma_offset_manager_init",
            "description": "drm vma offset manager init initialize new offset manager initialize new offset manager the offset and area size available for the manager are given a page offset and size both are interpreted a page number not byte adding removing node from the manager is locked internally and protected against concurrent access however node allocation and destruction is left for the caller while calling into the vma manager given node must always be guaranteed to be referenced struct drm vma offset manager mgr manager object unsigned long page offset offset of available memory area page based unsigned long size size of available address space range page based"
        },
        "xa_reserve": {
            "ground_truth": "0",
            "function": "xa_reserve",
            "description": "xa reserve reserve this index in the xarray ensures there is somewhere to store an entry at index in the array if there is already something stored at index this function doe nothing if there wa nothing there the entry is marked a reserved loading from reserved entry return null pointer if you do not use the entry that you have reserved call xa release or xa erase to free any unnecessary memory struct xarray xa xarray unsigned long index index into array gfp gfp memory allocation flag any context take and release the xa lock may sleep if the gfp flag permit if the reservation succeeded or enomem if it failed"
        },
        "radix_tree_next_chunk": {
            "ground_truth": "0",
            "function": "radix_tree_next_chunk",
            "description": "radix tree next chunk find next chunk of slot for iteration this function look up the next chunk in the radix tree starting from iter next index it return pointer to the chunk is first slot also it fill iter with data about chunk position in the tree index it end next index and construct bit mask for tagged iterating tag const struct radix tree root undescribed struct radix tree iter iter iterator state unsigned flag radix tree iter flag and tag index pointer to chunk first slot or null if there no more left"
        },
        "setup_events_to_report": {
            "ground_truth": "0",
            "function": "setup_events_to_report",
            "description": "setup event to report setup which logical event to report"
        },
        "jz4740_mmc_release_dma_channels": {
            "ground_truth": "0",
            "function": "jz4740_mmc_release_dma_channels",
            "description": "jz4740 mmc release dma channel dma infrastructure"
        },
        "ascii2desc": {
            "ground_truth": "0",
            "function": "ascii2desc",
            "description": "ascii2desc helper routine for producing utf 16le string descriptor char const null terminated ascii actually iso string u8 buf buffer for usb string descriptor header utf 16le unsigned len length in byte may be odd of descriptor buffer the number of byte filled in strlen or len whichever is le note usb string descriptor can contain at most character input string longer than that are truncated"
        },
        "netlbl_domhsh_search": {
            "ground_truth": "0",
            "function": "netlbl_domhsh_search",
            "description": "netlbl domhsh search search for domain entry search the domain hash table and return pointer to the hash table entry if found otherwise null is returned family may be af unspec which match any address family entry the caller is responsible for ensuring that the hash table is protected with either rcu read lock or the hash table lock const char domain the domain u16 family the address family"
        },
        "a3d_adc_close": {
            "ground_truth": "0",
            "function": "a3d_adc_close",
            "description": "a3d adc close a3d adc close is callback from the input close routine"
        },
        "bcma_host_soc_register_driver": {
            "ground_truth": "0",
            "function": "bcma_host_soc_register_driver",
            "description": "bcma host soc register driver host soc"
        },
        "mhi_alloc_controller": {
            "ground_truth": "0",
            "function": "mhi_alloc_controller",
            "description": "mhi alloc controller allocate the mhi controller structure allocate the mhi controller structure using zero initialized memory void no argument"
        },
        "mmhub_v1_0_set_fault_enable_default": {
            "ground_truth": "0",
            "function": "mmhub_v1_0_set_fault_enable_default",
            "description": "mmhub v1 set fault enable default update gart vm fault handling struct amdgpu device adev amdgpu device pointer bool value true redirects vm fault to the default page"
        },
        "vortex_wt_SetVolume": {
            "ground_truth": "0",
            "function": "vortex_wt_SetVolume",
            "description": "vortex wt setvolume extract of cadbtopology setvolume struct aspvolume"
        },
        "rcar_drif_get_fbuf": {
            "ground_truth": "0",
            "function": "rcar_drif_get_fbuf",
            "description": "rcar drif get fbuf get frame buf from list"
        },
        "sanitize_watermarks": {
            "ground_truth": "0",
            "function": "sanitize_watermarks",
            "description": "sanitize watermark calculate what we think the watermark should be for the state we have read out of the hardware and then immediately program those watermark so that we ensure the hardware setting match our internal state we can calculate what we think wm is should be by creating duplicate of the current state which wa constructed during hardware readout and running it through the atomic check code to calculate new watermark value in the state object"
        },
        "dm_set_geometry": {
            "ground_truth": "0",
            "function": "dm_set_geometry",
            "description": "dm set geometry set the geometry of device"
        },
        "vmci_dbell_host_context_notify": {
            "ground_truth": "0",
            "function": "vmci_dbell_host_context_notify",
            "description": "vmci dbell host context notify dispatch doorbell notification to the host context"
        },
        "ap_get_table_length": {
            "ground_truth": "0",
            "function": "ap_get_table_length",
            "description": "ap get table length function ap get table length parameter table pointer to the table return table length description obtain table length according to table signature"
        },
        "mc_remove": {
            "ground_truth": "0",
            "function": "mc_remove",
            "description": "mc remove unbind driver from controller struct platform device pdev platform device unconditionally"
        },
        "mlx5_eswitch_manager_vport": {
            "ground_truth": "0",
            "function": "mlx5_eswitch_manager_vport",
            "description": "mlx5 eswitch manager vport the returned number is valid only when the dev is eswitch manager"
        },
        "iavf_set_promiscuous": {
            "ground_truth": "0",
            "function": "iavf_set_promiscuous",
            "description": "iavf set promiscuous request that the pf enable promiscuous mode for our vsi struct iavf adapter adapter adapter structure int flag bitmask to control unicast multicast promiscuous"
        },
        "__nla_validate_nested": {
            "ground_truth": "0",
            "function": "__nla_validate_nested",
            "description": "nla validate nested validate stream of nested attribute validates all attribute in the nested attribute stream against the specified policy attribute with type exceeding maxtype will be ignored see documenation of struct nla policy for more detail return on success or negative error code const struct nlattr start container attribute int maxtype maximum attribute type to be expected const struct nla policy policy validation policy unsigned int validate validation strictness struct netlink ext ack extack extended ack report struct"
        },
        "ipr_oper_timeout": {
            "ground_truth": "0",
            "function": "ipr_oper_timeout",
            "description": "ipr oper timeout adapter timed out transitioning to operational this function block host request and initiate an adapter reset return value none struct timer list timer context used to fetch ipr command struct"
        },
        "sg_to_qm_sg": {
            "ground_truth": "0",
            "function": "sg_to_qm_sg",
            "description": "sg to qm sg convert scatterlist to link table format but doe not have final bit instead return last entry"
        },
        "get_voice": {
            "ground_truth": "0",
            "function": "get_voice",
            "description": "get voice prototype"
        },
        "rcu_scale_async_cb": {
            "ground_truth": "0",
            "function": "rcu_scale_async_cb",
            "description": "rcu scale async cb callback function for asynchronous grace period from rcu scale writer"
        },
        "plpar_hcall": {
            "ground_truth": "0",
            "function": "plpar_hcall",
            "description": "plpar hcall plpar hcall make pseries hypervisor call this call support up to argument and return argument use plpar hcall bufsize to size the return argument buffer used for all but the craziest of phyp interface see plpar hcall9 opcode the hypervisor call to make retbuf buffer to store up to return argument in"
        },
        "ibwdt_ping": {
            "ground_truth": "0",
            "function": "ibwdt_ping",
            "description": "ibwdt ping watchdog operation"
        },
        "jbd2_journal_unlock_updates": {
            "ground_truth": "0",
            "function": "jbd2_journal_unlock_updates",
            "description": "jbd2 journal unlock update release barrier release transaction barrier obtained with jbd2 journal lock update should be called without the journal lock held journal journal journal to release the barrier on"
        },
        "stat_start": {
            "ground_truth": "0",
            "function": "stat_start",
            "description": "stat start iteration over statistic entry"
        },
        "ishtp_hbm_cl_hdr": {
            "ground_truth": "0",
            "function": "ishtp_hbm_cl_hdr",
            "description": "ishtp hbm cl hdr construct client hbm header initialize hbm buffer struct ishtp cl cl client uint8 hbm cmd host bus message command void buf buffer for cl header size len buffer length"
        },
        "zpa2326_reset_device": {
            "ground_truth": "0",
            "function": "zpa2326_reset_device",
            "description": "zpa2326 reset device reset device to default hardware state disable sampling and empty hardware fifo device must be enabled before reset not in low power mode const struct iio dev indio dev the iio device associated with the hardware to reset zero when successful negative error code otherwise"
        },
        "ocfs2_shift_tree_depth": {
            "ground_truth": "0",
            "function": "ocfs2_shift_tree_depth",
            "description": "ocfs2 shift tree depth add another level to the allocation tree return back the new extent block so you can add branch to it after this call"
        },
        "netlink_table_grab": {
            "ground_truth": "0",
            "function": "netlink_table_grab",
            "description": "netlink table grab this lock without wq flag exclusive is good on up and it is very bad on smp look when several writer sleep and reader wake them up all but one immediately hit write lock and grab all the cpu exclusive sleep solves this but remember it add useless work on up machine"
        },
        "dm_helpers_parse_edid_caps": {
            "ground_truth": "0",
            "function": "dm_helpers_parse_edid_caps",
            "description": "dm helper parse edid cap dm helper parse edid cap parse edid cap edid cap in pointer to edid cap void edid in pointer to edid return"
        },
        "defined": {
            "ground_truth": "0",
            "function": "defined",
            "description": "defined writeback"
        },
        "ishtp_bus_remove_all_clients": {
            "ground_truth": "0",
            "function": "ishtp_bus_remove_all_clients",
            "description": "ishtp bus remove all client remove all client this is part of reset remove flow this function the main processing only target error processing if the fw ha forced reset or error to remove connected client when warm reset the client device are not removed struct ishtp device ishtp dev ishtp device bool warm reset reset due to fw reset dure to error or s3 suspend"
        },
        "jsm_uart_port_init": {
            "ground_truth": "0",
            "function": "jsm_uart_port_init",
            "description": "jsm uart port init prototype for non static function used in more than one module"
        },
        "qxl_release_from_id_locked": {
            "ground_truth": "0",
            "function": "qxl_release_from_id_locked",
            "description": "qxl release from id locked used by qxl debugfs release"
        },
        "i2400m_roq_log_dump": {
            "ground_truth": "0",
            "function": "i2400m_roq_log_dump",
            "description": "i2400m roq log dump dump all the entry in the fifo and reinitialize it"
        },
        "bdc_submit_cmd": {
            "ground_truth": "0",
            "function": "bdc_submit_cmd",
            "description": "bdc submit cmd submits cmd and analyze the return value of bdc issue cmd"
        },
        "dce120_timing_generator_disable_vga": {
            "ground_truth": "0",
            "function": "dce120_timing_generator_disable_vga",
            "description": "dce120 timing generator disable vga stuff to move to other virtual hw object"
        },
        "islpci_mgmt_rx_fill": {
            "ground_truth": "0",
            "function": "islpci_mgmt_rx_fill",
            "description": "islpci mgmt rx fill fill the receive queue for management frame with fresh buffer"
        },
        "timekeeping_resume": {
            "ground_truth": "0",
            "function": "timekeeping_resume",
            "description": "timekeeping resume resume the generic timekeeping subsystem void no argument"
        },
        "efx_farch_filter_increment": {
            "ground_truth": "0",
            "function": "efx_farch_filter_increment",
            "description": "efx farch filter increment to allow for hash collision filter search continues at these increment from the first possible entry selected by the hash"
        },
        "api_cmd_head_init": {
            "ground_truth": "0",
            "function": "api_cmd_head_init",
            "description": "api cmd head init set the head of chain in the hw struct hinic api cmd chain chain the api cmd specific chain to set in hw the head for"
        },
        "mwifiex_pcie_cmdrsp_complete": {
            "ground_truth": "0",
            "function": "mwifiex_pcie_cmdrsp_complete",
            "description": "mwifiex pcie cmdrsp complete command response processing complete handler"
        },
        "hpfs_remove_dtree": {
            "ground_truth": "0",
            "function": "hpfs_remove_dtree",
            "description": "hpfs remove dtree remove empty directory in normal case it is only one dnode with two entry but we must handle also such obscure case when it is tree of empty dnodes"
        },
        "drm_dp_dual_mode_detect": {
            "ground_truth": "0",
            "function": "drm_dp_dual_mode_detect",
            "description": "drm dp dual mode detect identify the dp dual mode adaptor attempt to identify the type of the dp dual mode adaptor used note that when the answer is drm dp dual mode unknown it is not certain whether we are dealing with native hdmi port or type dvi dual mode adaptor the driver will have to use some other hardware driver specific mechanism to make that distinction struct i2c adapter adapter i2c adapter for the ddc bus the type of the dp dual mode adaptor used"
        },
        "tcx_blank": {
            "ground_truth": "0",
            "function": "tcx_blank",
            "description": "tcx blank optional function blank the display int blank undescribed struct fb info info frame buffer structure that represents single frame buffer"
        },
        "nfs_init_server": {
            "ground_truth": "0",
            "function": "nfs_init_server",
            "description": "nfs init server create version or client"
        },
        "bochs_hw_init": {
            "ground_truth": "0",
            "function": "bochs_hw_init",
            "description": "bochs hw init bochs hw"
        },
        "setcolor": {
            "ground_truth": "0",
            "function": "setcolor",
            "description": "setcolor set the set reset register and return it old value"
        },
        "batadv_nc_init_bat_priv": {
            "ground_truth": "0",
            "function": "batadv_nc_init_bat_priv",
            "description": "batadv nc init bat priv initialise the nc specific bat priv variable struct batadv priv bat priv the bat priv with all the soft interface information"
        },
        "ibmvmc_handle_crq": {
            "ground_truth": "0",
            "function": "ibmvmc_handle_crq",
            "description": "ibmvmc handle crq handle crq read the command element from the command queue and execute the request based upon the type of crq message struct ibmvmc crq msg crq ibmvmc crq msg struct struct crq server adapter adapter crq server adapter struct"
        },
        "usb4_port_enumerate_retimers": {
            "ground_truth": "0",
            "function": "usb4_port_enumerate_retimers",
            "description": "usb4 port enumerate retimers send rt broadcast transaction this force the usb4 port to send broadcast rt transaction which make the retimers on the link to assign index to themselves return in case of success and negative errno if there wa an error struct tb port port usb4 port"
        },
        "pick_next_task": {
            "ground_truth": "0",
            "function": "pick_next_task",
            "description": "pick next task pick up the highest prio task"
        },
        "pcibios_plat_dev_init": {
            "ground_truth": "0",
            "function": "pcibios_plat_dev_init",
            "description": "pcibios plat dev init do platform specific device initialization at pci enable device time"
        },
        "WRITE_IT_WAIT": {
            "ground_truth": "0",
            "function": "WRITE_IT_WAIT",
            "description": "write it wait read the burnt in address"
        },
        "i3c_generic_ibi_alloc_pool": {
            "ground_truth": "0",
            "function": "i3c_generic_ibi_alloc_pool",
            "description": "i3c generic ibi alloc pool create generic ibi pool create generic ibi pool based on the information provided in req struct i3c dev desc dev the device this pool will be used for const struct i3c ibi setup req ibi setup request describing what the device driver expects valid ibi pool in case of success an err ptr otherwise"
        },
        "__acquires": {
            "ground_truth": "0",
            "function": "__acquires",
            "description": "acquires compaction requires the taking of some coarse lock that are potentially very heavily contended for async compaction trylock and record if the lock is contended the lock will still be acquired but compaction will abort when the current block is finished regardless of success rate sync compaction acquires the lock always return true which make it easier to track lock state in caller"
        },
        "cvmx_helper_initialize_packet_io_local": {
            "ground_truth": "0",
            "function": "cvmx_helper_initialize_packet_io_local",
            "description": "cvmx helper initialize packet io local return zero on success non zero on failure void no argument"
        },
        "ser12_set_divisor": {
            "ground_truth": "0",
            "function": "ser12_set_divisor",
            "description": "ser12 set divisor ser12 specific routine"
        },
        "scmi_initialize_events_queue": {
            "ground_truth": "0",
            "function": "scmi_initialize_events_queue",
            "description": "scmi initialize event queue allocate initialize kfifo buffer allocate buffer for the kfifo and initialize it struct scmi notify instance ni reference to the notification instance to use struct event queue equeue the event queue to initialize size sz size of the kfifo buffer to allocate on success"
        },
        "set_raw_egress_record": {
            "ground_truth": "0",
            "function": "set_raw_egress_record",
            "description": "set raw egress record write packed record to the specified egress lut table row"
        },
        "ufshcd_exec_raw_upiu_cmd": {
            "ground_truth": "0",
            "function": "ufshcd_exec_raw_upiu_cmd",
            "description": "ufshcd exec raw upiu cmd api function for sending raw upiu command support utp transfer request nop and query and utp task management request it is up to the caller to fill the upiu conent properly a it will be copied without any further input validation struct ufs hba hba per adapter instance struct utp upiu req req upiu upiu request struct utp upiu req rsp upiu upiu reply only dw a we do not support scsi command int msgcode message code one of upiu transaction code initiator to target u8 desc buff pointer to descriptor buffer null if na int buff len descriptor size if na enum query opcode desc op descriptor operation"
        },
        "sxgbe_tx_ctxt_desc_get_cde": {
            "ground_truth": "0",
            "function": "sxgbe_tx_ctxt_desc_get_cde",
            "description": "sxgbe tx ctxt desc get cde wb status of context descriptor"
        },
        "rt2x00queue_update_beacon_locked": {
            "ground_truth": "0",
            "function": "rt2x00queue_update_beacon_locked",
            "description": "rt2x00queue update beacon locked send new beacon from mac80211 to hardware caller need to ensure locking struct rt2x00 dev rt2x00dev pointer to type struct rt2x00 dev struct ieee80211 vif vif interface for which the beacon should be updated"
        },
        "reqsk_queue_unlink": {
            "ground_truth": "0",
            "function": "reqsk_queue_unlink",
            "description": "reqsk queue unlink return true if req wa found in the ehash table"
        },
        "mvpp2_port_probe": {
            "ground_truth": "0",
            "function": "mvpp2_port_probe",
            "description": "mvpp2 port probe port initialization"
        },
        "ds1685_rtc_read_alarm": {
            "ground_truth": "0",
            "function": "ds1685_rtc_read_alarm",
            "description": "ds1685 rtc read alarm read the alarm register there are three primary alarm register second minute and hour fourth alarm register for the month date is also available in bank1 for kickstart wakeup feature the ds1685 ds1687 manual state that do not care value ranging from to may be written into one or more of the three alarm byte to act a wildcard value the fourth byte doe not support do not care value struct device dev pointer to device structure struct rtc wkalrm alrm pointer to rtc wkalrm structure"
        },
        "gcov_iter_get_info": {
            "ground_truth": "0",
            "function": "gcov_iter_get_info",
            "description": "gcov iter get info return profiling data set for given file iterator struct gcov iterator iter file iterator"
        },
        "pm80xx_chip_soft_rst": {
            "ground_truth": "0",
            "function": "pm80xx_chip_soft_rst",
            "description": "pm80xx chip soft rst soft reset the pm8001 chip so that the clear all the fw register status to the originated status struct pm8001 hba info pm8001 ha our hba card information"
        },
        "m920x_identify_state": {
            "ground_truth": "0",
            "function": "m920x_identify_state",
            "description": "m920x identify state callback for dvb usb"
        },
        "cros_ec_keyb_report_bs": {
            "ground_truth": "0",
            "function": "cros_ec_keyb_report_bs",
            "description": "cro ec keyb report b report non matrixed button or switch this take bitmap of button or switch from the ec and report event syncing at the end struct cro ec keyb ckdev the keyboard device unsigned int ev type the input event type ev key u32 mask bitmap of button from the ec"
        },
        "ali_lock_sectors": {
            "ground_truth": "0",
            "function": "ali_lock_sectors",
            "description": "ali lock sector keep older device to sector mode struct ata device adev device called during the bus probe for each device that is found we use this call to lock the sector count of the device to or le on older ali controller if we did not do this then large is would require lba48 command which the older ali requires are issued by slower pio method"
        },
        "d40_desc_queue": {
            "ground_truth": "0",
            "function": "d40_desc_queue",
            "description": "d40 desc queue remove desc from current queue and add it to the pending queue"
        },
        "ipu_csi_init_interface": {
            "ground_truth": "0",
            "function": "ipu_csi_init_interface",
            "description": "ipu csi init interface ipu cmos sensor interface csi function"
        },
        "zr364xx_vidioc_streamon": {
            "ground_truth": "0",
            "function": "zr364xx_vidioc_streamon",
            "description": "zr364xx vidioc streamon v4l2 integration"
        },
        "mwifiex_update_autoindex_ies": {
            "ground_truth": "0",
            "function": "mwifiex_update_autoindex_ies",
            "description": "mwifiex update autoindex y this function prepares ie data buffer for command to be sent to fw"
        },
        "tb_xdomain_add": {
            "ground_truth": "0",
            "function": "tb_xdomain_add",
            "description": "tb xdomain add add xdomain to the bus this function start xdomain discovery protocol handshake and eventually add the xdomain to the bus after calling this function the caller need to call tb xdomain remove in order to remove and release the object regardless whether the handshake succeeded or not struct tb xdomain xd xdomain to add"
        },
        "lt9611_connector_detect": {
            "ground_truth": "0",
            "function": "lt9611_connector_detect",
            "description": "lt9611 connector detect connector funcs"
        },
        "otx_cptvf_send_vf_down": {
            "ground_truth": "0",
            "function": "otx_cptvf_send_vf_down",
            "description": "otx cptvf send vf down communicate to pf that vf is down and running"
        },
        "load_elfcorehdr_segment": {
            "ground_truth": "0",
            "function": "load_elfcorehdr_segment",
            "description": "load elfcorehdr segment setup crash memory range and initialize elfcorehdr segment needed to load kdump kernel return on success negative errno on error struct kimage image kexec image struct kexec buf kbuf buffer content and memory parameter"
        },
        "snd_soc_component_open": {
            "ground_truth": "0",
            "function": "snd_soc_component_open",
            "description": "snd soc component open component driver ops"
        },
        "rq_depth_scale_up": {
            "ground_truth": "0",
            "function": "rq_depth_scale_up",
            "description": "rq depth scale up return true on success and false if scaling up wa not possible"
        },
        "ni65_set_performance": {
            "ground_truth": "0",
            "function": "ni65_set_performance",
            "description": "ni65 set performance set performance register we must stop lance for that"
        },
        "t4_fw_bye": {
            "ground_truth": "0",
            "function": "t4_fw_bye",
            "description": "t4 fw bye end communication with fw struct adapter adap the adapter unsigned int mbox mailbox to use for the fw command issue command to terminate communication with fw"
        },
        "sirfsoc_dma_irq": {
            "ground_truth": "0",
            "function": "sirfsoc_dma_irq",
            "description": "sirfsoc dma irq interrupt handler"
        },
        "ehci_turn_off_all_ports": {
            "ground_truth": "0",
            "function": "ehci_turn_off_all_ports",
            "description": "ehci turn off all port on some system leaving remote wakeup enabled prevents system shutdown the firmware seems to think that powering off is wakeup event this routine turn off remote wakeup and everything else on all port"
        },
        "ch7017_dpms": {
            "ground_truth": "0",
            "function": "ch7017_dpms",
            "description": "ch7017 dpms set the ch7017 power state"
        },
        "nfs_create_rpc_client": {
            "ground_truth": "0",
            "function": "nfs_create_rpc_client",
            "description": "nfs create rpc client create an rpc client handle"
        },
        "dvb_ringbuffer_flush_spinlock_wakeup": {
            "ground_truth": "0",
            "function": "dvb_ringbuffer_flush_spinlock_wakeup",
            "description": "dvb ringbuffer flush spinlock wakeup flush buffer protected by spinlock and wake up waiting task struct dvb ringbuffer rbuf pointer to struct dvb ringbuffer"
        },
        "rcu_scale_shutdown": {
            "ground_truth": "0",
            "function": "rcu_scale_shutdown",
            "description": "rcu scale shutdown rcu scalability shutdown kthread just wait to be awakened then shuts down system"
        },
        "rcu_sync_is_idle": {
            "ground_truth": "0",
            "function": "rcu_sync_is_idle",
            "description": "rcu sync is idle are reader permitted to use their fastpaths return true if reader are permitted to use their fastpaths must be invoked within some flavor of rcu read side critical section struct rcu sync rsp pointer to rcu sync structure to use for synchronization"
        },
        "xfs_fs_set_info": {
            "ground_truth": "0",
            "function": "xfs_fs_set_info",
            "description": "xfs f set info adjust quota timer warning"
        },
        "cmm_oom_notify": {
            "ground_truth": "0",
            "function": "cmm_oom_notify",
            "description": "cmm oom notify oom notifier return value notify ok struct notifier block self notifier block struct unsigned long dummy not used void parm returned number of page freed"
        },
        "calc_l1_acceptable": {
            "ground_truth": "0",
            "function": "calc_l1_acceptable",
            "description": "calc l1 acceptable convert l1 acceptable latency encoding to n"
        },
        "do_sync_gen_syndrome": {
            "ground_truth": "0",
            "function": "do_sync_gen_syndrome",
            "description": "do sync gen syndrome synchronously calculate raid6 syndrome struct page block undescribed unsigned int offset undescribed int disk undescribed size len undescribed struct async submit ctl submit undescribed"
        },
        "sunzilog_stop_tx": {
            "ground_truth": "0",
            "function": "sunzilog_stop_tx",
            "description": "sunzilog stop tx the port lock is held and interrupt are disabled"
        },
        "sst_handle_vb_timer": {
            "ground_truth": "0",
            "function": "sst_handle_vb_timer",
            "description": "sst handle vb timer sst handle vb timer start stop the dsp scheduler the dsp expects first cmd to be sba vb start so at first startup send that dsp expects last cmd to be sba vb idle so at last shutdown send that do refcount internally so that we send command only at first start and last end since sst driver doe it own ref count invoke sst is power ops always"
        },
        "efi_map_regions": {
            "ground_truth": "0",
            "function": "efi_map_regions",
            "description": "efi map region map the efi memory range of the runtime service and update new mmap with virtual address"
        },
        "intel_guc_ads_create": {
            "ground_truth": "0",
            "function": "intel_guc_ads_create",
            "description": "intel guc ad create allocates and initializes guc ad guc need memory block additional data struct where it will store some data allocate and initialize such memory block for guc use struct intel guc guc intel guc struct"
        },
        "drm_atomic_helper_check_plane_damage": {
            "ground_truth": "0",
            "function": "drm_atomic_helper_check_plane_damage",
            "description": "drm atomic helper check plane damage verify plane damage on atomic check this helper function make sure that damage from plane state is discarded for full modeset if there are more reason driver would want to do full plane update rather than processing individual damage region then those case should be taken care of here note that type drm plane state fb damage clip null in plane state mean that full plane update should happen it also ensure helper iterator will return type drm plane state src a damage struct drm atomic state state the driver state object struct drm plane state plane state plane state for which to verify damage"
        },
        "sa_sync_cmd": {
            "ground_truth": "0",
            "function": "sa_sync_cmd",
            "description": "sa sync cmd send command and wait struct aac dev dev adapter u32 command command to execute u32 p1 first parameter u32 p2 second parameter u32 p3 third parameter u32 p4 forth parameter u32 p5 fifth parameter u32 p6 sixth parameter u32 ret adapter status u32 r1 first return value u32 r2 second return value u32 r3 third return value u32 r4 forth return value this routine will send synchronous command to the adapter and wait for it completion"
        },
        "at91_cf_set_mem_map": {
            "ground_truth": "0",
            "function": "at91_cf_set_mem_map",
            "description": "at91 cf set mem map pcmcia layer map unmaps mem region"
        },
        "cfpkt_peek_head": {
            "ground_truth": "0",
            "function": "cfpkt_peek_head",
            "description": "cfpkt peek head peek header from packet read data from packet without changing packet pkt packet to extract header data from data pointer to copy the header data into len length of head data to copy return zero on success and error code upon failure"
        },
        "remove_ranges": {
            "ground_truth": "0",
            "function": "remove_ranges",
            "description": "remove range this routine deletes the range from given bus and the entry from the parent is bus in the resource input current bus previous bus output einval"
        },
        "affinity_check": {
            "ground_truth": "0",
            "function": "affinity_check",
            "description": "affinity check affinity"
        },
        "gpio_reg_init": {
            "ground_truth": "0",
            "function": "gpio_reg_init",
            "description": "gpio reg init add fixed in out register a gpio add single register gpio device containing up to gpio signal where each gpio ha fixed input or output configuration only input gpios are assumed to be readable from the register and only then after double read output value are assumed not to be readable struct device dev optional struct device associated with this register void iomem reg undescribed int base start gpio number or to allocate int num number of gpios maximum const char label gpio chip label u32 direction bitmask of fixed direction one per gpio signal in u32 def out initial gpio output value const char const name array of num string describing each gpio signal or null struct irq domain irqdom irq domain or null const int irqs array of num ints describing the interrupt mapping for each gpio signal or null if irqdom is null then this describes the linux interrupt number otherwise it describes the hardware interrupt number in the specified irq domain"
        },
        "chain_block_next": {
            "ground_truth": "0",
            "function": "chain_block_next",
            "description": "chain block next next block or"
        },
        "atif_probe_device": {
            "ground_truth": "0",
            "function": "atif_probe_device",
            "description": "atif probe device perform phase aarp probing on our tentative address"
        },
        "zfcp_qdio_sbale_req": {
            "ground_truth": "0",
            "function": "zfcp_qdio_sbale_req",
            "description": "zfcp qdio sbale req return pointer to sbale on req for request struct zfcp qdio qdio pointer to struct zfcp qdio struct zfcp qdio req req pointer to struct zfcp qdio req pointer to qdio buffer element sbale structure"
        },
        "ubifs_fast_find_empty": {
            "ground_truth": "0",
            "function": "ubifs_fast_find_empty",
            "description": "ubifs fast find empty try to find an empty leb quickly this function return leb property for an empty leb or null if the function is unable to find an empty leb quickly struct ubifs info the ubifs file system description object"
        },
        "iomap_end": {
            "ground_truth": "0",
            "function": "iomap_end",
            "description": "iomap end commit and or unreserve space previous allocated using iomap begin written indicates the length of the successful write operation which need to be commited while the rest need to be unreserved written might be zero if no data wa written"
        },
        "ice_fltr_remove_mac_list": {
            "ground_truth": "0",
            "function": "ice_fltr_remove_mac_list",
            "description": "ice fltr remove mac list remove list of mac filter struct ice vsi vsi pointer to vsi struct struct list head list list of filter"
        },
        "prom_apply_generic_ranges": {
            "ground_truth": "0",
            "function": "prom_apply_generic_ranges",
            "description": "prom apply generic range apply range of any prom node and optionally parent node a well to register"
        },
        "vio_cmo_entitlement_update": {
            "ground_truth": "0",
            "function": "vio_cmo_entitlement_update",
            "description": "vio cmo entitlement update manage system entitlement change increase in entitlement will be used to fulfill the spare entitlement and the rest is given to the excess pool decrease if they are possible come from the excess pool and from unused device entitlement size new entitlement new system entitlement to attempt to accommodate on success enomem when change can not be made"
        },
        "ixgb_get_ee_mac_addr": {
            "ground_truth": "0",
            "function": "ixgb_get_ee_mac_addr",
            "description": "ixgb get ee mac addr return the mac address from eeprom hw struct containing variable accessed by shared code mac addr ethernet address if eeprom content are valid otherwise return none"
        },
        "init_follower_unmute": {
            "ground_truth": "0",
            "function": "init_follower_unmute",
            "description": "init follower unmute unmute the follower via snd ctl apply vmaster follower"
        },
        "intel_write_sha_text": {
            "ground_truth": "0",
            "function": "intel_write_sha_text",
            "description": "intel write sha text return updated sha index"
        },
        "arch_uprobe_xol_was_trapped": {
            "ground_truth": "0",
            "function": "arch_uprobe_xol_was_trapped",
            "description": "arch uprobe xol wa trapped if xol insn itself trap and generates signal say sigill sigsegv etc then detect the case where singlestepped instruction jump back to it own address it is assumed that anything like do page fault do trap etc set thread trap nr arch uprobe pre xol arch uprobe post xol save restore thread trap nr arch uprobe xol wa trapped simply check that trap nr is not equal to uprobe trap nr set by arch uprobe pre xol"
        },
        "hw_atl_rpo_rx_desc_vlan_stripping_set": {
            "ground_truth": "0",
            "function": "hw_atl_rpo_rx_desc_vlan_stripping_set",
            "description": "hw atl rpo rx desc vlan stripping set set rx descriptor vlan stripping"
        },
        "ia_css_set_wb_config": {
            "ground_truth": "0",
            "function": "ia_css_set_wb_config",
            "description": "ia cs set wb config code generated by genparam gencode gen set function"
        },
        "sst_slot_put": {
            "ground_truth": "0",
            "function": "sst_slot_put",
            "description": "sst slot put set the status of interleaver deinterleaver control instead of the enum value being the value written to the register it is the register address and the kcontrol number register num is the value written to the register this is so that there can be only one value for each slot channel since there is only one control for each slot channel this mean that whenever an enum is set we need to clear the bit for that kcontrol no for all the interleaver or deinterleaver register struct snd kcontrol kcontrol control pointer struct snd ctl elem value ucontrol user data de interleaver control are defined in opposite sense to be user friendly"
        },
        "devm_mbox_controller_register": {
            "ground_truth": "0",
            "function": "devm_mbox_controller_register",
            "description": "devm mbox controller register managed mbox controller register this function add device managed resource that will make sure that the mailbox controller which is registered using mbox controller register a part of this function will be unregistered along with the rest of device managed resource upon driver probe failure or driver removal return on success or negative error code on failure struct device dev device owning the mailbox controller being registered struct mbox controller mbox mailbox controller being registered"
        },
        "radeon_atpx_switch_i2c_mux": {
            "ground_truth": "0",
            "function": "radeon_atpx_switch_i2c_mux",
            "description": "radeon atpx switch i2c mux switch i2c hpd mux execute the atpx function i2c mux control atpx function to switch the i2c hpd mux between the discrete gpu and integrated gpu all asics return on success error on failure struct radeon atpx atpx atpx info struct u16 mux id mux state integrated gpu discrete gpu"
        },
        "ubifs_add_snod": {
            "ground_truth": "0",
            "function": "ubifs_add_snod",
            "description": "ubifs add snod add scanned node to leb scanning information this function return on success and negative error code on failure const struct ubifs info ubifs file system description object struct ubifs scan leb sleb scanning information void buf buffer containing node int offs offset of node on flash"
        },
        "dasd_find_busid": {
            "ground_truth": "0",
            "function": "dasd_find_busid",
            "description": "dasd find busid find devmap for device with given bus id"
        },
        "sitd_sched_init": {
            "ground_truth": "0",
            "function": "sitd_sched_init",
            "description": "sitd sched init split iso tds used for usb device going through the tt in usb hub these need microframe scheduling"
        },
        "lpfc_stop_port_s4": {
            "ground_truth": "0",
            "function": "lpfc_stop_port_s4",
            "description": "lpfc stop port s4 stop sli4 device port this routine is invoked to stop an sli4 device port it stop the device from generating interrupt and stop the device driver is timer for the device struct lpfc hba phba pointer to lpfc hba data structure"
        },
        "iscsi_iser_conn_start": {
            "ground_truth": "0",
            "function": "iscsi_iser_conn_start",
            "description": "iscsi iser conn start start iscsi iser connection struct iscsi cl conn cl conn iscsi class connection note here iser intialize or re initialize stop completion a from this point iscsi must call conn stop in session connection teardown so iser transport must wait for it"
        },
        "tb_drom_read": {
            "ground_truth": "0",
            "function": "tb_drom_read",
            "description": "tb drom read copy drom to sw drom and parse it struct tb switch sw undescribed"
        },
        "get_secindex": {
            "ground_truth": "0",
            "function": "get_secindex",
            "description": "get secindex accessor for sym st shndx hide ugliness of 64k section"
        },
        "dlm_slots_assign": {
            "ground_truth": "0",
            "function": "dlm_slots_assign",
            "description": "dlm slot assign for any node that do not support slot we will not have set memb slot in wait status all so memb slot will remain and we will not assign slot or set l num slot here"
        },
        "ieee80211_ibss_notify_scan_completed": {
            "ground_truth": "0",
            "function": "ieee80211_ibss_notify_scan_completed",
            "description": "ieee80211 ibss notify scan completed scan finished notification"
        },
        "asm9260_timer_init": {
            "ground_truth": "0",
            "function": "asm9260_timer_init",
            "description": "asm9260 timer init timer initialization"
        },
        "cxusb_auxbuf_append_urb": {
            "ground_truth": "0",
            "function": "cxusb_auxbuf_append_urb",
            "description": "cxusb auxbuf append urb return false if some data wa overwritten"
        },
        "sa1100_mask_irq": {
            "ground_truth": "0",
            "function": "sa1100_mask_irq",
            "description": "sa1100 mask irq we do not need to ack irqs on the sa1100 unless they are gpios this is for internal irqs from irq lcd to rtcalrm"
        },
        "ps3_start_probe_thread": {
            "ground_truth": "0",
            "function": "ps3_start_probe_thread",
            "description": "ps3 start probe thread start the background probe thread enum ps3 bus type bus type undescribed"
        },
        "return_all_reservations": {
            "ground_truth": "0",
            "function": "return_all_reservations",
            "description": "return all reservation return all reserved block back to the rgrp we previously reserved bunch of block for allocation now we need to give them back this leave the reservation structure in tact but remove all of their corresponding no fly zone struct gfs2 rgrpd rgd the rgrp that need it space back"
        },
        "ieee80211_get_SA": {
            "ground_truth": "0",
            "function": "ieee80211_get_SA",
            "description": "ieee80211 get sa get pointer to sa given an frame this function return the offset to the source address sa it doe not verify that the header is long enough to contain the address and the header must be long enough to contain the frame control field struct ieee80211 hdr hdr the frame"
        },
        "update_turbo_limits": {
            "ground_truth": "0",
            "function": "update_turbo_limits",
            "description": "update turbo limit get various limit setting from regs update the ip power temp limit along with turbo enable flag based on latest register content used at init time and for runtime bios support which requires polling the regs for update a result of ac dc transition for example locking caller must hold turbo status lock outside of init struct ip driver ip ip driver struct"
        },
        "leon_flush_needed": {
            "ground_truth": "0",
            "function": "leon_flush_needed",
            "description": "leon flush needed due to virtual cache we need to check cache configuration if it is possible to skip flushing in some case leon2 and leon3 differ in their way of telling cache information"
        },
        "is_handled_by_aud_tr_if": {
            "ground_truth": "0",
            "function": "is_handled_by_aud_tr_if",
            "description": "is handled by aud tr if fn bool is handled by aud tr if u32 addr brief check if this address is handled by the audio token ring interface param addr return bool retval true yes handled by audio token ring interface retval false no not handled by audio token ring interface"
        },
        "dm9000_inblk_8bit": {
            "ground_truth": "0",
            "function": "dm9000_inblk_8bit",
            "description": "dm9000 inblk 8bit input block from chip to memory"
        },
        "write_d8": {
            "ground_truth": "0",
            "function": "write_d8",
            "description": "write d8 i2c bus function"
        },
        "eeh_pe_set_option": {
            "ground_truth": "0",
            "function": "eeh_pe_set_option",
            "description": "eeh pe set option set option for the indicated pe the routine is called to enable or disable eeh functionality on the indicated pe to enable io or dma for the frozen pe struct eeh pe pe eeh pe int option requested option"
        },
        "sun4i_hash": {
            "ground_truth": "0",
            "function": "sun4i_hash",
            "description": "sun4i hash sun4i hash update update hash engine could be used for both sha1 and md5 write data by step of 32bits and put then in the s since we cannot leave partial data and hash state in the engine we need to get the hash state at the end of this function we can get the hash state every byte so the first work is to get the number of byte to write to s modulo the extra byte will go to temporary buffer op buf storing op len byte so at the begin of update if op len areq nbytes all data will be written to wait buffer op buf and end if not write all data from op buf to the device and position end to complete to 64bytes example update1 60o op len update2 60o need one more word to have byte end so write all data from op buf and one word of sg write remaining data in op buf final state op len"
        },
        "pcnet32_suspend": {
            "ground_truth": "0",
            "function": "pcnet32_suspend",
            "description": "pcnet32 suspend lp lock must be held"
        },
        "xz_dec_test_init": {
            "ground_truth": "0",
            "function": "xz_dec_test_init",
            "description": "xz dec test init allocate the xz decoder state and register the character device"
        },
        "i3c_generic_ibi_recycle_slot": {
            "ground_truth": "0",
            "function": "i3c_generic_ibi_recycle_slot",
            "description": "i3c generic ibi recycle slot return slot to generic ibi pool add an ibi slot back to it generic ibi pool should be called from the master driver struct master controller ops recycle ibi method struct i3c generic ibi pool pool the pool to return the ibi slot to struct i3c ibi slot ibi slot to recycle"
        },
        "batadv_gw_bandwidth_set": {
            "ground_truth": "0",
            "function": "batadv_gw_bandwidth_set",
            "description": "batadv gw bandwidth set parse and set download upload gateway bandwidth from supplied string buffer struct net device net dev netdev struct of the soft interface char buff the buffer containing the user data size count number of byte in the buffer count on success or negative error code in case of failure"
        },
        "dwc2_op_mode": {
            "ground_truth": "0",
            "function": "dwc2_op_mode",
            "description": "dwc2 op mode return the controller is ghwcfg2 otg mode"
        },
        "e1000_kmrn_lock_loss_workaround_ich8lan": {
            "ground_truth": "0",
            "function": "e1000_kmrn_lock_loss_workaround_ich8lan",
            "description": "e1000 kmrn lock loss workaround ich8lan kumeran workaround struct e1000 hw hw pointer to the hw structure work around for kumeran pc lock loss on link status change pci reset speed change and link is up and speed is gigabit if workaround is optionally disabled do nothing wait 1ms for kumeran link to come up check kumeran diagnostic register pc lock loss bit if not set the link is locked all is good otherwise reset the phy repeat up to time note this is only called for igp3 copper when speed is 1gb"
        },
        "usb_bus_start_enum": {
            "ground_truth": "0",
            "function": "usb_bus_start_enum",
            "description": "usb bus start enum start immediate enumeration for otg start enumeration with an immediate reset followed later by hub wq identifying and possibly configuring the device this is needed by otg controller driver where it help meet hnp protocol timing requirement for starting port reset struct usb bus bus the bus must use hcd framework unsigned port num based number of port usually bus otg port in interrupt if successful"
        },
        "sclp_sd_receiver": {
            "ground_truth": "0",
            "function": "sclp_sd_receiver",
            "description": "sclp sd receiver receiver for store data event process store data event and complete listener with matching event id struct evbuf header evbuf hdr header of received event"
        },
        "ia_css_frame_allocate_contiguous_from_info": {
            "ground_truth": "0",
            "function": "ia_css_frame_allocate_contiguous_from_info",
            "description": "ia cs frame allocate contiguous from info allocate frame using the resolution and format from frame info struct this is convenience function implemented on top of ia cs frame allocate contiguous only for fpga display driver which need physically contiguous memory deprecated brief allocate contiguous cs frame from frame info structure param frame the allocated frame param in info the frame info structure return the error code"
        },
        "memory_bm_next_pfn": {
            "ground_truth": "0",
            "function": "memory_bm_next_pfn",
            "description": "memory bm next pfn find the next set bit in memory bitmap starting from the last returned position this function search for the next set bit in bm and return the pfn represented by it if no more bit are set bm end of map is returned it is required to run memory bm position reset before the first call to this function for the given memory bitmap struct memory bitmap bm memory bitmap"
        },
        "__dev_get_by_index": {
            "ground_truth": "0",
            "function": "__dev_get_by_index",
            "description": "dev get by index find device by it ifindex struct net net the applicable net namespace int ifindex index of device search for an interface by index return null if the device is not found or pointer to the device the device ha not had it reference counter increased so the caller must be careful about locking the caller must hold either the rtnl semaphore or dev base lock"
        },
        "__ab_c_size": {
            "ground_truth": "0",
            "function": "__ab_c_size",
            "description": "ab size compute returning size max on overflow internal helper for struct size below"
        },
        "nand_onfi_detect": {
            "ground_truth": "0",
            "function": "nand_onfi_detect",
            "description": "nand onfi detect check if the nand chip is onfi compliant return if it is otherwise"
        },
        "bnx2x_check_half_open_conn": {
            "ground_truth": "0",
            "function": "bnx2x_check_half_open_conn",
            "description": "bnx2x check half open conn description this function check for half opened connection change indication when such change occurs it call the bnx2x analyze link error to check if remote fault is set or cleared reception of remote fault status message in the mac indicates that the peer is mac ha detected fault for example due to break in the tx side of fiber"
        },
        "acpi_ex_do_match": {
            "ground_truth": "0",
            "function": "acpi_ex_do_match",
            "description": "acpi ex do match naming convention for aml interpreter execution routine the routine that begin execution of aml opcodes are named with common convention based upon the number of argument the number of target operand and whether or not value is returned acpiexopcode xa yt zr where xa argument the number of argument input operand that are required for this opcode type through args yt target the number of target output operand that are required for this opcode type or target zr return value indicates whether this opcode type return value a the function return or the acpiexopcode function are called via the dispatcher component with fully resolved operand"
        },
        "ethtool_rxfh_indir_default": {
            "ground_truth": "0",
            "function": "ethtool_rxfh_indir_default",
            "description": "ethtool rxfh indir default get default value for rx flow hash indirection this function provides the default policy for rx flow hash indirection u32 index index in rx flow hash indirection table u32 rx ring number of rx ring to use"
        },
        "freezer_apply_state": {
            "ground_truth": "0",
            "function": "freezer_apply_state",
            "description": "freezer apply state apply state change to single cgroup freezer set or clear state on cgroup according to freeze and perform freezing or thawing a necessary struct freezer freezer freezer to apply state change to bool freeze whether to freeze or unfreeze unsigned int state cgroup freezing flag to set or clear"
        },
        "qed_iov_is_valid_vfid": {
            "ground_truth": "0",
            "function": "qed_iov_is_valid_vfid",
            "description": "qed iov is valid vfid enabled only value if enabled only true only enabled vf id is valid else any vf id le than max vfs is valid brief check if given vf id vfid is valid param hwfn param rel vf id relative vf id param enabled only consider only enabled vf param non malicious true iff we want to validate vf is not malicious return bool true for valid vf id"
        },
        "ieee_hw_rate_init": {
            "ground_truth": "0",
            "function": "ieee_hw_rate_init",
            "description": "ieee hw rate init is called in brcms pci probe context therefore no locking required"
        },
        "ucb1x00_disable": {
            "ground_truth": "0",
            "function": "ucb1x00_disable",
            "description": "ucb1x00 disable disable the ucb1x00 sib clock struct ucb1x00 ucb ucb1x00 structure describing chip disable the sib clock the sib clock will only be disabled when the number of ucb1x00 enable call match the number of ucb1x00 disable call"
        },
        "fsm_getstate": {
            "ground_truth": "0",
            "function": "fsm_getstate",
            "description": "fsm getstate param fi pointer to fsm return the current state of the fsm fsm instance fi undescribed"
        },
        "nvkm_sddr3_calc": {
            "ground_truth": "0",
            "function": "nvkm_sddr3_calc",
            "description": "nvkm sddr3 calc ram type specific mr calculation routine"
        },
        "offset_in_entry": {
            "ground_truth": "0",
            "function": "offset_in_entry",
            "description": "offset in entry helper to check if given offset is inside given entry"
        },
        "clk_hw_round_rate": {
            "ground_truth": "0",
            "function": "clk_hw_round_rate",
            "description": "clk hw round rate round the given rate for hw clk take in rate a input and round it to rate that the clk can actually use struct clk hw hw the hw clk for which we are rounding rate unsigned long rate the rate which is to be rounded prepare lock must be held for clk provider to call from within clk ops such a round rate determine rate return rounded rate of hw clk if clk support round rate operation else return the parent rate"
        },
        "done": {
            "ground_truth": "0",
            "function": "done",
            "description": "done public"
        },
        "sctp_ulpq_abort_pd": {
            "ground_truth": "0",
            "function": "sctp_ulpq_abort_pd",
            "description": "sctp ulpq abort pd abort the partial delivery"
        },
        "snd_hda_jack_add_kctl": {
            "ground_truth": "0",
            "function": "snd_hda_jack_add_kctl",
            "description": "snd hda jack add kctl add kctl for the given pin this assigns jack detection kctl to the given pin the kcontrol will have the given name and index struct hda codec codec the hda codec hda nid nid pin nid to assign const char name string name for the jack bool phantom jack flag to deal a phantom jack int type jack type bit to be reported for guessing from pincfg const struct hda jack keymap keymap optional jack key mapping"
        },
        "of_usb_get_dr_mode_by_phy": {
            "ground_truth": "0",
            "function": "of_usb_get_dr_mode_by_phy",
            "description": "of usb get dr mode by phy get dual role mode for the controller device which is associated with the given phy device node in dts usb controller associate with phy device the function get the string from property wouldr mode of the controller associated with the given phy device node and return the correspondig enum usb dr mode struct device node np pointer to the given phy device node int arg0 phandle args for phy is with phy cell or for phys which do not have phy cell"
        },
        "ccw_device_siosl": {
            "ground_truth": "0",
            "function": "ccw_device_siosl",
            "description": "ccw device siosl initiate logging this function is used to invoke model dependent logging within the channel subsystem struct ccw device cdev ccw device"
        },
        "saa7134_enable_i2s": {
            "ground_truth": "0",
            "function": "saa7134_enable_i2s",
            "description": "saa7134 enable i2s common stuff external entry point"
        },
        "__range_ok": {
            "ground_truth": "0",
            "function": "__range_ok",
            "description": "range ok test whether block of memory is valid user space address return if the range is valid otherwise this is equivalent to the following test u65 addr u65 size u65 current addr limit"
        },
        "amd_threshold_interrupt": {
            "ground_truth": "0",
            "function": "amd_threshold_interrupt",
            "description": "amd threshold interrupt threshold interrupt handler will service threshold apic vector the interrupt go off when error count reach threshold limit"
        },
        "css_get": {
            "ground_truth": "0",
            "function": "css_get",
            "description": "cs get obtain reference on the specified cs the caller must already have reference struct cgroup subsys state cs target cs"
        },
        "dm_crtc_high_irq": {
            "ground_truth": "0",
            "function": "dm_crtc_high_irq",
            "description": "dm crtc high irq handle crtc interrupt handle the crtc vsync interrupt by notfying drm is vblank event handler void interrupt params used for determining the crtc instance"
        },
        "rpc_wake_up_first_on_wq": {
            "ground_truth": "0",
            "function": "rpc_wake_up_first_on_wq",
            "description": "rpc wake up first on wq wake up the first task on the wait queue"
        },
        "sta32x_set_dai_fmt": {
            "ground_truth": "0",
            "function": "sta32x_set_dai_fmt",
            "description": "sta32x set dai fmt configure the codec for the selected audio format this function take bitmask of snd soc daifmt bit and program the codec accordingly struct snd soc dai codec dai the codec dai unsigned int fmt snd soc daifmt value indicating the data format"
        },
        "dbl_to_sgl_fcnvuf": {
            "ground_truth": "0",
            "function": "dbl_to_sgl_fcnvuf",
            "description": "dbl to sgl fcnvuf double unsigned fixed to single floating point"
        },
        "amdgpu_dm_irq_register_interrupt": {
            "ground_truth": "0",
            "function": "amdgpu_dm_irq_register_interrupt",
            "description": "amdgpu dm irq register interrupt register irq handler for display block cannot be called from an interrupt handler struct amdgpu device adev amd drm device struct dc interrupt params int params parameter for the irq void ih void pointer to the irq hander function void handler args argument which will be passed to ih irq handler index on success null on failure"
        },
        "drm_vm_shm_close": {
            "ground_truth": "0",
            "function": "drm_vm_shm_close",
            "description": "drm vm shm close close method for shared virtual memory param vma virtual memory area deletes map information if we are the last person to close mapping and it is not in the global maplist"
        },
        "rxrpc_end_rx_phase": {
            "ground_truth": "0",
            "function": "rxrpc_end_rx_phase",
            "description": "rxrpc end rx phase end the packet reception phase"
        },
        "visor_open": {
            "ground_truth": "0",
            "function": "visor_open",
            "description": "visor open handspring visor specific driver function"
        },
        "amd_pre_reset": {
            "ground_truth": "0",
            "function": "amd_pre_reset",
            "description": "amd pre reset perform reset handling struct ata link link ata link unsigned long deadline deadline jiffy for the operation reset sequence checking enable bit to see which port are active"
        },
        "array_find_l": {
            "ground_truth": "0",
            "function": "array_find_l",
            "description": "array find the same for long"
        },
        "mlx5_eq_update_cc": {
            "ground_truth": "0",
            "function": "mlx5_eq_update_cc",
            "description": "mlx5 eq update cc the hca will think the queue ha overflowed if we do not tell it we have been processing event we create eq with mlx5 num spare eqe extra entry so we must update our consumer index at least that often mlx5 eq update cc must be called on every eqe eq irq handler"
        },
        "i40e_vc_config_irq_map_msg": {
            "ground_truth": "0",
            "function": "i40e_vc_config_irq_map_msg",
            "description": "i40e vc config irq map msg called from the vf to configure the irq to queue map struct i40e vf vf pointer to the vf info u8 msg pointer to the msg buffer"
        },
        "ixgbe_set_num_queues": {
            "ground_truth": "0",
            "function": "ixgbe_set_num_queues",
            "description": "ixgbe set num queue allocate queue for device feature dependent this is the top level queue allocation routine the order here is very important starting with the most number of feature turned on at once and ending with the smallest set of feature this way large combination can be allocated if they are turned on and smaller combination are the fallthrough condition struct ixgbe adapter adapter board private structure to initialize"
        },
        "ib_test": {
            "ground_truth": "0",
            "function": "ib_test",
            "description": "ib test testing function"
        },
        "kvm_set_way_flush": {
            "ground_truth": "0",
            "function": "kvm_set_way_flush",
            "description": "kvm set way flush see note at armv7 arm b1 tl dr ops are not easily virtualized main problem ops are local to cpu not broadcast we have line migration behind our back speculation system cache do not support at all damn in the face of the above the best we can do is to try and convert ops to va ops because the guest is not allowed to infer the to pa mapping it can only use to nuke the whole cache which is rather good thing for u also it is only used when turning cache on off the expected usage of the cache maintenance instruction that operate by set way is associated with the cache maintenance instruction associated with the powerdown and powerup of cache if this is required by the implementation we use the following policy if we trap operation we enable vm trapping to detect cache being turned on off and do full clean we flush the cache on both cache being turned on and off once the cache are enabled we stop trapping vm ops"
        },
        "smc_conn_abort_work": {
            "ground_truth": "0",
            "function": "smc_conn_abort_work",
            "description": "smc conn abort work abort connection abort work scheduled from tasklet context"
        },
        "__cvmx_helper_xaui_enumerate": {
            "ground_truth": "0",
            "function": "__cvmx_helper_xaui_enumerate",
            "description": "cvmx helper xaui enumerate probe xaui interface and determine the number of port connected to it the xaui interface should still be down after this call interface interface to probe return number of port on the interface zero to disable"
        },
        "afs_wait_for_fs_probes": {
            "ground_truth": "0",
            "function": "afs_wait_for_fs_probes",
            "description": "afs wait for f probe wait for the first a yet untried fileserver to respond"
        },
        "MT2063_AddExclZone": {
            "ground_truth": "0",
            "function": "MT2063_AddExclZone",
            "description": "mt2063 addexclzone mt addexclzone add and merge an exclusion zone into the list if the range min max is totally outside the 1st if bw ignore the entry if the range min max is negative ignore the entry"
        },
        "qib_7322_boardname": {
            "ground_truth": "0",
            "function": "qib_7322_boardname",
            "description": "qib boardname fill in the board name and note feature info will be based on the board revision register struct qib devdata dd the qlogic ib device"
        },
        "synthesize_reljump": {
            "ground_truth": "0",
            "function": "synthesize_reljump",
            "description": "synthesize reljump generate relative jump call instruction"
        },
        "drbd_process_write_request": {
            "ground_truth": "0",
            "function": "drbd_process_write_request",
            "description": "drbd process write request return number of connection for drbd expected to actually write this data which doe not include those that we are ahead for"
        },
        "chained_irq_enter": {
            "ground_truth": "0",
            "function": "chained_irq_enter",
            "description": "chained irq enter entry exit function for chained handler where the primary irq chip may implement either fasteoi or level trigger flow control"
        },
        "locks_free_lock": {
            "ground_truth": "0",
            "function": "locks_free_lock",
            "description": "lock free lock free lock which is not in use"
        }
    }
}